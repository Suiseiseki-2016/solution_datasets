{
  "metadata": {
    "batch_number": 53,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 5400,
    "created_at": "2025-08-28T21:02:08.070438",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "612/A",
      "title": "A. The Text Splitting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three positive integers n, p, q (1 ≤ p, q ≤ n ≤ 100).The second line contains the string s consists of lowercase and uppercase latin letters and digits.",
      "output_spec": "OutputIf it's impossible to split the string s to the strings of length p and q print the only number \"-1\".Otherwise in the first line print integer k — the number of strings in partition of s.Each of the next k lines should contain the strings in partition. Each string should be of the length p or q. The string should be in order of their appearing in string s — from left to right.If there are several solutions print any of them.",
      "sample_tests": "ExamplesInputCopy5 2 3HelloOutputCopy2HelloInputCopy10 9 5CodeforcesOutputCopy2CodeforcesInputCopy6 4 5PrivetOutputCopy-1InputCopy8 1 1abacabacOutputCopy8abacabac",
      "description": "A. The Text Splitting\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three positive integers n, p, q (1 ≤ p, q ≤ n ≤ 100).The second line contains the string s consists of lowercase and uppercase latin letters and digits.\n\nOutputIf it's impossible to split the string s to the strings of length p and q print the only number \"-1\".Otherwise in the first line print integer k — the number of strings in partition of s.Each of the next k lines should contain the strings in partition. Each string should be of the length p or q. The string should be in order of their appearing in string s — from left to right.If there are several solutions print any of them.\n\nInputCopy5 2 3HelloOutputCopy2HelloInputCopy10 9 5CodeforcesOutputCopy2CodeforcesInputCopy6 4 5PrivetOutputCopy-1InputCopy8 1 1abacabacOutputCopy8abacabac\n\nInputCopy5 2 3Hello\n\nOutputCopy2Hello\n\nInputCopy10 9 5Codeforces\n\nOutputCopy2Codeforces\n\nInputCopy6 4 5Privet\n\nOutputCopy-1\n\nInputCopy8 1 1abacabac\n\nOutputCopy8abacabac",
      "solutions": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces",
          "content": "Hi, Codeforces!Educational Codeforces Round 4 will take place on 25 December 2015 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here. This time a little time has passed since the previous round. Although we planned this round at Monday, we forgot to include it to schedule, so it was appeared only now. So it is the fourth and the last educational round this year.<Maybe this paragraph will not be changed ever>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</Maybe this paragraph will not be changed ever>This time the round was prepared only by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements, when they will be ready :-)I think this time the problems is simpler than usually, because at first we have too hard problemset and removed the hardest problem and added very simple problem. I hope you will enjoy the problems and solve all of them!Also I want to wish you Happy New Year!!!Good luck and have fun!UPD 1: The first phase is ended, hack the solutions of your opponents!UPD 2: The editorial is ready.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22262",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1394
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces",
          "content": "612A - The Text SplittingLet's fix the number a of strings of length p and the number b of strings of length q. If a·p + b·q = n, we can build the answer by splitting the string s to a parts of the length p and b parts of the length q, in order from left to right. If we can't find any good pair a, b then the answer doesn't exist. Of course this problem can be solved in linear time, but the constraints are small, so you don't need linear solution.Complexity: O(n2).612B - HDD is Outdated TechnologyYou are given the permutation f. Let's build another permutation p in the following way: pfi = i. So the permutation p defines the number of sector by the number of fragment. The permutation p is called inverse permutation to f and denoted f - 1. Now the answer to problem is .Complexity: O(n).612C - Replace To Make Regular Bracket SequenceIf we forget about bracket kinds the string s should be RBS, otherwise the answer doesn't exist. If the answer exists each opening bracket matches to exactly one closing bracket and vice verse. Easy to see that if two matching brackets have the same kind we don't need to replace them. In other case we can change the kind of the closing bracket to the kind of the opening. So we can build some answer. Obviously the answer is minimal, because the problems for some pair of matching pairs are independent and can be solved separately.The only technical problem is to find the matching pairs. To do that we should store the stack of opening brackets. Let's iterate from left to right in s and if the bracket is opening, we would simply add it to the stack. Now if the bracket is closing there are three cases: 1) the stack is empty; 2) at the top of the stack is the opening bracket with the same kind as the current closing; 3) the kind of the opening bracket differs from the kind of the closing bracket. In the first case answer doesn't exist, in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one.Complexity: O(n).612D - The Union of k-SegmentsLet's create two events for each segment li is the time of the segment opening and ri is the time of the segment closing. Let's sort all events by time, if the times are equal let's sort them with priority to opening events. In C++ it can be done with sorting by standard comparator of vector<pair<int, int>> events, where each element of events is the pair with event time and event type ( - 1 for opening and  + 1 for closing).Let's iterate over events and maintain the balance. To do that we should simply decrease the balance by the value of the event type. Now if the balance value equals to k and before updating it was k - 1 then we are in the left end of some segment from the answer. If the balance equals to k - 1 and before updating it was k then we are in the right end of the segment from the answer. Let's simply add segment [left, right] to the answer. So now we have disjoint set of segments contains all satisfied points in order from left to right. Obviously it's the answer to the problem.Complexity: O(nlogn).612E - Square Root of PermutationConsider some permutation q. Let's build by it the oriented graph with edges (i, qi). Easy to see (and easy to prove) that this graph is the set of disjoint cycles. Now let's see what would be with that graph when the permutation will be multiplied by itself: all the cycles of odd length would remain so (only the order of vertices will change, they will be alternated), but the cycles of even length will be split to the two cycles of the same length. So to get the square root from the permutation we should simply alternate (in reverse order) all cycles of the odd length, and group all the cycles of the same even length to pairs and merge cycles in each pair. If it's impossible to group all even cycles to pairs then the answer doesn't exist.Complexity: O(n).612F - Simba on the Circle The author solution for this problem uses dynamic programming. I think that this problem can't be solved by greedy ideas. Let's calculate two dp's: z1i is the answer to the problem if all numbers less than ai are already printed, but the others are not; and z2i is the answer to the problem if all numbers less than or equal to ai are already printed, but the others are not. Let's denote dij — the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order. Easy to see that z2i = minj(zj + dij) for all j such that the value aj is the least value greater than ai. Now let's calculate the value z1i. Consider all elements equals to ai (in one of them we are). If there is only one such element then z1i = z2i. Otherwise we have two alternatives: to move in clockwise or counterclockwise direction. Let we are moving in clockwise direction, the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction, let's denote it u. Otherwise at last we will write out the number from the nearest to the i element in clockwise direction, let's denote it v. Now z1i = min(z2u + odiu, z2v + odvi). Easy to see that the answer to the problem is mini(z1i + dsi), over all i such that ai is the smallest value in array and s is the start position.Additionally you should restore the answer. To do that, on my mind, the simplest way is to write the recursive realization of dp, test it carefully and then copy it to restore answer (see my code below). Of course, it's possible to restore the answer without copy-paste. For example, you can add to your dp parameter b which means it's need to restore answer or not.Complexity: O(n2).Code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22299",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 612\\s*A"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "q = [4, 5, 1, 2, 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 5",
          "code": "q = (1 4)(2 5)(3 1)(4 2)(5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 6",
          "code": "q = (1 4 2)(2 5)(3 1)(5 3) = (1 4 2 5)(3 1)(5 3) = (1 4 2 5 3)(3 1) =  (1 4 2 5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 7",
          "code": "q=(i1, i2, i3, i4, i5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 8",
          "code": "q^2=(i1, ..., i2, ...)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 9",
          "code": "q^2=(i1, i4, i2, i5, i3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 10",
          "code": "q^2 = (1 4 2 5 3)^2 = (1 2 3 4 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 11",
          "code": "p = [2 3 4 5 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 12",
          "code": "p = (i1, i2, i3, i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 13",
          "code": "p = (i1 i3)(i2 i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 14",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 15",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 16",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 17",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 18",
          "code": "3->2->4->1->3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 19",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 20",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, n, \"q\");\n    inf.readEoln();\n\n    string pattern = \"[a-zA-Z0-9]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, n, \"q\");\n    inf.readEoln();\n\n    string pattern = \"[a-zA-Z0-9]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int q = inf.readInt(1, n, \"q\");\n    inf.readEoln();\n\n    string pattern = \"[a-zA-Z0-9]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n    int p = inf.readInt();\n    int q = inf.readInt();\n    string s = inf.readToken();\n    if ((int)s.length() != n) {\n        quitf(_fail, \"Length of string s (%d) does not equal n=%d\", (int)s.length(), n);\n    }\n    int k = ouf.readInt(-1, n, \"k\");\n    if (k == -1) {\n        // Contestant says impossible\n        bool possible = false;\n        for (int i = 0; i <= n / p; ++i) {\n            int remain = n - i * p;\n            if (remain >= 0 && remain % q == 0) {\n                possible = true;\n                break;\n            }\n        }\n        if (possible) {\n            quitf(_wa, \"Contestant says impossible but solution exists\");\n        } else {\n            quitf(_ok, \"Correctly reported impossible\");\n        }\n    } else {\n        // Contestant gives solution\n        vector<string> parts;\n        for (int i = 0; i < k; ++i) {\n            string part = ouf.readToken();\n            parts.push_back(part);\n        }\n        int total_length = 0;\n        for (int i = 0; i < k; ++i) {\n            int len = parts[i].length();\n            if (len != p && len != q) {\n                quitf(_wa, \"Part %d has invalid length %d (should be %d or %d)\", i+1, len, p, q);\n            }\n            total_length += len;\n        }\n        if (total_length != n) {\n            quitf(_wa, \"Total length of parts (%d) does not equal n=%d\", total_length, n);\n        }\n        // Check concatenation\n        string concat;\n        for (int i = 0; i < k; ++i) {\n            concat += parts[i];\n        }\n        if (concat != s) {\n            quitf(_wa, \"Concatenation of parts does not equal s\");\n        }\n        // Verify that possible\n        bool possible = false;\n        for (int i = 0; i <= n / p; ++i) {\n            int remain = n - i * p;\n            if (remain >= 0 && remain % q == 0) {\n                possible = true;\n                break;\n            }\n        }\n        if (!possible) {\n            // Contestant gives a solution but we think no solution exists\n            quitf(_fail, \"Contestant gives a solution but we think no solution exists\");\n        } else {\n            // Accept\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll generate one test case per execution.\n// Usage examples (no random seed parameter!):\n//   ./gen -n 10 -type random\n//   ./gen -n 15 -p 2 -q 3 -type mixed\n//   ./gen -n 8 -p 1 -q 1 -type onlyp\n\n// Character set for the string: lowercase, uppercase, digits\nstatic const string CHARSET =\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n// Helper function to generate a random string of length len\n// using the specified CHARSET.\nstring genRandomString(int len) {\n    string s;\n    s.reserve(len);\n    for (int i = 0; i < len; i++) {\n        s.push_back(CHARSET[rnd.next((int)CHARSET.size())]);\n    }\n    return s;\n}\n\n// Ensure that (x, y) cannot represent n as x * i + y * j for any nonnegative i,j.\nbool impossibleToSplit(int n, int p, int q) {\n    // Check all i in [0..n], j in [0..n] -> if i*p + j*q == n\n    // If no combination yields n, it's impossible.\n    // Since n <= 100 in constraints, we can just brute force.\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i * p + j * q == n) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    // Register the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters with defaults.\n    // n is the length of the string.\n    // p, q can be forced or left unspecified. If they aren't provided, we do not default them to random immediately;\n    // we might compute them depending on the \"type\".\n    int n = opt<int>(\"n\", 10); // By default, 10\n    // p, q might not always be relevant if \"type\" is \"random\" - we'll handle that logic below.\n    // For safety, set a default of 1 each if they aren't passed:\n    int p = opt<int>(\"p\", 1);\n    int q = opt<int>(\"q\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Clamp n to [1, 100], just in case the user passes something out of bound.\n    if (n < 1) n = 1;\n    if (n > 100) n = 100;\n\n    // We will produce exactly one test case.\n\n    // Strategy:\n    // 1) Based on \"type\", we decide how to pick p, q, possibly ignoring user-provided p,q if \"type\" is random.\n    // 2) Generate a random string of length n from CHARSET.\n    // 3) Print n, p, q on a line.\n    // 4) Print that string on the next line.\n    // We do not check for correctness solutions or anything else; we just produce data.\n\n    // We'll store the final p, q in realP, realQ.\n    int realP = p, realQ = q;\n\n    // Make sure p, q are in [1, n] (clamp them, if needed).\n    auto clampToN = [&](int &x) {\n        if (x < 1) x = 1;\n        if (x > n) x = n;\n    };\n    clampToN(realP);\n    clampToN(realQ);\n\n    // If type == \"random\", pick p, q randomly from [1..n].\n    if (type == \"random\") {\n        realP = rnd.next(1, n);\n        realQ = rnd.next(1, n);\n    }\n    // If type == \"onlyp\", ensure n is a multiple of p. We'll ignore input p, q except p if user provided it, \n    // and adjust it to ensure it's in range. Then pick p so that n % p == 0. \n    if (type == \"onlyp\") {\n        // Reclamp p\n        clampToN(realP);\n        // force n % realP == 0 if possible\n        // if it isn't possible for the user-provided p, we can adjust it or brute force a p that divides n\n        if (n % realP != 0) {\n            // find a p that divides n\n            // smallest possible p is 1, largest is n\n            vector<int> divisors;\n            for (int cand = 1; cand <= n; cand++) {\n                if (n % cand == 0) divisors.push_back(cand);\n            }\n            // pick one randomly\n            if (!divisors.empty()) {\n                realP = divisors[rnd.next((int)divisors.size())];\n            } else {\n                // fallback, if we somehow can't find any divisor (shouldn't happen, 1 is always a divisor)\n                realP = 1;\n            }\n        }\n        // set q = 1.. ensure 1 <= q <= n\n        realQ = rnd.next(1, n);\n    }\n    // If type == \"onlyq\", ensure n is a multiple of q\n    if (type == \"onlyq\") {\n        clampToN(realQ);\n        if (n % realQ != 0) {\n            // find a q that divides n\n            vector<int> divisors;\n            for (int cand = 1; cand <= n; cand++) {\n                if (n % cand == 0) divisors.push_back(cand);\n            }\n            if (!divisors.empty()) {\n                realQ = divisors[rnd.next((int)divisors.size())];\n            } else {\n                realQ = 1;\n            }\n        }\n        // set p = something random\n        realP = rnd.next(1, n);\n    }\n    // If type == \"impossible\", pick p,q such that no combination of p,q can form n.\n    // We'll try some random picks until we find something that doesn't work, but we also\n    // must clamp them. We'll do up to 50 random tries.\n    if (type == \"impossible\") {\n        bool found = false;\n        for (int tries = 0; tries < 50 && !found; tries++) {\n            int candP = rnd.next(1, n);\n            int candQ = rnd.next(1, n);\n            if (impossibleToSplit(n, candP, candQ)) {\n                realP = candP;\n                realQ = candQ;\n                found = true;\n            }\n        }\n        // If not found, just forcibly pick something small that ensures impossibility for typical n > 1.\n        // For n = 1, it's impossible if p > 1 or q > 1, but we clamp to n. So for n=1, no combination is possible if p=2 or q=2 is out of range.\n        // We'll just do a fallback approach:\n        if (!found) {\n            // we try p=2, q=4 for example and check. But for n=3, that is indeed impossible.\n            // We'll ensure n > 1 to do that. If n=1, we do something else, but actually 1 can't be formed by 2 or 4.\n            // But 2 or 4 might be out of range if n=1. We'll just degrade to p=1, q=1 => that is in fact possible for n=1. \n            // So we can't do \"impossible\" for n=1. We'll do it anyway for demonstration.\n            if (n >= 3) {\n                // p=2, q=4 if that is still within [1..n], typically for n=3 that's impossible\n                realP = min(n, 2);\n                realQ = min(n, 4);\n                if (!impossibleToSplit(n, realP, realQ)) {\n                    // If it's not truly impossible, let's force a different approach:\n                    // We'll set p = n, q = n for n>1 => Then n can be formed by 1 piece => possible. \n                    // So that won't work. Let's do p=2, q=2 => that forms all pairs => if n is multiple of 2, it's possible. \n                    // This is tricky. Let's do p=2, q=3 => if n=1 or n=4 or n=5 or n=6, etc. might or might not be impossible.\n                    // We'll just forcibly pick something that doesn't work for n=3 or n=5, e.g. p=2, q=4 for n=5 => 2*i+4*j=5 is impossible.\n                    realP = 2;\n                    realQ = 4;\n                }\n            }\n        }\n    }\n    // If type == \"mixed\", we try to pick p,q so that n can be formed by some positive combination of them.\n    // e.g. p=2, q=3, n=7 => 2+2+3=7 => possible\n    // We'll do random picks until we find a combination that can form n.\n    if (type == \"mixed\") {\n        bool found = false;\n        for (int tries = 0; tries < 50 && !found; tries++) {\n            int candP = rnd.next(1, n);\n            int candQ = rnd.next(1, n);\n            // check if possible\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    if (candP * i + candQ * j == n) {\n                        realP = candP;\n                        realQ = candQ;\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n        }\n        // if we still didn't find, fallback to p=1, q=1 => always possible\n        if (!found) {\n            realP = 1;\n            realQ = 1;\n        }\n    }\n\n    // Make sure final p,q are in [1,n].\n    clampToN(realP);\n    clampToN(realQ);\n\n    // Generate random string s of length n\n    string s = genRandomString(n);\n\n    // Print\n    // First line: n, p, q\n    // Second line: s\n    cout << n << \" \" << realP << \" \" << realQ << \"\\n\";\n    cout << s << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll generate one test case per execution.\n// Usage examples (no random seed parameter!):\n//   ./gen -n 10 -type random\n//   ./gen -n 15 -p 2 -q 3 -type mixed\n//   ./gen -n 8 -p 1 -q 1 -type onlyp\n\n// Character set for the string: lowercase, uppercase, digits\nstatic const string CHARSET =\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n// Helper function to generate a random string of length len\n// using the specified CHARSET.\nstring genRandomString(int len) {\n    string s;\n    s.reserve(len);\n    for (int i = 0; i < len; i++) {\n        s.push_back(CHARSET[rnd.next((int)CHARSET.size())]);\n    }\n    return s;\n}\n\n// Ensure that (x, y) cannot represent n as x * i + y * j for any nonnegative i,j.\nbool impossibleToSplit(int n, int p, int q) {\n    // Check all i in [0..n], j in [0..n] -> if i*p + j*q == n\n    // If no combination yields n, it's impossible.\n    // Since n <= 100 in constraints, we can just brute force.\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i * p + j * q == n) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    // Register the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters with defaults.\n    // n is the length of the string.\n    // p, q can be forced or left unspecified. If they aren't provided, we do not default them to random immediately;\n    // we might compute them depending on the \"type\".\n    int n = opt<int>(\"n\", 10); // By default, 10\n    // p, q might not always be relevant if \"type\" is \"random\" - we'll handle that logic below.\n    // For safety, set a default of 1 each if they aren't passed:\n    int p = opt<int>(\"p\", 1);\n    int q = opt<int>(\"q\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Clamp n to [1, 100], just in case the user passes something out of bound.\n    if (n < 1) n = 1;\n    if (n > 100) n = 100;\n\n    // We will produce exactly one test case.\n\n    // Strategy:\n    // 1) Based on \"type\", we decide how to pick p, q, possibly ignoring user-provided p,q if \"type\" is random.\n    // 2) Generate a random string of length n from CHARSET.\n    // 3) Print n, p, q on a line.\n    // 4) Print that string on the next line.\n    // We do not check for correctness solutions or anything else; we just produce data.\n\n    // We'll store the final p, q in realP, realQ.\n    int realP = p, realQ = q;\n\n    // Make sure p, q are in [1, n] (clamp them, if needed).\n    auto clampToN = [&](int &x) {\n        if (x < 1) x = 1;\n        if (x > n) x = n;\n    };\n    clampToN(realP);\n    clampToN(realQ);\n\n    // If type == \"random\", pick p, q randomly from [1..n].\n    if (type == \"random\") {\n        realP = rnd.next(1, n);\n        realQ = rnd.next(1, n);\n    }\n    // If type == \"onlyp\", ensure n is a multiple of p. We'll ignore input p, q except p if user provided it, \n    // and adjust it to ensure it's in range. Then pick p so that n % p == 0. \n    if (type == \"onlyp\") {\n        // Reclamp p\n        clampToN(realP);\n        // force n % realP == 0 if possible\n        // if it isn't possible for the user-provided p, we can adjust it or brute force a p that divides n\n        if (n % realP != 0) {\n            // find a p that divides n\n            // smallest possible p is 1, largest is n\n            vector<int> divisors;\n            for (int cand = 1; cand <= n; cand++) {\n                if (n % cand == 0) divisors.push_back(cand);\n            }\n            // pick one randomly\n            if (!divisors.empty()) {\n                realP = divisors[rnd.next((int)divisors.size())];\n            } else {\n                // fallback, if we somehow can't find any divisor (shouldn't happen, 1 is always a divisor)\n                realP = 1;\n            }\n        }\n        // set q = 1.. ensure 1 <= q <= n\n        realQ = rnd.next(1, n);\n    }\n    // If type == \"onlyq\", ensure n is a multiple of q\n    if (type == \"onlyq\") {\n        clampToN(realQ);\n        if (n % realQ != 0) {\n            // find a q that divides n\n            vector<int> divisors;\n            for (int cand = 1; cand <= n; cand++) {\n                if (n % cand == 0) divisors.push_back(cand);\n            }\n            if (!divisors.empty()) {\n                realQ = divisors[rnd.next((int)divisors.size())];\n            } else {\n                realQ = 1;\n            }\n        }\n        // set p = something random\n        realP = rnd.next(1, n);\n    }\n    // If type == \"impossible\", pick p,q such that no combination of p,q can form n.\n    // We'll try some random picks until we find something that doesn't work, but we also\n    // must clamp them. We'll do up to 50 random tries.\n    if (type == \"impossible\") {\n        bool found = false;\n        for (int tries = 0; tries < 50 && !found; tries++) {\n            int candP = rnd.next(1, n);\n            int candQ = rnd.next(1, n);\n            if (impossibleToSplit(n, candP, candQ)) {\n                realP = candP;\n                realQ = candQ;\n                found = true;\n            }\n        }\n        // If not found, just forcibly pick something small that ensures impossibility for typical n > 1.\n        // For n = 1, it's impossible if p > 1 or q > 1, but we clamp to n. So for n=1, no combination is possible if p=2 or q=2 is out of range.\n        // We'll just do a fallback approach:\n        if (!found) {\n            // we try p=2, q=4 for example and check. But for n=3, that is indeed impossible.\n            // We'll ensure n > 1 to do that. If n=1, we do something else, but actually 1 can't be formed by 2 or 4.\n            // But 2 or 4 might be out of range if n=1. We'll just degrade to p=1, q=1 => that is in fact possible for n=1. \n            // So we can't do \"impossible\" for n=1. We'll do it anyway for demonstration.\n            if (n >= 3) {\n                // p=2, q=4 if that is still within [1..n], typically for n=3 that's impossible\n                realP = min(n, 2);\n                realQ = min(n, 4);\n                if (!impossibleToSplit(n, realP, realQ)) {\n                    // If it's not truly impossible, let's force a different approach:\n                    // We'll set p = n, q = n for n>1 => Then n can be formed by 1 piece => possible. \n                    // So that won't work. Let's do p=2, q=2 => that forms all pairs => if n is multiple of 2, it's possible. \n                    // This is tricky. Let's do p=2, q=3 => if n=1 or n=4 or n=5 or n=6, etc. might or might not be impossible.\n                    // We'll just forcibly pick something that doesn't work for n=3 or n=5, e.g. p=2, q=4 for n=5 => 2*i+4*j=5 is impossible.\n                    realP = 2;\n                    realQ = 4;\n                }\n            }\n        }\n    }\n    // If type == \"mixed\", we try to pick p,q so that n can be formed by some positive combination of them.\n    // e.g. p=2, q=3, n=7 => 2+2+3=7 => possible\n    // We'll do random picks until we find a combination that can form n.\n    if (type == \"mixed\") {\n        bool found = false;\n        for (int tries = 0; tries < 50 && !found; tries++) {\n            int candP = rnd.next(1, n);\n            int candQ = rnd.next(1, n);\n            // check if possible\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    if (candP * i + candQ * j == n) {\n                        realP = candP;\n                        realQ = candQ;\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n        }\n        // if we still didn't find, fallback to p=1, q=1 => always possible\n        if (!found) {\n            realP = 1;\n            realQ = 1;\n        }\n    }\n\n    // Make sure final p,q are in [1,n].\n    clampToN(realP);\n    clampToN(realQ);\n\n    // Generate random string s of length n\n    string s = genRandomString(n);\n\n    // Print\n    // First line: n, p, q\n    // Second line: s\n    cout << n << \" \" << realP << \" \" << realQ << \"\\n\";\n    cout << s << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are sample commands to run this generator with various parameters.\n# Each command prints exactly one test case to standard output.\n# We do NOT use \">\" to redirect output here.\n\n./gen -n 1 -type onlyp\n./gen -n 1 -type onlyq\n./gen -n 2 -p 1 -q 2 -type mixed\n./gen -n 3 -type impossible\n./gen -n 5 -p 2 -q 3 -type mixed\n./gen -n 5 -type random\n./gen -n 6 -p 3 -q 5 -type impossible\n./gen -n 7 -p 2 -q 2 -type mixed\n./gen -n 8 -p 1 -q 1 -type onlyp\n./gen -n 8 -p 1 -q 1 -type onlyq\n./gen -n 9 -type random\n./gen -n 10 -type random\n./gen -n 10 -p 2 -q 5 -type mixed\n./gen -n 12 -type impossible\n./gen -n 15 -type random\n./gen -n 15 -p 3 -q 6 -type mixed\n./gen -n 20 -type onlyp\n./gen -n 25 -type onlyq\n./gen -n 30 -type random\n./gen -n 30 -p 4 -q 5 -type mixed\n./gen -n 50 -type random\n./gen -n 50 -type impossible\n./gen -n 75 -type mixed\n./gen -n 100 -type random\n./gen -n 100 -p 10 -q 25 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:45.853046",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "612/B",
      "title": "B. HDD - устаревшая технология",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится целое положительное число n (1 ≤ n ≤ 2·105) — количество фрагментов файла.Во второй строке находятся n различных целых чисел fi (1 ≤ fi ≤ n) — номер фрагмента, записанного в i-м секторе.",
      "output_spec": "Выходные данныеВыведите одно целое число — количество единиц времени, необходимое для считывания файла.",
      "sample_tests": "ПримерыВходные данныеСкопировать33 1 2Выходные данныеСкопировать3Входные данныеСкопировать51 3 5 4 2Выходные данныеСкопировать10",
      "description": "B. HDD - устаревшая технология\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится целое положительное число n (1 ≤ n ≤ 2·105) — количество фрагментов файла.Во второй строке находятся n различных целых чисел fi (1 ≤ fi ≤ n) — номер фрагмента, записанного в i-м секторе.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — количество единиц времени, необходимое для считывания файла.\n\nВыходные данные\n\nВходные данныеСкопировать33 1 2Выходные данныеСкопировать3Входные данныеСкопировать51 3 5 4 2Выходные данныеСкопировать10\n\nВходные данныеСкопировать33 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 3 5 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере магнитная головка двигается следующим образом:  1->2: передвижение из сектора 1 в сектор 5 — требует 4 единицы времени  2->3: передвижение из сектора 5 в сектор 2 — требует 3 единицы времени  3->4: передвижение из сектора 2 в сектор 4 — требует 2 единицы времени  4->5: передвижение из сектора 4 в сектор 3 — требует 1 единицы времени Таким образом, ответ равен 4 + 3 + 2 + 1 = 10.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces",
          "content": "Привет, Codeforces!25 декабря 2015 года в 18:00 MSK состоится четвертый учебный раунд Educational Codeforces Round 4 для участников из первого и второго дивизионов. С прошлого учебного раунда в этот раз прошло всего ничего. Несмотря на то, что проведение раунда мы спланировали ещё в понедельник, мы почему-то забыли включить его в расписание, поэтому в расписании раунд только появился. Таким образом, это уже четвертый и последний в этом году учебный раунд.<Эти два абзаца может быть никогда не изменятся>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день в течении, которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.</Эти два абзаца может быть никогда не изменятся>Подготовкой задач в этот раз занимался только я (Эдвард Давтян). Пока благодарю, только MikeMirzayanov мы вместе придумывали задачи. Через некоторое время здесь появится благодарность тестеру. Также заранее благодарю Машу Белову Delinur, которая вычитает английские тексты условий, когда они появятся :-)На этом раунде вам по традиции будет предложено шесть задач. Думаю задачи в этот раз будут немного проще, чем обычно. Это связано с тем, что исходный комплект задач оказался чересчур сложным, поэтому мы убрали самую сложную задачу (она скорее всего будет самой сложной на следующем раунде) и добавили очень простую задачу. Надеюсь комплект задач вам понравится и вы решите все задачи!Поздравляю всех с наступающим новым годом!!!Good luck and have fun!UPD 1: Первая фаза соревнования закончена, ломайте решения соперников!UPD 2: Опубликован полный разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22262",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2039
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces",
          "content": "612A - Разбиение текстаПереберём количество строк длины p и q в ответе. Пусть это величины a и b. Если a·p + b·q = n, то посторим ответ, откусив с префикса сначала a раз строки длины p, а затем b раз строки длины q. Если ни одной подходящей пары a, b не нашлось, то ответа не существует. Конечно эту задачу можно решать и за линейное время, но здесь это не требовалось, поскольку ограничение на длину строки было маленьким.Асимптотическая сложность решения: O(n2).612B - HDD - устаревшая технологияВ условии задачи задана перестановка f. Построим по ней другую перестановку p следующим образом: pfi = i. Таким образом, перестановка p определяет номер сектора по номеру фрагмента. Перестановка p называется обратной к перестановке f и обозначается f - 1. Теперь ответ на задачу равен просто .Асимптотическая сложность решения: O(n).612C - Заменить до правильной скобочной последовательностиЗаметим, что поскольку мы не можем менять тип скобок, то для существования ответа необходимо, чтобы заданная строка была правильной скобочной последовательностью без учета вида скобок. Если это не так, то ответа не существует. Иначе каждой открывающей скобке соответствует ровно одна закрывающая, и каждой закрывающей — ровно одна открывающаяя. Теперь заметим, что если пара соответствующих друг другу скобок одного вида, то их мы можем не менять. Если же они разного вида, то поменяем вид закрывающей на вид открывающей. Таким образом, мы построим ответ. Легко убедиться, что ответ оптимальный, поскольку задачи для несоответствующих друг другу скобок не связаны друг с другом и могут быть рассмотрены по отдельности.Единственная техническая тонкость в том как найти соответствующие друг другу скобки. Для этого заведем стек открытых скобок. Теперь будем идти по строке слева направо и если скобка открывающая, то просто добавим ее в стек. Если же она закрывающая, то возникает три случая: 1) стек пуст; 2) вверху стека лежит открывающая скобка того же вида, что и текущая закрывающая; 3) вверху стека скобка вида отличного от текущего. В первом случае ответа не существует, во втором нужно просто выкинуть открывающую скобку из стека, а в третьем нужно выкинуть открывающую скобку из стека и увеличить ответ на единицу.Асимптотическая сложность решения: O(n).612D - Объединение k-подотрезковДля каждого отрезка создадим два события в момент li — открытие отрезка и в момент ri — закрытие отрезка. Отсортируем все события по моменту времени, при равенстве сначала будем обрабатывать события открытия отрезков. Это можно сделать, например, накидав в vector<pair<int, int>> events (пример для языка C++) пары момент времени и тип события ( - 1 для открытия и  + 1 для закрытия). Далее это массив можно отсортировать стандартным компаратором.Теперь будем идти по массиву events и считать баланс отрезков balance, для этого каждый раз нужно просто из баланса вычесть тип события. Теперь если баланс оказался равен k, а до этого был k - 1 значит мы стоим в левом конце отрезка из ответа, запомним этот левый конец (равный моменту текущего события) в переменную left и будем идти дальше. Если баланс оказался равен k - 1, а до этого был равен k значит мы обнаружили конец некоторого отрезка из ответа right. Добавим в ответ отрезок [left, right]. Таким образом, мы получим непересекающийся набор отрезков, содержащий все покрытые точки, в порядке слева направо. Очевидно он и является ответом на задачу.Асимптотическая сложность решения: O(nlogn).612E - Корень квадратный из перестановкиРассмотрим некоторую перестанову q. Построим по ней ориентированный граф дугами, которого будут (i, qi). Этот граф, как известно, представляет собой набор неперескающихся циклов. Теперь посмотрим, что происходит с этим графом при возведениии перестановки в квадрат: все циклы нечетной длины остаются таковыми (только порядок вершин меняется, происходит чередование через одну вершину), а циклы четной длины разбиваются на два цикла вдвое меньшей длины. Таким образом, чтобы найти корень из перестановки нужно оставить все циклы нечетный длины, прочередовав их в обратном от возведения в квадрат порядке, а циклы четной одинаковой длины нужно разбить на пары и слить в один цикл (если оказывается невозможным разбиение на пары, то ответа не существует).Асимптотическая сложность решения: O(n).612F - Робот на кольце Авторское решение по этой задаче основано на динамическом программировании. На мой взгляд никакие жадные идеи в этой задаче не работают. Для решения задачи будем считать две динамики z1i — ответ на задачу если все числа меньшие ai уже выведены, а больше либо равные еще нет; и z2i — ответ на задачу если все числа меньше либо равные ai уже выведены, а большие еще нет. Введем обозначение dij — кратчайшее расстояние от i до j на кольце и odij — расстояние от i до j если идти по часовой стрелке. Легко видеть, что z2i = minj(zj + dij), по всем j таким, что aj есть наименьшее число большее ai. Пусть теперь хотим посчитать значение z1i. Рассмотрим все элементы равные ai (в одном из них мы сейчас находимся). Если такой элементв один, то z1i = z2i. Иначе у нас есть два варианта обхода этих элементов: по или против часовой стрелки. Пусть мы идём по часовой стрелке, тогда последним мы выпишем число из ближайшего к i равный элемент против часов стрелке, пусть это элемент u. Иначе последним мы последним посетим ближайший к i элемент по часовой стрелке, пусть это элемент v. Тогда z1i = min(z2u + odiu, z2v + odvi). Теперь легко видеть, что ответ на задачу равен mini(z1i + dsi), по всем i таким, что ai есть наименьший элемент в массиве, а s есть стартовая позиция. Плюс к этому ко всему как усложнение в задаче нужно было восстановить ответ. В этих случаях, на мой взгляд, проще всего написать рекурсивную реализацию динамики (хорошо протестировать её на работоспособность), затем скопировать всю динамику на восстановление ответа (для деталей выкладываю свой код). Конечно это можно делать и без копипасты, например, передавая в динамику булеву величину нужно ли восстанавливать ответ.Асимптотическая сложность решения: O(n2).Code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22299",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 612\\s*B"
          },
          "content_length": 6020
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "q = [4, 5, 1, 2, 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 5",
          "code": "q = (1 4)(2 5)(3 1)(4 2)(5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 6",
          "code": "q = (1 4 2)(2 5)(3 1)(5 3) = (1 4 2 5)(3 1)(5 3) = (1 4 2 5 3)(3 1) =  (1 4 2 5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 7",
          "code": "q=(i1, i2, i3, i4, i5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 8",
          "code": "q^2=(i1, ..., i2, ...)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 9",
          "code": "q^2=(i1, i4, i2, i5, i3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 10",
          "code": "q^2 = (1 4 2 5 3)^2 = (1 2 3 4 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 11",
          "code": "p = [2 3 4 5 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 12",
          "code": "p = (i1, i2, i3, i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 13",
          "code": "p = (i1 i3)(i2 i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 14",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 15",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 16",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 17",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 18",
          "code": "3->2->4->1->3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 19",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 20",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> fi = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Ensure that all fi are distinct\n    set<int> s(fi.begin(), fi.end());\n    ensuref((int)s.size() == n, \"Numbers fi must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> fi = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Ensure that all fi are distinct\n    set<int> s(fi.begin(), fi.end());\n    ensuref((int)s.size() == n, \"Numbers fi must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> fi = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Ensure that all fi are distinct\n    set<int> s(fi.begin(), fi.end());\n    ensuref((int)s.size() == n, \"Numbers fi must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> fi(n + 1); // fi[1..n], fragment in sector i\n    if (type == \"in_order\") {\n        // Fragments are in sectors in order\n        for (int i = 1; i <= n; ++i)\n            fi[i] = i;\n    } else if (type == \"reverse_order\") {\n        // Fragments are in reverse order\n        for (int i = 1; i <= n; ++i)\n            fi[i] = n - i + 1;\n    } else if (type == \"max_move\") {\n        // Arrange fragments to maximize movement\n        vector<int> sector_positions;\n        int left = 1, right = n;\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 1) {\n                sector_positions.push_back(left++);\n            } else {\n                sector_positions.push_back(right--);\n            }\n        }\n        vector<int> sector_to_fragment(n + 1);\n        for (int i = 0; i < n; ++i) {\n            int sector = sector_positions[i];\n            int fragment = i + 1;\n            sector_to_fragment[sector] = fragment;\n        }\n        fi = sector_to_fragment;\n    } else if (type == \"zigzag\") {\n        // Fragments placed in a zigzag manner\n        int mid = (n + 1) / 2;\n        vector<int> sectors_left, sectors_right;\n        for (int i = 1; i <= n; ++i) {\n            if (i <= mid)\n                sectors_left.push_back(i);\n            else\n                sectors_right.push_back(i);\n        }\n        reverse(sectors_right.begin(), sectors_right.end());\n        vector<int> sectors;\n        for (size_t i = 0; i < sectors_left.size(); ++i) {\n            sectors.push_back(sectors_left[i]);\n            if (i < sectors_right.size())\n                sectors.push_back(sectors_right[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            fi[sectors[i]] = i + 1;\n        }\n    } else if (type == \"small_n\") {\n        // Small n, random permutation\n        n = min(n, 10);\n        for (int i = 1; i <= n; ++i)\n            fi[i] = i;\n        shuffle(fi.begin() + 1, fi.begin() + n + 1);\n    } else {\n        // Random permutation\n        for (int i = 1; i <= n; ++i)\n            fi[i] = i;\n        shuffle(fi.begin() + 1, fi.begin() + n + 1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", fi[i]);\n        if (i < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> fi(n + 1); // fi[1..n], fragment in sector i\n    if (type == \"in_order\") {\n        // Fragments are in sectors in order\n        for (int i = 1; i <= n; ++i)\n            fi[i] = i;\n    } else if (type == \"reverse_order\") {\n        // Fragments are in reverse order\n        for (int i = 1; i <= n; ++i)\n            fi[i] = n - i + 1;\n    } else if (type == \"max_move\") {\n        // Arrange fragments to maximize movement\n        vector<int> sector_positions;\n        int left = 1, right = n;\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 1) {\n                sector_positions.push_back(left++);\n            } else {\n                sector_positions.push_back(right--);\n            }\n        }\n        vector<int> sector_to_fragment(n + 1);\n        for (int i = 0; i < n; ++i) {\n            int sector = sector_positions[i];\n            int fragment = i + 1;\n            sector_to_fragment[sector] = fragment;\n        }\n        fi = sector_to_fragment;\n    } else if (type == \"zigzag\") {\n        // Fragments placed in a zigzag manner\n        int mid = (n + 1) / 2;\n        vector<int> sectors_left, sectors_right;\n        for (int i = 1; i <= n; ++i) {\n            if (i <= mid)\n                sectors_left.push_back(i);\n            else\n                sectors_right.push_back(i);\n        }\n        reverse(sectors_right.begin(), sectors_right.end());\n        vector<int> sectors;\n        for (size_t i = 0; i < sectors_left.size(); ++i) {\n            sectors.push_back(sectors_left[i]);\n            if (i < sectors_right.size())\n                sectors.push_back(sectors_right[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            fi[sectors[i]] = i + 1;\n        }\n    } else if (type == \"small_n\") {\n        // Small n, random permutation\n        n = min(n, 10);\n        for (int i = 1; i <= n; ++i)\n            fi[i] = i;\n        shuffle(fi.begin() + 1, fi.begin() + n + 1);\n    } else {\n        // Random permutation\n        for (int i = 1; i <= n; ++i)\n            fi[i] = i;\n        shuffle(fi.begin() + 1, fi.begin() + n + 1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", fi[i]);\n        if (i < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type in_order\n./gen -n 1 -type reverse_order\n./gen -n 1 -type random\n./gen -n 2 -type in_order\n./gen -n 2 -type reverse_order\n./gen -n 2 -type max_move\n\n./gen -n 10 -type in_order\n./gen -n 10 -type reverse_order\n./gen -n 10 -type max_move\n./gen -n 10 -type random\n\n./gen -n 100 -type in_order\n./gen -n 100 -type reverse_order\n./gen -n 100 -type max_move\n./gen -n 100 -type zigzag\n./gen -n 100 -type random\n\n./gen -n 1000 -type reverse_order\n./gen -n 1000 -type max_move\n./gen -n 1000 -type random\n\n./gen -n 100000 -type in_order\n./gen -n 100000 -type reverse_order\n./gen -n 100000 -type max_move\n./gen -n 100000 -type random\n\n./gen -n 200000 -type in_order\n./gen -n 200000 -type reverse_order\n./gen -n 200000 -type max_move\n./gen -n 200000 -type random\n\n./gen -n 200000 -type zigzag\n\n./gen -n 200000 -type small_n\n\n./gen -n 199999 -type max_move\n\n./gen -n 199998 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:47.533715",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "612/C",
      "title": "C. Заменить до правильной скобочной последовательности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеЕдинственная строка содержит непустую строку s, состоящую только из открывающих и закрывающих скобок, заданных четырех видов. Длина строки s не превосходит 106.",
      "output_spec": "Выходные данныеЕсли получить правильную скобочную последовательность из строки s невозможно выведите слово Impossible.Иначе выведите наименьшее количество замен, необходимое для получения правильной скобочной последовательности из строки s.",
      "sample_tests": "ПримерыВходные данныеСкопировать[<}){}Выходные данныеСкопировать2Входные данныеСкопировать{()}[]Выходные данныеСкопировать0Входные данныеСкопировать]]Выходные данныеСкопироватьImpossible",
      "description": "C. Заменить до правильной скобочной последовательности\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеЕдинственная строка содержит непустую строку s, состоящую только из открывающих и закрывающих скобок, заданных четырех видов. Длина строки s не превосходит 106.\n\nВходные данные\n\nВыходные данныеЕсли получить правильную скобочную последовательность из строки s невозможно выведите слово Impossible.Иначе выведите наименьшее количество замен, необходимое для получения правильной скобочной последовательности из строки s.\n\nВыходные данные\n\nВходные данныеСкопировать[<}){}Выходные данныеСкопировать2Входные данныеСкопировать{()}[]Выходные данныеСкопировать0Входные данныеСкопировать]]Выходные данныеСкопироватьImpossible\n\nВходные данныеСкопировать[<}){}\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать{()}[]\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать]]\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces",
          "content": "Привет, Codeforces!25 декабря 2015 года в 18:00 MSK состоится четвертый учебный раунд Educational Codeforces Round 4 для участников из первого и второго дивизионов. С прошлого учебного раунда в этот раз прошло всего ничего. Несмотря на то, что проведение раунда мы спланировали ещё в понедельник, мы почему-то забыли включить его в расписание, поэтому в расписании раунд только появился. Таким образом, это уже четвертый и последний в этом году учебный раунд.<Эти два абзаца может быть никогда не изменятся>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день в течении, которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.</Эти два абзаца может быть никогда не изменятся>Подготовкой задач в этот раз занимался только я (Эдвард Давтян). Пока благодарю, только MikeMirzayanov мы вместе придумывали задачи. Через некоторое время здесь появится благодарность тестеру. Также заранее благодарю Машу Белову Delinur, которая вычитает английские тексты условий, когда они появятся :-)На этом раунде вам по традиции будет предложено шесть задач. Думаю задачи в этот раз будут немного проще, чем обычно. Это связано с тем, что исходный комплект задач оказался чересчур сложным, поэтому мы убрали самую сложную задачу (она скорее всего будет самой сложной на следующем раунде) и добавили очень простую задачу. Надеюсь комплект задач вам понравится и вы решите все задачи!Поздравляю всех с наступающим новым годом!!!Good luck and have fun!UPD 1: Первая фаза соревнования закончена, ломайте решения соперников!UPD 2: Опубликован полный разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22262",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2039
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces",
          "content": "612A - Разбиение текстаПереберём количество строк длины p и q в ответе. Пусть это величины a и b. Если a·p + b·q = n, то посторим ответ, откусив с префикса сначала a раз строки длины p, а затем b раз строки длины q. Если ни одной подходящей пары a, b не нашлось, то ответа не существует. Конечно эту задачу можно решать и за линейное время, но здесь это не требовалось, поскольку ограничение на длину строки было маленьким.Асимптотическая сложность решения: O(n2).612B - HDD - устаревшая технологияВ условии задачи задана перестановка f. Построим по ней другую перестановку p следующим образом: pfi = i. Таким образом, перестановка p определяет номер сектора по номеру фрагмента. Перестановка p называется обратной к перестановке f и обозначается f - 1. Теперь ответ на задачу равен просто .Асимптотическая сложность решения: O(n).612C - Заменить до правильной скобочной последовательностиЗаметим, что поскольку мы не можем менять тип скобок, то для существования ответа необходимо, чтобы заданная строка была правильной скобочной последовательностью без учета вида скобок. Если это не так, то ответа не существует. Иначе каждой открывающей скобке соответствует ровно одна закрывающая, и каждой закрывающей — ровно одна открывающаяя. Теперь заметим, что если пара соответствующих друг другу скобок одного вида, то их мы можем не менять. Если же они разного вида, то поменяем вид закрывающей на вид открывающей. Таким образом, мы построим ответ. Легко убедиться, что ответ оптимальный, поскольку задачи для несоответствующих друг другу скобок не связаны друг с другом и могут быть рассмотрены по отдельности.Единственная техническая тонкость в том как найти соответствующие друг другу скобки. Для этого заведем стек открытых скобок. Теперь будем идти по строке слева направо и если скобка открывающая, то просто добавим ее в стек. Если же она закрывающая, то возникает три случая: 1) стек пуст; 2) вверху стека лежит открывающая скобка того же вида, что и текущая закрывающая; 3) вверху стека скобка вида отличного от текущего. В первом случае ответа не существует, во втором нужно просто выкинуть открывающую скобку из стека, а в третьем нужно выкинуть открывающую скобку из стека и увеличить ответ на единицу.Асимптотическая сложность решения: O(n).612D - Объединение k-подотрезковДля каждого отрезка создадим два события в момент li — открытие отрезка и в момент ri — закрытие отрезка. Отсортируем все события по моменту времени, при равенстве сначала будем обрабатывать события открытия отрезков. Это можно сделать, например, накидав в vector<pair<int, int>> events (пример для языка C++) пары момент времени и тип события ( - 1 для открытия и  + 1 для закрытия). Далее это массив можно отсортировать стандартным компаратором.Теперь будем идти по массиву events и считать баланс отрезков balance, для этого каждый раз нужно просто из баланса вычесть тип события. Теперь если баланс оказался равен k, а до этого был k - 1 значит мы стоим в левом конце отрезка из ответа, запомним этот левый конец (равный моменту текущего события) в переменную left и будем идти дальше. Если баланс оказался равен k - 1, а до этого был равен k значит мы обнаружили конец некоторого отрезка из ответа right. Добавим в ответ отрезок [left, right]. Таким образом, мы получим непересекающийся набор отрезков, содержащий все покрытые точки, в порядке слева направо. Очевидно он и является ответом на задачу.Асимптотическая сложность решения: O(nlogn).612E - Корень квадратный из перестановкиРассмотрим некоторую перестанову q. Построим по ней ориентированный граф дугами, которого будут (i, qi). Этот граф, как известно, представляет собой набор неперескающихся циклов. Теперь посмотрим, что происходит с этим графом при возведениии перестановки в квадрат: все циклы нечетной длины остаются таковыми (только порядок вершин меняется, происходит чередование через одну вершину), а циклы четной длины разбиваются на два цикла вдвое меньшей длины. Таким образом, чтобы найти корень из перестановки нужно оставить все циклы нечетный длины, прочередовав их в обратном от возведения в квадрат порядке, а циклы четной одинаковой длины нужно разбить на пары и слить в один цикл (если оказывается невозможным разбиение на пары, то ответа не существует).Асимптотическая сложность решения: O(n).612F - Робот на кольце Авторское решение по этой задаче основано на динамическом программировании. На мой взгляд никакие жадные идеи в этой задаче не работают. Для решения задачи будем считать две динамики z1i — ответ на задачу если все числа меньшие ai уже выведены, а больше либо равные еще нет; и z2i — ответ на задачу если все числа меньше либо равные ai уже выведены, а большие еще нет. Введем обозначение dij — кратчайшее расстояние от i до j на кольце и odij — расстояние от i до j если идти по часовой стрелке. Легко видеть, что z2i = minj(zj + dij), по всем j таким, что aj есть наименьшее число большее ai. Пусть теперь хотим посчитать значение z1i. Рассмотрим все элементы равные ai (в одном из них мы сейчас находимся). Если такой элементв один, то z1i = z2i. Иначе у нас есть два варианта обхода этих элементов: по или против часовой стрелки. Пусть мы идём по часовой стрелке, тогда последним мы выпишем число из ближайшего к i равный элемент против часов стрелке, пусть это элемент u. Иначе последним мы последним посетим ближайший к i элемент по часовой стрелке, пусть это элемент v. Тогда z1i = min(z2u + odiu, z2v + odvi). Теперь легко видеть, что ответ на задачу равен mini(z1i + dsi), по всем i таким, что ai есть наименьший элемент в массиве, а s есть стартовая позиция. Плюс к этому ко всему как усложнение в задаче нужно было восстановить ответ. В этих случаях, на мой взгляд, проще всего написать рекурсивную реализацию динамики (хорошо протестировать её на работоспособность), затем скопировать всю динамику на восстановление ответа (для деталей выкладываю свой код). Конечно это можно делать и без копипасты, например, передавая в динамику булеву величину нужно ли восстанавливать ответ.Асимптотическая сложность решения: O(n2).Code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22299",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 612\\s*C"
          },
          "content_length": 6020
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "q = [4, 5, 1, 2, 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 5",
          "code": "q = (1 4)(2 5)(3 1)(4 2)(5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 6",
          "code": "q = (1 4 2)(2 5)(3 1)(5 3) = (1 4 2 5)(3 1)(5 3) = (1 4 2 5 3)(3 1) =  (1 4 2 5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 7",
          "code": "q=(i1, i2, i3, i4, i5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 8",
          "code": "q^2=(i1, ..., i2, ...)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 9",
          "code": "q^2=(i1, i4, i2, i5, i3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 10",
          "code": "q^2 = (1 4 2 5 3)^2 = (1 2 3 4 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 11",
          "code": "p = [2 3 4 5 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 12",
          "code": "p = (i1, i2, i3, i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 13",
          "code": "p = (i1 i3)(i2 i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 14",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 15",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 16",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 17",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 18",
          "code": "3->2->4->1->3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 19",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 4 - Codeforces - Code 20",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[<>{}\\\\[\\\\]\\\\(\\\\)]{1,1000000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[<>{}\\\\[\\\\]\\\\(\\\\)]{1,1000000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[<>{}\\\\[\\\\]\\\\(\\\\)]{1,1000000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Define opening and closing brackets\n    vector<char> openingBrackets = {'<', '{', '[', '('};\n    vector<char> closingBrackets = {'>', '}', ']', ')'};\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"RBS\") {\n        // Generate a valid Regular Bracket Sequence (RBS)\n\n        vector<char> stack;\n        int total_length = 0;\n\n        while (total_length < n) {\n            if (stack.empty() || (rnd.next(0, 1) == 0 && total_length + (int)stack.size() < n)) {\n                // Push an opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n                stack.push_back(ob);\n                total_length++;\n            } else {\n                // Add a closing bracket\n                char ob = stack.back();\n                stack.pop_back();\n                int idx = find(openingBrackets.begin(), openingBrackets.end(), ob) - openingBrackets.begin();\n                char cb = closingBrackets[idx];\n                s.push_back(cb);\n                total_length++;\n            }\n        }\n\n        // Close any remaining brackets if total_length < n\n        while (!stack.empty() && total_length < n) {\n            char ob = stack.back();\n            stack.pop_back();\n            int idx = find(openingBrackets.begin(), openingBrackets.end(), ob) - openingBrackets.begin();\n            char cb = closingBrackets[idx];\n            s.push_back(cb);\n            total_length++;\n        }\n\n    } else if (type == \"Random\") {\n        // Generate a random sequence of brackets of length n\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1); // 0 for opening, 1 for closing\n            if (t == 0) {\n                // Opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n            } else {\n                // Closing bracket\n                char cb = closingBrackets[rnd.next(0, 3)];\n                s.push_back(cb);\n            }\n        }\n\n    } else if (type == \"Impossible\") {\n        // Generate a sequence that cannot be transformed into RBS\n        // Create a sequence with imbalance in opening and closing brackets\n        int numOpening = n / 2 + 1;\n        int numClosing = n - numOpening;\n        s = \"\";\n        for (int i = 0; i < numOpening; ++i) {\n            char ob = openingBrackets[rnd.next(0, 3)];\n            s.push_back(ob);\n        }\n        for (int i = 0; i < numClosing; ++i) {\n            char cb = closingBrackets[rnd.next(0, 3)];\n            s.push_back(cb);\n        }\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"AllOpening\") {\n        // Generate a sequence of only opening brackets\n        for (int i = 0; i < n; ++i) {\n            char ob = openingBrackets[rnd.next(0, 3)];\n            s.push_back(ob);\n        }\n    } else if (type == \"AllClosing\") {\n        // Generate a sequence of only closing brackets\n        for (int i = 0; i < n; ++i) {\n            char cb = closingBrackets[rnd.next(0, 3)];\n            s.push_back(cb);\n        }\n    } else if (type == \"StartsWithClosing\") {\n        // Generate a sequence that starts with closing brackets\n        int numClosing = n / 2 + rnd.next(0, n / 2);\n        int numOpening = n - numClosing;\n        s = \"\";\n        for (int i = 0; i < numClosing; ++i) {\n            char cb = closingBrackets[rnd.next(0, 3)];\n            s.push_back(cb);\n        }\n        for (int i = 0; i < numOpening; ++i) {\n            char ob = openingBrackets[rnd.next(0, 3)];\n            s.push_back(ob);\n        }\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"UnmatchedPairs\") {\n        // Generate a sequence with unmatched pairs that require replacements\n        vector<char> unmatched;\n        for (int i = 0; i < n / 2; ++i) {\n            // Add unmatched pairs\n            char ob = openingBrackets[rnd.next(0,3)];\n            char cb;\n            do {\n                cb = closingBrackets[rnd.next(0,3)];\n            } while (cb == closingBrackets[find(openingBrackets.begin(), openingBrackets.end(), ob) - openingBrackets.begin()]);\n            s.push_back(ob);\n            s.push_back(cb);\n        }\n        if (n % 2 != 0) {\n            // Add an extra bracket\n            int t = rnd.next(0, 1); // 0 for opening, 1 for closing\n            if (t == 0) {\n                // Opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n            } else {\n                // Closing bracket\n                char cb = closingBrackets[rnd.next(0, 3)];\n                s.push_back(cb);\n            }\n        }\n        shuffle(s.begin(), s.end());\n\n    } else {\n        // Default: random sequence\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1); // 0 for opening, 1 for closing\n            if (t == 0) {\n                // Opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n            } else {\n                // Closing bracket\n                char cb = closingBrackets[rnd.next(0, 3)];\n                s.push_back(cb);\n            }\n        }\n    }\n\n    // Output the generated sequence\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Define opening and closing brackets\n    vector<char> openingBrackets = {'<', '{', '[', '('};\n    vector<char> closingBrackets = {'>', '}', ']', ')'};\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"RBS\") {\n        // Generate a valid Regular Bracket Sequence (RBS)\n\n        vector<char> stack;\n        int total_length = 0;\n\n        while (total_length < n) {\n            if (stack.empty() || (rnd.next(0, 1) == 0 && total_length + (int)stack.size() < n)) {\n                // Push an opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n                stack.push_back(ob);\n                total_length++;\n            } else {\n                // Add a closing bracket\n                char ob = stack.back();\n                stack.pop_back();\n                int idx = find(openingBrackets.begin(), openingBrackets.end(), ob) - openingBrackets.begin();\n                char cb = closingBrackets[idx];\n                s.push_back(cb);\n                total_length++;\n            }\n        }\n\n        // Close any remaining brackets if total_length < n\n        while (!stack.empty() && total_length < n) {\n            char ob = stack.back();\n            stack.pop_back();\n            int idx = find(openingBrackets.begin(), openingBrackets.end(), ob) - openingBrackets.begin();\n            char cb = closingBrackets[idx];\n            s.push_back(cb);\n            total_length++;\n        }\n\n    } else if (type == \"Random\") {\n        // Generate a random sequence of brackets of length n\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1); // 0 for opening, 1 for closing\n            if (t == 0) {\n                // Opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n            } else {\n                // Closing bracket\n                char cb = closingBrackets[rnd.next(0, 3)];\n                s.push_back(cb);\n            }\n        }\n\n    } else if (type == \"Impossible\") {\n        // Generate a sequence that cannot be transformed into RBS\n        // Create a sequence with imbalance in opening and closing brackets\n        int numOpening = n / 2 + 1;\n        int numClosing = n - numOpening;\n        s = \"\";\n        for (int i = 0; i < numOpening; ++i) {\n            char ob = openingBrackets[rnd.next(0, 3)];\n            s.push_back(ob);\n        }\n        for (int i = 0; i < numClosing; ++i) {\n            char cb = closingBrackets[rnd.next(0, 3)];\n            s.push_back(cb);\n        }\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"AllOpening\") {\n        // Generate a sequence of only opening brackets\n        for (int i = 0; i < n; ++i) {\n            char ob = openingBrackets[rnd.next(0, 3)];\n            s.push_back(ob);\n        }\n    } else if (type == \"AllClosing\") {\n        // Generate a sequence of only closing brackets\n        for (int i = 0; i < n; ++i) {\n            char cb = closingBrackets[rnd.next(0, 3)];\n            s.push_back(cb);\n        }\n    } else if (type == \"StartsWithClosing\") {\n        // Generate a sequence that starts with closing brackets\n        int numClosing = n / 2 + rnd.next(0, n / 2);\n        int numOpening = n - numClosing;\n        s = \"\";\n        for (int i = 0; i < numClosing; ++i) {\n            char cb = closingBrackets[rnd.next(0, 3)];\n            s.push_back(cb);\n        }\n        for (int i = 0; i < numOpening; ++i) {\n            char ob = openingBrackets[rnd.next(0, 3)];\n            s.push_back(ob);\n        }\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"UnmatchedPairs\") {\n        // Generate a sequence with unmatched pairs that require replacements\n        vector<char> unmatched;\n        for (int i = 0; i < n / 2; ++i) {\n            // Add unmatched pairs\n            char ob = openingBrackets[rnd.next(0,3)];\n            char cb;\n            do {\n                cb = closingBrackets[rnd.next(0,3)];\n            } while (cb == closingBrackets[find(openingBrackets.begin(), openingBrackets.end(), ob) - openingBrackets.begin()]);\n            s.push_back(ob);\n            s.push_back(cb);\n        }\n        if (n % 2 != 0) {\n            // Add an extra bracket\n            int t = rnd.next(0, 1); // 0 for opening, 1 for closing\n            if (t == 0) {\n                // Opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n            } else {\n                // Closing bracket\n                char cb = closingBrackets[rnd.next(0, 3)];\n                s.push_back(cb);\n            }\n        }\n        shuffle(s.begin(), s.end());\n\n    } else {\n        // Default: random sequence\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 1); // 0 for opening, 1 for closing\n            if (t == 0) {\n                // Opening bracket\n                char ob = openingBrackets[rnd.next(0, 3)];\n                s.push_back(ob);\n            } else {\n                // Closing bracket\n                char cb = closingBrackets[rnd.next(0, 3)];\n                s.push_back(cb);\n            }\n        }\n    }\n\n    // Output the generated sequence\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small size RBS sequences\n./gen -n 2 -type RBS\n./gen -n 5 -type RBS\n./gen -n 10 -type RBS\n\n# Random sequences of small sizes\n./gen -n 2 -type Random\n./gen -n 5 -type Random\n./gen -n 10 -type Random\n\n# Impossible sequences of small sizes\n./gen -n 3 -type Impossible\n./gen -n 5 -type Impossible\n./gen -n 7 -type Impossible\n\n# All opening brackets\n./gen -n 10 -type AllOpening\n./gen -n 100 -type AllOpening\n\n# All closing brackets\n./gen -n 10 -type AllClosing\n./gen -n 100 -type AllClosing\n\n# Sequences starting with closing brackets\n./gen -n 10 -type StartsWithClosing\n./gen -n 100 -type StartsWithClosing\n\n# Unmatched pairs requiring replacements\n./gen -n 10 -type UnmatchedPairs\n./gen -n 100 -type UnmatchedPairs\n\n# Large size RBS sequences\n./gen -n 1000 -type RBS\n./gen -n 10000 -type RBS\n./gen -n 100000 -type RBS\n./gen -n 1000000 -type RBS\n\n# Random sequences of large sizes\n./gen -n 1000 -type Random\n./gen -n 10000 -type Random\n./gen -n 100000 -type Random\n./gen -n 1000000 -type Random\n\n# Impossible sequences of large sizes\n./gen -n 1001 -type Impossible\n./gen -n 10001 -type Impossible\n./gen -n 100001 -type Impossible\n./gen -n 1000001 -type Impossible\n\n# Edge cases\n./gen -n 1 -type RBS\n./gen -n 1 -type Random\n./gen -n 1 -type Impossible\n\n# Sequences of maximum allowed length\n./gen -n 1000000 -type AllOpening\n./gen -n 1000000 -type AllClosing\n\n# Sequences with equal number of opening and closing brackets but impossible to balance\n./gen -n 1000 -type StartsWithClosing\n./gen -n 1000 -type UnmatchedPairs\n\n# Random sequences with n being an odd number\n./gen -n 999 -type Random\n./gen -n 9999 -type Random\n./gen -n 99999 -type Random\n\n# Sequences requiring minimal changes to become RBS\n./gen -n 1000 -type UnmatchedPairs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:49.553270",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "612/D",
      "title": "D. The Union of k-Segments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 106) — the number of segments and the value of k.The next n lines contain two integers li, ri ( - 109 ≤ li ≤ ri ≤ 109) each — the endpoints of the i-th segment. The segments can degenerate and intersect each other. The segments are given in arbitrary order.",
      "output_spec": "OutputFirst line contains integer m — the smallest number of segments.Next m lines contain two integers aj, bj (aj ≤ bj) — the ends of j-th segment in the answer. The segments should be listed in the order from left to right.",
      "sample_tests": "ExamplesInputCopy3 20 5-3 23 8OutputCopy20 23 5InputCopy3 20 5-3 33 8OutputCopy10 5",
      "description": "D. The Union of k-Segments\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 106) — the number of segments and the value of k.The next n lines contain two integers li, ri ( - 109 ≤ li ≤ ri ≤ 109) each — the endpoints of the i-th segment. The segments can degenerate and intersect each other. The segments are given in arbitrary order.\n\nOutputFirst line contains integer m — the smallest number of segments.Next m lines contain two integers aj, bj (aj ≤ bj) — the ends of j-th segment in the answer. The segments should be listed in the order from left to right.\n\nInputCopy3 20 5-3 23 8OutputCopy20 23 5InputCopy3 20 5-3 33 8OutputCopy10 5\n\nInputCopy3 20 5-3 23 8\n\nOutputCopy20 23 5\n\nInputCopy3 20 5-3 33 8\n\nOutputCopy10 5",
      "solutions": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces",
          "content": "Hi, Codeforces!Educational Codeforces Round 4 will take place on 25 December 2015 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here. This time a little time has passed since the previous round. Although we planned this round at Monday, we forgot to include it to schedule, so it was appeared only now. So it is the fourth and the last educational round this year.<Maybe this paragraph will not be changed ever>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</Maybe this paragraph will not be changed ever>This time the round was prepared only by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements, when they will be ready :-)I think this time the problems is simpler than usually, because at first we have too hard problemset and removed the hardest problem and added very simple problem. I hope you will enjoy the problems and solve all of them!Also I want to wish you Happy New Year!!!Good luck and have fun!UPD 1: The first phase is ended, hack the solutions of your opponents!UPD 2: The editorial is ready.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22262",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1394
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces",
          "content": "612A - The Text SplittingLet's fix the number a of strings of length p and the number b of strings of length q. If a·p + b·q = n, we can build the answer by splitting the string s to a parts of the length p and b parts of the length q, in order from left to right. If we can't find any good pair a, b then the answer doesn't exist. Of course this problem can be solved in linear time, but the constraints are small, so you don't need linear solution.Complexity: O(n2).612B - HDD is Outdated TechnologyYou are given the permutation f. Let's build another permutation p in the following way: pfi = i. So the permutation p defines the number of sector by the number of fragment. The permutation p is called inverse permutation to f and denoted f - 1. Now the answer to problem is .Complexity: O(n).612C - Replace To Make Regular Bracket SequenceIf we forget about bracket kinds the string s should be RBS, otherwise the answer doesn't exist. If the answer exists each opening bracket matches to exactly one closing bracket and vice verse. Easy to see that if two matching brackets have the same kind we don't need to replace them. In other case we can change the kind of the closing bracket to the kind of the opening. So we can build some answer. Obviously the answer is minimal, because the problems for some pair of matching pairs are independent and can be solved separately.The only technical problem is to find the matching pairs. To do that we should store the stack of opening brackets. Let's iterate from left to right in s and if the bracket is opening, we would simply add it to the stack. Now if the bracket is closing there are three cases: 1) the stack is empty; 2) at the top of the stack is the opening bracket with the same kind as the current closing; 3) the kind of the opening bracket differs from the kind of the closing bracket. In the first case answer doesn't exist, in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one.Complexity: O(n).612D - The Union of k-SegmentsLet's create two events for each segment li is the time of the segment opening and ri is the time of the segment closing. Let's sort all events by time, if the times are equal let's sort them with priority to opening events. In C++ it can be done with sorting by standard comparator of vector<pair<int, int>> events, where each element of events is the pair with event time and event type ( - 1 for opening and  + 1 for closing).Let's iterate over events and maintain the balance. To do that we should simply decrease the balance by the value of the event type. Now if the balance value equals to k and before updating it was k - 1 then we are in the left end of some segment from the answer. If the balance equals to k - 1 and before updating it was k then we are in the right end of the segment from the answer. Let's simply add segment [left, right] to the answer. So now we have disjoint set of segments contains all satisfied points in order from left to right. Obviously it's the answer to the problem.Complexity: O(nlogn).612E - Square Root of PermutationConsider some permutation q. Let's build by it the oriented graph with edges (i, qi). Easy to see (and easy to prove) that this graph is the set of disjoint cycles. Now let's see what would be with that graph when the permutation will be multiplied by itself: all the cycles of odd length would remain so (only the order of vertices will change, they will be alternated), but the cycles of even length will be split to the two cycles of the same length. So to get the square root from the permutation we should simply alternate (in reverse order) all cycles of the odd length, and group all the cycles of the same even length to pairs and merge cycles in each pair. If it's impossible to group all even cycles to pairs then the answer doesn't exist.Complexity: O(n).612F - Simba on the Circle The author solution for this problem uses dynamic programming. I think that this problem can't be solved by greedy ideas. Let's calculate two dp's: z1i is the answer to the problem if all numbers less than ai are already printed, but the others are not; and z2i is the answer to the problem if all numbers less than or equal to ai are already printed, but the others are not. Let's denote dij — the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order. Easy to see that z2i = minj(zj + dij) for all j such that the value aj is the least value greater than ai. Now let's calculate the value z1i. Consider all elements equals to ai (in one of them we are). If there is only one such element then z1i = z2i. Otherwise we have two alternatives: to move in clockwise or counterclockwise direction. Let we are moving in clockwise direction, the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction, let's denote it u. Otherwise at last we will write out the number from the nearest to the i element in clockwise direction, let's denote it v. Now z1i = min(z2u + odiu, z2v + odvi). Easy to see that the answer to the problem is mini(z1i + dsi), over all i such that ai is the smallest value in array and s is the start position.Additionally you should restore the answer. To do that, on my mind, the simplest way is to write the recursive realization of dp, test it carefully and then copy it to restore answer (see my code below). Of course, it's possible to restore the answer without copy-paste. For example, you can add to your dp parameter b which means it's need to restore answer or not.Complexity: O(n2).Code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22299",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 612\\s*D"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "q = [4, 5, 1, 2, 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 5",
          "code": "q = (1 4)(2 5)(3 1)(4 2)(5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 6",
          "code": "q = (1 4 2)(2 5)(3 1)(5 3) = (1 4 2 5)(3 1)(5 3) = (1 4 2 5 3)(3 1) =  (1 4 2 5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 7",
          "code": "q=(i1, i2, i3, i4, i5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 8",
          "code": "q^2=(i1, ..., i2, ...)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 9",
          "code": "q^2=(i1, i4, i2, i5, i3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 10",
          "code": "q^2 = (1 4 2 5 3)^2 = (1 2 3 4 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 11",
          "code": "p = [2 3 4 5 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 12",
          "code": "p = (i1, i2, i3, i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 13",
          "code": "p = (i1 i3)(i2 i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 14",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 15",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 16",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 17",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 18",
          "code": "3->2->4->1->3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 19",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 20",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(-1000000000, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(-1000000000, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(-1000000000, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<pair<int,int>> segments;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(-1000000000, 1000000000);\n            int r = rnd.next(-1000000000, 1000000000);\n            if (l > r) swap(l, r);\n            segments.emplace_back(l, r);\n        }\n    } else if (type == \"full_overlap\") {\n        int l = rnd.next(-1000000000, 1000000000);\n        int r = rnd.next(l, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            segments.emplace_back(l, r);\n        }\n    } else if (type == \"no_overlap\") {\n        int l = -1000000000;\n        int segment_length = 1;\n        for (int i = 0; i < n; ++i) {\n            int left = l + i * segment_length * 2;\n            int right = left + segment_length;\n            segments.emplace_back(left, right);\n        }\n        shuffle(segments.begin(), segments.end());\n    } else if (type == \"point_segments\") {\n        int base = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int x = base + rnd.next(-1000, 1000); // Points around 'base'\n            segments.emplace_back(x, x);\n        }\n    } else if (type == \"max_range\") {\n        int l = -1000000000;\n        int r = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            segments.emplace_back(l, r);\n        }\n    } else if (type == \"staggered_overlap\") {\n        int l = -1000000000;\n        int segment_length = 2000000;\n        for (int i = 0; i < n; ++i) {\n            int left = l + i * segment_length / 2;\n            int right = left + segment_length;\n            segments.emplace_back(left, right);\n        }\n        shuffle(segments.begin(), segments.end());\n    } else if (type == \"edges_touch\") {\n        int l = -1000000000;\n        int segment_length = 1;\n        for (int i = 0; i < n; ++i) {\n            int left = l + i * segment_length;\n            int right = left + segment_length;\n            segments.emplace_back(left, right);\n        }\n        shuffle(segments.begin(), segments.end());\n    } else if (type == \"reverse_order\") {\n        vector<int> lefts(n);\n        for (int i = 0; i < n; ++i) {\n            lefts[i] = rnd.next(-1000000000, 1000000000);\n        }\n        sort(lefts.begin(), lefts.end(), greater<int>());\n        for (int i = 0; i < n; ++i) {\n            int l = lefts[i];\n            int r = rnd.next(l, 1000000000);\n            segments.emplace_back(l, r);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    for (const auto& p : segments) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<pair<int,int>> segments;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(-1000000000, 1000000000);\n            int r = rnd.next(-1000000000, 1000000000);\n            if (l > r) swap(l, r);\n            segments.emplace_back(l, r);\n        }\n    } else if (type == \"full_overlap\") {\n        int l = rnd.next(-1000000000, 1000000000);\n        int r = rnd.next(l, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            segments.emplace_back(l, r);\n        }\n    } else if (type == \"no_overlap\") {\n        int l = -1000000000;\n        int segment_length = 1;\n        for (int i = 0; i < n; ++i) {\n            int left = l + i * segment_length * 2;\n            int right = left + segment_length;\n            segments.emplace_back(left, right);\n        }\n        shuffle(segments.begin(), segments.end());\n    } else if (type == \"point_segments\") {\n        int base = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int x = base + rnd.next(-1000, 1000); // Points around 'base'\n            segments.emplace_back(x, x);\n        }\n    } else if (type == \"max_range\") {\n        int l = -1000000000;\n        int r = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            segments.emplace_back(l, r);\n        }\n    } else if (type == \"staggered_overlap\") {\n        int l = -1000000000;\n        int segment_length = 2000000;\n        for (int i = 0; i < n; ++i) {\n            int left = l + i * segment_length / 2;\n            int right = left + segment_length;\n            segments.emplace_back(left, right);\n        }\n        shuffle(segments.begin(), segments.end());\n    } else if (type == \"edges_touch\") {\n        int l = -1000000000;\n        int segment_length = 1;\n        for (int i = 0; i < n; ++i) {\n            int left = l + i * segment_length;\n            int right = left + segment_length;\n            segments.emplace_back(left, right);\n        }\n        shuffle(segments.begin(), segments.end());\n    } else if (type == \"reverse_order\") {\n        vector<int> lefts(n);\n        for (int i = 0; i < n; ++i) {\n            lefts[i] = rnd.next(-1000000000, 1000000000);\n        }\n        sort(lefts.begin(), lefts.end(), greater<int>());\n        for (int i = 0; i < n; ++i) {\n            int l = lefts[i];\n            int r = rnd.next(l, 1000000000);\n            segments.emplace_back(l, r);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    for (const auto& p : segments) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -type random\n./gen -n 2 -k 2 -type random\n./gen -n 2 -k 1 -type full_overlap\n./gen -n 2 -k 2 -type full_overlap\n\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 5 -type full_overlap\n./gen -n 10 -k 1 -type no_overlap\n./gen -n 10 -k 10 -type no_overlap\n./gen -n 10 -k 1 -type point_segments\n./gen -n 10 -k 5 -type point_segments\n./gen -n 10 -k 1 -type max_range\n./gen -n 10 -k 10 -type staggered_overlap\n./gen -n 10 -k 5 -type edges_touch\n\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 1 -type full_overlap\n./gen -n 100000 -k 100000 -type full_overlap\n./gen -n 100000 -k 1 -type no_overlap\n./gen -n 100000 -k 100000 -type no_overlap\n./gen -n 100000 -k 1 -type point_segments\n./gen -n 100000 -k 100000 -type point_segments\n./gen -n 100000 -k 50000 -type staggered_overlap\n./gen -n 100000 -k 100000 -type edges_touch\n\n./gen -n 1000000 -k 1 -type random\n./gen -n 1000000 -k 1000000 -type random\n./gen -n 1000000 -k 1 -type full_overlap\n./gen -n 1000000 -k 1000000 -type full_overlap\n./gen -n 1000000 -k 1 -type reverse_order\n./gen -n 1000000 -k 1000000 -type reverse_order\n./gen -n 1000000 -k 500000 -type max_range\n./gen -n 1000000 -k 1 -type edges_touch\n./gen -n 1000000 -k 1000000 -type edges_touch\n\n./gen -n 1 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:51.292145",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "612/E",
      "title": "E. Square Root of Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106) — the number of elements in permutation p.The second line contains n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) — the elements of permutation p.",
      "output_spec": "OutputIf there is no permutation q such that q2 = p print the number \"-1\".If the answer exists print it. The only line should contain n different integers qi (1 ≤ qi ≤ n) — the elements of the permutation q. If there are several solutions print any of them.",
      "sample_tests": "ExamplesInputCopy42 1 4 3OutputCopy3 4 2 1InputCopy42 1 3 4OutputCopy-1InputCopy52 3 4 5 1OutputCopy4 5 1 2 3",
      "description": "E. Square Root of Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 106) — the number of elements in permutation p.The second line contains n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) — the elements of permutation p.\n\nOutputIf there is no permutation q such that q2 = p print the number \"-1\".If the answer exists print it. The only line should contain n different integers qi (1 ≤ qi ≤ n) — the elements of the permutation q. If there are several solutions print any of them.\n\nInputCopy42 1 4 3OutputCopy3 4 2 1InputCopy42 1 3 4OutputCopy-1InputCopy52 3 4 5 1OutputCopy4 5 1 2 3\n\nInputCopy42 1 4 3\n\nOutputCopy3 4 2 1\n\nInputCopy42 1 3 4\n\nOutputCopy-1\n\nInputCopy52 3 4 5 1\n\nOutputCopy4 5 1 2 3",
      "solutions": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces",
          "content": "Hi, Codeforces!Educational Codeforces Round 4 will take place on 25 December 2015 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here. This time a little time has passed since the previous round. Although we planned this round at Monday, we forgot to include it to schedule, so it was appeared only now. So it is the fourth and the last educational round this year.<Maybe this paragraph will not be changed ever>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</Maybe this paragraph will not be changed ever>This time the round was prepared only by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements, when they will be ready :-)I think this time the problems is simpler than usually, because at first we have too hard problemset and removed the hardest problem and added very simple problem. I hope you will enjoy the problems and solve all of them!Also I want to wish you Happy New Year!!!Good luck and have fun!UPD 1: The first phase is ended, hack the solutions of your opponents!UPD 2: The editorial is ready.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22262",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1394
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces",
          "content": "612A - The Text SplittingLet's fix the number a of strings of length p and the number b of strings of length q. If a·p + b·q = n, we can build the answer by splitting the string s to a parts of the length p and b parts of the length q, in order from left to right. If we can't find any good pair a, b then the answer doesn't exist. Of course this problem can be solved in linear time, but the constraints are small, so you don't need linear solution.Complexity: O(n2).612B - HDD is Outdated TechnologyYou are given the permutation f. Let's build another permutation p in the following way: pfi = i. So the permutation p defines the number of sector by the number of fragment. The permutation p is called inverse permutation to f and denoted f - 1. Now the answer to problem is .Complexity: O(n).612C - Replace To Make Regular Bracket SequenceIf we forget about bracket kinds the string s should be RBS, otherwise the answer doesn't exist. If the answer exists each opening bracket matches to exactly one closing bracket and vice verse. Easy to see that if two matching brackets have the same kind we don't need to replace them. In other case we can change the kind of the closing bracket to the kind of the opening. So we can build some answer. Obviously the answer is minimal, because the problems for some pair of matching pairs are independent and can be solved separately.The only technical problem is to find the matching pairs. To do that we should store the stack of opening brackets. Let's iterate from left to right in s and if the bracket is opening, we would simply add it to the stack. Now if the bracket is closing there are three cases: 1) the stack is empty; 2) at the top of the stack is the opening bracket with the same kind as the current closing; 3) the kind of the opening bracket differs from the kind of the closing bracket. In the first case answer doesn't exist, in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one.Complexity: O(n).612D - The Union of k-SegmentsLet's create two events for each segment li is the time of the segment opening and ri is the time of the segment closing. Let's sort all events by time, if the times are equal let's sort them with priority to opening events. In C++ it can be done with sorting by standard comparator of vector<pair<int, int>> events, where each element of events is the pair with event time and event type ( - 1 for opening and  + 1 for closing).Let's iterate over events and maintain the balance. To do that we should simply decrease the balance by the value of the event type. Now if the balance value equals to k and before updating it was k - 1 then we are in the left end of some segment from the answer. If the balance equals to k - 1 and before updating it was k then we are in the right end of the segment from the answer. Let's simply add segment [left, right] to the answer. So now we have disjoint set of segments contains all satisfied points in order from left to right. Obviously it's the answer to the problem.Complexity: O(nlogn).612E - Square Root of PermutationConsider some permutation q. Let's build by it the oriented graph with edges (i, qi). Easy to see (and easy to prove) that this graph is the set of disjoint cycles. Now let's see what would be with that graph when the permutation will be multiplied by itself: all the cycles of odd length would remain so (only the order of vertices will change, they will be alternated), but the cycles of even length will be split to the two cycles of the same length. So to get the square root from the permutation we should simply alternate (in reverse order) all cycles of the odd length, and group all the cycles of the same even length to pairs and merge cycles in each pair. If it's impossible to group all even cycles to pairs then the answer doesn't exist.Complexity: O(n).612F - Simba on the Circle The author solution for this problem uses dynamic programming. I think that this problem can't be solved by greedy ideas. Let's calculate two dp's: z1i is the answer to the problem if all numbers less than ai are already printed, but the others are not; and z2i is the answer to the problem if all numbers less than or equal to ai are already printed, but the others are not. Let's denote dij — the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order. Easy to see that z2i = minj(zj + dij) for all j such that the value aj is the least value greater than ai. Now let's calculate the value z1i. Consider all elements equals to ai (in one of them we are). If there is only one such element then z1i = z2i. Otherwise we have two alternatives: to move in clockwise or counterclockwise direction. Let we are moving in clockwise direction, the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction, let's denote it u. Otherwise at last we will write out the number from the nearest to the i element in clockwise direction, let's denote it v. Now z1i = min(z2u + odiu, z2v + odvi). Easy to see that the answer to the problem is mini(z1i + dsi), over all i such that ai is the smallest value in array and s is the start position.Additionally you should restore the answer. To do that, on my mind, the simplest way is to write the recursive realization of dp, test it carefully and then copy it to restore answer (see my code below). Of course, it's possible to restore the answer without copy-paste. For example, you can add to your dp parameter b which means it's need to restore answer or not.Complexity: O(n2).Code",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22299",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 612\\s*E"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "q = [4, 5, 1, 2, 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 5",
          "code": "q = (1 4)(2 5)(3 1)(4 2)(5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 6",
          "code": "q = (1 4 2)(2 5)(3 1)(5 3) = (1 4 2 5)(3 1)(5 3) = (1 4 2 5 3)(3 1) =  (1 4 2 5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 7",
          "code": "q=(i1, i2, i3, i4, i5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 8",
          "code": "q^2=(i1, ..., i2, ...)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 9",
          "code": "q^2=(i1, i4, i2, i5, i3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 10",
          "code": "q^2 = (1 4 2 5 3)^2 = (1 2 3 4 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 11",
          "code": "p = [2 3 4 5 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 12",
          "code": "p = (i1, i2, i3, i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 13",
          "code": "p = (i1 i3)(i2 i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 14",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 15",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 16",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 17",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 18",
          "code": "3->2->4->1->3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 19",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 20",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> s(p.begin(), p.end());\n    ensuref(s.size() == n, \"Elements of p must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> s(p.begin(), p.end());\n    ensuref(s.size() == n, \"Elements of p must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    set<int> s(p.begin(), p.end());\n    ensuref(s.size() == n, \"Elements of p must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> p;\n\nbool readAnswer(InStream &stream) {\n    int first = stream.readInt();\n    if (first == -1) {\n        return false; // indicates no solution according to stream\n    }\n    vector<int> q(n + 1);\n    q[1] = first;\n    for (int i = 2; i <= n; i++) {\n        q[i] = stream.readInt(1, n, format(\"q[%d]\", i).c_str());\n    }\n    vector<bool> used(n + 1, false);\n    used[q[1]] = true;\n    for (int i = 2; i <= n; i++) {\n        if (used[q[i]]) {\n            stream.quitf(_wa, \"Number %d appears multiple times in q\", q[i]);\n        }\n        used[q[i]] = true;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (p[i] != q[q[i]]) {\n            stream.quitf(_wa, \"At position %d, p[i] != q[q[i]] (%d != %d)\", i, p[i], q[q[i]]);\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1000000);\n    p.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        p[i] = inf.readInt(1, n);\n    }\n\n    bool juryHasAnswer = readAnswer(ans);\n    bool participantHasAnswer = readAnswer(ouf);\n\n    if (!juryHasAnswer && !participantHasAnswer) {\n        quitf(_ok, \"Correctly reports no solution\");\n    } else if (juryHasAnswer && !participantHasAnswer) {\n        quitf(_wa, \"Participant reports no solution but solution exists\");\n    } else if (!juryHasAnswer && participantHasAnswer) {\n        quitf(_fail, \"Participant found a solution but jury says no solution exists\");\n    } else {\n        quitf(_ok, \"Participant's answer is correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid generate_cycles(vector<int>& p, const vector<int>& lengths, const vector<int>& indices) {\n    int pos = 0;\n    for (int len : lengths) {\n        vector<int> cycle_indices(indices.begin() + pos, indices.begin() + pos + len);\n        for (int i = 0; i < len; ++i) {\n            p[cycle_indices[i]-1] = cycle_indices[(i+1)%len];\n        }\n        pos += len;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"identity\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"twocycles\") {\n        if (n % 2 != 0) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        for (int i = 0; i < n; i += 2) {\n            p[i] = i + 2;\n            p[i+1] = i + 1;\n        }\n    } else if (type == \"even\") {\n        if (n == 1) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        vector<int> lengths;\n        int remaining = n;\n        while (remaining > 0) {\n            int max_len = min(remaining, 10);\n            int len = rnd.next(2, max_len);\n            if (len % 2 == 1)\n                len--; // Ensure even length\n            if (len < 2) len = 2;\n            if (len > remaining)\n                len = remaining;\n            if (len % 2 == 1)\n                len--; // Ensure even length\n\n            lengths.push_back(len);\n            remaining -= len;\n\n            if (remaining == 1) {\n                // Can't make even cycles with 1 remaining\n                lengths.back() += 1;\n                remaining -= 1;\n            }\n        }\n\n        generate_cycles(p, lengths, indices);\n    } else if (type == \"odd\") {\n        if (n <= 2) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        vector<int> lengths;\n        int remaining = n;\n        while (remaining > 0) {\n            int max_len = min(remaining, 10);\n            int len = rnd.next(3, max_len);\n            if (len % 2 == 0)\n                len--; // Ensure odd length\n            if (len < 3) len = 3;\n            if (len > remaining)\n                len = remaining;\n            if (len % 2 == 0)\n                len--; // Ensure odd length\n\n            lengths.push_back(len);\n            remaining -= len;\n\n            if (remaining == 1) {\n                // Can't make cycles of length >=3 with 1 remaining\n                lengths.back() += 1;\n                remaining -= 1;\n            } else if (remaining == 2) {\n                // Can't make cycles of length >=3 with 2 remaining\n                lengths.back() += remaining;\n                remaining = 0;\n            }\n        }\n\n        generate_cycles(p, lengths, indices);\n    } else if (type == \"mixed\") {\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        vector<int> lengths;\n        int remaining = n;\n        while (remaining > 0) {\n            int len = rnd.next(1, min(remaining,10));\n            if (len > remaining)\n                len = remaining;\n            lengths.push_back(len);\n            remaining -= len;\n        }\n\n        generate_cycles(p, lengths, indices);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid generate_cycles(vector<int>& p, const vector<int>& lengths, const vector<int>& indices) {\n    int pos = 0;\n    for (int len : lengths) {\n        vector<int> cycle_indices(indices.begin() + pos, indices.begin() + pos + len);\n        for (int i = 0; i < len; ++i) {\n            p[cycle_indices[i]-1] = cycle_indices[(i+1)%len];\n        }\n        pos += len;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"identity\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"twocycles\") {\n        if (n % 2 != 0) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        for (int i = 0; i < n; i += 2) {\n            p[i] = i + 2;\n            p[i+1] = i + 1;\n        }\n    } else if (type == \"even\") {\n        if (n == 1) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        vector<int> lengths;\n        int remaining = n;\n        while (remaining > 0) {\n            int max_len = min(remaining, 10);\n            int len = rnd.next(2, max_len);\n            if (len % 2 == 1)\n                len--; // Ensure even length\n            if (len < 2) len = 2;\n            if (len > remaining)\n                len = remaining;\n            if (len % 2 == 1)\n                len--; // Ensure even length\n\n            lengths.push_back(len);\n            remaining -= len;\n\n            if (remaining == 1) {\n                // Can't make even cycles with 1 remaining\n                lengths.back() += 1;\n                remaining -= 1;\n            }\n        }\n\n        generate_cycles(p, lengths, indices);\n    } else if (type == \"odd\") {\n        if (n <= 2) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        vector<int> lengths;\n        int remaining = n;\n        while (remaining > 0) {\n            int max_len = min(remaining, 10);\n            int len = rnd.next(3, max_len);\n            if (len % 2 == 0)\n                len--; // Ensure odd length\n            if (len < 3) len = 3;\n            if (len > remaining)\n                len = remaining;\n            if (len % 2 == 0)\n                len--; // Ensure odd length\n\n            lengths.push_back(len);\n            remaining -= len;\n\n            if (remaining == 1) {\n                // Can't make cycles of length >=3 with 1 remaining\n                lengths.back() += 1;\n                remaining -= 1;\n            } else if (remaining == 2) {\n                // Can't make cycles of length >=3 with 2 remaining\n                lengths.back() += remaining;\n                remaining = 0;\n            }\n        }\n\n        generate_cycles(p, lengths, indices);\n    } else if (type == \"mixed\") {\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n\n        vector<int> lengths;\n        int remaining = n;\n        while (remaining > 0) {\n            int len = rnd.next(1, min(remaining,10));\n            if (len > remaining)\n                len = remaining;\n            lengths.push_back(len);\n            remaining -= len;\n        }\n\n        generate_cycles(p, lengths, indices);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identity\n./gen -n 2 -type identity\n./gen -n 5 -type identity\n./gen -n 1000000 -type identity\n\n./gen -n 2 -type twocycles\n./gen -n 4 -type twocycles\n./gen -n 6 -type twocycles\n./gen -n 1000000 -type twocycles\n\n./gen -n 1 -type even      # Should output -1\n./gen -n 2 -type even\n./gen -n 3 -type even      # Should output -1\n./gen -n 5 -type even      # Should output -1\n./gen -n 6 -type even\n./gen -n 100000 -type even\n./gen -n 999999 -type even # Should output -1\n./gen -n 1000000 -type even\n\n./gen -n 3 -type odd\n./gen -n 4 -type odd\n./gen -n 5 -type odd\n./gen -n 100001 -type odd\n./gen -n 1000000 -type odd\n\n./gen -n 4 -type mixed\n./gen -n 7 -type mixed\n./gen -n 1000 -type mixed\n./gen -n 500000 -type mixed\n./gen -n 1000000 -type mixed\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100000 -type random\n./gen -n 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:53.740744",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "612/F",
      "title": "F. Simba on the Circle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and s (1 ≤ s ≤ n ≤ 2000) — the number of cells in the circular array and the starting position of Simba.The second line contains n integers ai ( - 109 ≤ ai ≤ 109) — the number written in the i-th cell. The numbers are given for cells in order from 1 to n. Some of numbers ai can be equal.",
      "output_spec": "OutputIn the first line print the number t — the least number of time units.Each of the next n lines should contain the direction of robot movement and the number of cells to move in that direction. After that movement the robot writes out the number from the cell in which it turns out. The direction and the number of cells should be printed in the form of +x in case of clockwise movement and -x in case of counterclockwise movement to x cells (0 ≤ x ≤ n - 1).Note that the sum of absolute values of x should be equal to t.",
      "sample_tests": "ExamplesInputCopy9 10 1 2 2 2 1 0 1 1OutputCopy12+0-3-1+2+1+2+1+1+1InputCopy8 10 1 0 1 0 1 0 1OutputCopy13+0+2+2+2-1+2+2+2InputCopy8 11 2 3 4 5 6 7 8OutputCopy7+0+1+1+1+1+1+1+1InputCopy8 10 0 0 0 0 0 0 0OutputCopy7+0+1+1+1+1+1+1+1",
      "description": "F. Simba on the Circle\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and s (1 ≤ s ≤ n ≤ 2000) — the number of cells in the circular array and the starting position of Simba.The second line contains n integers ai ( - 109 ≤ ai ≤ 109) — the number written in the i-th cell. The numbers are given for cells in order from 1 to n. Some of numbers ai can be equal.\n\nOutputIn the first line print the number t — the least number of time units.Each of the next n lines should contain the direction of robot movement and the number of cells to move in that direction. After that movement the robot writes out the number from the cell in which it turns out. The direction and the number of cells should be printed in the form of +x in case of clockwise movement and -x in case of counterclockwise movement to x cells (0 ≤ x ≤ n - 1).Note that the sum of absolute values of x should be equal to t.\n\nInputCopy9 10 1 2 2 2 1 0 1 1OutputCopy12+0-3-1+2+1+2+1+1+1InputCopy8 10 1 0 1 0 1 0 1OutputCopy13+0+2+2+2-1+2+2+2InputCopy8 11 2 3 4 5 6 7 8OutputCopy7+0+1+1+1+1+1+1+1InputCopy8 10 0 0 0 0 0 0 0OutputCopy7+0+1+1+1+1+1+1+1\n\nInputCopy9 10 1 2 2 2 1 0 1 1\n\nOutputCopy12+0-3-1+2+1+2+1+1+1\n\nInputCopy8 10 1 0 1 0 1 0 1\n\nOutputCopy13+0+2+2+2-1+2+2+2\n\nInputCopy8 11 2 3 4 5 6 7 8\n\nOutputCopy7+0+1+1+1+1+1+1+1\n\nInputCopy8 10 0 0 0 0 0 0 0\n\nOutputCopy7+0+1+1+1+1+1+1+1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces",
          "content": "Hi, Codeforces!Educational Codeforces Round 4 will take place on 25 December 2015 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here. This time a little time has passed since the previous round. Although we planned this round at Monday, we forgot to include it to schedule, so it was appeared only now. So it is the fourth and the last educational round this year.<Maybe this paragraph will not be changed ever>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</Maybe this paragraph will not be changed ever>This time the round was prepared only by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements, when they will be ready :-)I think this time the problems is simpler than usually, because at first we have too hard problemset and removed the hardest problem and added very simple problem. I hope you will enjoy the problems and solve all of them!Also I want to wish you Happy New Year!!!Good luck and have fun!UPD 1: The first phase is ended, hack the solutions of your opponents!UPD 2: The editorial is ready.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22262",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1394
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces",
          "content": "612A - The Text SplittingLet's fix the number a of strings of length p and the number b of strings of length q. If a·p + b·q = n, we can build the answer by splitting the string s to a parts of the length p and b parts of the length q, in order from left to right. If we can't find any good pair a, b then the answer doesn't exist. Of course this problem can be solved in linear time, but the constraints are small, so you don't need linear solution.Complexity: O(n2).612B - HDD is Outdated TechnologyYou are given the permutation f. Let's build another permutation p in the following way: pfi = i. So the permutation p defines the number of sector by the number of fragment. The permutation p is called inverse permutation to f and denoted f - 1. Now the answer to problem is .Complexity: O(n).612C - Replace To Make Regular Bracket SequenceIf we forget about bracket kinds the string s should be RBS, otherwise the answer doesn't exist. If the answer exists each opening bracket matches to exactly one closing bracket and vice verse. Easy to see that if two matching brackets have the same kind we don't need to replace them. In other case we can change the kind of the closing bracket to the kind of the opening. So we can build some answer. Obviously the answer is minimal, because the problems for some pair of matching pairs are independent and can be solved separately.The only technical problem is to find the matching pairs. To do that we should store the stack of opening brackets. Let's iterate from left to right in s and if the bracket is opening, we would simply add it to the stack. Now if the bracket is closing there are three cases: 1) the stack is empty; 2) at the top of the stack is the opening bracket with the same kind as the current closing; 3) the kind of the opening bracket differs from the kind of the closing bracket. In the first case answer doesn't exist, in the second case we should simply remove the opening bracket from the stack and in the third case we should remove the opening bracket from the stack and increase the answer by one.Complexity: O(n).612D - The Union of k-SegmentsLet's create two events for each segment li is the time of the segment opening and ri is the time of the segment closing. Let's sort all events by time, if the times are equal let's sort them with priority to opening events. In C++ it can be done with sorting by standard comparator of vector<pair<int, int>> events, where each element of events is the pair with event time and event type ( - 1 for opening and  + 1 for closing).Let's iterate over events and maintain the balance. To do that we should simply decrease the balance by the value of the event type. Now if the balance value equals to k and before updating it was k - 1 then we are in the left end of some segment from the answer. If the balance equals to k - 1 and before updating it was k then we are in the right end of the segment from the answer. Let's simply add segment [left, right] to the answer. So now we have disjoint set of segments contains all satisfied points in order from left to right. Obviously it's the answer to the problem.Complexity: O(nlogn).612E - Square Root of PermutationConsider some permutation q. Let's build by it the oriented graph with edges (i, qi). Easy to see (and easy to prove) that this graph is the set of disjoint cycles. Now let's see what would be with that graph when the permutation will be multiplied by itself: all the cycles of odd length would remain so (only the order of vertices will change, they will be alternated), but the cycles of even length will be split to the two cycles of the same length. So to get the square root from the permutation we should simply alternate (in reverse order) all cycles of the odd length, and group all the cycles of the same even length to pairs and merge cycles in each pair. If it's impossible to group all even cycles to pairs then the answer doesn't exist.Complexity: O(n).612F - Simba on the Circle The author solution for this problem uses dynamic programming. I think that this problem can't be solved by greedy ideas. Let's calculate two dp's: z1i is the answer to the problem if all numbers less than ai are already printed, but the others are not; and z2i is the answer to the problem if all numbers less than or equal to ai are already printed, but the others are not. Let's denote dij — the least distance between i and j on the circular array and odij is the distance from i to j in clockwise order. Easy to see that z2i = minj(zj + dij) for all j such that the value aj is the least value greater than ai. Now let's calculate the value z1i. Consider all elements equals to ai (in one of them we are). If there is only one such element then z1i = z2i. Otherwise we have two alternatives: to move in clockwise or counterclockwise direction. Let we are moving in clockwise direction, the last element from which we will write out the number would be the nearest to the i element in counterclockwise direction, let's denote it u. Otherwise at last we will write out the number from the nearest to the i element in clockwise direction, let's denote it v. Now z1i = min(z2u + odiu, z2v + odvi). Easy to see that the answer to the problem is mini(z1i + dsi), over all i such that ai is the smallest value in array and s is the start position.Additionally you should restore the answer. To do that, on my mind, the simplest way is to write the recursive realization of dp, test it carefully and then copy it to restore answer (see my code below). Of course, it's possible to restore the answer without copy-paste. For example, you can add to your dp parameter b which means it's need to restore answer or not.Complexity: O(n2).Code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22299",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 612\\s*F"
          },
          "content_length": 5706
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "2 1\n1 3\n3 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "for(int c=0;c<n;c++)\n    {\n        i=arr[c].first;\n        j=arr[c].second;\n        i=mp[i];\n        j=mp[j];\n        for(int k=i;k<=j;k++)\n            axis[k]++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22262",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 1",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 2",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 3",
          "code": "ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 4",
          "code": "q = [4, 5, 1, 2, 3]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 5",
          "code": "q = (1 4)(2 5)(3 1)(4 2)(5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 6",
          "code": "q = (1 4 2)(2 5)(3 1)(5 3) = (1 4 2 5)(3 1)(5 3) = (1 4 2 5 3)(3 1) =  (1 4 2 5 3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 7",
          "code": "q=(i1, i2, i3, i4, i5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 8",
          "code": "q^2=(i1, ..., i2, ...)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 9",
          "code": "q^2=(i1, i4, i2, i5, i3)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 10",
          "code": "q^2 = (1 4 2 5 3)^2 = (1 2 3 4 5)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 11",
          "code": "p = [2 3 4 5 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 12",
          "code": "p = (i1, i2, i3, i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 13",
          "code": "p = (i1 i3)(i2 i4)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 14",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 15",
          "code": "10 5\n1 1 1 0 0 0 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 16",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 17",
          "code": "j <------ i\n          -------------> k\n\n--------X---X-X---X--X---X---------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 18",
          "code": "3->2->4->1->3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 19",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 4 - Codeforces - Code 20",
          "code": "3 2\n0 5\n-3 2\n3 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22299",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const long long INFLL = 2000000000000000000LL;\n\n// We'll store the problem data in global (or static) variables for convenience.\nint n, s;\nvector<long long> a;\n\n// This function checks a purported solution in the given stream. It returns\n// the claimed minimal time T if (and only if) the solution is valid. Otherwise,\n// it calls quitf(_wa) [or _fail if called on the jury's answer] with an\n// appropriate message.\nlong long readAnswer(InStream &stream)\n{\n    // Read the claimed minimal time\n    long long T = stream.readLong(0, INFLL, \"T\");\n    \n    // We expect exactly n lines describing the movement steps.\n    // After each step, the robot \"writes out\" the number in that cell.\n    // The sum of absolute steps must be equal to T.\n    long long sumMoves = 0;      // will accumulate |x|\n    \n    // We'll track which cells have been used so that we write each cell's\n    // number exactly once.\n    vector<bool> used(n, false);\n\n    // The robot starts at cell s (1-based). We'll store it as 0-based internally.\n    // so currentPosition = s - 1\n    int currentPos = s - 1;\n\n    // We'll store the sequence of values that we \"write out\", to check non-decreasing order\n    vector<long long> writtenValues;\n    writtenValues.reserve(n);\n\n    // First writing is after the first step (which might be 0 movement).\n    // We read n lines in the format [+x] or [-x].\n    for(int i = 0; i < n; i++){\n        string token = stream.readToken();\n        // Must begin with '+' or '-'\n        if(token.size() < 2) {\n            stream.quitf(_wa, \"Invalid format for movement (must be +x or -x with x >= 0)\");\n        }\n\n        char sign = token[0];\n        long long steps;\n        // parse the integer part\n        // Allowed range: 0 <= steps <= n-1\n        // We'll try to parse everything after the sign as a (non-negative) integer.\n        {\n            // everything after the sign\n            string stepsPart = token.substr(1);\n            // check that stepsPart is an integer\n            // we could do a quick parse with stoll, but we rely on testlib's checking\n            // approach. Let's do a manual attempt or a safe approach:\n            // We'll create a new InStream from the string if we want to be thorough.\n            // But simpler is to do stoll carefully, letting exceptions cause WA.\n            // We'll just do stoll, and if it throws, we catch manually.\n            // Then we confirm 0 <= steps <= n-1.\n            // If there's any parse error, we call WA.\n\n            long long val;\n            try {\n                val = stoll(stepsPart);\n            } catch(...) {\n                stream.quitf(_wa, \"Movement step is not a valid integer: '%s'\", stepsPart.c_str());\n            }\n            if(val < 0 || val > (long long)(n-1)) {\n                stream.quitf(_wa, \"Movement step out of range [0, n-1]: %lld\", val);\n            }\n            steps = val;\n        }\n\n        sumMoves += steps; // accumulate absolute value\n\n        // Now update currentPos depending on sign\n        if(sign == '+'){\n            currentPos = (currentPos + steps) % n;\n        } else if(sign == '-'){\n            currentPos = (currentPos - steps + n) % n;\n        } else {\n            stream.quitf(_wa, \"Invalid sign character (expected '+' or '-')\");\n        }\n\n        // Now the robot \"writes out\" the number in currentPos\n        if(used[currentPos]) {\n            stream.quitf(_wa, \"Cell %d is used more than once\", currentPos + 1);\n        }\n        used[currentPos] = true;\n        writtenValues.push_back(a[currentPos]);\n    }\n\n    // Check that the sum of absolute steps equals T\n    if(sumMoves != T) {\n        stream.quitf(_wa, \"Claimed time T=%lld but sum of moves is %lld\", T, sumMoves);\n    }\n\n    // Check that each cell is used exactly once\n    // We have read n lines and used n cells, so presumably they are all used,\n    // but let's be sure:\n    for(int i = 0; i < n; i++){\n        if(!used[i]) {\n            stream.quitf(_wa, \"Not all cells are used in the provided path (missed cell %d).\", i+1);\n        }\n    }\n\n    // Finally check that the written values are in non-decreasing order\n    for(int i = 1; i < n; i++){\n        if(writtenValues[i] < writtenValues[i-1]) {\n            stream.quitf(_wa, \"The written sequence is not non-decreasing at position %d\", i+1);\n        }\n    }\n\n    // If everything is good, return T\n    return T;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the INF stream\n    n = inf.readInt(1, 2000, \"n\");\n    s = inf.readInt(1, n, \"s\");\n    a.resize(n);\n    for(int i = 0; i < n; i++){\n        a[i] = inf.readLong(-1000000000LL, 1000000000LL, format(\"a[%d]\", i+1).c_str());\n    }\n\n    // Read the jury's answer and check it\n    long long juryTime = readAnswer(ans);\n\n    // Read the participant's answer and check it\n    long long partTime = readAnswer(ouf);\n\n    // Compare results:\n    // We want the participant's time to match the jury's minimal time exactly.\n    // If participant's time is larger -> WA (not minimal).\n    // If participant's time is smaller -> FAIL (they found better than the jury).\n    // If they are equal -> OK.\n    if(partTime > juryTime)\n        quitf(_wa, \"Participant's time %lld is greater than jury's time %lld\", partTime, juryTime);\n    else if(partTime < juryTime)\n        quitf(_fail, \"Participant's time %lld is smaller than jury's time %lld\", partTime, juryTime);\n    else\n        quitf(_ok, \"Answer is correct, time = %lld\", partTime);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (s < 1 || s > n) {\n        fprintf(stderr, \"Error: s must be between 1 and n inclusive.\\n\");\n        exit(1);\n    }\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int value = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n - 1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = start - i;\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? -1000000000 : 1000000000;\n        }\n    } else if (type == \"duplicates\") {\n        int num_values = rnd.next(1, 10);\n        vector<int> values(num_values);\n        for (int i = 0; i < num_values; ++i) {\n            values[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = values[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"alternating\") {\n        int low = rnd.next(-1000000000, -500000000);\n        int high = rnd.next(500000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? low : high;\n        }\n    } else if (type == \"single_negative\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        int pos = rnd.next(0, n - 1);\n        ai[pos] = rnd.next(-1000000000, -1);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n and s\n    printf(\"%d %d\\n\", n, s);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (s < 1 || s > n) {\n        fprintf(stderr, \"Error: s must be between 1 and n inclusive.\\n\");\n        exit(1);\n    }\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int value = rnd.next(-1000000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = value;\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n - 1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = start - i;\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? -1000000000 : 1000000000;\n        }\n    } else if (type == \"duplicates\") {\n        int num_values = rnd.next(1, 10);\n        vector<int> values(num_values);\n        for (int i = 0; i < num_values; ++i) {\n            values[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = values[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"alternating\") {\n        int low = rnd.next(-1000000000, -500000000);\n        int high = rnd.next(500000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? low : high;\n        }\n    } else if (type == \"single_negative\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n        int pos = rnd.next(0, n - 1);\n        ai[pos] = rnd.next(-1000000000, -1);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n and s\n    printf(\"%d %d\\n\", n, s);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -s 1 -type random\n./gen -n 1 -s 1 -type equal\n./gen -n 1 -s 1 -type increasing\n./gen -n 2 -s 1 -type decreasing\n./gen -n 2 -s 2 -type increasing\n./gen -n 2 -s 1 -type duplicates\n./gen -n 3 -s 2 -type max_values\n./gen -n 3 -s 1 -type alternating\n\n# Medium n\n./gen -n 10 -s 5 -type random\n./gen -n 10 -s 1 -type equal\n./gen -n 10 -s 10 -type increasing\n./gen -n 10 -s 10 -type decreasing\n./gen -n 10 -s 5 -type duplicates\n./gen -n 10 -s 5 -type max_values\n./gen -n 10 -s 5 -type alternating\n./gen -n 10 -s 5 -type single_negative\n\n# Large n\n./gen -n 1000 -s 500 -type random\n./gen -n 1000 -s 1 -type equal\n./gen -n 1000 -s 1000 -type increasing\n./gen -n 1000 -s 1 -type decreasing\n./gen -n 1000 -s 500 -type duplicates\n./gen -n 1000 -s 500 -type max_values\n./gen -n 1000 -s 500 -type alternating\n./gen -n 1000 -s 500 -type single_negative\n\n# Maximum n\n./gen -n 2000 -s 1 -type random\n./gen -n 2000 -s 2000 -type equal\n./gen -n 2000 -s 1000 -type increasing\n./gen -n 2000 -s 1000 -type decreasing\n./gen -n 2000 -s 1 -type duplicates\n./gen -n 2000 -s 1 -type max_values\n./gen -n 2000 -s 1 -type alternating\n./gen -n 2000 -s 1 -type single_negative\n\n# Additional test cases\n./gen -n 500 -s 250 -type random\n./gen -n 500 -s 500 -type increasing\n./gen -n 500 -s 1 -type decreasing\n./gen -n 500 -s 250 -type duplicates\n./gen -n 500 -s 250 -type alternating\n\n# Edge cases with s at boundaries\n./gen -n 5 -s 5 -type random\n./gen -n 5 -s 1 -type random\n./gen -n 5 -s 3 -type random\n\n# Testing negative numbers\n./gen -n 10 -s 5 -type single_negative\n./gen -n 2000 -s 1000 -type single_negative\n\n# Type not specified (should default to random)\n./gen -n 100 -s 50\n\n# Mixed types with random s\n./gen -n 100 -s 25 -type random\n./gen -n 100 -s 50 -type max_values\n./gen -n 100 -s 75 -type duplicates\n./gen -n 100 -s 100 -type alternating\n\n# Small n with varying s\n./gen -n 5 -s 2 -type random\n./gen -n 5 -s 3 -type equal\n./gen -n 5 -s 4 -type increasing\n\n# n = 1 with different types\n./gen -n 1 -s 1 -type decreasing\n./gen -n 1 -s 1 -type max_values\n./gen -n 1 -s 1 -type single_negative\n\n# Additional large n cases\n./gen -n 1999 -s 1000 -type random\n./gen -n 1999 -s 1999 -type increasing\n./gen -n 1999 -s 1 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:55.708649",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "613/A",
      "title": "A. Peter and Snow Blower",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers — the number of vertices of the polygon n (), and coordinates of point P.Each of the next n lines contains two integers — coordinates of the vertices of the polygon in the clockwise or counterclockwise order. It is guaranteed that no three consecutive vertices lie on a common straight line.All the numbers in the input are integers that do not exceed 1 000 000 in their absolute value.",
      "output_spec": "OutputPrint a single real value number — the area of the region that will be cleared. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy3 0 00 1-1 21 2OutputCopy12.566370614359172464InputCopy4 1 -10 01 22 01 1OutputCopy21.991148575128551812",
      "description": "A. Peter and Snow Blower\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three integers — the number of vertices of the polygon n (), and coordinates of point P.Each of the next n lines contains two integers — coordinates of the vertices of the polygon in the clockwise or counterclockwise order. It is guaranteed that no three consecutive vertices lie on a common straight line.All the numbers in the input are integers that do not exceed 1 000 000 in their absolute value.\n\nOutputPrint a single real value number — the area of the region that will be cleared. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy3 0 00 1-1 21 2OutputCopy12.566370614359172464InputCopy4 1 -10 01 22 01 1OutputCopy21.991148575128551812\n\nInputCopy3 0 00 1-1 21 2\n\nOutputCopy12.566370614359172464\n\nInputCopy4 1 -10 01 22 01 1\n\nOutputCopy21.991148575128551812\n\nNoteIn the first sample snow will be removed from that area:",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 613\\s*A"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool point_on_segment(int xi, int yi, int xi_next, int yi_next, int Px, int Py) {\n    // Check if (xi, yi) to (xi_next, yi_next) contains (Px, Py)\n    long long cross = (long long)(xi_next - xi)*(Py - yi) - (long long)(yi_next - yi)*(Px - xi);\n    if (cross != 0) return false; // Not colinear\n    int minx = min(xi, xi_next);\n    int maxx = max(xi, xi_next);\n    int miny = min(yi, yi_next);\n    int maxy = max(yi, yi_next);\n    if (Px >= minx && Px <= maxx && Py >= miny && Py <= maxy) {\n        return true;\n    }\n    return false;\n}\n\nbool point_on_edge(int Px, int Py, const vector<int>& x, const vector<int>& y) {\n    int n = x.size();\n    for (int i = 0; i < n; ++i) {\n        int xi = x[i], yi = y[i];\n        int xi_next = x[(i + 1)%n], yi_next = y[(i + 1)%n];\n        if (point_on_segment(xi, yi, xi_next, yi_next, Px, Py)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool point_in_polygon(int Px, int Py, const vector<int>& x, const vector<int>& y) {\n    int n = x.size();\n    int cnt = 0;\n    for (int i = 0; i < n; ++i) {\n        int xi = x[i], yi = y[i];\n        int xi_next = x[(i + 1)%n], yi_next = y[(i + 1)%n];\n        if ((yi <= Py && yi_next > Py) || (yi > Py && yi_next <= Py)) {\n            long long cross = (long long)(xi_next - xi)*(Py - yi) - (long long)(yi_next - yi)*(Px - xi);\n            if (cross == 0) return true; // P is on edge\n            if ((cross > 0) == (yi_next > yi)) {\n                cnt++;\n            }\n        }\n    }\n    return cnt % 2 == 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int Px = inf.readInt(-1000000, 1000000, \"Px\");\n    inf.readSpace();\n    int Py = inf.readInt(-1000000, 1000000, \"Py\");\n    inf.readEoln();\n    \n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        y[i] = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n    }\n    \n    // Check that no three consecutive vertices lie on a straight line\n    for (int i = 0; i < n; ++i) {\n        int xi_prev = x[(i - 1 + n)%n];\n        int yi_prev = y[(i - 1 + n)%n];\n        int xi_curr = x[i];\n        int yi_curr = y[i];\n        int xi_next = x[(i + 1)%n];\n        int yi_next = y[(i + 1)%n];\n        \n        int dx1 = xi_curr - xi_prev;\n        int dy1 = yi_curr - yi_prev;\n        int dx2 = xi_next - xi_curr;\n        int dy2 = yi_next - yi_curr;\n        long long cross = (long long)dx1 * dy2 - (long long)dx2 * dy1;\n        ensuref(cross != 0, \"No three consecutive vertices lie on a common straight line at vertex %d\", i + 1);\n    }\n    \n    // Check that point P lies strictly outside the polygon\n    ensuref(!point_on_edge(Px, Py, x, y), \"Point P lies on the edge of the polygon\");\n    ensuref(!point_in_polygon(Px, Py, x, y), \"Point P lies inside the polygon\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool point_on_segment(int xi, int yi, int xi_next, int yi_next, int Px, int Py) {\n    // Check if (xi, yi) to (xi_next, yi_next) contains (Px, Py)\n    long long cross = (long long)(xi_next - xi)*(Py - yi) - (long long)(yi_next - yi)*(Px - xi);\n    if (cross != 0) return false; // Not colinear\n    int minx = min(xi, xi_next);\n    int maxx = max(xi, xi_next);\n    int miny = min(yi, yi_next);\n    int maxy = max(yi, yi_next);\n    if (Px >= minx && Px <= maxx && Py >= miny && Py <= maxy) {\n        return true;\n    }\n    return false;\n}\n\nbool point_on_edge(int Px, int Py, const vector<int>& x, const vector<int>& y) {\n    int n = x.size();\n    for (int i = 0; i < n; ++i) {\n        int xi = x[i], yi = y[i];\n        int xi_next = x[(i + 1)%n], yi_next = y[(i + 1)%n];\n        if (point_on_segment(xi, yi, xi_next, yi_next, Px, Py)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool point_in_polygon(int Px, int Py, const vector<int>& x, const vector<int>& y) {\n    int n = x.size();\n    int cnt = 0;\n    for (int i = 0; i < n; ++i) {\n        int xi = x[i], yi = y[i];\n        int xi_next = x[(i + 1)%n], yi_next = y[(i + 1)%n];\n        if ((yi <= Py && yi_next > Py) || (yi > Py && yi_next <= Py)) {\n            long long cross = (long long)(xi_next - xi)*(Py - yi) - (long long)(yi_next - yi)*(Px - xi);\n            if (cross == 0) return true; // P is on edge\n            if ((cross > 0) == (yi_next > yi)) {\n                cnt++;\n            }\n        }\n    }\n    return cnt % 2 == 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int Px = inf.readInt(-1000000, 1000000, \"Px\");\n    inf.readSpace();\n    int Py = inf.readInt(-1000000, 1000000, \"Py\");\n    inf.readEoln();\n    \n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        y[i] = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n    }\n    \n    // Check that no three consecutive vertices lie on a straight line\n    for (int i = 0; i < n; ++i) {\n        int xi_prev = x[(i - 1 + n)%n];\n        int yi_prev = y[(i - 1 + n)%n];\n        int xi_curr = x[i];\n        int yi_curr = y[i];\n        int xi_next = x[(i + 1)%n];\n        int yi_next = y[(i + 1)%n];\n        \n        int dx1 = xi_curr - xi_prev;\n        int dy1 = yi_curr - yi_prev;\n        int dx2 = xi_next - xi_curr;\n        int dy2 = yi_next - yi_curr;\n        long long cross = (long long)dx1 * dy2 - (long long)dx2 * dy1;\n        ensuref(cross != 0, \"No three consecutive vertices lie on a common straight line at vertex %d\", i + 1);\n    }\n    \n    // Check that point P lies strictly outside the polygon\n    ensuref(!point_on_edge(Px, Py, x, y), \"Point P lies on the edge of the polygon\");\n    ensuref(!point_in_polygon(Px, Py, x, y), \"Point P lies inside the polygon\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool point_on_segment(int xi, int yi, int xi_next, int yi_next, int Px, int Py) {\n    // Check if (xi, yi) to (xi_next, yi_next) contains (Px, Py)\n    long long cross = (long long)(xi_next - xi)*(Py - yi) - (long long)(yi_next - yi)*(Px - xi);\n    if (cross != 0) return false; // Not colinear\n    int minx = min(xi, xi_next);\n    int maxx = max(xi, xi_next);\n    int miny = min(yi, yi_next);\n    int maxy = max(yi, yi_next);\n    if (Px >= minx && Px <= maxx && Py >= miny && Py <= maxy) {\n        return true;\n    }\n    return false;\n}\n\nbool point_on_edge(int Px, int Py, const vector<int>& x, const vector<int>& y) {\n    int n = x.size();\n    for (int i = 0; i < n; ++i) {\n        int xi = x[i], yi = y[i];\n        int xi_next = x[(i + 1)%n], yi_next = y[(i + 1)%n];\n        if (point_on_segment(xi, yi, xi_next, yi_next, Px, Py)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool point_in_polygon(int Px, int Py, const vector<int>& x, const vector<int>& y) {\n    int n = x.size();\n    int cnt = 0;\n    for (int i = 0; i < n; ++i) {\n        int xi = x[i], yi = y[i];\n        int xi_next = x[(i + 1)%n], yi_next = y[(i + 1)%n];\n        if ((yi <= Py && yi_next > Py) || (yi > Py && yi_next <= Py)) {\n            long long cross = (long long)(xi_next - xi)*(Py - yi) - (long long)(yi_next - yi)*(Px - xi);\n            if (cross == 0) return true; // P is on edge\n            if ((cross > 0) == (yi_next > yi)) {\n                cnt++;\n            }\n        }\n    }\n    return cnt % 2 == 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int Px = inf.readInt(-1000000, 1000000, \"Px\");\n    inf.readSpace();\n    int Py = inf.readInt(-1000000, 1000000, \"Py\");\n    inf.readEoln();\n    \n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        y[i] = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n    }\n    \n    // Check that no three consecutive vertices lie on a straight line\n    for (int i = 0; i < n; ++i) {\n        int xi_prev = x[(i - 1 + n)%n];\n        int yi_prev = y[(i - 1 + n)%n];\n        int xi_curr = x[i];\n        int yi_curr = y[i];\n        int xi_next = x[(i + 1)%n];\n        int yi_next = y[(i + 1)%n];\n        \n        int dx1 = xi_curr - xi_prev;\n        int dy1 = yi_curr - yi_prev;\n        int dx2 = xi_next - xi_curr;\n        int dy2 = yi_next - yi_curr;\n        long long cross = (long long)dx1 * dy2 - (long long)dx2 * dy1;\n        ensuref(cross != 0, \"No three consecutive vertices lie on a common straight line at vertex %d\", i + 1);\n    }\n    \n    // Check that point P lies strictly outside the polygon\n    ensuref(!point_on_edge(Px, Py, x, y), \"Point P lies on the edge of the polygon\");\n    ensuref(!point_in_polygon(Px, Py, x, y), \"Point P lies inside the polygon\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_convex_polygon(int n) {\n    double max_abs = 1e6;\n    double radius = max_abs / 2;\n\n    vector<double> deltas(n);\n    for (int i = 0; i < n; ++i) {\n        deltas[i] = rnd.next(0.1, 1.0); // Ensure minimum delta\n    }\n    double delta_sum = accumulate(deltas.begin(), deltas.end(), 0.0);\n    for (int i = 0; i < n; ++i) {\n        deltas[i] = deltas[i] / delta_sum * 2 * M_PI;\n    }\n    vector<double> angles(n);\n    angles[0] = deltas[0];\n    for (int i = 1; i < n; ++i) {\n        angles[i] = angles[i-1] + deltas[i];\n    }\n    vector<pair<int,int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double r = radius * (0.8 + 0.2 * rnd.next(0.0,1.0)); // Vary radius slightly\n        int x = (int)(r * cos(angle));\n        int y = (int)(r * sin(angle));\n        x = max((int)-1e6, min((int)1e6, x));\n        y = max((int)-1e6, min((int)1e6, y));\n        points[i] = {x, y};\n    }\n    // Adjust duplicate points\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        if (points[i] == points[j]) {\n            points[j].first += 1;\n            if (points[j].first > 1e6)\n                points[j].first -= 2;\n        }\n    }\n    // Adjust colinear points\n    for (int i = 0; i < n; ++i) {\n        int a = i;\n        int b = (i + 1) % n;\n        int c = (i + 2) % n;\n        int x1 = points[b].first - points[a].first;\n        int y1 = points[b].second - points[a].second;\n        int x2 = points[c].first - points[b].first;\n        int y2 = points[c].second - points[b].second;\n        int cross = x1 * y2 - x2 * y1;\n        if (cross == 0) {\n            points[c].first += 1;\n            if (points[c].first > 1e6)\n                points[c].first -= 2;\n        }\n    }\n    return points;\n}\n\nvector<pair<int,int>> generate_concave_polygon(int n) {\n    if (n < 4) {\n        return generate_convex_polygon(n);\n    }\n    double max_abs = 1e6;\n    double R1 = max_abs / 2;\n    double R2 = R1 / 2;\n    vector<double> angles(n);\n    for (int i = 0; i < n; ++i) {\n        angles[i] = rnd.next(0.0, 2 * M_PI);\n    }\n    sort(angles.begin(), angles.end());\n    vector<pair<int,int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double r = (i % 2 == 0) ? R1 * (0.8 + 0.2 * rnd.next(0.0,1.0)) : R2 * (0.8 + 0.2 * rnd.next(0.0,1.0));\n        int x = (int)(r * cos(angle));\n        int y = (int)(r * sin(angle));\n        x = max((int)-1e6, min((int)1e6, x));\n        y = max((int)-1e6, min((int)1e6, y));\n        points[i] = {x, y};\n    }\n    // Adjust duplicate points\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        if (points[i] == points[j]) {\n            points[j].first += 1;\n            if (points[j].first > 1e6)\n                points[j].first -= 2;\n        }\n    }\n    // Adjust colinear points\n    for (int i = 0; i < n; ++i) {\n        int a = i;\n        int b = (i + 1) % n;\n        int c = (i + 2) % n;\n        int x1 = points[b].first - points[a].first;\n        int y1 = points[b].second - points[a].second;\n        int x2 = points[c].first - points[b].first;\n        int y2 = points[c].second - points[b].second;\n        int cross = x1 * y2 - x2 * y1;\n        if (cross == 0) {\n            points[c].first += 1;\n            if (points[c].first > 1e6)\n                points[c].first -= 2;\n        }\n    }\n    return points;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n    string position = opt<string>(\"position\", \"outside\");\n\n    vector<pair<int,int>> polygon;\n    if (type == \"convex\") {\n        polygon = generate_convex_polygon(n);\n    } else if (type == \"concave\") {\n        polygon = generate_concave_polygon(n);\n    } else {\n        polygon = generate_convex_polygon(n);\n    }\n\n    // Compute bounding box\n    int minX = INT_MAX, minY = INT_MAX, maxX = INT_MIN, maxY = INT_MIN;\n    for (const auto& p : polygon) {\n        minX = min(minX, p.first);\n        minY = min(minY, p.second);\n        maxX = max(maxX, p.first);\n        maxY = max(maxY, p.second);\n    }\n\n    int Px, Py;\n    if (position == \"inside\") {\n        Px = (minX + maxX) / 2;\n        Py = (minY + maxY) / 2;\n    } else if (position == \"outside\") {\n        int delta = 1000;\n        if (maxX + delta <= 1e6) {\n            Px = maxX + delta;\n            Py = (minY + maxY) / 2;\n        } else if (minX - delta >= -1e6) {\n            Px = minX - delta;\n            Py = (minY + maxY) / 2;\n        } else if (maxY + delta <= 1e6) {\n            Px = (minX + maxX) / 2;\n            Py = maxY + delta;\n        } else if (minY - delta >= -1e6) {\n            Px = (minX + maxX) / 2;\n            Py = minY - delta;\n        } else {\n            Px = (int)1e6;\n            Py = (int)1e6;\n        }\n    } else if (position == \"onedge\") {\n        int edge_idx = rnd.next(0, n-1);\n        int a = edge_idx;\n        int b = (edge_idx + 1) % n;\n        Px = (polygon[a].first + polygon[b].first) / 2;\n        Py = (polygon[a].second + polygon[b].second) / 2;\n    } else {\n        Px = (int)1e6;\n        Py = (int)1e6;\n    }\n\n    printf(\"%d %d %d\\n\", n, Px, Py);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", polygon[i].first, polygon[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_convex_polygon(int n) {\n    double max_abs = 1e6;\n    double radius = max_abs / 2;\n\n    vector<double> deltas(n);\n    for (int i = 0; i < n; ++i) {\n        deltas[i] = rnd.next(0.1, 1.0); // Ensure minimum delta\n    }\n    double delta_sum = accumulate(deltas.begin(), deltas.end(), 0.0);\n    for (int i = 0; i < n; ++i) {\n        deltas[i] = deltas[i] / delta_sum * 2 * M_PI;\n    }\n    vector<double> angles(n);\n    angles[0] = deltas[0];\n    for (int i = 1; i < n; ++i) {\n        angles[i] = angles[i-1] + deltas[i];\n    }\n    vector<pair<int,int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double r = radius * (0.8 + 0.2 * rnd.next(0.0,1.0)); // Vary radius slightly\n        int x = (int)(r * cos(angle));\n        int y = (int)(r * sin(angle));\n        x = max((int)-1e6, min((int)1e6, x));\n        y = max((int)-1e6, min((int)1e6, y));\n        points[i] = {x, y};\n    }\n    // Adjust duplicate points\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        if (points[i] == points[j]) {\n            points[j].first += 1;\n            if (points[j].first > 1e6)\n                points[j].first -= 2;\n        }\n    }\n    // Adjust colinear points\n    for (int i = 0; i < n; ++i) {\n        int a = i;\n        int b = (i + 1) % n;\n        int c = (i + 2) % n;\n        int x1 = points[b].first - points[a].first;\n        int y1 = points[b].second - points[a].second;\n        int x2 = points[c].first - points[b].first;\n        int y2 = points[c].second - points[b].second;\n        int cross = x1 * y2 - x2 * y1;\n        if (cross == 0) {\n            points[c].first += 1;\n            if (points[c].first > 1e6)\n                points[c].first -= 2;\n        }\n    }\n    return points;\n}\n\nvector<pair<int,int>> generate_concave_polygon(int n) {\n    if (n < 4) {\n        return generate_convex_polygon(n);\n    }\n    double max_abs = 1e6;\n    double R1 = max_abs / 2;\n    double R2 = R1 / 2;\n    vector<double> angles(n);\n    for (int i = 0; i < n; ++i) {\n        angles[i] = rnd.next(0.0, 2 * M_PI);\n    }\n    sort(angles.begin(), angles.end());\n    vector<pair<int,int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double r = (i % 2 == 0) ? R1 * (0.8 + 0.2 * rnd.next(0.0,1.0)) : R2 * (0.8 + 0.2 * rnd.next(0.0,1.0));\n        int x = (int)(r * cos(angle));\n        int y = (int)(r * sin(angle));\n        x = max((int)-1e6, min((int)1e6, x));\n        y = max((int)-1e6, min((int)1e6, y));\n        points[i] = {x, y};\n    }\n    // Adjust duplicate points\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        if (points[i] == points[j]) {\n            points[j].first += 1;\n            if (points[j].first > 1e6)\n                points[j].first -= 2;\n        }\n    }\n    // Adjust colinear points\n    for (int i = 0; i < n; ++i) {\n        int a = i;\n        int b = (i + 1) % n;\n        int c = (i + 2) % n;\n        int x1 = points[b].first - points[a].first;\n        int y1 = points[b].second - points[a].second;\n        int x2 = points[c].first - points[b].first;\n        int y2 = points[c].second - points[b].second;\n        int cross = x1 * y2 - x2 * y1;\n        if (cross == 0) {\n            points[c].first += 1;\n            if (points[c].first > 1e6)\n                points[c].first -= 2;\n        }\n    }\n    return points;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n    string position = opt<string>(\"position\", \"outside\");\n\n    vector<pair<int,int>> polygon;\n    if (type == \"convex\") {\n        polygon = generate_convex_polygon(n);\n    } else if (type == \"concave\") {\n        polygon = generate_concave_polygon(n);\n    } else {\n        polygon = generate_convex_polygon(n);\n    }\n\n    // Compute bounding box\n    int minX = INT_MAX, minY = INT_MAX, maxX = INT_MIN, maxY = INT_MIN;\n    for (const auto& p : polygon) {\n        minX = min(minX, p.first);\n        minY = min(minY, p.second);\n        maxX = max(maxX, p.first);\n        maxY = max(maxY, p.second);\n    }\n\n    int Px, Py;\n    if (position == \"inside\") {\n        Px = (minX + maxX) / 2;\n        Py = (minY + maxY) / 2;\n    } else if (position == \"outside\") {\n        int delta = 1000;\n        if (maxX + delta <= 1e6) {\n            Px = maxX + delta;\n            Py = (minY + maxY) / 2;\n        } else if (minX - delta >= -1e6) {\n            Px = minX - delta;\n            Py = (minY + maxY) / 2;\n        } else if (maxY + delta <= 1e6) {\n            Px = (minX + maxX) / 2;\n            Py = maxY + delta;\n        } else if (minY - delta >= -1e6) {\n            Px = (minX + maxX) / 2;\n            Py = minY - delta;\n        } else {\n            Px = (int)1e6;\n            Py = (int)1e6;\n        }\n    } else if (position == \"onedge\") {\n        int edge_idx = rnd.next(0, n-1);\n        int a = edge_idx;\n        int b = (edge_idx + 1) % n;\n        Px = (polygon[a].first + polygon[b].first) / 2;\n        Py = (polygon[a].second + polygon[b].second) / 2;\n    } else {\n        Px = (int)1e6;\n        Py = (int)1e6;\n    }\n\n    printf(\"%d %d %d\\n\", n, Px, Py);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", polygon[i].first, polygon[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type convex -position inside\n./gen -n 3 -type convex -position outside\n./gen -n 3 -type convex -position onedge\n./gen -n 3 -type concave -position inside\n./gen -n 3 -type concave -position outside\n./gen -n 4 -type convex -position inside\n./gen -n 4 -type convex -position outside\n./gen -n 4 -type concave -position inside\n./gen -n 4 -type concave -position outside\n./gen -n 10 -type convex -position inside\n./gen -n 10 -type convex -position outside\n./gen -n 10 -type concave -position inside\n./gen -n 10 -type concave -position outside\n./gen -n 100 -type convex -position inside\n./gen -n 100 -type convex -position outside\n./gen -n 100 -type concave -position inside\n./gen -n 100 -type concave -position outside\n./gen -n 1000 -type convex -position inside\n./gen -n 1000 -type convex -position outside\n./gen -n 1000 -type concave -position inside\n./gen -n 1000 -type concave -position outside\n./gen -n 100000 -type convex -position inside\n./gen -n 100000 -type convex -position outside\n./gen -n 100000 -type concave -position inside\n./gen -n 100000 -type concave -position outside\n./gen -n 99999 -type convex -position inside\n./gen -n 99999 -type concave -position outside\n./gen -n 50000 -type convex -position onedge\n./gen -n 50000 -type concave -position onedge\n./gen -n 100000 -type convex -position onedge\n./gen -n 100000 -type concave -position onedge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:57.601083",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "613/B",
      "title": "B. Skills",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains five space-separated integers n, A, cf, cm and m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 109, 0 ≤ cf, cm ≤ 1000, 0 ≤ m ≤ 1015).The second line contains exactly n integers ai (0 ≤ ai ≤ A), separated by spaces, — the current levels of skills.",
      "output_spec": "OutputOn the first line print the maximum value of the Force that the character can achieve using no more than m currency units.On the second line print n integers a'i (ai ≤ a'i ≤ A), skill levels which one must achieve in order to reach the specified value of the Force, while using no more than m currency units. Numbers should be separated by spaces.",
      "sample_tests": "ExamplesInputCopy3 5 10 1 51 3 1OutputCopy122 5 2 InputCopy3 5 10 1 3391 3 1OutputCopy355 5 5",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains five space-separated integers n, A, cf, cm and m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 109, 0 ≤ cf, cm ≤ 1000, 0 ≤ m ≤ 1015).The second line contains exactly n integers ai (0 ≤ ai ≤ A), separated by spaces, — the current levels of skills.\n\nOutputOn the first line print the maximum value of the Force that the character can achieve using no more than m currency units.On the second line print n integers a'i (ai ≤ a'i ≤ A), skill levels which one must achieve in order to reach the specified value of the Force, while using no more than m currency units. Numbers should be separated by spaces.\n\nInputCopy3 5 10 1 51 3 1OutputCopy122 5 2 InputCopy3 5 10 1 3391 3 1OutputCopy355 5 5\n\nInputCopy3 5 10 1 51 3 1\n\nOutputCopy122 5 2\n\nInputCopy3 5 10 1 3391 3 1\n\nOutputCopy355 5 5\n\nNoteIn the first test the optimal strategy is to increase the second skill to its maximum, and increase the two others by 1.In the second test one should increase all skills to maximum.",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 613\\s*B"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int A = inf.readInt(1, 1000000000, \"A\");\n    inf.readSpace();\n    int cf = inf.readInt(0, 1000, \"cf\");\n    inf.readSpace();\n    int cm = inf.readInt(0, 1000, \"cm\");\n    inf.readSpace();\n    long long m = inf.readLong(0, 1000000000000000LL, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, A, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int A = inf.readInt(1, 1000000000, \"A\");\n    inf.readSpace();\n    int cf = inf.readInt(0, 1000, \"cf\");\n    inf.readSpace();\n    int cm = inf.readInt(0, 1000, \"cm\");\n    inf.readSpace();\n    long long m = inf.readLong(0, 1000000000000000LL, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, A, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int A = inf.readInt(1, 1000000000, \"A\");\n    inf.readSpace();\n    int cf = inf.readInt(0, 1000, \"cf\");\n    inf.readSpace();\n    int cm = inf.readInt(0, 1000, \"cm\");\n    inf.readSpace();\n    long long m = inf.readLong(0, 1000000000000000LL, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, A, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int n = inf.readInt();\n    ll A = inf.readLong();\n    ll cf = inf.readLong();\n    ll cm = inf.readLong();\n    ll m = inf.readLong();\n\n    vector<ll> ai(n);\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readLong();\n    }\n\n    // Read jury's answer\n    ll jans = ans.readLong();\n\n    // Read participant's answer\n    ll pans = ouf.readLong();\n    vector<ll> a_prime(n);\n    for (int i = 0; i < n; ++i) {\n        a_prime[i] = ouf.readLong();\n        if (a_prime[i] < ai[i])\n            quitf(_wa, \"Skill level a'[%d] = %lld is less than initial skill level a[%d] = %lld\", i + 1, a_prime[i], i + 1, ai[i]);\n        if (a_prime[i] > A)\n            quitf(_wa, \"Skill level a'[%d] = %lld exceeds maximum skill level A = %lld\", i + 1, a_prime[i], A);\n    }\n\n    // Calculate total cost\n    ll total_cost = 0;\n    for (int i = 0; i < n; ++i) {\n        total_cost += (a_prime[i] - ai[i]);\n    }\n    if (total_cost > m)\n        quitf(_wa, \"Total cost %lld exceeds available currency m = %lld\", total_cost, m);\n\n    // Calculate Force\n    ll num_maxed = 0;\n    ll min_skill = LLONG_MAX;\n    for (int i = 0; i < n; ++i) {\n        if (a_prime[i] == A)\n            num_maxed++;\n        if (a_prime[i] < min_skill)\n            min_skill = a_prime[i];\n    }\n    ll Force = num_maxed * cf + min_skill * cm;\n    if (Force != pans)\n        quitf(_wa, \"Calculated Force %lld does not match the reported Force %lld\", Force, pans);\n\n    if (pans > jans)\n        quitf(_fail, \"Participant's Force %lld is greater than jury's Force %lld\", pans, jans);\n    else if (pans < jans)\n        quitf(_wa, \"Participant's Force %lld is less than jury's Force %lld\", pans, jans);\n    else\n        quitf(_ok, \"Correct answer with Force = %lld\", pans);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int A = opt<int>(\"A\");\n    int cf = opt<int>(\"cf\");\n    int cm = opt<int>(\"cm\");\n    long long m = opt<long long>(\"m\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (ai_type == \"zeros\") {\n        fill(ai.begin(), ai.end(), 0);\n    } else if (ai_type == \"max\") {\n        fill(ai.begin(), ai.end(), A);\n    } else if (ai_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, A);\n    } else if (ai_type == \"inc\") {\n        int delta = A / max(n - 1, 1);\n        for (int i = 0; i < n; ++i)\n            ai[i] = min(i * delta, A);\n    } else if (ai_type == \"dec\") {\n        int delta = A / max(n - 1, 1);\n        for (int i = 0; i < n; ++i)\n            ai[i] = max(A - i * delta, 0);\n    } else if (ai_type == \"half\") {\n        int delta = A / 10;\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(max(0, A / 2 - delta), min(A, A / 2 + delta));\n    } else if (ai_type == \"low\") {\n        int max_low = min(A / 10, A);\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, max_low);\n    } else if (ai_type == \"high\") {\n        int min_high = max(A - A / 10, 0);\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(min_high, A);\n    } else if (ai_type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0)\n                ai[i] = 0;\n            else if (t == 1)\n                ai[i] = A;\n            else\n                ai[i] = rnd.next(0, A);\n        }\n    }\n\n    printf(\"%d %d %d %d %lld\\n\", n, A, cf, cm, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int A = opt<int>(\"A\");\n    int cf = opt<int>(\"cf\");\n    int cm = opt<int>(\"cm\");\n    long long m = opt<long long>(\"m\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (ai_type == \"zeros\") {\n        fill(ai.begin(), ai.end(), 0);\n    } else if (ai_type == \"max\") {\n        fill(ai.begin(), ai.end(), A);\n    } else if (ai_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, A);\n    } else if (ai_type == \"inc\") {\n        int delta = A / max(n - 1, 1);\n        for (int i = 0; i < n; ++i)\n            ai[i] = min(i * delta, A);\n    } else if (ai_type == \"dec\") {\n        int delta = A / max(n - 1, 1);\n        for (int i = 0; i < n; ++i)\n            ai[i] = max(A - i * delta, 0);\n    } else if (ai_type == \"half\") {\n        int delta = A / 10;\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(max(0, A / 2 - delta), min(A, A / 2 + delta));\n    } else if (ai_type == \"low\") {\n        int max_low = min(A / 10, A);\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, max_low);\n    } else if (ai_type == \"high\") {\n        int min_high = max(A - A / 10, 0);\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(min_high, A);\n    } else if (ai_type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0)\n                ai[i] = 0;\n            else if (t == 1)\n                ai[i] = A;\n            else\n                ai[i] = rnd.next(0, A);\n        }\n    }\n\n    printf(\"%d %d %d %d %lld\\n\", n, A, cf, cm, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -A 1 -cf 0 -cm 0 -m 0 -ai_type zeros\n./gen -n 5 -A 10 -cf 1000 -cm 1000 -m 0 -ai_type zeros\n./gen -n 5 -A 10 -cf 1000 -cm 1000 -m 1000 -ai_type zeros\n./gen -n 5 -A 10 -cf 1000 -cm 1000 -m 1000 -ai_type max\n./gen -n 5 -A 10 -cf 1000 -cm 1000 -m 1000 -ai_type random\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -ai_type random\n./gen -n 100000 -A 1000000000 -cf 0 -cm 0 -m 0 -ai_type zeros\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 0 -ai_type zeros\n./gen -n 100000 -A 1 -cf 1000 -cm 1000 -m 0 -ai_type zeros\n./gen -n 100000 -A 1 -cf 0 -cm 1000 -m 0 -ai_type zeros\n./gen -n 100000 -A 1 -cf 1000 -cm 0 -m 0 -ai_type zeros\n./gen -n 100000 -A 1 -cf 0 -cm 0 -m 0 -ai_type zeros\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -ai_type zeros\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -ai_type max\n./gen -n 100000 -A 1000000000 -cf 0 -cm 1000 -m 500000000000000 -ai_type low\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 0 -m 500000000000000 -ai_type high\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 500000000000000 -ai_type half\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000 -ai_type mixed\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -ai_type inc\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -ai_type dec\n./gen -n 1000 -A 1000 -cf 1000 -cm 1000 -m 0 -ai_type random\n./gen -n 1000 -A 1000 -cf 1000 -cm 1000 -m 1000000 -ai_type random\n./gen -n 1 -A 1000000000 -cf 1000 -cm 1000 -m 0 -ai_type zeros\n./gen -n 1 -A 1000000000 -cf 1000 -cm 1000 -m 500000 -ai_type zeros\n./gen -n 50000 -A 1 -cf 500 -cm 500 -m 25000 -ai_type mixed\n./gen -n 2 -A 2 -cf 0 -cm 1000 -m 1 -ai_type zeros\n./gen -n 2 -A 2 -cf 1000 -cm 0 -m 1 -ai_type max\n./gen -n 99999 -A 999999999 -cf 999 -cm 999 -m 999999999999999 -ai_type random\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 500 -m 1000000000 -ai_type low\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:58:59.655797",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "613/C",
      "title": "C. Бусы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задано единственное число n (1 ≤ n ≤ 26) — количество цветов бусинок. Во второй строке через пробел записано n целых положительных чисел ai — количество бусинок i-го цвета.Гарантируется, что сумма ai не меньше двух и не превосходит 100 000.",
      "output_spec": "Выходные данныеВ первой строке выведите единственное число — наибольшее количество красивых разрезов, которого можно добиться. Во второй строке выведите бусы, обладающие таким числом красивых разрезов.Каждый цвет бусинок кодируется соответствующей строчной английской буквой (начиная с a), содержимое бус можно выводить начиная с любой позиции. Если правильных ответов несколько, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать34 2 1Выходные данныеСкопировать1abacabaВходные данныеСкопировать14Выходные данныеСкопировать4aaaaВходные данныеСкопировать21 1Выходные данныеСкопировать0ab",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных задано единственное число n (1 ≤ n ≤ 26) — количество цветов бусинок. Во второй строке через пробел записано n целых положительных чисел ai — количество бусинок i-го цвета.Гарантируется, что сумма ai не меньше двух и не превосходит 100 000.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное число — наибольшее количество красивых разрезов, которого можно добиться. Во второй строке выведите бусы, обладающие таким числом красивых разрезов.Каждый цвет бусинок кодируется соответствующей строчной английской буквой (начиная с a), содержимое бус можно выводить начиная с любой позиции. Если правильных ответов несколько, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать34 2 1Выходные данныеСкопировать1abacabaВходные данныеСкопировать14Выходные данныеСкопировать4aaaaВходные данныеСкопировать21 1Выходные данныеСкопировать0ab\n\nВходные данныеСкопировать34 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1abacaba\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать14\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4aaaa\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0ab\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте бусы не могут иметь более одного красивого разреза. Пример бус с одним красивым разрезом приведен на картинке.Во втором тесте бусы можно составить единственным образом.",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Всем привет! Через два дня, в 19:35 состоится Codeforces Round #339 (Div. 1 & Div. 2) Этот раунд необычен тем, что мы, его составители — обычные школьники, объединенные тем, что вместе занимаемся на кружке в 179 школе. Для нас этот раунд — первый опыт и мы постарались сделать его максимально интересным и безошибочным. Я приглашаю вас всех писать этот раунд, потому что задачи будут решаемы, но при этом даже tourist-у придётся подумать над некоторыми :)Под началом и полным контролем Михаила Тихомирова(Endagorion) задачи для вас готовили: Егор Чунаев(ch_egor), Василий Алферов(platypus179), Дмитрий Саютин(cdkrot), Тимофей Гутор(Tigutor), Мария Федоркина (crossopt). Кроме того, задачи придумывали: Михаил Сорокин(themikemikovi4), Сергей Алейкин(Derrior). Отдельное спасибо Глебу Евстропову(GlebsHP) за помощь в подготовке контеста, Маше Беловой(Delinur) за перевод условий на английский язык, AlexFetisov и winger за тестирование, и, конечно, (MikeMirzayanov) за уникальные системы CodeForces и Polygon.Раунд будет проведен по стандартным правилам Codeforces, сначала — претесты, потом финальное тестирование, внимательно продумывайте все случаи в своём решении. Удачи всем на контесте!UPD Разбалловка: Div 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Поздравляем победителей! результатыDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1485
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 613\\s*C"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 31",
          "code": "v[l] <= val < v[l+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 26, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n\n    long long totalBeads = 0;\n    for (int i = 0; i < n; i++) {\n        totalBeads += a[i];\n    }\n\n    ensuref(totalBeads >= 2 && totalBeads <= 100000, \"Sum of ai must be between 2 and 100000 inclusive, but it's %lld.\", totalBeads);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 26, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n\n    long long totalBeads = 0;\n    for (int i = 0; i < n; i++) {\n        totalBeads += a[i];\n    }\n\n    ensuref(totalBeads >= 2 && totalBeads <= 100000, \"Sum of ai must be between 2 and 100000 inclusive, but it's %lld.\", totalBeads);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 26, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n\n    long long totalBeads = 0;\n    for (int i = 0; i < n; i++) {\n        totalBeads += a[i];\n    }\n\n    ensuref(totalBeads >= 2 && totalBeads <= 100000, \"Sum of ai must be between 2 and 100000 inclusive, but it's %lld.\", totalBeads);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll implement a custom checker because there can be multiple valid necklaces \n// (i.e., multiple correct outputs) that use the same multiset of beads and achieve\n// the same maximum number of \"beautiful cuts\".\n\n// To verify correctness, we will:\n// 1) Read the problem input from inf (the number of colors and their quantities).\n// 2) Read the jury's solution from ans, check correctness, and compute its number of beautiful cuts.\n// 3) Read the participant's solution from ouf, check correctness, and compute its number of beautiful cuts.\n// 4) Compare: if the jury's solution has strictly more beautiful cuts, we issue WA; \n//    if the participant's solution has strictly more, we issue FAIL (the jury's solution was not optimal).\n//    Otherwise, we accept (OK).\n\nstatic const unsigned long long BASE = 131542391ULL;\nstatic vector<unsigned long long> p; // Powers of BASE for hashing\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input (n and the array of bead counts)\n    int n = inf.readInt(1, 26);\n    vector<long long> beads(n);\n    long long total = 0;\n    for (int i = 0; i < n; i++) {\n        beads[i] = inf.readLong(1, 100000);\n        total += beads[i];\n    }\n    // total is guaranteed to be >= 2 and <= 100000.\n\n    // Precompute powers of BASE up to length = 2 * total (for the doubled string).\n    p.resize(2 * total + 1);\n    p[0] = 1ULL;\n    for (int i = 1; i <= 2 * total; i++) {\n        p[i] = p[i - 1] * BASE;\n    }\n\n    // Helper function: reads a solution from the given stream, checks correctness,\n    // and returns the actual number of beautiful cuts. If it fails, it calls quitf(_wa/_fail).\n    auto readSolutionAndCountCuts = [&](InStream &stream)\n    {\n        // 1) Read the declared number of beautiful cuts\n        long long declaredCuts = stream.readLong(0, total, \"declared_cuts\");\n        \n        // 2) Read the necklace as a token (it must match the total length in beads).\n        //    IMPORTANT: do NOT supply a pattern string like \"necklace\" here; that\n        //    would mean the token must literally match \"necklace\". So just readToken().\n        string necklace = stream.readToken();\n\n        // Check length\n        if ((long long)necklace.size() != total) {\n            stream.quitf(_wa, \n                \"Necklace length mismatch: expected %lld, got %d\",\n                total, (int)necklace.size());\n        }\n\n        // 3) Check letter usage\n        vector<long long> used(n, 0LL);\n        for (char c : necklace) {\n            if (c < 'a' || c >= char('a' + n)) {\n                stream.quitf(_wa, \"Invalid color '%c' found in the necklace\", c);\n            }\n            used[c - 'a']++;\n        }\n        for (int i = 0; i < n; i++) {\n            if (used[i] != beads[i]) {\n                stream.quitf(_wa, \n                    \"Wrong usage for color '%c': expected %lld, got %lld\",\n                    char('a' + i), beads[i], used[i]);\n            }\n        }\n\n        // 4) Count the actual number of beautiful cuts using a rolling-hash palindrome check\n        auto countBeautifulCuts = [&](const string &s) {\n            // ds = s + s\n            string ds = s + s;\n            // Build prefix hashes for ds\n            static vector<unsigned long long> H, R;\n            H.resize(ds.size() + 1);\n            R.resize(ds.size() + 1);\n\n            // Forward hash\n            H[0] = 0ULL;\n            for (int i = 0; i < (int)ds.size(); i++) {\n                H[i + 1] = H[i] * BASE + (unsigned long long)(ds[i] - 'a' + 1);\n            }\n\n            // Reverse hash (we can build it by reversing ds or we can index from the end on the fly).\n            // For simplicity, let's build the reversed ds directly:\n            string dsr(ds.rbegin(), ds.rend());\n            R[0] = 0ULL;\n            for (int i = 0; i < (int)dsr.size(); i++) {\n                R[i + 1] = R[i] * BASE + (unsigned long long)(dsr[i] - 'a' + 1);\n            }\n\n            // Helper to get substring hash in O(1)\n            auto getHash = [&](const vector<unsigned long long> &pref, int l, int r){\n                unsigned long long res = pref[r + 1] - pref[l] * p[r - l + 1];\n                return res;\n            };\n\n            int len = (int)s.size();\n            long long countCuts = 0;\n            for (int i = 0; i < len; i++) {\n                // substring [i..i+len-1] in ds, reversed substring is [i2..i2+len-1] in dsr\n                int i2 = 2 * len - (i + len);\n                // get forward hash\n                unsigned long long hashF = getHash(H, i, i + len - 1);\n                // get reverse hash\n                unsigned long long hashR = getHash(R, i2, i2 + len - 1);\n                if (hashF == hashR) {\n                    countCuts++;\n                }\n            }\n            return countCuts;\n        };\n\n        long long realCuts = countBeautifulCuts(necklace);\n\n        // 5) Compare realCuts vs declaredCuts\n        if (realCuts != declaredCuts) {\n            stream.quitf(_wa, \n                \"Mismatch in the number of beautiful cuts: declared %lld, found %lld\",\n                declaredCuts, realCuts);\n        }\n\n        return realCuts;\n    };\n\n    // Read jury's solution\n    long long jVal = readSolutionAndCountCuts(ans);\n    // Read participant's solution\n    long long pVal = readSolutionAndCountCuts(ouf);\n\n    // Compare\n    if (jVal > pVal) {\n        quitf(_wa, \n            \"Participant's solution has fewer beautiful cuts than jury's (jury=%lld > part=%lld)\", \n            jVal, pVal);\n    }\n    else if (jVal < pVal) {\n        quitf(_fail, \n            \"Participant's solution has more beautiful cuts than jury's (jury=%lld < part=%lld)\", \n            jVal, pVal);\n    }\n    else {\n        quitf(_ok, \"OK: number of beautiful cuts = %lld\", pVal);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int sum = opt<int>(\"sum\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Enforce constraints\n    ensure(1 <= n && n <= 26);\n    ensure(2 <= sum && sum <= 100000);\n    ensure(sum >= n); // Each ai >= 1\n\n    vector<int> ai(n);\n\n    if (type == \"minimal\") {\n        if (n != 1 || sum != 2) {\n            cerr << \"For 'minimal' type, n must be 1 and sum must be 2.\" << endl;\n            exit(1);\n        }\n        ai[0] = 2;\n    } else if (type == \"maximal\") {\n        if (n != 26 || sum != 100000) {\n            cerr << \"For 'maximal' type, n must be 26 and sum must be 100000.\" << endl;\n            exit(1);\n        }\n        ai.assign(n, sum / n);\n        int remaining = sum % n;\n        for (int i = 0; i < remaining; ++i) {\n            ++ai[i];\n        }\n    } else if (type == \"equal\") {\n        ai.assign(n, sum / n);\n        int remaining = sum % n;\n        for (int i = 0; i < remaining; ++i) {\n            ++ai[i];\n        }\n    } else if (type == \"one_bead_each\") {\n        if (sum != n) {\n            cerr << \"For 'one_bead_each' type, sum must equal n.\" << endl;\n            exit(1);\n        }\n        ai.assign(n, 1);\n    } else if (type == \"large_ai_variation\") {\n        ai.assign(n, 1);\n        int remaining = sum - n;\n        ai[0] += remaining; // Make the first ai large\n    } else if (type == \"random\") {\n        // Generate random ai >= 1, sum(ai) = sum\n        int sum_prime = sum - n;\n        vector<int> cuts;\n        cuts.push_back(0);\n        cuts.push_back(sum_prime);\n        for (int i = 0; i < n - 1; ++i) {\n            int cut = rnd.next(0, sum_prime);\n            cuts.push_back(cut);\n        }\n        sort(cuts.begin(), cuts.end());\n        for (int i = 0; i < n; ++i) {\n            ai[i] = cuts[i + 1] - cuts[i] + 1;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int sum = opt<int>(\"sum\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Enforce constraints\n    ensure(1 <= n && n <= 26);\n    ensure(2 <= sum && sum <= 100000);\n    ensure(sum >= n); // Each ai >= 1\n\n    vector<int> ai(n);\n\n    if (type == \"minimal\") {\n        if (n != 1 || sum != 2) {\n            cerr << \"For 'minimal' type, n must be 1 and sum must be 2.\" << endl;\n            exit(1);\n        }\n        ai[0] = 2;\n    } else if (type == \"maximal\") {\n        if (n != 26 || sum != 100000) {\n            cerr << \"For 'maximal' type, n must be 26 and sum must be 100000.\" << endl;\n            exit(1);\n        }\n        ai.assign(n, sum / n);\n        int remaining = sum % n;\n        for (int i = 0; i < remaining; ++i) {\n            ++ai[i];\n        }\n    } else if (type == \"equal\") {\n        ai.assign(n, sum / n);\n        int remaining = sum % n;\n        for (int i = 0; i < remaining; ++i) {\n            ++ai[i];\n        }\n    } else if (type == \"one_bead_each\") {\n        if (sum != n) {\n            cerr << \"For 'one_bead_each' type, sum must equal n.\" << endl;\n            exit(1);\n        }\n        ai.assign(n, 1);\n    } else if (type == \"large_ai_variation\") {\n        ai.assign(n, 1);\n        int remaining = sum - n;\n        ai[0] += remaining; // Make the first ai large\n    } else if (type == \"random\") {\n        // Generate random ai >= 1, sum(ai) = sum\n        int sum_prime = sum - n;\n        vector<int> cuts;\n        cuts.push_back(0);\n        cuts.push_back(sum_prime);\n        for (int i = 0; i < n - 1; ++i) {\n            int cut = rnd.next(0, sum_prime);\n            cuts.push_back(cut);\n        }\n        sort(cuts.begin(), cuts.end());\n        for (int i = 0; i < n; ++i) {\n            ai[i] = cuts[i + 1] - cuts[i] + 1;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -sum 2 -type minimal\n./gen -n 1 -sum 100000 -type random\n\n./gen -n 2 -sum 2 -type one_bead_each\n./gen -n 2 -sum 100000 -type random\n./gen -n 2 -sum 100000 -type large_ai_variation\n\n./gen -n 26 -sum 26 -type one_bead_each\n./gen -n 26 -sum 100000 -type maximal\n./gen -n 26 -sum 100000 -type equal\n./gen -n 26 -sum 100000 -type random\n./gen -n 26 -sum 100000 -type large_ai_variation\n\n./gen -n 13 -sum 100000 -type random\n\n./gen -n 5 -sum 10 -type random\n./gen -n 5 -sum 100 -type random\n./gen -n 5 -sum 1000 -type random\n./gen -n 5 -sum 10000 -type random\n./gen -n 5 -sum 100000 -type random\n\n./gen -n 26 -sum 26 -type equal\n./gen -n 26 -sum 2600 -type equal\n./gen -n 26 -sum 26000 -type equal\n\n./gen -n 4 -sum 4 -type equal\n./gen -n 4 -sum 40 -type equal\n./gen -n 4 -sum 400 -type equal\n./gen -n 4 -sum 4000 -type equal\n./gen -n 4 -sum 40000 -type equal\n\n./gen -n 1 -sum 100000 -type random\n\n./gen -n 2 -sum 99999 -type large_ai_variation\n./gen -n 25 -sum 100 -type large_ai_variation\n./gen -n 3 -sum 3 -type one_bead_each\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:01.669302",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "613/D",
      "title": "D. Kingdom and its Cities",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 100 000) — the number of cities in the kingdom.Each of the next n - 1 lines contains two distinct integers ui, vi (1 ≤ ui, vi ≤ n) — the indices of the cities connected by the i-th road. It is guaranteed that you can get from any city to any other one moving only along the existing roads.The next line contains a single integer q (1 ≤ q ≤ 100 000) — the number of King's plans.Each of the next q lines looks as follows: first goes number ki — the number of important cities in the King's plan, (1 ≤ ki ≤ n), then follow exactly ki space-separated pairwise distinct numbers from 1 to n — the numbers of important cities in this plan.The sum of all ki's does't exceed 100 000.",
      "output_spec": "OutputFor each plan print a single integer — the minimum number of cities that the barbarians need to capture, or print  - 1 if all the barbarians' attempts to isolate important cities will not be effective.",
      "sample_tests": "ExamplesInputCopy41 32 34 342 1 23 2 3 43 1 2 44 1 2 3 4OutputCopy1-11-1InputCopy71 22 33 41 55 65 714 2 4 6 7OutputCopy2",
      "description": "D. Kingdom and its Cities\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 100 000) — the number of cities in the kingdom.Each of the next n - 1 lines contains two distinct integers ui, vi (1 ≤ ui, vi ≤ n) — the indices of the cities connected by the i-th road. It is guaranteed that you can get from any city to any other one moving only along the existing roads.The next line contains a single integer q (1 ≤ q ≤ 100 000) — the number of King's plans.Each of the next q lines looks as follows: first goes number ki — the number of important cities in the King's plan, (1 ≤ ki ≤ n), then follow exactly ki space-separated pairwise distinct numbers from 1 to n — the numbers of important cities in this plan.The sum of all ki's does't exceed 100 000.\n\nOutputFor each plan print a single integer — the minimum number of cities that the barbarians need to capture, or print  - 1 if all the barbarians' attempts to isolate important cities will not be effective.\n\nInputCopy41 32 34 342 1 23 2 3 43 1 2 44 1 2 3 4OutputCopy1-11-1InputCopy71 22 33 41 55 65 714 2 4 6 7OutputCopy2\n\nInputCopy41 32 34 342 1 23 2 3 43 1 2 44 1 2 3 4\n\nOutputCopy1-11-1\n\nInputCopy71 22 33 41 55 65 714 2 4 6 7\n\nOutputCopy2\n\nNoteIn the first sample, in the first and the third King's plan barbarians can capture the city 3, and that will be enough. In the second and the fourth plans all their attempts will not be effective.In the second sample the cities to capture are 3 and 5.",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 613\\s*D"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy) {\n        // x and y are already connected, there is a cycle\n        return false;\n    }\n    parent[fy] = fx;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Initialize Union-Find\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        // ui != vi\n        ensuref(u != v, \"u_i (%d) should not equal v_i (%d)\", u, v);\n        // Check for cycles and multi-edges\n        ensuref(unite(u, v), \"Graph contains a cycle or multiple edges; edge between %d and %d creates a cycle or duplicates an existing edge\", u, v);\n    }\n\n    // After all edges are processed, check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected; node %d is not connected to node 1\", i);\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    int total_ki = 0;\n    for (int i = 0; i < q; ++i) {\n        int ki = inf.readInt(1, n, \"k_i\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Sum of all ki should not exceed 100000, but is %d after processing %d plans\", total_ki, i + 1);\n        inf.readSpace();\n        vector<int> important_cities = inf.readInts(ki, 1, n, \"important_cities\");\n        inf.readEoln();\n        set<int> cities_in_plan(important_cities.begin(), important_cities.end());\n        ensuref((int)cities_in_plan.size() == ki, \"Important cities in plan %d are not pairwise distinct\", i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy) {\n        // x and y are already connected, there is a cycle\n        return false;\n    }\n    parent[fy] = fx;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Initialize Union-Find\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        // ui != vi\n        ensuref(u != v, \"u_i (%d) should not equal v_i (%d)\", u, v);\n        // Check for cycles and multi-edges\n        ensuref(unite(u, v), \"Graph contains a cycle or multiple edges; edge between %d and %d creates a cycle or duplicates an existing edge\", u, v);\n    }\n\n    // After all edges are processed, check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected; node %d is not connected to node 1\", i);\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    int total_ki = 0;\n    for (int i = 0; i < q; ++i) {\n        int ki = inf.readInt(1, n, \"k_i\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Sum of all ki should not exceed 100000, but is %d after processing %d plans\", total_ki, i + 1);\n        inf.readSpace();\n        vector<int> important_cities = inf.readInts(ki, 1, n, \"important_cities\");\n        inf.readEoln();\n        set<int> cities_in_plan(important_cities.begin(), important_cities.end());\n        ensuref((int)cities_in_plan.size() == ki, \"Important cities in plan %d are not pairwise distinct\", i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy) {\n        // x and y are already connected, there is a cycle\n        return false;\n    }\n    parent[fy] = fx;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Initialize Union-Find\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        // ui != vi\n        ensuref(u != v, \"u_i (%d) should not equal v_i (%d)\", u, v);\n        // Check for cycles and multi-edges\n        ensuref(unite(u, v), \"Graph contains a cycle or multiple edges; edge between %d and %d creates a cycle or duplicates an existing edge\", u, v);\n    }\n\n    // After all edges are processed, check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected; node %d is not connected to node 1\", i);\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    int total_ki = 0;\n    for (int i = 0; i < q; ++i) {\n        int ki = inf.readInt(1, n, \"k_i\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Sum of all ki should not exceed 100000, but is %d after processing %d plans\", total_ki, i + 1);\n        inf.readSpace();\n        vector<int> important_cities = inf.readInts(ki, 1, n, \"important_cities\");\n        inf.readEoln();\n        set<int> cities_in_plan(important_cities.begin(), important_cities.end());\n        ensuref((int)cities_in_plan.size() == ki, \"Important cities in plan %d are not pairwise distinct\", i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_tree(int n, string tree_type) {\n    vector<pair<int,int>> edges;\n    vector<int> parent(n+1);\n\n    if(tree_type == \"chain\") {\n        // Chain tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"star\") {\n        // Star tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"balanced\") {\n        // Balanced binary tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"skewed\") {\n        // Skewed tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(max(1, i - 3), i -1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else {\n        // Random tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i -1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    return edges;\n}\n\nvoid generate_plans(int n, int q, string plan_type, vector<vector<int>> & plans) {\n    int total_ki = 0, max_total_ki = 100000;\n    int max_q = min(q, max_total_ki);\n    for(int i = 0; i < max_q; ++i) {\n        // Decide ki\n        int ki;\n        if(plan_type == \"small_ki\") {\n            ki = rnd.next(1, min(n, 5));\n        } else if(plan_type == \"large_ki\") {\n            ki = rnd.next(max(1, n - 5), n);\n        } else if (plan_type == \"all_nodes\") {\n            ki = n;\n        } else {\n            // Random ki\n            ki = rnd.next(1, n);\n        }\n        // Adjust ki if total_ki exceeds max_total_ki\n        if (total_ki + ki > max_total_ki) {\n            ki = max_total_ki - total_ki;\n            if (ki <= 0) break;\n        }\n        total_ki += ki;\n\n        // Generate ki unique nodes\n        vector<int> important_cities;\n        if(plan_type == \"leaves\") {\n            // For simplicity, select nodes from n/2 to n\n            set<int> cities;\n            while (cities.size() < ki) {\n                int city = rnd.next(n/2, n);\n                cities.insert(city);\n            }\n            for (int city : cities) {\n                important_cities.push_back(city);\n            }\n        } else if (plan_type == \"rooted\") {\n            // Include root\n            important_cities.push_back(1);\n            set<int> cities;\n            while (cities.size() < ki - 1) {\n                int city = rnd.next(2, n);\n                cities.insert(city);\n            }\n            for (int city : cities) {\n                important_cities.push_back(city);\n            }\n        } else if (plan_type == \"all_nodes\") {\n            for(int city = 1; city <= n; ++city) {\n                important_cities.push_back(city);\n            }\n        } else {\n            // Random selection\n            set<int> cities;\n            while (cities.size() < ki) {\n                int city = rnd.next(1, n);\n                cities.insert(city);\n            }\n            for (int city : cities) {\n                important_cities.push_back(city);\n            }\n        }\n\n        plans.push_back(important_cities);\n    }\n}\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // number of nodes\n    int q = opt<int>(\"q\"); // number of plans\n    string tree_type = opt<string>(\"tree_type\", \"random\"); // Type of tree\n    string plan_type = opt<string>(\"plan_type\", \"random\"); // How to select important cities\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Error: n must be between 1 and 100000\\n\");\n        exit(1);\n    }\n\n    vector<pair<int,int>> edges = generate_tree(n, tree_type);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for(const auto & e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate plans\n    vector<vector<int>> plans;\n    generate_plans(n, q, plan_type, plans);\n\n    // Output q\n    int output_q = plans.size();\n    printf(\"%d\\n\", output_q);\n\n    // Output plans\n    for(const auto & plan : plans) {\n        int ki = plan.size();\n        printf(\"%d\", ki);\n        for(int city : plan) {\n            printf(\" %d\", city);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_tree(int n, string tree_type) {\n    vector<pair<int,int>> edges;\n    vector<int> parent(n+1);\n\n    if(tree_type == \"chain\") {\n        // Chain tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"star\") {\n        // Star tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"balanced\") {\n        // Balanced binary tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else if(tree_type == \"skewed\") {\n        // Skewed tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(max(1, i - 3), i -1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n    } else {\n        // Random tree\n        for(int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i -1);\n            edges.push_back(make_pair(parent[i], i));\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    return edges;\n}\n\nvoid generate_plans(int n, int q, string plan_type, vector<vector<int>> & plans) {\n    int total_ki = 0, max_total_ki = 100000;\n    int max_q = min(q, max_total_ki);\n    for(int i = 0; i < max_q; ++i) {\n        // Decide ki\n        int ki;\n        if(plan_type == \"small_ki\") {\n            ki = rnd.next(1, min(n, 5));\n        } else if(plan_type == \"large_ki\") {\n            ki = rnd.next(max(1, n - 5), n);\n        } else if (plan_type == \"all_nodes\") {\n            ki = n;\n        } else {\n            // Random ki\n            ki = rnd.next(1, n);\n        }\n        // Adjust ki if total_ki exceeds max_total_ki\n        if (total_ki + ki > max_total_ki) {\n            ki = max_total_ki - total_ki;\n            if (ki <= 0) break;\n        }\n        total_ki += ki;\n\n        // Generate ki unique nodes\n        vector<int> important_cities;\n        if(plan_type == \"leaves\") {\n            // For simplicity, select nodes from n/2 to n\n            set<int> cities;\n            while (cities.size() < ki) {\n                int city = rnd.next(n/2, n);\n                cities.insert(city);\n            }\n            for (int city : cities) {\n                important_cities.push_back(city);\n            }\n        } else if (plan_type == \"rooted\") {\n            // Include root\n            important_cities.push_back(1);\n            set<int> cities;\n            while (cities.size() < ki - 1) {\n                int city = rnd.next(2, n);\n                cities.insert(city);\n            }\n            for (int city : cities) {\n                important_cities.push_back(city);\n            }\n        } else if (plan_type == \"all_nodes\") {\n            for(int city = 1; city <= n; ++city) {\n                important_cities.push_back(city);\n            }\n        } else {\n            // Random selection\n            set<int> cities;\n            while (cities.size() < ki) {\n                int city = rnd.next(1, n);\n                cities.insert(city);\n            }\n            for (int city : cities) {\n                important_cities.push_back(city);\n            }\n        }\n\n        plans.push_back(important_cities);\n    }\n}\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // number of nodes\n    int q = opt<int>(\"q\"); // number of plans\n    string tree_type = opt<string>(\"tree_type\", \"random\"); // Type of tree\n    string plan_type = opt<string>(\"plan_type\", \"random\"); // How to select important cities\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Error: n must be between 1 and 100000\\n\");\n        exit(1);\n    }\n\n    vector<pair<int,int>> edges = generate_tree(n, tree_type);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for(const auto & e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate plans\n    vector<vector<int>> plans;\n    generate_plans(n, q, plan_type, plans);\n\n    // Output q\n    int output_q = plans.size();\n    printf(\"%d\\n\", output_q);\n\n    // Output plans\n    for(const auto & plan : plans) {\n        int ki = plan.size();\n        printf(\"%d\", ki);\n        for(int city : plan) {\n            printf(\" %d\", city);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -q 1 -tree_type chain -plan_type random\n./gen -n 5 -q 1 -tree_type star -plan_type small_ki\n./gen -n 5 -q 1 -tree_type balanced -plan_type large_ki\n\n./gen -n 10 -q 5 -tree_type random -plan_type random\n./gen -n 10 -q 5 -tree_type chain -plan_type leaves\n./gen -n 10 -q 5 -tree_type star -plan_type rooted\n\n./gen -n 100 -q 10 -tree_type skewed -plan_type small_ki\n./gen -n 100 -q 10 -tree_type balanced -plan_type large_ki\n\n./gen -n 1000 -q 50 -tree_type random -plan_type random\n./gen -n 1000 -q 50 -tree_type chain -plan_type leaves\n./gen -n 1000 -q 50 -tree_type star -plan_type rooted\n\n./gen -n 10000 -q 1000 -tree_type skewed -plan_type small_ki\n./gen -n 10000 -q 1000 -tree_type balanced -plan_type large_ki\n\n./gen -n 100000 -q 100000 -tree_type random -plan_type random\n./gen -n 100000 -q 1 -tree_type chain -plan_type all_nodes\n./gen -n 100000 -q 100000 -tree_type star -plan_type small_ki\n./gen -n 100000 -q 100000 -tree_type balanced -plan_type small_ki\n./gen -n 100000 -q 50000 -tree_type skewed -plan_type leaves\n\n./gen -n 99999 -q 99999 -tree_type chain -plan_type random\n./gen -n 99999 -q 99999 -tree_type skewed -plan_type large_ki\n\n./gen -n 100000 -q 50000 -tree_type chain -plan_type large_ki\n./gen -n 100000 -q 50000 -tree_type star -plan_type rooted\n\n./gen -n 2 -q 1 -tree_type chain -plan_type random\n./gen -n 2 -q 1 -tree_type star -plan_type random\n\n./gen -n 3 -q 1 -tree_type chain -plan_type random\n./gen -n 3 -q 1 -tree_type star -plan_type random\n\n./gen -n 100000 -q 1 -tree_type balanced -plan_type all_nodes\n\n./gen -n 1 -q 1 -tree_type random -plan_type random\n\n./gen -n 1000 -q 100000 -tree_type random -plan_type small_ki\n\n./gen -n 1000 -q 100000 -tree_type random -plan_type large_ki\n\n./gen -n 100000 -q 100000 -tree_type random -plan_type random\n\n./gen -n 100000 -q 100000 -tree_type star -plan_type random\n\n./gen -n 100000 -q 1 -tree_type skewed -plan_type large_ki\n\n./gen -n 100000 -q 1 -tree_type skewed -plan_type all_nodes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:03.487586",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "613/E",
      "title": "E. Любитель кроссвордов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первых двух строках записано состояние поля для головоломки. Каждая из этих строк непустая и содержит по n маленьких латинских букв.Следующая строка оставлена пустой.Последняя строка является непустой и содержит слово w, состоящее из строчных английских букв.Длина каждой из строк не превосходит 2 000.",
      "output_spec": "Выходные данныеВыведите одно целое число — количество решений головоломки по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопироватьcodeedoccodeВыходные данныеСкопировать4Входные данныеСкопироватьaaaaaaaaВыходные данныеСкопировать14",
      "description": "E. Любитель кроссвордов\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первых двух строках записано состояние поля для головоломки. Каждая из этих строк непустая и содержит по n маленьких латинских букв.Следующая строка оставлена пустой.Последняя строка является непустой и содержит слово w, состоящее из строчных английских букв.Длина каждой из строк не превосходит 2 000.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — количество решений головоломки по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопироватьcodeedoccodeВыходные данныеСкопировать4Входные данныеСкопироватьaaaaaaaaВыходные данныеСкопировать14\n\nВходные данныеСкопироватьcodeedoccode\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьaaaaaaaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать14\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Всем привет! Через два дня, в 19:35 состоится Codeforces Round #339 (Div. 1 & Div. 2) Этот раунд необычен тем, что мы, его составители — обычные школьники, объединенные тем, что вместе занимаемся на кружке в 179 школе. Для нас этот раунд — первый опыт и мы постарались сделать его максимально интересным и безошибочным. Я приглашаю вас всех писать этот раунд, потому что задачи будут решаемы, но при этом даже tourist-у придётся подумать над некоторыми :)Под началом и полным контролем Михаила Тихомирова(Endagorion) задачи для вас готовили: Егор Чунаев(ch_egor), Василий Алферов(platypus179), Дмитрий Саютин(cdkrot), Тимофей Гутор(Tigutor), Мария Федоркина (crossopt). Кроме того, задачи придумывали: Михаил Сорокин(themikemikovi4), Сергей Алейкин(Derrior). Отдельное спасибо Глебу Евстропову(GlebsHP) за помощь в подготовке контеста, Маше Беловой(Delinur) за перевод условий на английский язык, AlexFetisov и winger за тестирование, и, конечно, (MikeMirzayanov) за уникальные системы CodeForces и Polygon.Раунд будет проведен по стандартным правилам Codeforces, сначала — претесты, потом финальное тестирование, внимательно продумывайте все случаи в своём решении. Удачи всем на контесте!UPD Разбалловка: Div 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Поздравляем победителей! результатыDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1485
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 613\\s*E"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 31",
          "code": "v[l] <= val < v[l+1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line, s1\n    string s1 = inf.readLine(\"[a-z]{1,2000}\", \"First line s1\");\n    int n = s1.length();  // n is the length of the strings in the puzzle field\n\n    // Read the second line, s2\n    string s2 = inf.readLine(\"[a-z]{1,2000}\", \"Second line s2\");\n    ensuref(s2.length() == n, \"Length of the second line must be equal to the first line, got %zu vs %zu\", s2.length(), s1.length());\n\n    // Read the empty line\n    string emptyLine = inf.readLine();\n    ensuref(emptyLine.empty(), \"Expected an empty line after the second line\");\n\n    // Read the word w\n    string w = inf.readLine(\"[a-z]{1,2000}\", \"Word w\");\n\n    // Ensure that there is no extra data\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line, s1\n    string s1 = inf.readLine(\"[a-z]{1,2000}\", \"First line s1\");\n    int n = s1.length();  // n is the length of the strings in the puzzle field\n\n    // Read the second line, s2\n    string s2 = inf.readLine(\"[a-z]{1,2000}\", \"Second line s2\");\n    ensuref(s2.length() == n, \"Length of the second line must be equal to the first line, got %zu vs %zu\", s2.length(), s1.length());\n\n    // Read the empty line\n    string emptyLine = inf.readLine();\n    ensuref(emptyLine.empty(), \"Expected an empty line after the second line\");\n\n    // Read the word w\n    string w = inf.readLine(\"[a-z]{1,2000}\", \"Word w\");\n\n    // Ensure that there is no extra data\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line, s1\n    string s1 = inf.readLine(\"[a-z]{1,2000}\", \"First line s1\");\n    int n = s1.length();  // n is the length of the strings in the puzzle field\n\n    // Read the second line, s2\n    string s2 = inf.readLine(\"[a-z]{1,2000}\", \"Second line s2\");\n    ensuref(s2.length() == n, \"Length of the second line must be equal to the first line, got %zu vs %zu\", s2.length(), s1.length());\n\n    // Read the empty line\n    string emptyLine = inf.readLine();\n    ensuref(emptyLine.empty(), \"Expected an empty line after the second line\");\n\n    // Read the word w\n    string w = inf.readLine(\"[a-z]{1,2000}\", \"Word w\");\n\n    // Ensure that there is no extra data\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s;\n    for (int i = 0; i < len; ++i)\n        s += (char)('a' + rnd.next(26));\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\"); // field row length\n    int m = opt<int>(\"m\"); // word length\n    string type = opt<string>(\"type\", \"random\"); // default to random type\n\n    string row1, row2, word;\n    \n    if (type == \"random\") {\n        row1 = randomString(n);\n        row2 = randomString(n);\n        word = randomString(m);\n    } else if (type == \"same_letters\") {\n        char ch = 'a' + rnd.next(26);\n        row1 = string(n, ch);\n        row2 = string(n, ch);\n        word = string(m, ch);\n    } else if (type == \"impossible\") {\n        // Field letters from 'a' to 'y', word consists of 'z's\n        row1 = row2 = \"\";\n        for (int i = 0; i < n; ++i) {\n            row1 += (char)('a' + rnd.next(25)); // 'a' to 'y'\n            row2 += (char)('a' + rnd.next(25));\n        }\n        word = string(m, 'z'); // 'z'\n    } else if (type == \"min_paths\") {\n        // We need to ensure m is reasonable (<=26)\n        if (m > 26) m = 26;\n        string letters;\n        for (char c = 'a'; c < 'a' + m; ++c)\n            letters += c;\n        word = letters;\n        // Generate field with unique path matching the word\n        // Fill other positions with letters not in word\n        vector<char> other_letters;\n        for (char c = 'a' + m; c <= 'z'; ++c)\n            other_letters.push_back(c);\n        if (other_letters.empty()) {\n            // We cannot have letters not in word\n            // So we reduce m\n            m = 20;\n            letters = \"\";\n            for (char c = 'a'; c < 'a' + m; ++c)\n                letters += c;\n            word = letters;\n            other_letters.clear();\n            for (char c = 'a' + m; c <= 'z'; ++c)\n                other_letters.push_back(c);\n        }\n        row1 = \"\";\n        row2 = \"\";\n        int row = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i < m) {\n                if (row == 0) {\n                    row1 += word[i];\n                    row2 += other_letters[rnd.next(other_letters.size())];\n                } else {\n                    row1 += other_letters[rnd.next(other_letters.size())];\n                    row2 += word[i];\n                }\n                row = 1 - row;\n            } else {\n                row1 += other_letters[rnd.next(other_letters.size())];\n                row2 += other_letters[rnd.next(other_letters.size())];\n            }\n        }\n    } else if (type == \"long_word\") {\n        // m <= 2n\n        m = min(m, 2 * n);\n        row1 = string(n, 'a');\n        row2 = string(n, 'a');\n        word = \"\";\n        int row = 0;\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            char ch = 'a' + rnd.next(26);\n            if (row == 0) {\n                row1[idx] = ch;\n            } else {\n                row2[idx] = ch;\n            }\n            word += ch;\n            if (row == 1)\n                idx++;\n            row = 1 - row;\n            if (idx >= n) break;\n        }\n        // Fill the rest of the field with random letters\n        for (; idx < n; idx++) {\n            row1[idx] = 'a' + rnd.next(26);\n            row2[idx] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"large_field\") {\n        row1 = randomString(n);\n        row2 = randomString(n);\n        word = randomString(m);\n    } else {\n        // Unknown type, default to random\n        row1 = randomString(n);\n        row2 = randomString(n);\n        word = randomString(m);\n    }\n\n    printf(\"%s\\n%s\\n\\n%s\\n\", row1.c_str(), row2.c_str(), word.c_str());\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s;\n    for (int i = 0; i < len; ++i)\n        s += (char)('a' + rnd.next(26));\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\"); // field row length\n    int m = opt<int>(\"m\"); // word length\n    string type = opt<string>(\"type\", \"random\"); // default to random type\n\n    string row1, row2, word;\n    \n    if (type == \"random\") {\n        row1 = randomString(n);\n        row2 = randomString(n);\n        word = randomString(m);\n    } else if (type == \"same_letters\") {\n        char ch = 'a' + rnd.next(26);\n        row1 = string(n, ch);\n        row2 = string(n, ch);\n        word = string(m, ch);\n    } else if (type == \"impossible\") {\n        // Field letters from 'a' to 'y', word consists of 'z's\n        row1 = row2 = \"\";\n        for (int i = 0; i < n; ++i) {\n            row1 += (char)('a' + rnd.next(25)); // 'a' to 'y'\n            row2 += (char)('a' + rnd.next(25));\n        }\n        word = string(m, 'z'); // 'z'\n    } else if (type == \"min_paths\") {\n        // We need to ensure m is reasonable (<=26)\n        if (m > 26) m = 26;\n        string letters;\n        for (char c = 'a'; c < 'a' + m; ++c)\n            letters += c;\n        word = letters;\n        // Generate field with unique path matching the word\n        // Fill other positions with letters not in word\n        vector<char> other_letters;\n        for (char c = 'a' + m; c <= 'z'; ++c)\n            other_letters.push_back(c);\n        if (other_letters.empty()) {\n            // We cannot have letters not in word\n            // So we reduce m\n            m = 20;\n            letters = \"\";\n            for (char c = 'a'; c < 'a' + m; ++c)\n                letters += c;\n            word = letters;\n            other_letters.clear();\n            for (char c = 'a' + m; c <= 'z'; ++c)\n                other_letters.push_back(c);\n        }\n        row1 = \"\";\n        row2 = \"\";\n        int row = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i < m) {\n                if (row == 0) {\n                    row1 += word[i];\n                    row2 += other_letters[rnd.next(other_letters.size())];\n                } else {\n                    row1 += other_letters[rnd.next(other_letters.size())];\n                    row2 += word[i];\n                }\n                row = 1 - row;\n            } else {\n                row1 += other_letters[rnd.next(other_letters.size())];\n                row2 += other_letters[rnd.next(other_letters.size())];\n            }\n        }\n    } else if (type == \"long_word\") {\n        // m <= 2n\n        m = min(m, 2 * n);\n        row1 = string(n, 'a');\n        row2 = string(n, 'a');\n        word = \"\";\n        int row = 0;\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            char ch = 'a' + rnd.next(26);\n            if (row == 0) {\n                row1[idx] = ch;\n            } else {\n                row2[idx] = ch;\n            }\n            word += ch;\n            if (row == 1)\n                idx++;\n            row = 1 - row;\n            if (idx >= n) break;\n        }\n        // Fill the rest of the field with random letters\n        for (; idx < n; idx++) {\n            row1[idx] = 'a' + rnd.next(26);\n            row2[idx] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"large_field\") {\n        row1 = randomString(n);\n        row2 = randomString(n);\n        word = randomString(m);\n    } else {\n        // Unknown type, default to random\n        row1 = randomString(n);\n        row2 = randomString(n);\n        word = randomString(m);\n    }\n\n    printf(\"%s\\n%s\\n\\n%s\\n\", row1.c_str(), row2.c_str(), word.c_str());\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type same_letters\n./gen -n 1 -m 1 -type impossible\n./gen -n 2 -m 2 -type min_paths\n./gen -n 5 -m 5 -type min_paths\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type same_letters\n./gen -n 10 -m 5 -type min_paths\n./gen -n 10 -m 5 -type impossible\n./gen -n 50 -m 20 -type min_paths\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type same_letters\n./gen -n 50 -m 50 -type impossible\n./gen -n 500 -m 20 -type min_paths\n./gen -n 500 -m 200 -type impossible\n./gen -n 500 -m 200 -type long_word\n./gen -n 1000 -m 26 -type min_paths\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type same_letters\n./gen -n 1000 -m 1000 -type long_word\n./gen -n 1000 -m 500 -type large_field\n./gen -n 2000 -m 1 -type large_field\n./gen -n 2000 -m 2000 -type random\n./gen -n 2000 -m 2000 -type same_letters\n./gen -n 2000 -m 2000 -type impossible\n./gen -n 2000 -m 4000 -type long_word\n./gen -n 2000 -m 2000 -type large_field\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:05.139239",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "614/A",
      "title": "A. Link/Cut Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three space-separated integers l, r and k (1 ≤ l ≤ r ≤ 1018, 2 ≤ k ≤ 109).",
      "output_spec": "OutputPrint all powers of number k, that lie within range from l to r in the increasing order. If there are no such numbers, print \"-1\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy1 10 2OutputCopy1 2 4 8 InputCopy2 4 5OutputCopy-1",
      "description": "A. Link/Cut Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three space-separated integers l, r and k (1 ≤ l ≤ r ≤ 1018, 2 ≤ k ≤ 109).\n\nOutputPrint all powers of number k, that lie within range from l to r in the increasing order. If there are no such numbers, print \"-1\" (without the quotes).\n\nInputCopy1 10 2OutputCopy1 2 4 8 InputCopy2 4 5OutputCopy-1\n\nInputCopy1 10 2\n\nOutputCopy1 2 4 8\n\nInputCopy2 4 5\n\nOutputCopy-1\n\nNoteNote to the first sample: numbers 20 = 1, 21 = 2, 22 = 4, 23 = 8 lie within the specified range. The number 24 = 16 is greater then 10, thus it shouldn't be printed.",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 614\\s*A"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "// File: gen.cpp\n#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_LR = 1000000000000000000LL;\nconst int MAX_K = 1000000000;\n\nlong long power_k(int k, int e) {\n    long long res = 1;\n    for (int i = 0; i < e; ++i) {\n        if (res > MAX_LR / k)\n            return MAX_LR + 1; // Exceeded MAX_LR\n        res *= k;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long l = opt<long long>(\"l\", -1);\n    long long r = opt<long long>(\"r\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    if (type == \"random\") {\n        if (l == -1LL) l = rnd.next(1LL, MAX_LR);\n        if (r == -1LL) r = rnd.next(l, MAX_LR);\n        if (k == -1) k = rnd.next(2, MAX_K);\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"max_powers\") {\n        l = 1LL;\n        r = MAX_LR;\n        k = 2;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"no_powers\") {\n        if (k == -1) k = rnd.next(2, MAX_K);\n\n        long long curr = 1;\n        int e = 0;\n        while (curr < l && curr <= MAX_LR) {\n            if (curr > MAX_LR / k) break;\n            curr *= k;\n            ++e;\n        }\n        if (curr >= l && curr <= r) {\n            // Shift l and r to avoid powers\n            l = curr + 1;\n            r = l + rnd.next(1LL, 1000LL);\n            if (r > MAX_LR) r = MAX_LR;\n        } else {\n            l = curr + 1;\n            r = l + rnd.next(1LL, 1000LL);\n            if (r > MAX_LR) r = MAX_LR;\n        }\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"single_power\") {\n        if (k == -1) k = rnd.next(2, MAX_K);\n        vector<long long> powers;\n        long long curr = 1;\n        while (true) {\n            powers.push_back(curr);\n            if (curr > MAX_LR / k) break;\n            curr *= k;\n        }\n        int idx = rnd.next(0, (int)powers.size() - 1);\n        l = r = powers[idx];\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"minimal\") {\n        l = 1LL;\n        r = 1LL;\n        k = 2;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"edge_cases\") {\n        int edge_case_number = rnd.next(1, 4);\n        if (edge_case_number == 1) {\n            l = MAX_LR;\n            r = MAX_LR;\n            k = MAX_K;\n        } else if (edge_case_number == 2) {\n            l = 1;\n            r = MAX_LR;\n            k = MAX_K;\n        } else if (edge_case_number == 3) {\n            l = MAX_LR - 10;\n            r = MAX_LR;\n            k = 2;\n        } else if (edge_case_number == 4) {\n            l = 1;\n            r = rnd.next(1LL, 100LL);\n            k = 2;\n        }\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"large_k\") {\n        l = rnd.next(1LL, MAX_LR);\n        r = rnd.next(l, MAX_LR);\n        k = MAX_K;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"small_k\") {\n        l = rnd.next(1LL, MAX_LR);\n        r = rnd.next(l, MAX_LR);\n        k = 2;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else {\n        // Default to random\n        if (l == -1LL) l = rnd.next(1LL, MAX_LR);\n        if (r == -1LL) r = rnd.next(l, MAX_LR);\n        if (k == -1) k = rnd.next(2, MAX_K);\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "// File: gen.cpp\n#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_LR = 1000000000000000000LL;\nconst int MAX_K = 1000000000;\n\nlong long power_k(int k, int e) {\n    long long res = 1;\n    for (int i = 0; i < e; ++i) {\n        if (res > MAX_LR / k)\n            return MAX_LR + 1; // Exceeded MAX_LR\n        res *= k;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long l = opt<long long>(\"l\", -1);\n    long long r = opt<long long>(\"r\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    if (type == \"random\") {\n        if (l == -1LL) l = rnd.next(1LL, MAX_LR);\n        if (r == -1LL) r = rnd.next(l, MAX_LR);\n        if (k == -1) k = rnd.next(2, MAX_K);\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"max_powers\") {\n        l = 1LL;\n        r = MAX_LR;\n        k = 2;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"no_powers\") {\n        if (k == -1) k = rnd.next(2, MAX_K);\n\n        long long curr = 1;\n        int e = 0;\n        while (curr < l && curr <= MAX_LR) {\n            if (curr > MAX_LR / k) break;\n            curr *= k;\n            ++e;\n        }\n        if (curr >= l && curr <= r) {\n            // Shift l and r to avoid powers\n            l = curr + 1;\n            r = l + rnd.next(1LL, 1000LL);\n            if (r > MAX_LR) r = MAX_LR;\n        } else {\n            l = curr + 1;\n            r = l + rnd.next(1LL, 1000LL);\n            if (r > MAX_LR) r = MAX_LR;\n        }\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"single_power\") {\n        if (k == -1) k = rnd.next(2, MAX_K);\n        vector<long long> powers;\n        long long curr = 1;\n        while (true) {\n            powers.push_back(curr);\n            if (curr > MAX_LR / k) break;\n            curr *= k;\n        }\n        int idx = rnd.next(0, (int)powers.size() - 1);\n        l = r = powers[idx];\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"minimal\") {\n        l = 1LL;\n        r = 1LL;\n        k = 2;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"edge_cases\") {\n        int edge_case_number = rnd.next(1, 4);\n        if (edge_case_number == 1) {\n            l = MAX_LR;\n            r = MAX_LR;\n            k = MAX_K;\n        } else if (edge_case_number == 2) {\n            l = 1;\n            r = MAX_LR;\n            k = MAX_K;\n        } else if (edge_case_number == 3) {\n            l = MAX_LR - 10;\n            r = MAX_LR;\n            k = 2;\n        } else if (edge_case_number == 4) {\n            l = 1;\n            r = rnd.next(1LL, 100LL);\n            k = 2;\n        }\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"large_k\") {\n        l = rnd.next(1LL, MAX_LR);\n        r = rnd.next(l, MAX_LR);\n        k = MAX_K;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else if (type == \"small_k\") {\n        l = rnd.next(1LL, MAX_LR);\n        r = rnd.next(l, MAX_LR);\n        k = 2;\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    } else {\n        // Default to random\n        if (l == -1LL) l = rnd.next(1LL, MAX_LR);\n        if (r == -1LL) r = rnd.next(l, MAX_LR);\n        if (k == -1) k = rnd.next(2, MAX_K);\n        printf(\"%lld %lld %d\\n\", l, r, k);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n./gen -type max_powers\n./gen -type single_power\n./gen -type single_power -k 2\n./gen -type single_power -k 1000000000\n./gen -type no_powers\n./gen -type no_powers -k 2\n./gen -type no_powers -k 1000000000\n./gen -type edge_cases\n./gen -type edge_cases\n./gen -type edge_cases\n./gen -type small_k\n./gen -type large_k\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -k 2\n./gen -type random -k 1000000000\n./gen -type random -l 1 -r 1000000000\n./gen -type random -l 1 -r 1000 -k 2\n./gen -type random -l 999999999999999000 -r 1000000000000000000 -k 2\n./gen -type random -l 1 -r 1000 -k 1000000000\n./gen -type random -l 999999999999999000 -r 1000000000000000000 -k 1000000000\n./gen -type random -l 1 -r 1\n./gen -type random -l 1000000000000000000 -r 1000000000000000000\n./gen -type random -l 1 -r 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:07.549764",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "614/B",
      "title": "B. Gena's Code",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains the number of countries n (1 ≤ n ≤ 100 000). The second line contains n non-negative integers ai without leading zeroes — the number of tanks of the i-th country.It is guaranteed that the second line contains at least n - 1 beautiful numbers and the total length of all these number's representations doesn't exceed 100 000.",
      "output_spec": "OutputPrint a single number without leading zeroes — the product of the number of tanks presented by each country.",
      "sample_tests": "ExamplesInputCopy35 10 1OutputCopy50InputCopy41 1 10 11OutputCopy110InputCopy50 3 1 100 1OutputCopy0",
      "description": "B. Gena's Code\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains the number of countries n (1 ≤ n ≤ 100 000). The second line contains n non-negative integers ai without leading zeroes — the number of tanks of the i-th country.It is guaranteed that the second line contains at least n - 1 beautiful numbers and the total length of all these number's representations doesn't exceed 100 000.\n\nOutputPrint a single number without leading zeroes — the product of the number of tanks presented by each country.\n\nInputCopy35 10 1OutputCopy50InputCopy41 1 10 11OutputCopy110InputCopy50 3 1 100 1OutputCopy0\n\nInputCopy35 10 1\n\nOutputCopy50\n\nInputCopy41 1 10 11\n\nOutputCopy110\n\nInputCopy50 3 1 100 1\n\nOutputCopy0\n\nNoteIn sample 1 numbers 10 and 1 are beautiful, number 5 is not not.In sample 2 number 11 is not beautiful (contains two '1's), all others are beautiful.In sample 3 number 3 is not beautiful, all others are beautiful.",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 614\\s*B"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int num_beautiful = 0;\n    long long total_beautiful_length = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) inf.readSpace();\n\n        string variableName = \"a[\" + to_string(i + 1) + \"]\";\n        string s = inf.readToken(\"^[0-9]+$\", variableName);\n\n        // Check that s does not have leading zeros (except for '0')\n        if (s != \"0\" && s[0] == '0') {\n            ensuref(false, \"a[%d] has leading zeros\", i + 1);\n        }\n\n        // Check if s is a beautiful number\n        bool is_beautiful = true;\n        int count_ones = 0;\n\n        for (char c : s) {\n            if (c != '0' && c != '1') {\n                is_beautiful = false;\n                break;\n            }\n            if (c == '1') {\n                count_ones += 1;\n                if (count_ones > 1) {\n                    is_beautiful = false;\n                    break;\n                }\n            }\n        }\n\n        if (is_beautiful) {\n            num_beautiful += 1;\n            total_beautiful_length += s.length();\n        }\n    }\n\n    inf.readEoln();\n\n    ensuref(num_beautiful >= n - 1, \"Number of beautiful numbers (%d) is less than n - 1 (%d)\", num_beautiful, n - 1);\n    ensuref(total_beautiful_length <= 100000LL, \"Total length of beautiful numbers (%lld) exceeds 100000\", total_beautiful_length);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int num_beautiful = 0;\n    long long total_beautiful_length = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) inf.readSpace();\n\n        string variableName = \"a[\" + to_string(i + 1) + \"]\";\n        string s = inf.readToken(\"^[0-9]+$\", variableName);\n\n        // Check that s does not have leading zeros (except for '0')\n        if (s != \"0\" && s[0] == '0') {\n            ensuref(false, \"a[%d] has leading zeros\", i + 1);\n        }\n\n        // Check if s is a beautiful number\n        bool is_beautiful = true;\n        int count_ones = 0;\n\n        for (char c : s) {\n            if (c != '0' && c != '1') {\n                is_beautiful = false;\n                break;\n            }\n            if (c == '1') {\n                count_ones += 1;\n                if (count_ones > 1) {\n                    is_beautiful = false;\n                    break;\n                }\n            }\n        }\n\n        if (is_beautiful) {\n            num_beautiful += 1;\n            total_beautiful_length += s.length();\n        }\n    }\n\n    inf.readEoln();\n\n    ensuref(num_beautiful >= n - 1, \"Number of beautiful numbers (%d) is less than n - 1 (%d)\", num_beautiful, n - 1);\n    ensuref(total_beautiful_length <= 100000LL, \"Total length of beautiful numbers (%lld) exceeds 100000\", total_beautiful_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int num_beautiful = 0;\n    long long total_beautiful_length = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) inf.readSpace();\n\n        string variableName = \"a[\" + to_string(i + 1) + \"]\";\n        string s = inf.readToken(\"^[0-9]+$\", variableName);\n\n        // Check that s does not have leading zeros (except for '0')\n        if (s != \"0\" && s[0] == '0') {\n            ensuref(false, \"a[%d] has leading zeros\", i + 1);\n        }\n\n        // Check if s is a beautiful number\n        bool is_beautiful = true;\n        int count_ones = 0;\n\n        for (char c : s) {\n            if (c != '0' && c != '1') {\n                is_beautiful = false;\n                break;\n            }\n            if (c == '1') {\n                count_ones += 1;\n                if (count_ones > 1) {\n                    is_beautiful = false;\n                    break;\n                }\n            }\n        }\n\n        if (is_beautiful) {\n            num_beautiful += 1;\n            total_beautiful_length += s.length();\n        }\n    }\n\n    inf.readEoln();\n\n    ensuref(num_beautiful >= n - 1, \"Number of beautiful numbers (%d) is less than n - 1 (%d)\", num_beautiful, n - 1);\n    ensuref(total_beautiful_length <= 100000LL, \"Total length of beautiful numbers (%lld) exceeds 100000\", total_beautiful_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxlen = opt<int>(\"maxlen\", 100000);\n    string mode = opt<string>(\"mode\", \"random\");\n\n    vector<string> ai(n);\n\n    int num_beautiful = n;\n    int num_non_beautiful = 0;\n    vector<int> non_beautiful_indices;\n\n    if (mode == \"all_ones\") {\n        // All ai are '1'\n        for (int i = 0; i < n; ++i) {\n            ai[i] = \"1\";\n        }\n    } else if (mode == \"all_zeros\") {\n        // All ai are '0'\n        for (int i = 0; i < n; ++i) {\n            ai[i] = \"0\";\n        }\n    } else if (mode == \"single_large_non_beautiful\") {\n        // n - 1 beautiful numbers, 1 non-beautiful\n        num_non_beautiful = 1;\n        num_beautiful = n - num_non_beautiful;\n        // Generate positions for non-beautiful numbers\n        int idx = rnd.next(0, n - 1);\n        non_beautiful_indices.push_back(idx);\n\n        // Generate beautiful numbers\n        // We can set them to '1'\n        for (int i = 0; i < n; ++i) {\n            if (i != idx) {\n                ai[i] = \"1\";\n            }\n        }\n        // Generate one non-beautiful number\n        ai[idx] = \"12\"; // Any number not beautiful\n    } else if (mode == \"max_length_beautiful\") {\n        // n - 1 beautiful numbers with lengths summing to maxlen\n        num_non_beautiful = n >= 2 ? 1 : 0;\n        num_beautiful = n - num_non_beautiful;\n\n        int total_length_beautiful = maxlen;\n        if (num_beautiful == 0) {\n            total_length_beautiful = 0;\n        } else {\n            // Must have at least length of num_beautiful (since minimum length of each is 1)\n            total_length_beautiful = min(maxlen, num_beautiful * 100000); // limit length\n        }\n\n        int extra_length = total_length_beautiful - num_beautiful;\n\n        // Distribute extra_length among beautiful numbers\n        vector<int> positions;\n        positions.push_back(0);\n        positions.push_back(extra_length);\n\n        for (int i = 0; i < num_beautiful - 1; ++i) {\n            positions.push_back(rnd.next(0, extra_length));\n        }\n\n        sort(positions.begin(), positions.end());\n\n        vector<int> lengths;\n        for (int i = 0; i < num_beautiful; ++i) {\n            int len = positions[i + 1] - positions[i] + 1; // +1 for minimum length\n            lengths.push_back(len);\n        }\n\n        // Assign lengths to the beautiful numbers\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (num_non_beautiful == 1 && i == n - 1) {\n                continue;\n            }\n            int len = lengths[idx++];\n            ai[i] = \"1\" + string(len - 1, '0');\n        }\n\n        // Generate one non-beautiful number\n        if (num_non_beautiful == 1) {\n            ai[n - 1] = \"11\"; // Non-beautiful number\n        }\n    } else if (mode == \"random\") {\n        // Randomly generate n numbers, at least n - 1 beautiful\n        num_non_beautiful = rnd.next(0, 1);\n        num_beautiful = n - num_non_beautiful;\n\n        // Decide positions for non-beautiful numbers\n        if (num_non_beautiful == 1) {\n            int idx = rnd.next(0, n - 1);\n            non_beautiful_indices.push_back(idx);\n        }\n\n        // Ensure total length of beautiful numbers does not exceed maxlen\n        int total_length_beautiful = maxlen;\n        if (num_beautiful == 0) {\n            total_length_beautiful = 0;\n        } else {\n            total_length_beautiful = min(maxlen, num_beautiful * 100000); // limit length\n        }\n\n        int extra_length = total_length_beautiful - num_beautiful;\n\n        // Distribute extra_length among beautiful numbers\n        vector<int> positions;\n        positions.push_back(0);\n        positions.push_back(extra_length);\n\n        for (int i = 0; i < num_beautiful - 1; ++i) {\n            positions.push_back(rnd.next(0, extra_length));\n        }\n\n        sort(positions.begin(), positions.end());\n\n        vector<int> lengths;\n        for (int i = 0; i < num_beautiful; ++i) {\n            int len = positions[i + 1] - positions[i] + 1; // +1 for minimum length\n            lengths.push_back(len);\n        }\n\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (num_non_beautiful == 1 && non_beautiful_indices.size() && i == non_beautiful_indices[0]) {\n                continue;\n            }\n            // Generate beautiful numbers\n            int len = lengths[idx++];\n            int type = rnd.next(1, 3);\n            if (type == 1) {\n                // '0'\n                ai[i] = \"0\";\n            } else if (type == 2) {\n                // '1'\n                ai[i] = \"1\";\n            } else {\n                // '1' followed by zeros\n                ai[i] = \"1\" + string(len - 1, '0');\n            }\n        }\n\n        // Generate non-beautiful numbers\n        for (int idx : non_beautiful_indices) {\n            // Generate a random non-beautiful number with length between 1 and 5\n            int len = rnd.next(1, 5);\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                char digit = '2' + rnd.next(0, 7); // digits '2' to '9'\n                s += digit;\n            }\n            ai[idx] = s;\n        }\n    } else {\n        // Default: all ai are '1's\n        for (int i = 0; i < n; ++i) {\n            ai[i] = \"1\";\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", ai[i].c_str());\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxlen = opt<int>(\"maxlen\", 100000);\n    string mode = opt<string>(\"mode\", \"random\");\n\n    vector<string> ai(n);\n\n    int num_beautiful = n;\n    int num_non_beautiful = 0;\n    vector<int> non_beautiful_indices;\n\n    if (mode == \"all_ones\") {\n        // All ai are '1'\n        for (int i = 0; i < n; ++i) {\n            ai[i] = \"1\";\n        }\n    } else if (mode == \"all_zeros\") {\n        // All ai are '0'\n        for (int i = 0; i < n; ++i) {\n            ai[i] = \"0\";\n        }\n    } else if (mode == \"single_large_non_beautiful\") {\n        // n - 1 beautiful numbers, 1 non-beautiful\n        num_non_beautiful = 1;\n        num_beautiful = n - num_non_beautiful;\n        // Generate positions for non-beautiful numbers\n        int idx = rnd.next(0, n - 1);\n        non_beautiful_indices.push_back(idx);\n\n        // Generate beautiful numbers\n        // We can set them to '1'\n        for (int i = 0; i < n; ++i) {\n            if (i != idx) {\n                ai[i] = \"1\";\n            }\n        }\n        // Generate one non-beautiful number\n        ai[idx] = \"12\"; // Any number not beautiful\n    } else if (mode == \"max_length_beautiful\") {\n        // n - 1 beautiful numbers with lengths summing to maxlen\n        num_non_beautiful = n >= 2 ? 1 : 0;\n        num_beautiful = n - num_non_beautiful;\n\n        int total_length_beautiful = maxlen;\n        if (num_beautiful == 0) {\n            total_length_beautiful = 0;\n        } else {\n            // Must have at least length of num_beautiful (since minimum length of each is 1)\n            total_length_beautiful = min(maxlen, num_beautiful * 100000); // limit length\n        }\n\n        int extra_length = total_length_beautiful - num_beautiful;\n\n        // Distribute extra_length among beautiful numbers\n        vector<int> positions;\n        positions.push_back(0);\n        positions.push_back(extra_length);\n\n        for (int i = 0; i < num_beautiful - 1; ++i) {\n            positions.push_back(rnd.next(0, extra_length));\n        }\n\n        sort(positions.begin(), positions.end());\n\n        vector<int> lengths;\n        for (int i = 0; i < num_beautiful; ++i) {\n            int len = positions[i + 1] - positions[i] + 1; // +1 for minimum length\n            lengths.push_back(len);\n        }\n\n        // Assign lengths to the beautiful numbers\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (num_non_beautiful == 1 && i == n - 1) {\n                continue;\n            }\n            int len = lengths[idx++];\n            ai[i] = \"1\" + string(len - 1, '0');\n        }\n\n        // Generate one non-beautiful number\n        if (num_non_beautiful == 1) {\n            ai[n - 1] = \"11\"; // Non-beautiful number\n        }\n    } else if (mode == \"random\") {\n        // Randomly generate n numbers, at least n - 1 beautiful\n        num_non_beautiful = rnd.next(0, 1);\n        num_beautiful = n - num_non_beautiful;\n\n        // Decide positions for non-beautiful numbers\n        if (num_non_beautiful == 1) {\n            int idx = rnd.next(0, n - 1);\n            non_beautiful_indices.push_back(idx);\n        }\n\n        // Ensure total length of beautiful numbers does not exceed maxlen\n        int total_length_beautiful = maxlen;\n        if (num_beautiful == 0) {\n            total_length_beautiful = 0;\n        } else {\n            total_length_beautiful = min(maxlen, num_beautiful * 100000); // limit length\n        }\n\n        int extra_length = total_length_beautiful - num_beautiful;\n\n        // Distribute extra_length among beautiful numbers\n        vector<int> positions;\n        positions.push_back(0);\n        positions.push_back(extra_length);\n\n        for (int i = 0; i < num_beautiful - 1; ++i) {\n            positions.push_back(rnd.next(0, extra_length));\n        }\n\n        sort(positions.begin(), positions.end());\n\n        vector<int> lengths;\n        for (int i = 0; i < num_beautiful; ++i) {\n            int len = positions[i + 1] - positions[i] + 1; // +1 for minimum length\n            lengths.push_back(len);\n        }\n\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (num_non_beautiful == 1 && non_beautiful_indices.size() && i == non_beautiful_indices[0]) {\n                continue;\n            }\n            // Generate beautiful numbers\n            int len = lengths[idx++];\n            int type = rnd.next(1, 3);\n            if (type == 1) {\n                // '0'\n                ai[i] = \"0\";\n            } else if (type == 2) {\n                // '1'\n                ai[i] = \"1\";\n            } else {\n                // '1' followed by zeros\n                ai[i] = \"1\" + string(len - 1, '0');\n            }\n        }\n\n        // Generate non-beautiful numbers\n        for (int idx : non_beautiful_indices) {\n            // Generate a random non-beautiful number with length between 1 and 5\n            int len = rnd.next(1, 5);\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                char digit = '2' + rnd.next(0, 7); // digits '2' to '9'\n                s += digit;\n            }\n            ai[idx] = s;\n        }\n    } else {\n        // Default: all ai are '1's\n        for (int i = 0; i < n; ++i) {\n            ai[i] = \"1\";\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", ai[i].c_str());\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, all ones\n./gen -n 1 -mode all_ones\n./gen -n 5 -mode all_ones\n./gen -n 10 -mode all_ones\n\n# Small n, all zeros\n./gen -n 1 -mode all_zeros\n./gen -n 5 -mode all_zeros\n./gen -n 10 -mode all_zeros\n\n# Medium n, single large non-beautiful number\n./gen -n 100 -mode single_large_non_beautiful\n./gen -n 1000 -mode single_large_non_beautiful\n\n# Large n, single large non-beautiful number\n./gen -n 100000 -mode single_large_non_beautiful\n\n# Max length beautiful numbers\n./gen -n 1 -mode max_length_beautiful -maxlen 100000\n./gen -n 10 -mode max_length_beautiful -maxlen 100000\n./gen -n 1000 -mode max_length_beautiful -maxlen 100000\n./gen -n 100000 -mode max_length_beautiful -maxlen 100000\n\n# Random mode with small n\n./gen -n 10 -mode random\n./gen -n 50 -mode random\n\n# Random mode with medium n\n./gen -n 1000 -mode random\n\n# Random mode with large n\n./gen -n 100000 -mode random\n\n# Random mode with zero included\n./gen -n 10000 -mode random\n\n# Edge case: n = 1\n./gen -n 1 -mode random\n\n# Edge case: n = maximum, all ones\n./gen -n 100000 -mode all_ones\n\n# Edge case: n = maximum, all zeros\n./gen -n 100000 -mode all_zeros\n\n# Edge case: n = maximum, random mode\n./gen -n 100000 -mode random\n\n# Edge case: sum of lengths of beautiful numbers close to 100000\n./gen -n 500 -mode max_length_beautiful -maxlen 100000\n\n# Edge case: total length of beautiful numbers is minimal\n./gen -n 100000 -mode all_ones\n\n# Test with zeros in ai's\n./gen -n 100 -mode random\n\n# Test with non-beautiful zeros\n./gen -n 1000 -mode single_large_non_beautiful\n\n# Test with large numbers\n./gen -n 50 -mode max_length_beautiful -maxlen 100000\n\n# Test with maximum ai length for beautiful numbers\n./gen -n 1 -mode max_length_beautiful -maxlen 100000\n\n# Random tests to cover various cases\n./gen -n 10000 -mode random\n./gen -n 50000 -mode random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:09.467459",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "614/C",
      "title": "C. Peter and Snow Blower",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers — the number of vertices of the polygon n (), and coordinates of point P.Each of the next n lines contains two integers — coordinates of the vertices of the polygon in the clockwise or counterclockwise order. It is guaranteed that no three consecutive vertices lie on a common straight line.All the numbers in the input are integers that do not exceed 1 000 000 in their absolute value.",
      "output_spec": "OutputPrint a single real value number — the area of the region that will be cleared. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy3 0 00 1-1 21 2OutputCopy12.566370614359172464InputCopy4 1 -10 01 22 01 1OutputCopy21.991148575128551812",
      "description": "C. Peter and Snow Blower\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three integers — the number of vertices of the polygon n (), and coordinates of point P.Each of the next n lines contains two integers — coordinates of the vertices of the polygon in the clockwise or counterclockwise order. It is guaranteed that no three consecutive vertices lie on a common straight line.All the numbers in the input are integers that do not exceed 1 000 000 in their absolute value.\n\nOutputPrint a single real value number — the area of the region that will be cleared. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy3 0 00 1-1 21 2OutputCopy12.566370614359172464InputCopy4 1 -10 01 22 01 1OutputCopy21.991148575128551812\n\nInputCopy3 0 00 1-1 21 2\n\nOutputCopy12.566370614359172464\n\nInputCopy4 1 -10 01 22 01 1\n\nOutputCopy21.991148575128551812\n\nNoteIn the first sample snow will be removed from that area:",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 614 和字母"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int x_P = inf.readInt(-1000000, 1000000, \"x_P\");\n    inf.readSpace();\n    int y_P = inf.readInt(-1000000, 1000000, \"y_P\");\n    inf.readEoln();\n\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-1000000, 1000000);\n        inf.readSpace();\n        y[i] = inf.readInt(-1000000, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        int x0 = x[prev], y0 = y[prev];\n        int x1 = x[i], y1 = y[i];\n        int x2 = x[next], y2 = y[next];\n        long long cross = 1LL * (x1 - x0) * (y2 - y0) - 1LL * (x2 - x0) * (y1 - y0);\n        ensuref(cross != 0, \"Three consecutive vertices are colinear at positions %d, %d, %d\", prev + 1, i + 1, next + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int x_P = inf.readInt(-1000000, 1000000, \"x_P\");\n    inf.readSpace();\n    int y_P = inf.readInt(-1000000, 1000000, \"y_P\");\n    inf.readEoln();\n\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-1000000, 1000000);\n        inf.readSpace();\n        y[i] = inf.readInt(-1000000, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        int x0 = x[prev], y0 = y[prev];\n        int x1 = x[i], y1 = y[i];\n        int x2 = x[next], y2 = y[next];\n        long long cross = 1LL * (x1 - x0) * (y2 - y0) - 1LL * (x2 - x0) * (y1 - y0);\n        ensuref(cross != 0, \"Three consecutive vertices are colinear at positions %d, %d, %d\", prev + 1, i + 1, next + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int x_P = inf.readInt(-1000000, 1000000, \"x_P\");\n    inf.readSpace();\n    int y_P = inf.readInt(-1000000, 1000000, \"y_P\");\n    inf.readEoln();\n\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(-1000000, 1000000);\n        inf.readSpace();\n        y[i] = inf.readInt(-1000000, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        int x0 = x[prev], y0 = y[prev];\n        int x1 = x[i], y1 = y[i];\n        int x2 = x[next], y2 = y[next];\n        long long cross = 1LL * (x1 - x0) * (y2 - y0) - 1LL * (x2 - x0) * (y1 - y0);\n        ensuref(cross != 0, \"Three consecutive vertices are colinear at positions %d, %d, %d\", prev + 1, i + 1, next + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define PI 3.14159265358979323846\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_convex\");\n    int max_coord = opt<int>(\"max_coord\", 1000000);\n\n    int xP = opt<int>(\"xP\", rnd.next(-max_coord, max_coord));\n    int yP = opt<int>(\"yP\", rnd.next(-max_coord, max_coord));\n\n    vector<pair<int, int>> poly(n);\n\n    if (type == \"random_convex\") {\n        // Generate a random convex polygon\n\n        // Generate n angles\n        vector<double> angles(n);\n        for (int i = 0; i < n; i++) {\n            angles[i] = rnd.next(0.0, 2 * PI);\n        }\n        sort(angles.begin(), angles.end());\n\n        // Generate random radii\n        double min_radius = max_coord / 5.0;\n        double max_radius = max_coord / 1.5;\n        vector<double> radii(n);\n        for (int i = 0; i < n; i++) {\n            radii[i] = rnd.next(min_radius, max_radius);\n        }\n\n        for (int i = 0; i < n; i++) {\n            double angle = angles[i];\n            double r = radii[i];\n\n            int x = (int)(r * cos(angle));\n            int y = (int)(r * sin(angle));\n\n            poly[i] = make_pair(x, y);\n        }\n\n        // Ensure no three consecutive points are colinear\n        for (int i = 0; i < n; i++) {\n            int x1 = poly[(i + n - 1) % n].first;\n            int y1 = poly[(i + n - 1) % n].second;\n            int x2 = poly[i].first;\n            int y2 = poly[i].second;\n            int x3 = poly[(i + 1) % n].first;\n            int y3 = poly[(i + 1) % n].second;\n\n            // Check if the area of triangle (x1,y1)-(x2,y2)-(x3,y3) is zero\n            int area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n            if (area2 == 0) {\n                // Points are colinear\n                // Perturb point i slightly\n                poly[i].first += rnd.next(-2, 2);\n                poly[i].second += rnd.next(-2, 2);\n            }\n        }\n    } else if (type == \"star\") {\n        // Generate a star-shaped polygon\n        double inner_radius = max_coord / 3.0;\n        double outer_radius = max_coord / 1.5;\n\n        vector<double> angles;\n        for(int i = 0; i < n; ++i) {\n            angles.push_back(2 * PI * i / n);\n        }\n\n        for(int i = 0; i < n; ++i) {\n            double angle = angles[i];\n            double r = (i % 2 == 0) ? outer_radius : inner_radius;\n            r += rnd.next(-max_coord / 10.0, max_coord / 10.0);\n\n            int x = (int)(r * cos(angle));\n            int y = (int)(r * sin(angle));\n\n            poly[i] = make_pair(x, y);\n        }\n\n        // Ensure no three consecutive points are colinear\n        for (int i = 0; i < n; i++) {\n            int x1 = poly[(i + n - 1) % n].first;\n            int y1 = poly[(i + n - 1) % n].second;\n            int x2 = poly[i].first;\n            int y2 = poly[i].second;\n            int x3 = poly[(i + 1) % n].first;\n            int y3 = poly[(i + 1) % n].second;\n\n            // Check if the area of triangle (x1,y1)-(x2,y2)-(x3,y3) is zero\n            int area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n            if (area2 == 0) {\n                // Points are colinear\n                // Perturb point i slightly\n                poly[i].first += rnd.next(-2, 2);\n                poly[i].second += rnd.next(-2, 2);\n            }\n        }\n    } else if (type == \"concave\") {\n        // Generate a concave polygon\n        // One way is to generate a convex polygon and then indent one of its sides\n\n        // First, generate a convex polygon with n vertices\n        vector<double> angles(n);\n        for (int i = 0; i < n; i++) {\n            angles[i] = rnd.next(0.0, 2 * PI);\n        }\n        sort(angles.begin(), angles.end());\n\n        double min_radius = max_coord / 5.0;\n        double max_radius = max_coord / 1.5;\n        vector<double> radii(n);\n        for (int i = 0; i < n; i++) {\n            radii[i] = rnd.next(min_radius, max_radius);\n        }\n\n        for (int i = 0; i < n; i++) {\n            double angle = angles[i];\n            double r = radii[i];\n\n            int x = (int)(r * cos(angle));\n            int y = (int)(r * sin(angle));\n\n            poly[i] = make_pair(x, y);\n        }\n\n        // Now, indent one side to make it concave\n        int idx = rnd.next(0, n -1);\n        poly[idx].first /= 2;\n        poly[idx].second /= 2;\n\n        // Ensure no three consecutive points are colinear\n        for (int i = 0; i < n; i++) {\n            int x1 = poly[(i + n - 1) % n].first;\n            int y1 = poly[(i + n - 1) % n].second;\n            int x2 = poly[i].first;\n            int y2 = poly[i].second;\n            int x3 = poly[(i + 1) % n].first;\n            int y3 = poly[(i + 1) % n].second;\n\n            // Check if the area of triangle (x1,y1)-(x2,y2)-(x3,y3) is zero\n            int area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n            if (area2 == 0) {\n                // Points are colinear\n                // Perturb point i slightly\n                poly[i].first += rnd.next(-2, 2);\n                poly[i].second += rnd.next(-2, 2);\n            }\n        }\n\n    } else if (type == \"max_coord\") {\n        // Generate a polygon with coordinates near +/- max_coord\n        poly[0] = make_pair(max_coord, max_coord);\n        poly[1] = make_pair(-max_coord, max_coord);\n        poly[2] = make_pair(-max_coord, -max_coord);\n        poly[3] = make_pair(max_coord, -max_coord);\n        // Split edges to increase n\n        for (int i = 4; i < n; i++) {\n            int idx = i % 4;\n            int x = (poly[idx].first + poly[(idx + 1) % 4].first) / 2;\n            int y = (poly[idx].second + poly[(idx + 1) % 4].second) / 2;\n            poly[i] = make_pair(x, y);\n        }\n    } else if (type == \"small\") {\n        // Generate a small polygon with coordinates between -10 and 10\n        for (int i = 0; i < n; i++) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            poly[i] = make_pair(x, y);\n        }\n        // Ensure that the polygon is simple\n        // (Not guaranteed, but acceptable for small n)\n    } else {\n        // Default case\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that point P lies outside the polygon\n    // For this, we can compute the bounding box of the polygon and place P outside it\n\n    int xmin = poly[0].first, xmax = poly[0].first;\n    int ymin = poly[0].second, ymax = poly[0].second;\n    for (int i = 1; i < n; i++) {\n        xmin = min(xmin, poly[i].first);\n        xmax = max(xmax, poly[i].first);\n        ymin = min(ymin, poly[i].second);\n        ymax = max(ymax, poly[i].second);\n    }\n    // Adjust P to be outside the bounding box\n    if (xP >= xmin && xP <= xmax && yP >= ymin && yP <= ymax) {\n        // Move P outside\n        xP = xmax + rnd.next(1, max_coord / 10);\n        yP = ymax + rnd.next(1, max_coord / 10);\n    }\n\n    // Output n and P\n    printf(\"%d %d %d\\n\", n, xP, yP);\n\n    // Output the polygon vertices\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", poly[i].first, poly[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define PI 3.14159265358979323846\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_convex\");\n    int max_coord = opt<int>(\"max_coord\", 1000000);\n\n    int xP = opt<int>(\"xP\", rnd.next(-max_coord, max_coord));\n    int yP = opt<int>(\"yP\", rnd.next(-max_coord, max_coord));\n\n    vector<pair<int, int>> poly(n);\n\n    if (type == \"random_convex\") {\n        // Generate a random convex polygon\n\n        // Generate n angles\n        vector<double> angles(n);\n        for (int i = 0; i < n; i++) {\n            angles[i] = rnd.next(0.0, 2 * PI);\n        }\n        sort(angles.begin(), angles.end());\n\n        // Generate random radii\n        double min_radius = max_coord / 5.0;\n        double max_radius = max_coord / 1.5;\n        vector<double> radii(n);\n        for (int i = 0; i < n; i++) {\n            radii[i] = rnd.next(min_radius, max_radius);\n        }\n\n        for (int i = 0; i < n; i++) {\n            double angle = angles[i];\n            double r = radii[i];\n\n            int x = (int)(r * cos(angle));\n            int y = (int)(r * sin(angle));\n\n            poly[i] = make_pair(x, y);\n        }\n\n        // Ensure no three consecutive points are colinear\n        for (int i = 0; i < n; i++) {\n            int x1 = poly[(i + n - 1) % n].first;\n            int y1 = poly[(i + n - 1) % n].second;\n            int x2 = poly[i].first;\n            int y2 = poly[i].second;\n            int x3 = poly[(i + 1) % n].first;\n            int y3 = poly[(i + 1) % n].second;\n\n            // Check if the area of triangle (x1,y1)-(x2,y2)-(x3,y3) is zero\n            int area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n            if (area2 == 0) {\n                // Points are colinear\n                // Perturb point i slightly\n                poly[i].first += rnd.next(-2, 2);\n                poly[i].second += rnd.next(-2, 2);\n            }\n        }\n    } else if (type == \"star\") {\n        // Generate a star-shaped polygon\n        double inner_radius = max_coord / 3.0;\n        double outer_radius = max_coord / 1.5;\n\n        vector<double> angles;\n        for(int i = 0; i < n; ++i) {\n            angles.push_back(2 * PI * i / n);\n        }\n\n        for(int i = 0; i < n; ++i) {\n            double angle = angles[i];\n            double r = (i % 2 == 0) ? outer_radius : inner_radius;\n            r += rnd.next(-max_coord / 10.0, max_coord / 10.0);\n\n            int x = (int)(r * cos(angle));\n            int y = (int)(r * sin(angle));\n\n            poly[i] = make_pair(x, y);\n        }\n\n        // Ensure no three consecutive points are colinear\n        for (int i = 0; i < n; i++) {\n            int x1 = poly[(i + n - 1) % n].first;\n            int y1 = poly[(i + n - 1) % n].second;\n            int x2 = poly[i].first;\n            int y2 = poly[i].second;\n            int x3 = poly[(i + 1) % n].first;\n            int y3 = poly[(i + 1) % n].second;\n\n            // Check if the area of triangle (x1,y1)-(x2,y2)-(x3,y3) is zero\n            int area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n            if (area2 == 0) {\n                // Points are colinear\n                // Perturb point i slightly\n                poly[i].first += rnd.next(-2, 2);\n                poly[i].second += rnd.next(-2, 2);\n            }\n        }\n    } else if (type == \"concave\") {\n        // Generate a concave polygon\n        // One way is to generate a convex polygon and then indent one of its sides\n\n        // First, generate a convex polygon with n vertices\n        vector<double> angles(n);\n        for (int i = 0; i < n; i++) {\n            angles[i] = rnd.next(0.0, 2 * PI);\n        }\n        sort(angles.begin(), angles.end());\n\n        double min_radius = max_coord / 5.0;\n        double max_radius = max_coord / 1.5;\n        vector<double> radii(n);\n        for (int i = 0; i < n; i++) {\n            radii[i] = rnd.next(min_radius, max_radius);\n        }\n\n        for (int i = 0; i < n; i++) {\n            double angle = angles[i];\n            double r = radii[i];\n\n            int x = (int)(r * cos(angle));\n            int y = (int)(r * sin(angle));\n\n            poly[i] = make_pair(x, y);\n        }\n\n        // Now, indent one side to make it concave\n        int idx = rnd.next(0, n -1);\n        poly[idx].first /= 2;\n        poly[idx].second /= 2;\n\n        // Ensure no three consecutive points are colinear\n        for (int i = 0; i < n; i++) {\n            int x1 = poly[(i + n - 1) % n].first;\n            int y1 = poly[(i + n - 1) % n].second;\n            int x2 = poly[i].first;\n            int y2 = poly[i].second;\n            int x3 = poly[(i + 1) % n].first;\n            int y3 = poly[(i + 1) % n].second;\n\n            // Check if the area of triangle (x1,y1)-(x2,y2)-(x3,y3) is zero\n            int area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n            if (area2 == 0) {\n                // Points are colinear\n                // Perturb point i slightly\n                poly[i].first += rnd.next(-2, 2);\n                poly[i].second += rnd.next(-2, 2);\n            }\n        }\n\n    } else if (type == \"max_coord\") {\n        // Generate a polygon with coordinates near +/- max_coord\n        poly[0] = make_pair(max_coord, max_coord);\n        poly[1] = make_pair(-max_coord, max_coord);\n        poly[2] = make_pair(-max_coord, -max_coord);\n        poly[3] = make_pair(max_coord, -max_coord);\n        // Split edges to increase n\n        for (int i = 4; i < n; i++) {\n            int idx = i % 4;\n            int x = (poly[idx].first + poly[(idx + 1) % 4].first) / 2;\n            int y = (poly[idx].second + poly[(idx + 1) % 4].second) / 2;\n            poly[i] = make_pair(x, y);\n        }\n    } else if (type == \"small\") {\n        // Generate a small polygon with coordinates between -10 and 10\n        for (int i = 0; i < n; i++) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            poly[i] = make_pair(x, y);\n        }\n        // Ensure that the polygon is simple\n        // (Not guaranteed, but acceptable for small n)\n    } else {\n        // Default case\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that point P lies outside the polygon\n    // For this, we can compute the bounding box of the polygon and place P outside it\n\n    int xmin = poly[0].first, xmax = poly[0].first;\n    int ymin = poly[0].second, ymax = poly[0].second;\n    for (int i = 1; i < n; i++) {\n        xmin = min(xmin, poly[i].first);\n        xmax = max(xmax, poly[i].first);\n        ymin = min(ymin, poly[i].second);\n        ymax = max(ymax, poly[i].second);\n    }\n    // Adjust P to be outside the bounding box\n    if (xP >= xmin && xP <= xmax && yP >= ymin && yP <= ymax) {\n        // Move P outside\n        xP = xmax + rnd.next(1, max_coord / 10);\n        yP = ymax + rnd.next(1, max_coord / 10);\n    }\n\n    // Output n and P\n    printf(\"%d %d %d\\n\", n, xP, yP);\n\n    // Output the polygon vertices\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", poly[i].first, poly[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random_convex -xP 0 -yP 0\n./gen -n 3 -type random_convex -xP 1000000 -yP 1000000\n./gen -n 4 -type star -xP -1000000 -yP -1000000\n./gen -n 5 -type concave -xP 500000 -yP -500000\n\n./gen -n 10 -type random_convex\n./gen -n 10 -type concave\n./gen -n 10 -type star\n\n./gen -n 100 -type random_convex\n./gen -n 100 -type concave\n./gen -n 100 -type star\n\n./gen -n 1000 -type random_convex\n./gen -n 1000 -type concave\n./gen -n 1000 -type star\n\n./gen -n 10000 -type random_convex\n./gen -n 10000 -type concave\n./gen -n 10000 -type star\n\n./gen -n 100000 -type random_convex\n./gen -n 100000 -type concave\n./gen -n 100000 -type star\n\n./gen -n 100000 -type max_coord\n./gen -n 3 -type small\n./gen -n 3 -type small -xP 0 -yP 0\n\n./gen -n 100000 -type random_convex -xP 1000000 -yP 1000000\n\n./gen -n 10000 -type random_convex -xP -1000000 -yP -1000000\n\n./gen -n 50000 -type star -xP 0 -yP 0\n\n./gen -n 99999 -type concave -xP 123456 -yP 654321\n\n./gen -n 1000 -type random_convex -xP 0 -yP 0\n./gen -n 1000 -type concave -xP 500000 -yP 500000\n\n./gen -n 100 -type random_convex -xP 1 -yP 1\n\n./gen -n 100 -type random_convex -xP 999999 -yP 999999\n\n./gen -n 500 -type random_convex -xP -999999 -yP -999999\n\n./gen -n 1000 -type random_convex -xP 0 -yP 1000000\n\n./gen -n 1000 -type random_convex -xP 1000000 -yP 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:11.274837",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "614/D",
      "title": "D. Навыки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны пять целых чисел n, A, cf, cm и m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 109, 0 ≤ cf, cm ≤ 1000, 0 ≤ m ≤ 1015).Во второй строке записано ровно n целых чисел ai (0 ≤ ai ≤ A), разделённых пробелами, — текущие уровни навыков.",
      "output_spec": "Выходные данныеСначала выведите максимальное значение Cилы, которое может получить персонаж.Затем выведите n целых чисел — a'i (ai ≤ a'i ≤ A), уровни навыков, до которых следует развиться, чтобы достичь указанного значения Силы, при этом используя не более m денежных единиц. Если правильных ответов несколько — выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 5 10 1 51 3 1Выходные данныеСкопировать122 5 2 Входные данныеСкопировать3 5 10 1 3391 3 1Выходные данныеСкопировать355 5 5",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке через пробел записаны пять целых чисел n, A, cf, cm и m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 109, 0 ≤ cf, cm ≤ 1000, 0 ≤ m ≤ 1015).Во второй строке записано ровно n целых чисел ai (0 ≤ ai ≤ A), разделённых пробелами, — текущие уровни навыков.\n\nВходные данные\n\nВыходные данныеСначала выведите максимальное значение Cилы, которое может получить персонаж.Затем выведите n целых чисел — a'i (ai ≤ a'i ≤ A), уровни навыков, до которых следует развиться, чтобы достичь указанного значения Силы, при этом используя не более m денежных единиц. Если правильных ответов несколько — выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать3 5 10 1 51 3 1Выходные данныеСкопировать122 5 2 Входные данныеСкопировать3 5 10 1 3391 3 1Выходные данныеСкопировать355 5 5\n\nВходные данныеСкопировать3 5 10 1 51 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать122 5 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 5 10 1 3391 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать355 5 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте оптимальной стратегией является повышение второго навыка до его максимума, а остальных — на единицу.Во втором тесте нужно увеличить уровни всех навыков до максимума.",
      "solutions": [
        {
          "title": "codeforces.com | 502: Bad gateway",
          "content": "codeforces.com | 502: Bad gateway Bad gateway Error code 502 Visit cloudflare.com for more information. 2025-08-21 15:45:08 UTC You Browser Working Singapore Cloudflare Working codeforces.com Host Error What happened? The web server reported a bad gateway error. What can I do? Please try again in a few minutes. Cloudflare Ray ID: 972b41648e029e35 • Your IP: Click to reveal 137.132.214.135 • Performance &amp; security by Cloudflare",
          "author": "Unknown",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 434
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 614 和字母"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int A = inf.readInt(1, 1000000000, \"A\");\n    inf.readSpace();\n    int cf = inf.readInt(0, 1000, \"cf\");\n    inf.readSpace();\n    int cm = inf.readInt(0, 1000, \"cm\");\n    inf.readSpace();\n    long long m = inf.readLong(0, 1000000000000000LL, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, A);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int A = inf.readInt(1, 1000000000, \"A\");\n    inf.readSpace();\n    int cf = inf.readInt(0, 1000, \"cf\");\n    inf.readSpace();\n    int cm = inf.readInt(0, 1000, \"cm\");\n    inf.readSpace();\n    long long m = inf.readLong(0, 1000000000000000LL, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, A);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int A = inf.readInt(1, 1000000000, \"A\");\n    inf.readSpace();\n    int cf = inf.readInt(0, 1000, \"cf\");\n    inf.readSpace();\n    int cm = inf.readInt(0, 1000, \"cm\");\n    inf.readSpace();\n    long long m = inf.readLong(0, 1000000000000000LL, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, A);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read inputs from inf\n    int n = inf.readInt(1, 100000, \"n\");\n    long long A = inf.readLong(1, 1000000000LL, \"A\");\n    int cf = inf.readInt(0, 1000, \"cf\");\n    int cm = inf.readInt(0, 1000, \"cm\");\n    long long m_limit = inf.readLong(0, 1000000000000000LL, \"m\");\n\n    vector<long long> ai(n);\n    for (int i = 0; i < n; i++) {\n        ai[i] = inf.readLong(0, A, format(\"ai[%d]\", i + 1));\n    }\n\n    // Read maximum possible Force from ans\n    long long max_force = ans.readLong();\n\n    // Read participant's claimed Force from ouf\n    long long participant_force = ouf.readLong();\n\n    // Read participant's updated a'i from ouf\n    vector<long long> aip(n);\n    for (int i = 0; i < n; i++) {\n        aip[i] = ouf.readLong(ai[i], A, format(\"aip[%d]\", i + 1));\n    }\n\n    // Compute total cost\n    long long total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        total_cost += (aip[i] - ai[i]);\n        if (total_cost > m_limit) {\n            quitf(_wa, \"Total cost %lld exceeds limit m = %lld\", total_cost, m_limit);\n        }\n    }\n\n    // Compute Force from a'i\n    int num_perfected = 0;\n    long long min_ai = LLONG_MAX;\n    for (int i = 0; i < n; i++) {\n        if (aip[i] == A) num_perfected++;\n        if (aip[i] < min_ai) min_ai = aip[i];\n    }\n\n    long long computed_force = num_perfected * cf + min_ai * cm;\n\n    if (computed_force != participant_force) {\n        quitf(_wa, \"Computed force %lld does not match participant's claimed force %lld\", computed_force, participant_force);\n    }\n\n    // Compare participant's Force with maximum Force from ans\n    if (participant_force < max_force) {\n        quitf(_wa, \"Participant's force %lld is less than maximum possible force %lld\", participant_force, max_force);\n    } else if (participant_force == max_force) {\n        quitf(_ok, \"Correct, force = %lld\", participant_force);\n    } else { // participant_force > max_force\n        quitf(_fail, \"Participant's force %lld exceeds maximum possible force %lld\", participant_force, max_force);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int A = opt<int>(\"A\");\n    int cf = opt<int>(\"cf\");\n    int cm = opt<int>(\"cm\");\n    long long m = opt<long long>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"zero\") {\n        // All ai = 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n        }\n    } else if (type == \"max\") {\n        // All ai = A\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A;\n        }\n    } else if (type == \"random\") {\n        // ai random in [0, A]\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, A);\n        }\n    } else if (type == \"inc\") {\n        // ai in increasing order from 0 to A\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (long long)i * A / (n - 1);\n            if (ai[i] > A) ai[i] = A;\n        }\n    } else if (type == \"dec\") {\n        // ai in decreasing order from A to 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A - (long long)i * A / (n - 1);\n            if (ai[i] < 0) ai[i] = 0;\n        }\n    } else if (type == \"middle\") {\n        // All ai = A / 2\n        int mid = A / 2;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = mid;\n        }\n    } else if (type == \"ones\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // ai alternates between 0 and A\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ai[i] = 0;\n            else\n                ai[i] = A;\n        }\n    } else if (type == \"max1\") {\n        // All ai = 0 except one skill at A\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n        }\n        ai[rnd.next(0, n - 1)] = A;\n    } else if (type == \"min1\") {\n        // All ai = A except one skill at 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A;\n        }\n        ai[rnd.next(0, n - 1)] = 0;\n    } else if (type == \"sparse\") {\n        // Mostly zero, with a few random values\n        int k = rnd.next(1, min(n, 1000)); // between 1 and 1000 non-zero elements\n        set<int> pos;\n        while(pos.size() < k) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n        }\n        for (auto idx : pos) {\n            ai[idx] = rnd.next(0, A);\n        }\n    } else if (type == \"dense\") {\n        // Mostly A, with a few lower values\n        int k = rnd.next(1, min(n, 1000)); // between 1 and 1000 non-A elements\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A;\n        }\n        set<int> pos;\n        while(pos.size() < k) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        for (auto idx : pos) {\n            ai[idx] = rnd.next(0, A);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, A);\n        }\n    }\n\n    printf(\"%d %d %d %d %lld\\n\", n, A, cf, cm, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int A = opt<int>(\"A\");\n    int cf = opt<int>(\"cf\");\n    int cm = opt<int>(\"cm\");\n    long long m = opt<long long>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"zero\") {\n        // All ai = 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n        }\n    } else if (type == \"max\") {\n        // All ai = A\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A;\n        }\n    } else if (type == \"random\") {\n        // ai random in [0, A]\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, A);\n        }\n    } else if (type == \"inc\") {\n        // ai in increasing order from 0 to A\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (long long)i * A / (n - 1);\n            if (ai[i] > A) ai[i] = A;\n        }\n    } else if (type == \"dec\") {\n        // ai in decreasing order from A to 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A - (long long)i * A / (n - 1);\n            if (ai[i] < 0) ai[i] = 0;\n        }\n    } else if (type == \"middle\") {\n        // All ai = A / 2\n        int mid = A / 2;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = mid;\n        }\n    } else if (type == \"ones\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // ai alternates between 0 and A\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ai[i] = 0;\n            else\n                ai[i] = A;\n        }\n    } else if (type == \"max1\") {\n        // All ai = 0 except one skill at A\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n        }\n        ai[rnd.next(0, n - 1)] = A;\n    } else if (type == \"min1\") {\n        // All ai = A except one skill at 0\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A;\n        }\n        ai[rnd.next(0, n - 1)] = 0;\n    } else if (type == \"sparse\") {\n        // Mostly zero, with a few random values\n        int k = rnd.next(1, min(n, 1000)); // between 1 and 1000 non-zero elements\n        set<int> pos;\n        while(pos.size() < k) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n        }\n        for (auto idx : pos) {\n            ai[idx] = rnd.next(0, A);\n        }\n    } else if (type == \"dense\") {\n        // Mostly A, with a few lower values\n        int k = rnd.next(1, min(n, 1000)); // between 1 and 1000 non-A elements\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A;\n        }\n        set<int> pos;\n        while(pos.size() < k) {\n            pos.insert(rnd.next(0, n - 1));\n        }\n        for (auto idx : pos) {\n            ai[idx] = rnd.next(0, A);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, A);\n        }\n    }\n\n    printf(\"%d %d %d %d %lld\\n\", n, A, cf, cm, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, m = 0, all skills at zero\n./gen -n 1 -A 1 -cf 0 -cm 0 -m 0 -type zero\n\n# Small n, m = 0, all skills at maximum\n./gen -n 1 -A 1000000000 -cf 1000 -cm 1000 -m 0 -type max\n\n# Small n, random ai\n./gen -n 10 -A 100 -cf 10 -cm 10 -m 100 -type random\n\n# Small n, increasing ai\n./gen -n 10 -A 50 -cf 5 -cm 5 -m 50 -type inc\n\n# Small n, decreasing ai\n./gen -n 10 -A 50 -cf 5 -cm 5 -m 50 -type dec\n\n# n at maximum, m = 0, all ai = 0\n./gen -n 100000 -A 1000 -cf 100 -cm 100 -m 0 -type zero\n\n# n at maximum, m large, all ai = A\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -type max\n\n# n at maximum, random ai\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -type random\n\n# n at maximum, alternating ai\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 500000000000000 -type alternating\n\n# n at maximum, increasing ai\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -type inc\n\n# n at maximum, decreasing ai\n./gen -n 100000 -A 1000000000 -cf 0 -cm 1000 -m 1000000000000000 -type dec\n\n# m = 0, cf = 0, cm = 0\n./gen -n 100000 -A 1000000000 -cf 0 -cm 0 -m 0 -type random\n\n# m = maximum possible, cf = 0\n./gen -n 100000 -A 1000000000 -cf 0 -cm 1000 -m 1000000000000000 -type random\n\n# m = maximum possible, cm = 0\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 0 -m 1000000000000000 -type random\n\n# All skills at A/2\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 500000000000000 -type middle\n\n# All skills at 1\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -type ones\n\n# One skill at A, others at zero\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000 -type max1\n\n# One skill at zero, others at A\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000 -type min1\n\n# Sparse non-zero skills\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 100000000000 -type sparse\n\n# Dense near-maximum skills\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 100000000000 -type dense\n\n# Maximum m, random ai\n./gen -n 99999 -A 999999999 -cf 999 -cm 999 -m 999999999999999 -type random\n\n# Small A, random ai\n./gen -n 100000 -A 5 -cf 10 -cm 10 -m 1000000 -type random\n\n# All ai are the same\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 0 -type middle\n\n# Alternating zeros and maximum A\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -type alternating\n\n# Small n, m equals sum to reach A\n./gen -n 5 -A 10 -cf 10 -cm 10 -m 50 -type zero\n\n# Edge case: n=1, m large\n./gen -n 1 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000000000 -type random\n\n# Edge case: n=1, m=0\n./gen -n 1 -A 1000000000 -cf 1000 -cm 1000 -m 0 -type random\n\n# Edge case: All skills already at maximum\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000 -type max\n\n# Edge case: All skills at zero\n./gen -n 100000 -A 1000000000 -cf 1000 -cm 1000 -m 1000000000 -type zero\n\n# Random ai with large n and m\n./gen -n 99998 -A 999999999 -cf 999 -cm 999 -m 999999999999999 -type random\n\n# Random ai with small n and m\n./gen -n 2 -A 1000000000 -cf 500 -cm 500 -m 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:13.288633",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "614/E",
      "title": "E. Necklace",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single number n (1 ≤ n ≤ 26) — the number of colors of beads. The second line contains after n positive integers ai   — the quantity of beads of i-th color. It is guaranteed that the sum of ai is at least 2 and does not exceed 100 000.",
      "output_spec": "OutputIn the first line print a single number — the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace.Each color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.",
      "sample_tests": "ExamplesInputCopy34 2 1OutputCopy1abacabaInputCopy14OutputCopy4aaaaInputCopy21 1OutputCopy0ab",
      "description": "E. Necklace\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single number n (1 ≤ n ≤ 26) — the number of colors of beads. The second line contains after n positive integers ai   — the quantity of beads of i-th color. It is guaranteed that the sum of ai is at least 2 and does not exceed 100 000.\n\nOutputIn the first line print a single number — the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace.Each color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.\n\nInputCopy34 2 1OutputCopy1abacabaInputCopy14OutputCopy4aaaaInputCopy21 1OutputCopy0ab\n\nInputCopy34 2 1\n\nOutputCopy1abacaba\n\nInputCopy14\n\nOutputCopy4aaaa\n\nInputCopy21 1\n\nOutputCopy0ab\n\nNoteIn the first sample a necklace can have at most one beautiful cut. The example of such a necklace is shown on the picture.In the second sample there is only one way to compose a necklace.",
      "solutions": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces",
          "content": "Hi all!In two days, at 19:35 MSK Codeforces Round #339 (Div. 1 & Div. 2) will take place. This is an unusual round since we — the problemsetters — are highschool students who participate in the programming training group at high school #179. This round is our first effort and we did our best to make it interesting and bug-free. I invite you all to compete in this round since the problems will be solvable, but even tourist will have to think over some of them. :)With supervision and control from Mikhail Tikhomirov (Endagorion), the problems were developed by: Egor Chunaev (ch_egor), Vasily Alferov (platypus179), Dmitry Sayutin (cdkrot), Timofey Gutor (Tigutor), Maria Fedorkina (crossopt). Mikhail Sorokin (themikemikovi4) and Sergey Aleikin (Derrior) contributed their problem ideas.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements in English, AlexFetisov and winger for testing, and, of course, MikeMirzayanov for unique CodeForces and Polygon systems.Round will have standard Codeforces rules, with pretests at first, and final tests afterwards. Take care to account for all possible cases.Best of luck to everyone!UPD Points for problems areDiv 2. 500-1000-1750-2250-2250, Div 1. 750-1250-1250-2000-2500UPD Congratulations winners! standingsDiv1: TankEngineer KAN Petr Um_nik snuke matthew99 jcvb superpear pashka fsouza Div2: mingaleg Ronnoc BoQiR maks1906 zloyplace35 huansuz1 2016 Danlark MrPapaya bohuss UPD Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22726",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1510
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces",
          "content": "I'm terribly sorry for the delay.Please report any mistakes.614A - Link/Cut TreeAuthor: TigutorDevelopers: Tigutor, ch_egorYou had to print all numbers of form kx for non-negative integers x that lie with the range [l;r]. A simple cycle works: start with 1 = k0, go over all powers that do not exceed r and print those which are at least l. One should be careful with 64-bit integer overflows: consider the test l = 1, r = 1018, k = 109, the powers will be 1, 109, 1018, and the next power is 1027, which does not fit in a standard integer type.614B - Gena's CodeAuthor, developer: ch_egorYou were asked to print the product of n large numbers, but it was guaranteed that at least n - 1 are beautiful. It's not hard to see that beautiful numbers are 0 and all powers of 10 (that is, 1 followed by arbitrary number of zeros). If there is at least one zero among the given numbers, the product is 0. Otherwise, consider the only non-beautiful number x (if all numbers are beautiful, consider x = 1). Multiplying x by 10t appends t zeros to its decimal representation, so in this case we have to find the only non-beautiful number and print it with several additional zeros.We tried to cut off all naive solutions that use built-in long numbers multiplication in Python or Java. However, with some additional tricks (e.g., ``divide-and-conquer'') this could pass all tests.613A - Peter and Snow BlowerAuthor, developer: platypus179Consider distances between the point P and all points of the polygon. Let R be the largest among all distances, and r be the smallest among all distances. The swept area is then a ring between circles of radii R and r, and the answer is equal to π (R2 - r2).Clearly, R is the largest distance between P and vertices of the polygon. However, r can be the distance between P and some point lying on the side of the polygon, therefore, r is the smallest distance between P and all sides of the polygon.To find the shortest distance between a point p and a segment s, consider a straight line l containing the segment s. Clearly, the shortest distance between p and l is the length of the perpendicular segment. One should consider two cases: when the end of the perpendicular segment lies on the segment s (then the answer is the length of the perpendicular segment), or when it lies out of s (then the answer is the shortest distance to the ends of s).613B - SkillsAuthor: cdkrotDevelopers: cdkrot, galilei2000, ch_egorLet's save the original positions of skills and then sort the skills in non-increasing order (almost decreasing) by current level. We can always restore original order after.Imagine that we have decided that we want to use the minimum level X and now we're choosing which skills we should bring to the maximum.At first, let's rise all skills below X to level X, this will set some tail of array to X. But the original array was sorted, and this new change will not break the sort! So our array is still sorted.Obviously, the skills we want to take to the maximum are the ones with highest current level. They are in the prefix of array. It is easy to show that any other selection is no better than this greedy one.Now we have shown that the optimal strategy is to max out the skills in some prefix. Now let's solve the problem.Let's iterate over prefix to max out, now on each iteration we need to know the highest minimum we can achieve, let's store the index of the first element outside the prefix such that it is possible to reach the minimum level  ≥ arrindex.It is easy to recalc this index, it slightly moves forward each turn and, after precalcing the sum of all array's tails, you can update it easily (just move it forward until the invariant above holds). And knowing this index is enough to calc the current highest possible minimum level (min(A, arrindex + ⌊ sparemoney / (n - index)⌋).How to restore the answer? Actually, all you need to know is the count of maximums to take and minimum level to reach.613C - NecklaceAuthor: cdkrotDevelopers: cdkrot, crossopt, ch_egorSurprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three). If the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.If the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.Anyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero, or its divisor. If the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok. If the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing beads of i-th color, exactly n - 1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok. If num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero. Complexity: O(sum), just to output answer.Bonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?Bonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?613D - Kingdom and its CitiesAuthors: ch_egor and othersDeveloper: cdkrotObviously, the answer is -1 iff two important cities are adjacent.If there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.Let's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.How do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.How to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them.If we use the standard \"binary shifts\" approach to LCA, we answer the query in time, for a total complexity of .613E - Puzzle LoverAuthor, developer: EndagorionThe key observation: any way to cross out the word w looks roughly as follows: ..v<1.>>v.2<...\n..>>>>^.>>>^...That is, there can be following parts: go back a symbols in one row, then go forward a symbols in the other row (possibly a = 0) go forward with arbitrarily up and down shifts in a snake-like manner go forward b symbols in one row, then go back b in the other row (possibly b = 0) Note that the \"forward\" direction can be either to the left or to the right. It is convenient that for almost any such way we can determine the \"direction\" as well as the places where different \"parts\" of the path (according to the above) start. To avoid ambiguity, we will forbid a = 1 or b = 1 (since such parts can be included into the \"snake\").Fix the direction. We will count the DP dx, y, k for the number of ways to cross out first k letters of w and finished at the cell (x, y) while being inside the snake part of the way. The transitions are fairly clear (since the snake part only moves forward). However, we have to manually handle the first and the last part. For each cell and each value of k we can determine if the \"go-back-then-go-forward\" maneuver with parameter k can be performed with the chosen cell as finish; this can be reduced to comparing of some substrings of field of rows and the word w (and its reversed copy). In a similar way, for any state we can check if we can append the final \"go-forward-then-go-back\" part of the path to finally obtain a full-fledged path.This DP has O(n2) states and transitions. However, there are still some questions left. How do we perform the substring comparisons? There is a whole arsenal of possible options: (carefully implemented) hashes, suffix structures, etc. Probably the simplest way is to use Z-function for a solution that does O(n2) precalc and answers each substring query in O(1) time (can you see how to do it?).Also, there are paths that we can consider more than once. More precisely, a path that consists only of the \"go-forward-the-go-back\" part will be counted twice (for both directions), thus we have to subtract such paths explicitly. Every other path is counted only once, thus we are done. (Note: this does not exactly work when w is short, say, 4 symbols or less. The simplest way is to implement straightforward brute-force for such cases.)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22832",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 614 和字母"
          },
          "content_length": 10469
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 1",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 2",
          "code": "Your code here...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 3",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 4",
          "code": "3 0 0\n-1 1\n1 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 5",
          "code": "at least n - 1 beautiful numbers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 6",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 7",
          "code": "1 1000000000000000000 1000000000\n1 1000000000000000000 536870912\n1 1000000000000000000 536870913",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 8",
          "code": "system testing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 9",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 10",
          "code": "9007199515875289 9007199515875289 94906267",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 11",
          "code": "subSet(l, r+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 12",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 13",
          "code": "if ( start * k > LIMIT ) break;  // check overflow (LIMIT can be 10^18, or you can use 'r')\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 14",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 15",
          "code": "if ( start  > LIMIT / k ) break;\nstart *= k;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 16",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 17",
          "code": "pair<int, int> s = pair<long double, long double> (13.3, 14.4);\ncerr << s.first << ' ' << s.second << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 18",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 19",
          "code": "if (rand() % 10 < a.size()) puts(\"0\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 20",
          "code": "int x = 4.59;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 21",
          "code": "rand() % 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 22",
          "code": "if (rand() % 10 - 10 < a.size())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 23",
          "code": "rand() % 10 - 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 24",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 25",
          "code": "int ans2 = (long double) (10 + rand());\ncerr << ans << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 26",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 27",
          "code": "pair <T1, T2>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 28",
          "code": "-Wconversion",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 29",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 (Div. 1 & Div. 2) - Codeforces - Code 30",
          "code": "if( abs(x2-x1) < 10e-10 )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22726",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 1",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 2",
          "code": "..v<1.>>v.2<...\n..>>>>^.>>>^...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 3",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 4",
          "code": "for (int i = strlen(s1) - 1; i >= 0; --i)\n  for (int j = strlen(s2) - 1; j >= 0; --j)\n    lcp[i][j] = s1[i] == s2[j] ? 1 + lcp[i+1][j+1] : 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 5",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 6",
          "code": "4 0 0\n1 1000\n1 -1000\n500 0\n700 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 7",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #339 Editorial - Codeforces - Code 8",
          "code": "mAB=(B.y-A.y)/(B.x-A.x); //m from the straight line equation for side\nmMO=(A.x-B.x)/(B.y-A.y); //m for the distance from M to AB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22832",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 26, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += a[i];\n    }\n    ensuref(sum >= 2, \"Sum of a_i must be at least 2, but is %lld\", sum);\n    ensuref(sum <= 100000, \"Sum of a_i must be at most 100000, but is %lld\", sum);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 26, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += a[i];\n    }\n    ensuref(sum >= 2, \"Sum of a_i must be at least 2, but is %lld\", sum);\n    ensuref(sum <= 100000, \"Sum of a_i must be at most 100000, but is %lld\", sum);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 26, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += a[i];\n    }\n    ensuref(sum >= 2, \"Sum of a_i must be at least 2, but is %lld\", sum);\n    ensuref(sum <= 100000, \"Sum of a_i must be at most 100000, but is %lld\", sum);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Explanation of the Revision:\n\n  The previous checker was incorrectly counting palindromes because it used\n  the substring [i+1 .. i+n-1] (of length n-1) instead of [i+1 .. i+n] (of\n  length n) when checking each potential \"beautiful\" cut in a cyclic necklace.\n  That caused single-character substrings to be tested instead of the entire\n  chain of length n.\n\n  Below we fix the loop to:\n      for (int i = 0; i < n; i++) {\n         int l = i + 1;\n         int r = i + n;  // inclusive\n         ...\n      }\n  and call getForwardHash(l, r), getBackwardHash(l, r) with r instead of (r - 1).\n\n  This ensures that the substring being tested is of length n, precisely the\n  \"linear chain\" after cutting the necklace, rather than an off-by-one smaller\n  substring.\n*/\n\n// Constants for double-hashing:\nstatic const long long MOD1 = 1000000007LL;\nstatic const long long MOD2 = 1000000009LL;\nstatic const long long BASE1 = 911382307LL;\nstatic const long long BASE2 = 972663749LL;\n\n// Global prefix hash arrays:\nvector<long long> pf1, pf2, pr1, pr2, power1, power2;\n\n/*\n  getForwardHash(l, r) returns the pair of forward hashes for SS[l..r],\n  inclusive indices.\n*/\npair<long long, long long> getForwardHash(int l, int r) {\n    long long h1 = pf1[r + 1] - (pf1[l] * power1[r - l + 1] % MOD1);\n    long long h2 = pf2[r + 1] - (pf2[l] * power2[r - l + 1] % MOD2);\n    if (h1 < 0) h1 += MOD1;\n    if (h2 < 0) h2 += MOD2;\n    return make_pair(h1, h2);\n}\n\n/*\n  getBackwardHash(l, r, totalLen) returns the pair of backward hashes for SS[l..r],\n  inclusive indices, by looking up the forward hashes of the reversed string.\n*/\npair<long long, long long> getBackwardHash(int l, int r, int totalLen) {\n    // In the reversed string, index l in SS corresponds to index (totalLen - 1 - l)\n    int L = totalLen - 1 - r;\n    int R = totalLen - 1 - l;\n    long long h1 = pr1[R + 1] - (pr1[L] * power1[R - L + 1] % MOD1);\n    long long h2 = pr2[R + 1] - (pr2[L] * power2[R - L + 1] % MOD2);\n    if (h1 < 0) h1 += MOD1;\n    if (h2 < 0) h2 += MOD2;\n    return make_pair(h1, h2);\n}\n\n/*\n  computeBeautifulCuts(S) counts how many cuts of the cyclic necklace S\n  produce a palindrome. We'll check each cut i in [0..n-1] by verifying\n  SS[i+1..i+n] is a palindrome, where SS = S+S.\n*/\nint computeBeautifulCuts(const string &S) {\n    int n = (int)S.size();\n    string SS = S + S;   // length = 2n\n    int nn = 2 * n;\n\n    // Prepare arrays of length nn+1 for prefix hashing\n    pf1.assign(nn + 1, 0LL);\n    pf2.assign(nn + 1, 0LL);\n    pr1.assign(nn + 1, 0LL);\n    pr2.assign(nn + 1, 0LL);\n    power1.assign(nn + 1, 1LL);\n    power2.assign(nn + 1, 1LL);\n\n    // Precompute powers\n    for(int i = 1; i <= nn; i++){\n        power1[i] = (power1[i - 1] * BASE1) % MOD1;\n        power2[i] = (power2[i - 1] * BASE2) % MOD2;\n    }\n    // Forward hashes for SS\n    for(int i = 0; i < nn; i++){\n        long long x = (SS[i] - 'a' + 1);\n        pf1[i + 1] = (pf1[i] * BASE1 + x) % MOD1;\n        pf2[i + 1] = (pf2[i] * BASE2 + x) % MOD2;\n    }\n    // To compare backward hashes, build reversed(SS) and its forward hash\n    string RS = SS;\n    reverse(RS.begin(), RS.end());\n    for(int i = 0; i < nn; i++){\n        long long x = (RS[i] - 'a' + 1);\n        pr1[i + 1] = (pr1[i] * BASE1 + x) % MOD1;\n        pr2[i + 1] = (pr2[i] * BASE2 + x) % MOD2;\n    }\n\n    int countPal = 0;\n    // For each cut i in [0..n-1], we test substring SS[i+1.. i+n]\n    // which has length n\n    for(int i = 0; i < n; i++){\n        int l = i + 1;\n        int r = i + n; // inclusive\n        auto fwd = getForwardHash(l, r);\n        auto bwd = getBackwardHash(l, r, nn);\n        if (fwd == bwd) {\n            countPal++;\n        }\n    }\n    return countPal;\n}\n\n/*\n  readAnswer reads and validates an answer from \"stream\":\n   - declaredCuts (long long)\n   - a string \"necklace\"\n  Then it checks:\n   1) The necklace has the right length\n   2) The letter frequencies match exactly the input distribution\n   3) The actual number of beautiful cuts matches the declaredCuts\n  If it's a participant's answer, invalid => _wa\n  If it's the jury's answer, invalid => _fail\n*/\nint readAnswer(InStream &stream,\n               int n,\n               const vector<int> &cnt,\n               bool isParticipant)\n{\n    long long declaredCuts = stream.readLong(0, 100000LL, \"declaredBeautifulCuts\");\n\n    // readToken() with no regex ensures we just read a single token\n    string necklace = stream.readToken();\n\n    // Check length\n    long long sumBeads = 0;\n    for (int x : cnt) sumBeads += x;\n    if ((long long)necklace.size() != sumBeads) {\n        if (isParticipant) {\n            stream.quitf(_wa,\n                \"Necklace length (%d) != sum of beads (%lld).\",\n                (int)necklace.size(), sumBeads);\n        } else {\n            stream.quitf(_fail,\n                \"Jury's necklace length (%d) != sum of beads (%lld).\",\n                (int)necklace.size(), sumBeads);\n        }\n    }\n\n    // Check character usage\n    vector<int> used(n, 0);\n    for (char c : necklace) {\n        if (c < 'a' || c >= char('a' + n)) {\n            if (isParticipant) {\n                stream.quitf(_wa,\n                             \"Necklace contains invalid color '%c' (must be 'a'..'%c').\",\n                             c, char('a' + n - 1));\n            } else {\n                stream.quitf(_fail,\n                             \"Jury's necklace contains invalid color '%c'.\", c);\n            }\n        }\n        used[c - 'a']++;\n    }\n\n    // Compare counts\n    for (int i = 0; i < n; i++) {\n        if (used[i] != cnt[i]) {\n            if (isParticipant) {\n                stream.quitf(_wa,\n                             \"Mismatch in usage of color '%c': used %d, expected %d.\",\n                             char('a' + i), used[i], cnt[i]);\n            } else {\n                stream.quitf(_fail,\n                             \"Jury's mismatch in usage of color '%c': used %d, expected %d.\",\n                             char('a' + i), used[i], cnt[i]);\n            }\n        }\n    }\n\n    // Compute actual # of beautiful cuts\n    int actualCuts = computeBeautifulCuts(necklace);\n\n    // Check declared vs actual\n    if (actualCuts != declaredCuts) {\n        if (isParticipant) {\n            stream.quitf(_wa,\n                         \"Declared palindrome cuts %lld but got %d.\",\n                         declaredCuts, actualCuts);\n        } else {\n            stream.quitf(_fail,\n                         \"Jury's declared palindrome cuts %lld but got %d.\",\n                         declaredCuts, actualCuts);\n        }\n    }\n    return actualCuts;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 26, \"n\");\n    vector<int> cnt(n);\n    long long totalBeads = 0;\n    for (int i = 0; i < n; i++) {\n        cnt[i] = inf.readInt(1, 100000, \"countOfColor\");\n        totalBeads += cnt[i];\n    }\n\n    // Read jury's answer\n    int jans = readAnswer(ans, n, cnt, /*isParticipant=*/false);\n    // Read participant's answer\n    int pans = readAnswer(ouf, n, cnt, /*isParticipant=*/true);\n\n    // Compare which is bigger\n    if (pans < jans) {\n        quitf(_wa, \"Participant's solution has fewer beautiful cuts (%d) than jury's (%d).\",\n              pans, jans);\n    } else if (pans > jans) {\n        quitf(_fail, \"Participant's solution has more beautiful cuts (%d) than jury's (%d).\",\n              pans, jans);\n    } else {\n        // pans == jans\n        quitf(_ok, \"Both solutions have %d beautiful cuts.\", pans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int total_ai = opt<int>(\"sum_ai\");\n    string type = opt<string>(\"type\", \"random_ai\");\n\n    if (total_ai < n) {\n        cerr << \"Error: sum_ai must be at least n (since each ai >= 1)\" << endl;\n        return 1;\n    }\n    if (n < 1 || n > 26) {\n        cerr << \"Error: n must be between 1 and 26\" << endl;\n        return 1;\n    }\n    if (total_ai < 2 || total_ai > 100000) {\n        cerr << \"Error: sum_ai must be between 2 and 100000\" << endl;\n        return 1;\n    }\n\n    vector<int> ai(n, 1); // initialize with ones to satisfy ai >=1\n    int remaining = total_ai - n; // since we've already assigned 1 to each ai\n\n    if (type == \"all_same_color\") {\n        if (n != 1) {\n            cerr << \"Error: For all_same_color type, n must be 1\" << endl;\n            return 1;\n        }\n        ai[0] += remaining; // assign remaining beads to the single color\n    } else if (type == \"two_colors_equal\") {\n        if (n != 2) {\n            cerr << \"Error: For two_colors_equal type, n must be 2\" << endl;\n            return 1;\n        }\n        ai[0] = total_ai / 2;\n        ai[1] = total_ai - ai[0]; // to ensure sum of ai equals total_ai\n    } else if (type == \"one_max_others_min\") {\n        if (n < 2) {\n            cerr << \"Error: For one_max_others_min type, n must be at least 2\" << endl;\n            return 1;\n        }\n        ai[0] = remaining + 1; // first color gets all remaining beads\n        // ai[1..n-1] already initialized to 1\n    } else if (type == \"random_ai\") {\n        // Distribute remaining beads randomly among ai[0..n-1]\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, n - 1);\n            ai[idx]++;\n        }\n    } else if (type == \"max_palindrome\") {\n        // Create ai such that a palindrome is possible\n        // For a palindrome, need counts of colors to satisfy palindrome property\n        // The counts of colors with odd quantities must be at most 1\n        int num_odds = n <= 1 ? 0 : 1; // allow only 1 odd\n        // Assign even numbers to all ai, except possibly one\n        ai.assign(n, 2); // Start with 2 beads of each color\n        int total_assigned = 2 * n;\n        if (total_assigned > total_ai) {\n            // Adjust to fit total_ai\n            int reduce = total_assigned - total_ai;\n            for (int i = 0; i < n && reduce > 0; ++i) {\n                int reduction = min(1, reduce);\n                ai[i] -= reduction;\n                reduce -= reduction;\n            }\n        } else if (total_assigned < total_ai) {\n            // Add remaining beads to ai[0], making it odd if necessary\n            ai[0] += total_ai - total_assigned;\n        }\n        // Ensure ai are at least 1\n        for (int i = 0; i < n; ++i) {\n            if (ai[i] < 1) ai[i] = 1;\n        }\n    } else if (type == \"min_palindrome\") {\n        // Construct ai such that palindrome is impossible\n        // Maximize the number of colors with odd counts\n        // Assign ai as 1 until total_ai is exhausted\n        ai.assign(n, 1);\n        int total_assigned = n;\n        int idx = 0;\n        while (total_assigned < total_ai) {\n            ai[idx % n] += 2;\n            total_assigned += 2;\n            idx++;\n        }\n    } else {\n        cerr << \"Error: Unknown type \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int total_ai = opt<int>(\"sum_ai\");\n    string type = opt<string>(\"type\", \"random_ai\");\n\n    if (total_ai < n) {\n        cerr << \"Error: sum_ai must be at least n (since each ai >= 1)\" << endl;\n        return 1;\n    }\n    if (n < 1 || n > 26) {\n        cerr << \"Error: n must be between 1 and 26\" << endl;\n        return 1;\n    }\n    if (total_ai < 2 || total_ai > 100000) {\n        cerr << \"Error: sum_ai must be between 2 and 100000\" << endl;\n        return 1;\n    }\n\n    vector<int> ai(n, 1); // initialize with ones to satisfy ai >=1\n    int remaining = total_ai - n; // since we've already assigned 1 to each ai\n\n    if (type == \"all_same_color\") {\n        if (n != 1) {\n            cerr << \"Error: For all_same_color type, n must be 1\" << endl;\n            return 1;\n        }\n        ai[0] += remaining; // assign remaining beads to the single color\n    } else if (type == \"two_colors_equal\") {\n        if (n != 2) {\n            cerr << \"Error: For two_colors_equal type, n must be 2\" << endl;\n            return 1;\n        }\n        ai[0] = total_ai / 2;\n        ai[1] = total_ai - ai[0]; // to ensure sum of ai equals total_ai\n    } else if (type == \"one_max_others_min\") {\n        if (n < 2) {\n            cerr << \"Error: For one_max_others_min type, n must be at least 2\" << endl;\n            return 1;\n        }\n        ai[0] = remaining + 1; // first color gets all remaining beads\n        // ai[1..n-1] already initialized to 1\n    } else if (type == \"random_ai\") {\n        // Distribute remaining beads randomly among ai[0..n-1]\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, n - 1);\n            ai[idx]++;\n        }\n    } else if (type == \"max_palindrome\") {\n        // Create ai such that a palindrome is possible\n        // For a palindrome, need counts of colors to satisfy palindrome property\n        // The counts of colors with odd quantities must be at most 1\n        int num_odds = n <= 1 ? 0 : 1; // allow only 1 odd\n        // Assign even numbers to all ai, except possibly one\n        ai.assign(n, 2); // Start with 2 beads of each color\n        int total_assigned = 2 * n;\n        if (total_assigned > total_ai) {\n            // Adjust to fit total_ai\n            int reduce = total_assigned - total_ai;\n            for (int i = 0; i < n && reduce > 0; ++i) {\n                int reduction = min(1, reduce);\n                ai[i] -= reduction;\n                reduce -= reduction;\n            }\n        } else if (total_assigned < total_ai) {\n            // Add remaining beads to ai[0], making it odd if necessary\n            ai[0] += total_ai - total_assigned;\n        }\n        // Ensure ai are at least 1\n        for (int i = 0; i < n; ++i) {\n            if (ai[i] < 1) ai[i] = 1;\n        }\n    } else if (type == \"min_palindrome\") {\n        // Construct ai such that palindrome is impossible\n        // Maximize the number of colors with odd counts\n        // Assign ai as 1 until total_ai is exhausted\n        ai.assign(n, 1);\n        int total_assigned = n;\n        int idx = 0;\n        while (total_assigned < total_ai) {\n            ai[idx % n] += 2;\n            total_assigned += 2;\n            idx++;\n        }\n    } else {\n        cerr << \"Error: Unknown type \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -sum_ai 2 -type all_same_color\n./gen -n 1 -sum_ai 100000 -type all_same_color\n\n./gen -n 2 -sum_ai 2 -type two_colors_equal\n./gen -n 2 -sum_ai 100000 -type two_colors_equal\n\n./gen -n 2 -sum_ai 100 -type one_max_others_min\n./gen -n 10 -sum_ai 100 -type one_max_others_min\n./gen -n 26 -sum_ai 100000 -type one_max_others_min\n\n./gen -n 5 -sum_ai 100 -type random_ai\n./gen -n 10 -sum_ai 1000 -type random_ai\n./gen -n 26 -sum_ai 100000 -type random_ai\n\n./gen -n 1 -sum_ai 5 -type max_palindrome\n./gen -n 3 -sum_ai 15 -type max_palindrome\n./gen -n 5 -sum_ai 1000 -type max_palindrome\n./gen -n 26 -sum_ai 100000 -type max_palindrome\n\n./gen -n 2 -sum_ai 2 -type min_palindrome\n./gen -n 5 -sum_ai 15 -type min_palindrome\n./gen -n 26 -sum_ai 100000 -type min_palindrome\n\n# Additional test cases to cover more possibilities\n\n# Test with minimal n and sum_ai\n./gen -n 1 -sum_ai 2 -type random_ai\n\n# Test with maximal n and minimal sum_ai\n./gen -n 26 -sum_ai 26 -type random_ai\n\n# Test with sum_ai = n\n./gen -n 5 -sum_ai 5 -type random_ai\n\n# Test with n = 25, sum_ai = 100000\n./gen -n 25 -sum_ai 100000 -type random_ai\n\n# Test type \"one_max_others_min\" with n = 26, sum_ai = 100000\n./gen -n 26 -sum_ai 100000 -type one_max_others_min\n\n# Test type \"max_palindrome\" with n = 1\n./gen -n 1 -sum_ai 100000 -type max_palindrome\n\n# Test type \"max_palindrome\" with odd sum_ai\n./gen -n 5 -sum_ai 99999 -type max_palindrome\n\n# Test type \"min_palindrome\" with n = 25, sum_ai = 99999\n./gen -n 25 -sum_ai 99999 -type min_palindrome\n\n# Test type \"random_ai\" with sum_ai at maximum\n./gen -n 10 -sum_ai 100000 -type random_ai\n\n# Test type \"random_ai\"\n./gen -n 26 -sum_ai 50000 -type random_ai\n\n# Test with n = 3, sum_ai = 3\n./gen -n 3 -sum_ai 3 -type random_ai\n\n# Test with n = 3, sum_ai = 10\n./gen -n 3 -sum_ai 10 -type min_palindrome\n\n# Test with n = 15, sum_ai = 50000\n./gen -n 15 -sum_ai 50000 -type max_palindrome\n\n# Test with n = 2, sum_ai = 2\n./gen -n 2 -sum_ai 2 -type one_max_others_min\n\n# Test with n=10, sum_ai=10, type random_ai\n./gen -n 10 -sum_ai 10 -type random_ai\n\n# Test with n=2, sum_ai=10, type two_colors_equal\n./gen -n 2 -sum_ai 10 -type two_colors_equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:15.117276",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "615/A",
      "title": "A. Bulbs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n and m (1 ≤ n, m ≤ 100) — the number of buttons and the number of bulbs respectively. Each of the next n lines contains xi (0 ≤ xi ≤ m) — the number of bulbs that are turned on by the i-th button, and then xi numbers yij (1 ≤ yij ≤ m) — the numbers of these bulbs.",
      "output_spec": "OutputIf it's possible to turn on all m bulbs print \"YES\", otherwise print \"NO\".",
      "sample_tests": "ExamplesInputCopy3 42 1 43 1 3 11 2OutputCopyYESInputCopy3 31 11 21 1OutputCopyNO",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers n and m (1 ≤ n, m ≤ 100) — the number of buttons and the number of bulbs respectively. Each of the next n lines contains xi (0 ≤ xi ≤ m) — the number of bulbs that are turned on by the i-th button, and then xi numbers yij (1 ≤ yij ≤ m) — the numbers of these bulbs.\n\nOutputIf it's possible to turn on all m bulbs print \"YES\", otherwise print \"NO\".\n\nInputCopy3 42 1 43 1 3 11 2OutputCopyYESInputCopy3 31 11 21 1OutputCopyNO\n\nInputCopy3 42 1 43 1 3 11 2\n\nOutputCopyYES\n\nInputCopy3 31 11 21 1\n\nOutputCopyNO\n\nNoteIn the first sample you can press each button once and turn on all the bulbs. In the 2 sample it is impossible to turn on the 3-rd lamp.",
      "solutions": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Greetings!Codeforces Round #338 (Div. 2) will be held tomorrow. Note that round starts at the unusual time! This round was made by Maxim Vinnichenko(maxkvant), and me, Alexander Zoykin. It is our first round and we hope that everything will be OK. Thanks to GlebsHP for the great help in preparing the contest, Bobrosoft for being more than tester, Delinur for translating the statements into English, and MikeMirzayanov for the great Polygon and Codeforces systems.score distribution 500 — 1250 — 1750 — 2000 — 2500Good luck!upd Congratulations to winners!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavEditorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22619",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 692
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22619?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "615A - Лампочки (Автор: TheWishmaster)Заведем для каждой лампочки счетчик – сколько кнопок ее выключает. Если для какой-то лампочки счетчик равен 0, то ответ нет, иначе да.Код: 15260902615B - Длиннохвостый еж (Автор: TheWishmaster)Посчитаем dp[i] – максимальная длина хвоста, заканчивающегося в i-ой вершине. Обновлять его просто – пройдем по всем ребрам из вершины и попытаемся увеличить текущее значение в концах ребер. Для ответа пройдемся по всем вершинам и выберем лучшую.Код: 15260851615C - Беговой трек (Автор: maxkvant)Заметим, что если мы можем мы можем получить подстроку t[i, j] используя k полотен, то мы можем получить и подстроку t[i + 1, j] не более чем из k полотен. Поэтому нам выгодно каждый раз брать как можно более длинную подстроку.Пусть n = |s|, m = |t|. На каждом этапе будем за искать эту самую длинную подстроку (lj – ее длина) в s и s_reversed, которую можем приписать к ответу.Это можно делать несколькими способами: Посчитаем lcp[i][j] — наибольший общий префикс t[i, m] и s[j, n], lcprev[i][j] — t[i, m] и s[j, 1]. Найти нужную подстроку означает найти max(max(lcp[i][1], lcp[i][2], ..., lcp[i][n]), max(lcprev[i][1], lcprev[i][2], ..., lcprev[i][n])). Подсчёт lcp: for (int i = m; i >= 1; i--)\n for (int j = n; j >= 1; j--) \n if (t[i] == s[j])\n lcp[i][j] = lcp[i + 1][j + 1] + 1;Код: 15277213 Заведём массив endPos, где значит endPos[j] — равна ли t[i, i + cur_len - 1] и s[j - cur_len + 1, j]. Будем пересчитывать значения этого массива, добавляя по одному символу t[i],  t[i + 1],  t[i + 2].... Аналогичный массив заведём для s_reversed. Суммарно решение отработает за Код: 15260867Решение бором: 15260870bonusможете ли вы решить задачу за , ? ?Σ — размер алфавита.615D - Множители (Автор: maxkvant)Обозначим d(x) — к-во делителей числа x, f(x) — произведение делителей числа. Пусть x = p1α1p2α2... pnαn, тогда d(x) = (α1 + 1)·(α2 + 1)... (αn + 1) . Есть пар делителитей вида , , и если x — точный квадрат добавляется ещё 1 делитель : .для простого m и a ≠ 0 верно Можно заметь, если a и b взаимно простые, то , Пользуясь этими свойствами нетрудно посчитать ответ: d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n d = d * (cnt[i] + 1) % (MOD - 1);\n} Код: 15260890bonusДругая задача.Дана последовательность (p1, k1),  (p2, k2), ...,  (pn, kn) (p_i — различные простые) и q запоросов (l, r) вычислить f(plkl·pl + 1kl + 1... prkr)%MOD.Как решать за ?615E - Шестиугольники (Автор: TheWishmaster)Посмотрим, как изменяется координаты при переходе из текущего 6-угольника в каждый из смежных ему(назовем это 6 типами переходов). Если мы знаем сколько переходов каждого типа мы сделали на пути, то знаем и координаты конца пути.Разделим весь путь на кольца:Посчитаем количество переходов через каждую из сторон шестиугольника для 1 кольца. В каждом следующем кольце будет на 1 переход каждого типа больше, чем в предыдущем кольце. Длина каждого кольца = длина предыдущего + 6. Это арифметическая прогрессия. С помощью формулы суммы первых членов арифметической прогрессии и бинпоиска найдем номер последнего кольца и длину всех колец до него. Осталось только перебрать 6 типов последнего сделанного перехода и посчитать ответ.Код: 15260879",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22658",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 615\\s*A"
          },
          "content_length": 3265
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++){\n    ll p; cin >> p;\n    prime[p]++; //cocunt the number of prime 'p'\n}\nfor (int i = 0; i <= 200000; i++){\n    total *= (prime[i] + 1); //calculate the whole possible combination\n    total %= mod;\n}\nfor (ll i = 1; i <= 200000; i++){\n    if (prime[i] != 0){\n       // a/b (% p) = a * b^(p-2) % p\n        ll val = i;\n        ll pw = power(prime[i] + 1, (mod - 2)); //pw is b^(p-2)\n       ll comb = (total * pw) % mod;\n        for (ll c = 1; c <= prime[i]; c++){\n            ll next = power(val, comb); \n            ans = (ans * next) % mod;\n            val *= i;\n            val %= mod;\n        }\n    }\n}\ncout << ans;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(0, m, \"xi\");\n        if (xi == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < xi; j++) {\n                inf.readSpace();\n                int yij = inf.readInt(1, m, \"yij\");\n            }\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(0, m, \"xi\");\n        if (xi == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < xi; j++) {\n                inf.readSpace();\n                int yij = inf.readInt(1, m, \"yij\");\n            }\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(0, m, \"xi\");\n        if (xi == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < xi; j++) {\n                inf.readSpace();\n                int yij = inf.readInt(1, m, \"yij\");\n            }\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    if (type == \"possible\") {\n        // Ensure every bulb is connected to at least one button\n        vector<vector<int>> bulbs_per_button(n + 1);\n\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n\n        // Optionally add extra bulbs to buttons\n        for (int button = 1; button <= n; ++button) {\n            int extra_bulbs = rnd.next(0, m - (int)bulbs_per_button[button].size());\n            set<int> existing(bulbs_per_button[button].begin(), bulbs_per_button[button].end());\n            for (int k = 0; k < extra_bulbs; ++k) {\n                int bulb = rnd.next(1, m);\n                if (existing.count(bulb) == 0) {\n                    bulbs_per_button[button].push_back(bulb);\n                    existing.insert(bulb);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"impossible\") {\n        // Leave at least one bulb unconnected\n        if (m == 1) {\n            // Special case when m == 1\n            printf(\"%d %d\\n\", n, m);\n            for (int i = 0; i < n; ++i) {\n                printf(\"0\\n\");\n            }\n            return 0;\n        }\n\n        int bulb_left_out = rnd.next(1, m);\n        set<int> bulbs_left_out_set;\n        bulbs_left_out_set.insert(bulb_left_out);\n\n        vector<vector<int>> bulbs_per_button(n + 1);\n        vector<int> bulbs_included;\n\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            if (bulb != bulb_left_out) {\n                bulbs_included.push_back(bulb);\n            }\n        }\n\n        for (int bulb : bulbs_included) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n\n        for (int button = 1; button <= n; ++button) {\n            int extra_bulbs = rnd.next(0, m - (int)bulbs_per_button[button].size());\n            set<int> existing(bulbs_per_button[button].begin(), bulbs_per_button[button].end());\n            for (int k = 0; k < extra_bulbs; ++k) {\n                int bulb = bulbs_included[rnd.next(0, (int)bulbs_included.size() - 1)];\n                if (existing.count(bulb) == 0) {\n                    bulbs_per_button[button].push_back(bulb);\n                    existing.insert(bulb);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"random\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            int xi = rnd.next(0, m);\n            set<int> bulbs;\n            for (int k = 0; k < xi; ++k) {\n                int bulb = rnd.next(1, m);\n                bulbs.insert(bulb);\n            }\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"all_to_all\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\", m);\n            for (int bulb = 1; bulb <= m; ++bulb) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"empty_buttons\") {\n        vector<vector<int>> bulbs_per_button(n + 1);\n        int bulbs_covered = 0;\n        vector<int> bulbs_left(m);\n        iota(bulbs_left.begin(), bulbs_left.end(), 1);\n        shuffle(bulbs_left.begin(), bulbs_left.end());\n        int button = 1;\n        while (bulbs_covered < m && button <= n) {\n            int num_bulbs = rnd.next(1, min(10, m - bulbs_covered));\n            vector<int> bulbs(bulbs_left.begin() + bulbs_covered, bulbs_left.begin() + bulbs_covered + num_bulbs);\n            bulbs_per_button[button++] = bulbs;\n            bulbs_covered += num_bulbs;\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 1; i <= n; ++i) {\n            vector<int>& bulbs = bulbs_per_button[i];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"max\") {\n        n = 100;\n        m = 100;\n        vector<vector<int>> bulbs_per_button(n + 1);\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else {\n        // Default: possible\n        vector<vector<int>> bulbs_per_button(n + 1);\n\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n\n        for (int button = 1; button <= n; ++button) {\n            int extra_bulbs = rnd.next(0, m - (int)bulbs_per_button[button].size());\n            set<int> existing(bulbs_per_button[button].begin(), bulbs_per_button[button].end());\n            for (int k = 0; k < extra_bulbs; ++k) {\n                int bulb = rnd.next(1, m);\n                if (existing.count(bulb) == 0) {\n                    bulbs_per_button[button].push_back(bulb);\n                    existing.insert(bulb);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    if (type == \"possible\") {\n        // Ensure every bulb is connected to at least one button\n        vector<vector<int>> bulbs_per_button(n + 1);\n\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n\n        // Optionally add extra bulbs to buttons\n        for (int button = 1; button <= n; ++button) {\n            int extra_bulbs = rnd.next(0, m - (int)bulbs_per_button[button].size());\n            set<int> existing(bulbs_per_button[button].begin(), bulbs_per_button[button].end());\n            for (int k = 0; k < extra_bulbs; ++k) {\n                int bulb = rnd.next(1, m);\n                if (existing.count(bulb) == 0) {\n                    bulbs_per_button[button].push_back(bulb);\n                    existing.insert(bulb);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"impossible\") {\n        // Leave at least one bulb unconnected\n        if (m == 1) {\n            // Special case when m == 1\n            printf(\"%d %d\\n\", n, m);\n            for (int i = 0; i < n; ++i) {\n                printf(\"0\\n\");\n            }\n            return 0;\n        }\n\n        int bulb_left_out = rnd.next(1, m);\n        set<int> bulbs_left_out_set;\n        bulbs_left_out_set.insert(bulb_left_out);\n\n        vector<vector<int>> bulbs_per_button(n + 1);\n        vector<int> bulbs_included;\n\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            if (bulb != bulb_left_out) {\n                bulbs_included.push_back(bulb);\n            }\n        }\n\n        for (int bulb : bulbs_included) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n\n        for (int button = 1; button <= n; ++button) {\n            int extra_bulbs = rnd.next(0, m - (int)bulbs_per_button[button].size());\n            set<int> existing(bulbs_per_button[button].begin(), bulbs_per_button[button].end());\n            for (int k = 0; k < extra_bulbs; ++k) {\n                int bulb = bulbs_included[rnd.next(0, (int)bulbs_included.size() - 1)];\n                if (existing.count(bulb) == 0) {\n                    bulbs_per_button[button].push_back(bulb);\n                    existing.insert(bulb);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"random\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            int xi = rnd.next(0, m);\n            set<int> bulbs;\n            for (int k = 0; k < xi; ++k) {\n                int bulb = rnd.next(1, m);\n                bulbs.insert(bulb);\n            }\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"all_to_all\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\", m);\n            for (int bulb = 1; bulb <= m; ++bulb) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"empty_buttons\") {\n        vector<vector<int>> bulbs_per_button(n + 1);\n        int bulbs_covered = 0;\n        vector<int> bulbs_left(m);\n        iota(bulbs_left.begin(), bulbs_left.end(), 1);\n        shuffle(bulbs_left.begin(), bulbs_left.end());\n        int button = 1;\n        while (bulbs_covered < m && button <= n) {\n            int num_bulbs = rnd.next(1, min(10, m - bulbs_covered));\n            vector<int> bulbs(bulbs_left.begin() + bulbs_covered, bulbs_left.begin() + bulbs_covered + num_bulbs);\n            bulbs_per_button[button++] = bulbs;\n            bulbs_covered += num_bulbs;\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 1; i <= n; ++i) {\n            vector<int>& bulbs = bulbs_per_button[i];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else if (type == \"max\") {\n        n = 100;\n        m = 100;\n        vector<vector<int>> bulbs_per_button(n + 1);\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    } else {\n        // Default: possible\n        vector<vector<int>> bulbs_per_button(n + 1);\n\n        for (int bulb = 1; bulb <= m; ++bulb) {\n            int button = rnd.next(1, n);\n            bulbs_per_button[button].push_back(bulb);\n        }\n\n        for (int button = 1; button <= n; ++button) {\n            int extra_bulbs = rnd.next(0, m - (int)bulbs_per_button[button].size());\n            set<int> existing(bulbs_per_button[button].begin(), bulbs_per_button[button].end());\n            for (int k = 0; k < extra_bulbs; ++k) {\n                int bulb = rnd.next(1, m);\n                if (existing.count(bulb) == 0) {\n                    bulbs_per_button[button].push_back(bulb);\n                    existing.insert(bulb);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (int button = 1; button <= n; ++button) {\n            vector<int>& bulbs = bulbs_per_button[button];\n            printf(\"%d\", (int)bulbs.size());\n            for (int bulb : bulbs) {\n                printf(\" %d\", bulb);\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type possible\n./gen -n 1 -m 1 -type impossible\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type all_to_all\n./gen -n 1 -m 1 -type empty_buttons\n\n./gen -n 5 -m 5 -type possible\n./gen -n 5 -m 5 -type impossible\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type all_to_all\n./gen -n 5 -m 5 -type empty_buttons\n\n./gen -n 10 -m 10 -type possible\n./gen -n 10 -m 10 -type impossible\n./gen -n 10 -m 10 -type random\n\n./gen -n 20 -m 30 -type possible\n./gen -n 20 -m 30 -type impossible\n./gen -n 20 -m 30 -type random\n\n./gen -n 50 -m 50 -type possible\n./gen -n 50 -m 50 -type impossible\n./gen -n 50 -m 50 -type random\n\n./gen -n 100 -m 100 -type possible\n./gen -n 100 -m 100 -type impossible\n./gen -n 100 -m 100 -type random\n\n./gen -n 100 -m 100 -type max\n./gen -n 100 -m 100 -type all_to_all\n\n./gen -n 50 -m 70 -type empty_buttons\n./gen -n 70 -m 50 -type empty_buttons\n\n./gen -n 1 -m 100 -type possible\n./gen -n 1 -m 100 -type impossible\n./gen -n 1 -m 100 -type random\n\n./gen -n 100 -m 1 -type possible\n./gen -n 100 -m 1 -type impossible\n./gen -n 100 -m 1 -type random\n\n./gen -n 100 -m 100 -type impossible\n./gen -n 100 -m 100 -type empty_buttons\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:17.447843",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "615/B",
      "title": "B. Длиннохвостый еж",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны два числа n и m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000) — количество точек и отрезков на подаренной Маше картинке соответственно.В следующих m строках содержится по два числа ui и vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — номера точек, которые соединяет данный отрезок. Гарантируется, что никакие два отрезка не соединяют одну и ту же пару точек.",
      "output_spec": "Выходные данныеВыведите максимально возможную красоту ежа.",
      "sample_tests": "ПримерыВходные данныеСкопировать8 64 53 52 51 22 86 7Выходные данныеСкопировать9Входные данныеСкопировать4 61 21 31 42 32 43 4Выходные данныеСкопировать12",
      "description": "B. Длиннохвостый еж\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны два числа n и m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000) — количество точек и отрезков на подаренной Маше картинке соответственно.В следующих m строках содержится по два числа ui и vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — номера точек, которые соединяет данный отрезок. Гарантируется, что никакие два отрезка не соединяют одну и ту же пару точек.\n\nВходные данные\n\nВыходные данныеВыведите максимально возможную красоту ежа.\n\nВыходные данные\n\nВходные данныеСкопировать8 64 53 52 51 22 86 7Выходные данныеСкопировать9Входные данныеСкопировать4 61 21 31 42 32 43 4Выходные данныеСкопировать12\n\nВходные данныеСкопировать8 64 53 52 51 22 86 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 61 21 31 42 32 43 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеНа рисунке изображён первый пример. Красным обозначены отрезки, составляющие ежа. Хвост состоит из последовательности точек 1, 2 и 5. Колючками являются отрезки между парами точек (2, 5), (3, 5) и (4, 5). Таким образом, красота ежа равняется 3·3 = 9.",
      "solutions": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "615A - Лампочки (Автор: TheWishmaster)Заведем для каждой лампочки счетчик – сколько кнопок ее выключает. Если для какой-то лампочки счетчик равен 0, то ответ нет, иначе да.Код: 15260902615B - Длиннохвостый еж (Автор: TheWishmaster)Посчитаем dp[i] – максимальная длина хвоста, заканчивающегося в i-ой вершине. Обновлять его просто – пройдем по всем ребрам из вершины и попытаемся увеличить текущее значение в концах ребер. Для ответа пройдемся по всем вершинам и выберем лучшую.Код: 15260851615C - Беговой трек (Автор: maxkvant)Заметим, что если мы можем мы можем получить подстроку t[i, j] используя k полотен, то мы можем получить и подстроку t[i + 1, j] не более чем из k полотен. Поэтому нам выгодно каждый раз брать как можно более длинную подстроку.Пусть n = |s|, m = |t|. На каждом этапе будем за искать эту самую длинную подстроку (lj – ее длина) в s и s_reversed, которую можем приписать к ответу.Это можно делать несколькими способами: Посчитаем lcp[i][j] — наибольший общий префикс t[i, m] и s[j, n], lcprev[i][j] — t[i, m] и s[j, 1]. Найти нужную подстроку означает найти max(max(lcp[i][1], lcp[i][2], ..., lcp[i][n]), max(lcprev[i][1], lcprev[i][2], ..., lcprev[i][n])). Подсчёт lcp: for (int i = m; i >= 1; i--)\n for (int j = n; j >= 1; j--) \n if (t[i] == s[j])\n lcp[i][j] = lcp[i + 1][j + 1] + 1;Код: 15277213 Заведём массив endPos, где значит endPos[j] — равна ли t[i, i + cur_len - 1] и s[j - cur_len + 1, j]. Будем пересчитывать значения этого массива, добавляя по одному символу t[i],  t[i + 1],  t[i + 2].... Аналогичный массив заведём для s_reversed. Суммарно решение отработает за Код: 15260867Решение бором: 15260870bonusможете ли вы решить задачу за , ? ?Σ — размер алфавита.615D - Множители (Автор: maxkvant)Обозначим d(x) — к-во делителей числа x, f(x) — произведение делителей числа. Пусть x = p1α1p2α2... pnαn, тогда d(x) = (α1 + 1)·(α2 + 1)... (αn + 1) . Есть пар делителитей вида , , и если x — точный квадрат добавляется ещё 1 делитель : .для простого m и a ≠ 0 верно Можно заметь, если a и b взаимно простые, то , Пользуясь этими свойствами нетрудно посчитать ответ: d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n d = d * (cnt[i] + 1) % (MOD - 1);\n} Код: 15260890bonusДругая задача.Дана последовательность (p1, k1),  (p2, k2), ...,  (pn, kn) (p_i — различные простые) и q запоросов (l, r) вычислить f(plkl·pl + 1kl + 1... prkr)%MOD.Как решать за ?615E - Шестиугольники (Автор: TheWishmaster)Посмотрим, как изменяется координаты при переходе из текущего 6-угольника в каждый из смежных ему(назовем это 6 типами переходов). Если мы знаем сколько переходов каждого типа мы сделали на пути, то знаем и координаты конца пути.Разделим весь путь на кольца:Посчитаем количество переходов через каждую из сторон шестиугольника для 1 кольца. В каждом следующем кольце будет на 1 переход каждого типа больше, чем в предыдущем кольце. Длина каждого кольца = длина предыдущего + 6. Это арифметическая прогрессия. С помощью формулы суммы первых членов арифметической прогрессии и бинпоиска найдем номер последнего кольца и длину всех колец до него. Осталось только перебрать 6 типов последнего сделанного перехода и посчитать ответ.Код: 15260879",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22658",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 615\\s*B"
          },
          "content_length": 3265
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++){\n    ll p; cin >> p;\n    prime[p]++; //cocunt the number of prime 'p'\n}\nfor (int i = 0; i <= 200000; i++){\n    total *= (prime[i] + 1); //calculate the whole possible combination\n    total %= mod;\n}\nfor (ll i = 1; i <= 200000; i++){\n    if (prime[i] != 0){\n       // a/b (% p) = a * b^(p-2) % p\n        ll val = i;\n        ll pw = power(prime[i] + 1, (mod - 2)); //pw is b^(p-2)\n       ll comb = (total * pw) % mod;\n        for (ll c = 1; c <= prime[i]; c++){\n            ll next = power(val, comb); \n            ans = (ans * next) % mod;\n            val *= i;\n            val %= mod;\n        }\n    }\n}\ncout << ans;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Segments cannot connect the same point to itself (u_i != v_i)\");\n\n        int a = u, b = v;\n        if (a > b) swap(a, b);\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.insert(edge).second, \"Duplicate segment between points %d and %d\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Segments cannot connect the same point to itself (u_i != v_i)\");\n\n        int a = u, b = v;\n        if (a > b) swap(a, b);\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.insert(edge).second, \"Duplicate segment between points %d and %d\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Segments cannot connect the same point to itself (u_i != v_i)\");\n\n        int a = u, b = v;\n        if (a > b) swap(a, b);\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.insert(edge).second, \"Duplicate segment between points %d and %d\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check the constraints\n    ensure(2 <= n && n <= 100000);\n    ensure(1 <= m && m <= 200000);\n    ensure(m <= (long long) n * (n - 1) / 2);\n\n    set<pair<int, int>> edges; // to store edges and avoid duplicates\n    vector<int> parents(n);\n    iota(parents.begin(), parents.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return x == parents[x] ? x : parents[x] = find(parents[x]);\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (rnd.next(0, 1))\n                parents[x] = y;\n            else\n                parents[y] = x;\n            return true;\n        } else\n            return false;\n    };\n\n    if (type == \"random\") {\n        // Create a connected graph first\n        vector<int> nodes(n);\n        iota(nodes.begin(), nodes.end(), 0);\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i - 1)];\n            if (u > v) swap(u, v);\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges until we have m edges\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"chain\") {\n        // Build a chain\n        for (int i = 0; i < n - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            if (u > v) swap(u, v);\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges if necessary\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"star\") {\n        // Build a star centered at node 0\n        for (int i = 1; i < n; ++i) {\n            int u = 0;\n            int v = i;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges if necessary\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"tail_star\") {\n        // Build a tail from node 0 to t nodes and connect remaining nodes to last node\n        int t = opt<int>(\"t\", n / 2);\n        if (t > n) t = n;\n        // Build chain (tail)\n        for (int i = 0; i < t - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Connect remaining nodes to the last node of the tail\n        for (int i = t; i < n; ++i) {\n            int u = t - 1;\n            int v = i;\n            edges.insert({min(u, v), max(u, v)});\n            unite(u, v);\n        }\n        // Add random edges if necessary\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"complete\") {\n        // Build a complete graph\n        ensure((long long) n * (n - 1) / 2 <= m);\n        for (int u = 0; u < n; ++u) {\n            for (int v = u + 1; v < n; ++v) {\n                if ((int) edges.size() >= m) break;\n                edges.insert({u, v});\n                unite(u, v);\n            }\n            if ((int) edges.size() >= m) break;\n        }\n    } else if (type == \"two_components\") {\n        // Build two disconnected components\n        int n1 = n / 2;\n        int n2 = n - n1;\n        // First component\n        for (int i = 0; i < n1 - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Second component\n        for (int i = n1; i < n - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges within components if necessary\n        while ((int) edges.size() < m) {\n            int comp = rnd.next(0, 1);\n            int u, v;\n            if (comp == 0) {\n                u = rnd.next(0, n1 - 1);\n                v = rnd.next(0, n1 - 1);\n            } else {\n                u = rnd.next(n1, n - 1);\n                v = rnd.next(n1, n - 1);\n            }\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1); // Convert to 1-based indexing\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check the constraints\n    ensure(2 <= n && n <= 100000);\n    ensure(1 <= m && m <= 200000);\n    ensure(m <= (long long) n * (n - 1) / 2);\n\n    set<pair<int, int>> edges; // to store edges and avoid duplicates\n    vector<int> parents(n);\n    iota(parents.begin(), parents.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return x == parents[x] ? x : parents[x] = find(parents[x]);\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (rnd.next(0, 1))\n                parents[x] = y;\n            else\n                parents[y] = x;\n            return true;\n        } else\n            return false;\n    };\n\n    if (type == \"random\") {\n        // Create a connected graph first\n        vector<int> nodes(n);\n        iota(nodes.begin(), nodes.end(), 0);\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i - 1)];\n            if (u > v) swap(u, v);\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges until we have m edges\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"chain\") {\n        // Build a chain\n        for (int i = 0; i < n - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            if (u > v) swap(u, v);\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges if necessary\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"star\") {\n        // Build a star centered at node 0\n        for (int i = 1; i < n; ++i) {\n            int u = 0;\n            int v = i;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges if necessary\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"tail_star\") {\n        // Build a tail from node 0 to t nodes and connect remaining nodes to last node\n        int t = opt<int>(\"t\", n / 2);\n        if (t > n) t = n;\n        // Build chain (tail)\n        for (int i = 0; i < t - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Connect remaining nodes to the last node of the tail\n        for (int i = t; i < n; ++i) {\n            int u = t - 1;\n            int v = i;\n            edges.insert({min(u, v), max(u, v)});\n            unite(u, v);\n        }\n        // Add random edges if necessary\n        while ((int) edges.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else if (type == \"complete\") {\n        // Build a complete graph\n        ensure((long long) n * (n - 1) / 2 <= m);\n        for (int u = 0; u < n; ++u) {\n            for (int v = u + 1; v < n; ++v) {\n                if ((int) edges.size() >= m) break;\n                edges.insert({u, v});\n                unite(u, v);\n            }\n            if ((int) edges.size() >= m) break;\n        }\n    } else if (type == \"two_components\") {\n        // Build two disconnected components\n        int n1 = n / 2;\n        int n2 = n - n1;\n        // First component\n        for (int i = 0; i < n1 - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Second component\n        for (int i = n1; i < n - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.insert({u, v});\n            unite(u, v);\n        }\n        // Add random edges within components if necessary\n        while ((int) edges.size() < m) {\n            int comp = rnd.next(0, 1);\n            int u, v;\n            if (comp == 0) {\n                u = rnd.next(0, n1 - 1);\n                v = rnd.next(0, n1 - 1);\n            } else {\n                u = rnd.next(n1, n - 1);\n                v = rnd.next(n1, n - 1);\n            }\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (!edges.count({u, v})) {\n                edges.insert({u, v});\n            }\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1); // Convert to 1-based indexing\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small graphs\n./gen -n 5 -m 4 -type random\n./gen -n 5 -m 4 -type chain\n./gen -n 5 -m 4 -type star\n./gen -n 5 -m 10 -type complete\n\n# Medium graphs\n./gen -n 100 -m 200 -type random\n./gen -n 100 -m 99 -type chain\n./gen -n 100 -m 99 -type star\n./gen -n 100 -m 4950 -type complete\n\n# Large graphs\n./gen -n 100000 -m 200000 -type random\n./gen -n 100000 -m 99999 -type chain\n./gen -n 100000 -m 99999 -type star\n\n# Tail with star at the end\n./gen -n 1000 -m 2000 -type tail_star -t 500\n./gen -n 100000 -m 150000 -type tail_star -t 50000\n\n# Disconnected graphs\n./gen -n 1000 -m 1500 -type two_components\n./gen -n 10000 -m 15000 -type two_components\n\n# Edge cases\n./gen -n 2 -m 1 -type chain\n./gen -n 2 -m 1 -type star\n./gen -n 2 -m 1 -type random\n\n# Max edges\n./gen -n 100000 -m 200000 -type random\n\n# Minimum edges\n./gen -n 100000 -m 1 -type random\n\n# Chain with extra edges\n./gen -n 1000 -m 1500 -type chain\n\n# Star with extra edges\n./gen -n 1000 -m 1500 -type star\n\n# Complete graph for small n\n./gen -n 200 -m 19900 -type complete\n\n# Random graphs to test for potential overflows\n./gen -n 100000 -m 200000 -type random\n\n# Test cases where spines overlap with the tail\n./gen -n 1000 -m 1500 -type tail_star -t 1\n\n# Random sparse graphs\n./gen -n 100000 -m 50000 -type random\n\n# Random dense graphs\n./gen -n 100000 -m 200000 -type random\n\n# Small random graphs\n./gen -n 20 -m 50 -type random\n\n# Random trees\n./gen -n 100000 -m 99999 -type random\n\n# Graphs with maximum possible beauty\n./gen -n 100000 -m 200000 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:19.277991",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "615/C",
      "title": "C. Running Track",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputFirst line of the input contains the string s — the coating that is present in the shop. Second line contains the string t — the coating Ayrat wants to obtain. Both strings are non-empty, consist of only small English letters and their length doesn't exceed 2100.",
      "output_spec": "OutputThe first line should contain the minimum needed number of coatings n or -1 if it's impossible to create the desired coating.If the answer is not -1, then the following n lines should contain two integers xi and yi — numbers of ending blocks in the corresponding piece. If xi ≤ yi then this piece is used in the regular order, and if xi > yi piece is used in the reversed order. Print the pieces in the order they should be glued to get the string t.",
      "sample_tests": "ExamplesInputCopyabccbaabcOutputCopy23 11 3InputCopyaaabrytaaaayratOutputCopy31 16 58 7InputCopyaminoOutputCopy-1",
      "description": "C. Running Track\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of the input contains the string s — the coating that is present in the shop. Second line contains the string t — the coating Ayrat wants to obtain. Both strings are non-empty, consist of only small English letters and their length doesn't exceed 2100.\n\nOutputThe first line should contain the minimum needed number of coatings n or -1 if it's impossible to create the desired coating.If the answer is not -1, then the following n lines should contain two integers xi and yi — numbers of ending blocks in the corresponding piece. If xi ≤ yi then this piece is used in the regular order, and if xi > yi piece is used in the reversed order. Print the pieces in the order they should be glued to get the string t.\n\nInputCopyabccbaabcOutputCopy23 11 3InputCopyaaabrytaaaayratOutputCopy31 16 58 7InputCopyaminoOutputCopy-1\n\nInputCopyabccbaabc\n\nOutputCopy23 11 3\n\nInputCopyaaabrytaaaayrat\n\nOutputCopy31 16 58 7\n\nInputCopyamino\n\nOutputCopy-1\n\nNoteIn the first sample string \"cbaabc\" = \"cba\" + \"abc\".In the second sample: \"ayrat\" = \"a\" + \"yr\" + \"at\".",
      "solutions": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Greetings!Codeforces Round #338 (Div. 2) will be held tomorrow. Note that round starts at the unusual time! This round was made by Maxim Vinnichenko(maxkvant), and me, Alexander Zoykin. It is our first round and we hope that everything will be OK. Thanks to GlebsHP for the great help in preparing the contest, Bobrosoft for being more than tester, Delinur for translating the statements into English, and MikeMirzayanov for the great Polygon and Codeforces systems.score distribution 500 — 1250 — 1750 — 2000 — 2500Good luck!upd Congratulations to winners!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavEditorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 692
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "615A - Лампочки (Автор: TheWishmaster)Заведем для каждой лампочки счетчик – сколько кнопок ее выключает. Если для какой-то лампочки счетчик равен 0, то ответ нет, иначе да.Код: 15260902615B - Длиннохвостый еж (Автор: TheWishmaster)Посчитаем dp[i] – максимальная длина хвоста, заканчивающегося в i-ой вершине. Обновлять его просто – пройдем по всем ребрам из вершины и попытаемся увеличить текущее значение в концах ребер. Для ответа пройдемся по всем вершинам и выберем лучшую.Код: 15260851615C - Беговой трек (Автор: maxkvant)Заметим, что если мы можем мы можем получить подстроку t[i, j] используя k полотен, то мы можем получить и подстроку t[i + 1, j] не более чем из k полотен. Поэтому нам выгодно каждый раз брать как можно более длинную подстроку.Пусть n = |s|, m = |t|. На каждом этапе будем за искать эту самую длинную подстроку (lj – ее длина) в s и s_reversed, которую можем приписать к ответу.Это можно делать несколькими способами: Посчитаем lcp[i][j] — наибольший общий префикс t[i, m] и s[j, n], lcprev[i][j] — t[i, m] и s[j, 1]. Найти нужную подстроку означает найти max(max(lcp[i][1], lcp[i][2], ..., lcp[i][n]), max(lcprev[i][1], lcprev[i][2], ..., lcprev[i][n])). Подсчёт lcp: for (int i = m; i >= 1; i--)\n for (int j = n; j >= 1; j--) \n if (t[i] == s[j])\n lcp[i][j] = lcp[i + 1][j + 1] + 1;Код: 15277213 Заведём массив endPos, где значит endPos[j] — равна ли t[i, i + cur_len - 1] и s[j - cur_len + 1, j]. Будем пересчитывать значения этого массива, добавляя по одному символу t[i],  t[i + 1],  t[i + 2].... Аналогичный массив заведём для s_reversed. Суммарно решение отработает за Код: 15260867Решение бором: 15260870bonusможете ли вы решить задачу за , ? ?Σ — размер алфавита.615D - Множители (Автор: maxkvant)Обозначим d(x) — к-во делителей числа x, f(x) — произведение делителей числа. Пусть x = p1α1p2α2... pnαn, тогда d(x) = (α1 + 1)·(α2 + 1)... (αn + 1) . Есть пар делителитей вида , , и если x — точный квадрат добавляется ещё 1 делитель : .для простого m и a ≠ 0 верно Можно заметь, если a и b взаимно простые, то , Пользуясь этими свойствами нетрудно посчитать ответ: d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n d = d * (cnt[i] + 1) % (MOD - 1);\n} Код: 15260890bonusДругая задача.Дана последовательность (p1, k1),  (p2, k2), ...,  (pn, kn) (p_i — различные простые) и q запоросов (l, r) вычислить f(plkl·pl + 1kl + 1... prkr)%MOD.Как решать за ?615E - Шестиугольники (Автор: TheWishmaster)Посмотрим, как изменяется координаты при переходе из текущего 6-угольника в каждый из смежных ему(назовем это 6 типами переходов). Если мы знаем сколько переходов каждого типа мы сделали на пути, то знаем и координаты конца пути.Разделим весь путь на кольца:Посчитаем количество переходов через каждую из сторон шестиугольника для 1 кольца. В каждом следующем кольце будет на 1 переход каждого типа больше, чем в предыдущем кольце. Длина каждого кольца = длина предыдущего + 6. Это арифметическая прогрессия. С помощью формулы суммы первых членов арифметической прогрессии и бинпоиска найдем номер последнего кольца и длину всех колец до него. Осталось только перебрать 6 типов последнего сделанного перехода и посчитать ответ.Код: 15260879",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22658",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 615\\s*C"
          },
          "content_length": 3265
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++){\n    ll p; cin >> p;\n    prime[p]++; //cocunt the number of prime 'p'\n}\nfor (int i = 0; i <= 200000; i++){\n    total *= (prime[i] + 1); //calculate the whole possible combination\n    total %= mod;\n}\nfor (ll i = 1; i <= 200000; i++){\n    if (prime[i] != 0){\n       // a/b (% p) = a * b^(p-2) % p\n        ll val = i;\n        ll pw = power(prime[i] + 1, (mod - 2)); //pw is b^(p-2)\n       ll comb = (total * pw) % mod;\n        for (ll c = 1; c <= prime[i]; c++){\n            ll next = power(val, comb); \n            ans = (ans * next) % mod;\n            val *= i;\n            val %= mod;\n        }\n    }\n}\ncout << ans;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    // Read the first string 's' and ensure it meets the constraints\n    string s = inf.readLine(\"[a-z]{1,2100}\", \"s\");\n\n    // Read the second string 't' and ensure it meets the constraints\n    string t = inf.readLine(\"[a-z]{1,2100}\", \"t\");\n\n    // Ensure that we've reached the end of the file\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    // Read the first string 's' and ensure it meets the constraints\n    string s = inf.readLine(\"[a-z]{1,2100}\", \"s\");\n\n    // Read the second string 't' and ensure it meets the constraints\n    string t = inf.readLine(\"[a-z]{1,2100}\", \"t\");\n\n    // Ensure that we've reached the end of the file\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    // Read the first string 's' and ensure it meets the constraints\n    string s = inf.readLine(\"[a-z]{1,2100}\", \"s\");\n\n    // Read the second string 't' and ensure it meets the constraints\n    string t = inf.readLine(\"[a-z]{1,2100}\", \"t\");\n\n    // Ensure that we've reached the end of the file\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string s = inf.readLine();\n    string t = inf.readLine();\n\n    int n_ans = ans.readInt(-1, 2100, \"jury's n\");\n    int n_part = ouf.readInt(-1, 2100, \"participant's n\");\n\n    if (n_ans == -1) {\n        if (n_part == -1) {\n            quitf(_ok, \"both jury and participant report impossible\");\n        } else {\n            quitf(_fail, \"participant found a solution but jury reports impossible\");\n        }\n    } else {\n        if (n_part == -1) {\n            quitf(_wa, \"participant reports impossible but jury has a solution\");\n        } else {\n            if (n_part > n_ans) {\n                quitf(_wa, \"participant's solution is not minimal: participant's n = %d, jury's n = %d\", n_part, n_ans);\n            } else if (n_part < n_ans) {\n                quitf(_fail, \"participant found a better solution: participant's n = %d, jury's n = %d\", n_part, n_ans);\n            } else {\n                // n_part == n_ans\n                int s_len = s.length();\n                vector<string> pieces;\n                for (int i = 0; i < n_part; ++i) {\n                    int xi = ouf.readInt(1, s_len, format(\"xi[%d]\", i+1).c_str());\n                    int yi = ouf.readInt(1, s_len, format(\"yi[%d]\", i+1).c_str());\n                    string piece;\n                    if (xi <= yi) {\n                        piece = s.substr(xi - 1, yi - xi + 1);\n                    } else {\n                        string temp = s.substr(yi - 1, xi - yi + 1);\n                        reverse(temp.begin(), temp.end());\n                        piece = temp;\n                    }\n                    pieces.push_back(piece);\n                }\n                string s_concat = accumulate(pieces.begin(), pieces.end(), string());\n                if (s_concat == t) {\n                    quitf(_ok, \"answer is correct with n = %d\", n_part);\n                } else {\n                    quitf(_wa, \"the constructed string does not match t\");\n                }\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int length) {\n    string res = \"\";\n    for (int i = 0; i < length; ++i) {\n        res += rnd.next('a', 'z');\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int len_s = opt<int>(\"len_s\", 10);\n    int len_t = opt<int>(\"len_t\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s, t;\n    \n    if (type == \"same\") {\n        // s and t are the same\n        s = t = generate_random_string(len_s);\n    } else if (type == \"substring\") {\n        // t is a substring of s (could be reversed)\n        s = generate_random_string(len_s);\n        if (len_t > len_s) len_t = len_s;\n        int start = rnd.next(0, len_s - len_t);\n        t = s.substr(start, len_t);\n        // Possibly reverse t\n        if (rnd.next(0, 1) == 1) {\n            reverse(t.begin(), t.end());\n        }\n    } else if (type == \"reverse_only\") {\n        // t can only be formed by reversed substrings of s\n        s = generate_random_string(len_s);\n        t = \"\";\n        int pos = len_s - 1;\n        while ((int)t.length() < len_t && pos >= 0) {\n            int len = rnd.next(1, min(len_t - (int)t.length(), pos + 1));\n            string sub = s.substr(pos - len + 1, len);\n            reverse(sub.begin(), sub.end());\n            t += sub;\n            pos -= len;\n        }\n        if ((int)t.length() < len_t) {\n            // Cannot form t, adjust s\n            s = t;\n        }\n    } else if (type == \"multiple_substrings\") {\n        // t is formed by multiple substrings\n        s = generate_random_string(len_s);\n        t = \"\";\n        while ((int)t.length() < len_t) {\n            int len = rnd.next(1, min(len_s, len_t - (int)t.length()));\n            int start = rnd.next(0, len_s - len);\n            string sub = s.substr(start, len);\n            if (rnd.next(0,1)) {\n                reverse(sub.begin(), sub.end());\n            }\n            t += sub;\n        }\n    } else if (type == \"impossible\") {\n        // t cannot be formed from s\n        s = generate_random_string(len_s);\n        t = generate_random_string(len_t);\n        // Make sure that t cannot be formed from substrings of s\n        set<char> s_chars(s.begin(), s.end());\n        set<char> t_chars(t.begin(), t.end());\n        set<char> common_chars;\n        set_intersection(s_chars.begin(), s_chars.end(), t_chars.begin(), t_chars.end(),\n                         inserter(common_chars, common_chars.begin()));\n        if (!common_chars.empty()) {\n            // Remove common characters from t\n            string new_t;\n            for (char c : t) {\n                if (s_chars.count(c) == 0)\n                    new_t += c;\n                else\n                    new_t += rnd.next('a', 'z');\n            }\n            t = new_t;\n        }\n    } else if (type == \"repeated_s\") {\n        // t is s repeated multiple times\n        s = generate_random_string(len_s);\n        int repeat = len_t / len_s;\n        if (repeat == 0) repeat = 1;\n        string repeated_s = \"\";\n        for (int i = 0; i < repeat; ++i) {\n            repeated_s += s;\n        }\n        // Add extra characters to reach len_t\n        while ((int)repeated_s.length() < len_t) {\n            repeated_s += s;\n        }\n        repeated_s = repeated_s.substr(0, len_t);\n        t = repeated_s;\n    } else if (type == \"edge_case_min\") {\n        // s and t are of minimal length 1\n        s = generate_random_string(1);\n        t = s;\n    } else if (type == \"edge_case_max\") {\n        // s and t are of maximal length 2100\n        s = generate_random_string(2100);\n        t = generate_random_string(2100);\n    } else if (type == \"palindrome\") {\n        // t is a palindrome\n        s = generate_random_string(len_s);\n        t = \"\";\n        int half_len = len_t / 2;\n        for (int i = 0; i < half_len; ++i) {\n            char c = rnd.next('a', 'z');\n            t += c;\n        }\n        string t_rev = t;\n        reverse(t_rev.begin(), t_rev.end());\n        if (len_t % 2 == 1) {\n            t += rnd.next('a', 'z');\n        }\n        t += t_rev;\n    } else if (type == \"random\") {\n        // Completely random s and t\n        s = generate_random_string(len_s);\n        t = generate_random_string(len_t);\n    } else if (type == \"repetitive\") {\n        // s and t consist of repeated characters\n        char c_s = rnd.next('a', 'z');\n        char c_t = rnd.next('a', 'z');\n        s = string(len_s, c_s);\n        t = string(len_t, c_t);\n    } else if (type == \"unique_chars\") {\n        // s and t consist of unique characters\n        len_s = min(len_s, 26);\n        len_t = min(len_t, 26);\n        vector<char> letters(26);\n        iota(letters.begin(), letters.end(), 'a');\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < len_s; ++i) {\n            s += letters[i];\n        }\n        shuffle(letters.begin(), letters.end());\n        t = \"\";\n        for (int i = 0; i < len_t; ++i) {\n            t += letters[i];\n        }\n    } else if (type == \"max\") {\n        // Max lengths\n        s = generate_random_string(2100);\n        t = generate_random_string(2100);\n    } else {\n        // Default to random\n        s = generate_random_string(len_s);\n        t = generate_random_string(len_t);\n    }\n    \n    // Ensure s and t are non-empty and length ≤2100\n    len_s = max(1, min((int)s.length(), 2100));\n    len_t = max(1, min((int)t.length(), 2100));\n    s = s.substr(0, len_s);\n    t = t.substr(0, len_t);\n    \n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int length) {\n    string res = \"\";\n    for (int i = 0; i < length; ++i) {\n        res += rnd.next('a', 'z');\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int len_s = opt<int>(\"len_s\", 10);\n    int len_t = opt<int>(\"len_t\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s, t;\n    \n    if (type == \"same\") {\n        // s and t are the same\n        s = t = generate_random_string(len_s);\n    } else if (type == \"substring\") {\n        // t is a substring of s (could be reversed)\n        s = generate_random_string(len_s);\n        if (len_t > len_s) len_t = len_s;\n        int start = rnd.next(0, len_s - len_t);\n        t = s.substr(start, len_t);\n        // Possibly reverse t\n        if (rnd.next(0, 1) == 1) {\n            reverse(t.begin(), t.end());\n        }\n    } else if (type == \"reverse_only\") {\n        // t can only be formed by reversed substrings of s\n        s = generate_random_string(len_s);\n        t = \"\";\n        int pos = len_s - 1;\n        while ((int)t.length() < len_t && pos >= 0) {\n            int len = rnd.next(1, min(len_t - (int)t.length(), pos + 1));\n            string sub = s.substr(pos - len + 1, len);\n            reverse(sub.begin(), sub.end());\n            t += sub;\n            pos -= len;\n        }\n        if ((int)t.length() < len_t) {\n            // Cannot form t, adjust s\n            s = t;\n        }\n    } else if (type == \"multiple_substrings\") {\n        // t is formed by multiple substrings\n        s = generate_random_string(len_s);\n        t = \"\";\n        while ((int)t.length() < len_t) {\n            int len = rnd.next(1, min(len_s, len_t - (int)t.length()));\n            int start = rnd.next(0, len_s - len);\n            string sub = s.substr(start, len);\n            if (rnd.next(0,1)) {\n                reverse(sub.begin(), sub.end());\n            }\n            t += sub;\n        }\n    } else if (type == \"impossible\") {\n        // t cannot be formed from s\n        s = generate_random_string(len_s);\n        t = generate_random_string(len_t);\n        // Make sure that t cannot be formed from substrings of s\n        set<char> s_chars(s.begin(), s.end());\n        set<char> t_chars(t.begin(), t.end());\n        set<char> common_chars;\n        set_intersection(s_chars.begin(), s_chars.end(), t_chars.begin(), t_chars.end(),\n                         inserter(common_chars, common_chars.begin()));\n        if (!common_chars.empty()) {\n            // Remove common characters from t\n            string new_t;\n            for (char c : t) {\n                if (s_chars.count(c) == 0)\n                    new_t += c;\n                else\n                    new_t += rnd.next('a', 'z');\n            }\n            t = new_t;\n        }\n    } else if (type == \"repeated_s\") {\n        // t is s repeated multiple times\n        s = generate_random_string(len_s);\n        int repeat = len_t / len_s;\n        if (repeat == 0) repeat = 1;\n        string repeated_s = \"\";\n        for (int i = 0; i < repeat; ++i) {\n            repeated_s += s;\n        }\n        // Add extra characters to reach len_t\n        while ((int)repeated_s.length() < len_t) {\n            repeated_s += s;\n        }\n        repeated_s = repeated_s.substr(0, len_t);\n        t = repeated_s;\n    } else if (type == \"edge_case_min\") {\n        // s and t are of minimal length 1\n        s = generate_random_string(1);\n        t = s;\n    } else if (type == \"edge_case_max\") {\n        // s and t are of maximal length 2100\n        s = generate_random_string(2100);\n        t = generate_random_string(2100);\n    } else if (type == \"palindrome\") {\n        // t is a palindrome\n        s = generate_random_string(len_s);\n        t = \"\";\n        int half_len = len_t / 2;\n        for (int i = 0; i < half_len; ++i) {\n            char c = rnd.next('a', 'z');\n            t += c;\n        }\n        string t_rev = t;\n        reverse(t_rev.begin(), t_rev.end());\n        if (len_t % 2 == 1) {\n            t += rnd.next('a', 'z');\n        }\n        t += t_rev;\n    } else if (type == \"random\") {\n        // Completely random s and t\n        s = generate_random_string(len_s);\n        t = generate_random_string(len_t);\n    } else if (type == \"repetitive\") {\n        // s and t consist of repeated characters\n        char c_s = rnd.next('a', 'z');\n        char c_t = rnd.next('a', 'z');\n        s = string(len_s, c_s);\n        t = string(len_t, c_t);\n    } else if (type == \"unique_chars\") {\n        // s and t consist of unique characters\n        len_s = min(len_s, 26);\n        len_t = min(len_t, 26);\n        vector<char> letters(26);\n        iota(letters.begin(), letters.end(), 'a');\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < len_s; ++i) {\n            s += letters[i];\n        }\n        shuffle(letters.begin(), letters.end());\n        t = \"\";\n        for (int i = 0; i < len_t; ++i) {\n            t += letters[i];\n        }\n    } else if (type == \"max\") {\n        // Max lengths\n        s = generate_random_string(2100);\n        t = generate_random_string(2100);\n    } else {\n        // Default to random\n        s = generate_random_string(len_s);\n        t = generate_random_string(len_t);\n    }\n    \n    // Ensure s and t are non-empty and length ≤2100\n    len_s = max(1, min((int)s.length(), 2100));\n    len_t = max(1, min((int)t.length(), 2100));\n    s = s.substr(0, len_s);\n    t = t.substr(0, len_t);\n    \n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len_s 1 -len_t 1 -type edge_case_min\n./gen -len_s 2100 -len_t 2100 -type edge_case_max\n./gen -len_s 10 -len_t 10 -type same\n./gen -len_s 15 -len_t 10 -type same\n./gen -len_s 50 -len_t 10 -type substring\n./gen -len_s 100 -len_t 100 -type substring\n./gen -len_s 100 -len_t 150 -type reverse_only\n./gen -len_s 200 -len_t 200 -type reverse_only\n./gen -len_s 100 -len_t 500 -type multiple_substrings\n./gen -len_s 200 -len_t 1000 -type multiple_substrings\n./gen -len_s 1000 -len_t 1500 -type impossible\n./gen -len_s 2000 -len_t 2100 -type impossible\n./gen -len_s 100 -len_t 500 -type repeated_s\n./gen -len_s 100 -len_t 2000 -type repeated_s\n./gen -len_s 100 -len_t 100 -type palindrome\n./gen -len_s 200 -len_t 200 -type palindrome\n./gen -len_s 2000 -len_t 2000 -type random\n./gen -len_s 2100 -len_t 2100 -type random\n./gen -len_s 26 -len_t 26 -type unique_chars\n./gen -len_s 20 -len_t 15 -type unique_chars\n./gen -len_s 500 -len_t 500 -type repetitive\n./gen -len_s 1000 -len_t 1000 -type repetitive\n./gen -len_s 2100 -len_t 2100 -type max\n./gen -len_s 1 -len_t 2100 -type multiple_substrings\n./gen -len_s 2100 -len_t 1 -type substring\n./gen -len_s 2100 -len_t 2100 -type reverse_only\n./gen -len_s 2100 -len_t 2100 -type same\n./gen -len_s 2100 -len_t 1000 -type substring\n./gen -len_s 2100 -len_t 2100 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:21.029117",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "615/D",
      "title": "D. Множители",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находится число m(1 ≤ m ≤ 200 000) — количество чисел в разложении числа n на простые множители.Во второй строке записаны m простых чисел pi (2 ≤ pi ≤ 200 000).",
      "output_spec": "Выходные данныеВыведите одно число — произведение всех делителей числа n, вычисленное по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать22 3Выходные данныеСкопировать36Входные данныеСкопировать32 3 2Выходные данныеСкопировать1728",
      "description": "D. Множители\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находится число m(1 ≤ m ≤ 200 000) — количество чисел в разложении числа n на простые множители.Во второй строке записаны m простых чисел pi (2 ≤ pi ≤ 200 000).\n\nВходные данные\n\nВыходные данныеВыведите одно число — произведение всех делителей числа n, вычисленное по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать22 3Выходные данныеСкопировать36Входные данныеСкопировать32 3 2Выходные данныеСкопировать1728\n\nВходные данныеСкопировать22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать36\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать32 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1728\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере n = 2·3 = 6. Делителями числа 6 являются 1, 2, 3 и 6, их произведение 1·2·3·6 = 36.Во втором примере 2·3·2 = 12. Делители числа 12 — 1, 2, 3, 4, 6 и 12. 1·2·3·4·6·12 = 1728.",
      "solutions": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "615A - Лампочки (Автор: TheWishmaster)Заведем для каждой лампочки счетчик – сколько кнопок ее выключает. Если для какой-то лампочки счетчик равен 0, то ответ нет, иначе да.Код: 15260902615B - Длиннохвостый еж (Автор: TheWishmaster)Посчитаем dp[i] – максимальная длина хвоста, заканчивающегося в i-ой вершине. Обновлять его просто – пройдем по всем ребрам из вершины и попытаемся увеличить текущее значение в концах ребер. Для ответа пройдемся по всем вершинам и выберем лучшую.Код: 15260851615C - Беговой трек (Автор: maxkvant)Заметим, что если мы можем мы можем получить подстроку t[i, j] используя k полотен, то мы можем получить и подстроку t[i + 1, j] не более чем из k полотен. Поэтому нам выгодно каждый раз брать как можно более длинную подстроку.Пусть n = |s|, m = |t|. На каждом этапе будем за искать эту самую длинную подстроку (lj – ее длина) в s и s_reversed, которую можем приписать к ответу.Это можно делать несколькими способами: Посчитаем lcp[i][j] — наибольший общий префикс t[i, m] и s[j, n], lcprev[i][j] — t[i, m] и s[j, 1]. Найти нужную подстроку означает найти max(max(lcp[i][1], lcp[i][2], ..., lcp[i][n]), max(lcprev[i][1], lcprev[i][2], ..., lcprev[i][n])). Подсчёт lcp: for (int i = m; i >= 1; i--)\n for (int j = n; j >= 1; j--) \n if (t[i] == s[j])\n lcp[i][j] = lcp[i + 1][j + 1] + 1;Код: 15277213 Заведём массив endPos, где значит endPos[j] — равна ли t[i, i + cur_len - 1] и s[j - cur_len + 1, j]. Будем пересчитывать значения этого массива, добавляя по одному символу t[i],  t[i + 1],  t[i + 2].... Аналогичный массив заведём для s_reversed. Суммарно решение отработает за Код: 15260867Решение бором: 15260870bonusможете ли вы решить задачу за , ? ?Σ — размер алфавита.615D - Множители (Автор: maxkvant)Обозначим d(x) — к-во делителей числа x, f(x) — произведение делителей числа. Пусть x = p1α1p2α2... pnαn, тогда d(x) = (α1 + 1)·(α2 + 1)... (αn + 1) . Есть пар делителитей вида , , и если x — точный квадрат добавляется ещё 1 делитель : .для простого m и a ≠ 0 верно Можно заметь, если a и b взаимно простые, то , Пользуясь этими свойствами нетрудно посчитать ответ: d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n d = d * (cnt[i] + 1) % (MOD - 1);\n} Код: 15260890bonusДругая задача.Дана последовательность (p1, k1),  (p2, k2), ...,  (pn, kn) (p_i — различные простые) и q запоросов (l, r) вычислить f(plkl·pl + 1kl + 1... prkr)%MOD.Как решать за ?615E - Шестиугольники (Автор: TheWishmaster)Посмотрим, как изменяется координаты при переходе из текущего 6-угольника в каждый из смежных ему(назовем это 6 типами переходов). Если мы знаем сколько переходов каждого типа мы сделали на пути, то знаем и координаты конца пути.Разделим весь путь на кольца:Посчитаем количество переходов через каждую из сторон шестиугольника для 1 кольца. В каждом следующем кольце будет на 1 переход каждого типа больше, чем в предыдущем кольце. Длина каждого кольца = длина предыдущего + 6. Это арифметическая прогрессия. С помощью формулы суммы первых членов арифметической прогрессии и бинпоиска найдем номер последнего кольца и длину всех колец до него. Осталось только перебрать 6 типов последнего сделанного перехода и посчитать ответ.Код: 15260879",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22658",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 615\\s*D"
          },
          "content_length": 3265
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++){\n    ll p; cin >> p;\n    prime[p]++; //cocunt the number of prime 'p'\n}\nfor (int i = 0; i <= 200000; i++){\n    total *= (prime[i] + 1); //calculate the whole possible combination\n    total %= mod;\n}\nfor (ll i = 1; i <= 200000; i++){\n    if (prime[i] != 0){\n       // a/b (% p) = a * b^(p-2) % p\n        ll val = i;\n        ll pw = power(prime[i] + 1, (mod - 2)); //pw is b^(p-2)\n       ll comb = (total * pw) % mod;\n        for (ll c = 1; c <= prime[i]; c++){\n            ll next = power(val, comb); \n            ans = (ans * next) % mod;\n            val *= i;\n            val %= mod;\n        }\n    }\n}\ncout << ans;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXP = 200000;\n\nbool is_prime[MAXP + 1];\n\nvoid sieve() {\n    fill(is_prime, is_prime + MAXP + 1, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i <= MAXP; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAXP; j += i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    sieve();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 2, 200000, \"p_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(is_prime[p[i]], \"p_i[%d]=%d is not a prime number\", i+1, p[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXP = 200000;\n\nbool is_prime[MAXP + 1];\n\nvoid sieve() {\n    fill(is_prime, is_prime + MAXP + 1, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i <= MAXP; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAXP; j += i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    sieve();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 2, 200000, \"p_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(is_prime[p[i]], \"p_i[%d]=%d is not a prime number\", i+1, p[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXP = 200000;\n\nbool is_prime[MAXP + 1];\n\nvoid sieve() {\n    fill(is_prime, is_prime + MAXP + 1, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i <= MAXP; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAXP; j += i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    sieve();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(m, 2, 200000, \"p_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(is_prime[p[i]], \"p_i[%d]=%d is not a prime number\", i+1, p[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_PRIME = 200000;\n\nvector<int> primes;\n\nvoid generate_primes(int max_p) {\n    vector<bool> is_prime(max_p + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= max_p; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            if ((long long)i * i <= max_p) {\n                for (int j = i * i; j <= max_p; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");  // number of primes\n    int max_p = opt<int>(\"max_p\", 200000);  // maximum value of primes p_i\n    string type = opt<string>(\"type\", \"random\");\n\n    generate_primes(max_p);\n\n    vector<int> p(m);\n\n    if (type == \"same\") {\n        // All p_i are the same prime\n        int p_i;\n        if (max_p < 2) max_p = 2;\n        p_i = primes[rnd.next(primes.size())]; // pick a random prime\n        for (int i = 0; i < m; ++i) {\n            p[i] = p_i;\n        }\n    } else if (type == \"random\") {\n        // p_i are random primes between 2 and max_p\n        for (int i = 0; i < m; ++i) {\n            p[i] = primes[rnd.next(primes.size())];\n        }\n    } else if (type == \"smallprimes\") {\n        // p_i are random small primes between 2 and 100\n        vector<int> small_primes;\n        for (int i = 0; i < primes.size() && primes[i] <= 100; ++i) {\n            small_primes.push_back(primes[i]);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = small_primes[rnd.next(small_primes.size())];\n        }\n    } else if (type == \"largeprimes\") {\n        // p_i are random large primes close to max_p\n        vector<int> large_primes;\n        for (int i = primes.size() - 1; i >= 0 && primes[i] >= max_p - 1000; --i) {\n            large_primes.push_back(primes[i]);\n        }\n        if (large_primes.empty()) large_primes.push_back(primes.back());\n        for (int i = 0; i < m; ++i) {\n            p[i] = large_primes[rnd.next(large_primes.size())];\n        }\n    } else if (type == \"sequence\") {\n        // p_i are the first m primes starting from 2\n        for (int i = 0; i < m; ++i) {\n            p[i] = primes[i % primes.size()];\n        }\n    } else if (type == \"twos\") {\n        // All p_i are 2\n        for (int i = 0; i < m; ++i) {\n            p[i] = 2;\n        }\n    } else {\n        // default: random\n        for (int i = 0; i < m; ++i) {\n            p[i] = primes[rnd.next(primes.size())];\n        }\n    }\n\n    // output\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_PRIME = 200000;\n\nvector<int> primes;\n\nvoid generate_primes(int max_p) {\n    vector<bool> is_prime(max_p + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= max_p; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            if ((long long)i * i <= max_p) {\n                for (int j = i * i; j <= max_p; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");  // number of primes\n    int max_p = opt<int>(\"max_p\", 200000);  // maximum value of primes p_i\n    string type = opt<string>(\"type\", \"random\");\n\n    generate_primes(max_p);\n\n    vector<int> p(m);\n\n    if (type == \"same\") {\n        // All p_i are the same prime\n        int p_i;\n        if (max_p < 2) max_p = 2;\n        p_i = primes[rnd.next(primes.size())]; // pick a random prime\n        for (int i = 0; i < m; ++i) {\n            p[i] = p_i;\n        }\n    } else if (type == \"random\") {\n        // p_i are random primes between 2 and max_p\n        for (int i = 0; i < m; ++i) {\n            p[i] = primes[rnd.next(primes.size())];\n        }\n    } else if (type == \"smallprimes\") {\n        // p_i are random small primes between 2 and 100\n        vector<int> small_primes;\n        for (int i = 0; i < primes.size() && primes[i] <= 100; ++i) {\n            small_primes.push_back(primes[i]);\n        }\n        for (int i = 0; i < m; ++i) {\n            p[i] = small_primes[rnd.next(small_primes.size())];\n        }\n    } else if (type == \"largeprimes\") {\n        // p_i are random large primes close to max_p\n        vector<int> large_primes;\n        for (int i = primes.size() - 1; i >= 0 && primes[i] >= max_p - 1000; --i) {\n            large_primes.push_back(primes[i]);\n        }\n        if (large_primes.empty()) large_primes.push_back(primes.back());\n        for (int i = 0; i < m; ++i) {\n            p[i] = large_primes[rnd.next(large_primes.size())];\n        }\n    } else if (type == \"sequence\") {\n        // p_i are the first m primes starting from 2\n        for (int i = 0; i < m; ++i) {\n            p[i] = primes[i % primes.size()];\n        }\n    } else if (type == \"twos\") {\n        // All p_i are 2\n        for (int i = 0; i < m; ++i) {\n            p[i] = 2;\n        }\n    } else {\n        // default: random\n        for (int i = 0; i < m; ++i) {\n            p[i] = primes[rnd.next(primes.size())];\n        }\n    }\n\n    // output\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small m, small primes\n./gen -m 1 -type twos\n./gen -m 1 -type same\n./gen -m 1 -max_p 10 -type smallprimes\n\n# Medium m, small primes\n./gen -m 10 -type smallprimes\n./gen -m 100 -type smallprimes\n\n# Large m, small primes\n./gen -m 200000 -type smallprimes\n\n# Small m, large primes\n./gen -m 1 -type largeprimes\n./gen -m 10 -max_p 200000 -type largeprimes\n./gen -m 100 -max_p 200000 -type largeprimes\n\n# Large m, large primes\n./gen -m 200000 -type largeprimes\n\n# Random primes\n./gen -m 10 -max_p 1000 -type random\n./gen -m 1000 -max_p 1000 -type random\n./gen -m 10000 -max_p 200000 -type random\n./gen -m 100000 -max_p 200000 -type random\n./gen -m 200000 -max_p 200000 -type random\n\n# All same primes, to test big exponents\n./gen -m 200000 -type same\n\n# All twos\n./gen -m 200000 -type twos\n\n# Sequence of primes\n./gen -m 1000 -type sequence\n./gen -m 50000 -type sequence\n./gen -m 200000 -type sequence\n\n# Mixed types\n./gen -m 100000 -type twos\n./gen -m 100000 -max_p 10000 -type smallprimes\n./gen -m 100000 -max_p 200000 -type largeprimes\n./gen -m 100000 -type random\n\n# Edge cases\n./gen -m 200000 -max_p 2 -type twos  # m=200000, all p_i=2\n./gen -m 200000 -max_p 2 -type same  # same as above\n./gen -m 200000 -max_p 2 -type random  # all p_i=2\n\n# Very small m\n./gen -m 2 -type smallprimes\n./gen -m 2 -type largeprimes\n./gen -m 2 -max_p 200000 -type random\n\n# Unusual max_p\n./gen -m 1000 -max_p 100 -type random\n./gen -m 50000 -max_p 100 -type smallprimes\n./gen -m 100000 -max_p 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:22.961153",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "615/E",
      "title": "E. Шестиугольники",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВо входных данных записано единственное целое число n (0 ≤ n ≤ 1018) — число ходов, сделанных Айратом.",
      "output_spec": "Выходные данныеВыведите два целых числа x и y — координаты Айрата через n ходов.",
      "sample_tests": "ПримерыВходные данныеСкопировать3Выходные данныеСкопировать-2 0Входные данныеСкопировать7Выходные данныеСкопировать3 2",
      "description": "E. Шестиугольники\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВо входных данных записано единственное целое число n (0 ≤ n ≤ 1018) — число ходов, сделанных Айратом.\n\nВходные данные\n\nВыходные данныеВыведите два целых числа x и y — координаты Айрата через n ходов.\n\nВыходные данные\n\nВходные данныеСкопировать3Выходные данныеСкопировать-2 0Входные данныеСкопировать7Выходные данныеСкопировать3 2\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-2 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "Всем привет! Уже завтра состоится Codeforces Round #338 (Div. 2). Обратите внимание на необычное время проведения контеста! Раунд для вас готовили Максим Винниченко (maxkvant) и я, Александр Зойкин. Это наш первый раунд, очень надеемся, что все пройдет хорошо. Огромное спасибо GlebsHP за неоценимую помощь в подготовке контеста, Bobrosoft за тестирование и не только, Delinur за перевод условий на английский язык и, разумеется, MikeMirzayanov за системы Codeforces и Polygon. разбалловка 500 — 1250 — 1750 — 2000 — 2500Всем удачи на контесте!upd Поздравляем победителей!div 2:zhangzj_is_our_sunmarcoreziehoClarisucfptTomer.Adardiv 1:I_love_Tanya_Romanovangfam_kongusd0061--Pavel--ershov.stanislavРазбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22619?locale=ru",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 704
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces",
          "content": "615A - Лампочки (Автор: TheWishmaster)Заведем для каждой лампочки счетчик – сколько кнопок ее выключает. Если для какой-то лампочки счетчик равен 0, то ответ нет, иначе да.Код: 15260902615B - Длиннохвостый еж (Автор: TheWishmaster)Посчитаем dp[i] – максимальная длина хвоста, заканчивающегося в i-ой вершине. Обновлять его просто – пройдем по всем ребрам из вершины и попытаемся увеличить текущее значение в концах ребер. Для ответа пройдемся по всем вершинам и выберем лучшую.Код: 15260851615C - Беговой трек (Автор: maxkvant)Заметим, что если мы можем мы можем получить подстроку t[i, j] используя k полотен, то мы можем получить и подстроку t[i + 1, j] не более чем из k полотен. Поэтому нам выгодно каждый раз брать как можно более длинную подстроку.Пусть n = |s|, m = |t|. На каждом этапе будем за искать эту самую длинную подстроку (lj – ее длина) в s и s_reversed, которую можем приписать к ответу.Это можно делать несколькими способами: Посчитаем lcp[i][j] — наибольший общий префикс t[i, m] и s[j, n], lcprev[i][j] — t[i, m] и s[j, 1]. Найти нужную подстроку означает найти max(max(lcp[i][1], lcp[i][2], ..., lcp[i][n]), max(lcprev[i][1], lcprev[i][2], ..., lcprev[i][n])). Подсчёт lcp: for (int i = m; i >= 1; i--)\n for (int j = n; j >= 1; j--) \n if (t[i] == s[j])\n lcp[i][j] = lcp[i + 1][j + 1] + 1;Код: 15277213 Заведём массив endPos, где значит endPos[j] — равна ли t[i, i + cur_len - 1] и s[j - cur_len + 1, j]. Будем пересчитывать значения этого массива, добавляя по одному символу t[i],  t[i + 1],  t[i + 2].... Аналогичный массив заведём для s_reversed. Суммарно решение отработает за Код: 15260867Решение бором: 15260870bonusможете ли вы решить задачу за , ? ?Σ — размер алфавита.615D - Множители (Автор: maxkvant)Обозначим d(x) — к-во делителей числа x, f(x) — произведение делителей числа. Пусть x = p1α1p2α2... pnαn, тогда d(x) = (α1 + 1)·(α2 + 1)... (αn + 1) . Есть пар делителитей вида , , и если x — точный квадрат добавляется ещё 1 делитель : .для простого m и a ≠ 0 верно Можно заметь, если a и b взаимно простые, то , Пользуясь этими свойствами нетрудно посчитать ответ: d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n d = d * (cnt[i] + 1) % (MOD - 1);\n} Код: 15260890bonusДругая задача.Дана последовательность (p1, k1),  (p2, k2), ...,  (pn, kn) (p_i — различные простые) и q запоросов (l, r) вычислить f(plkl·pl + 1kl + 1... prkr)%MOD.Как решать за ?615E - Шестиугольники (Автор: TheWishmaster)Посмотрим, как изменяется координаты при переходе из текущего 6-угольника в каждый из смежных ему(назовем это 6 типами переходов). Если мы знаем сколько переходов каждого типа мы сделали на пути, то знаем и координаты конца пути.Разделим весь путь на кольца:Посчитаем количество переходов через каждую из сторон шестиугольника для 1 кольца. В каждом следующем кольце будет на 1 переход каждого типа больше, чем в предыдущем кольце. Длина каждого кольца = длина предыдущего + 6. Это арифметическая прогрессия. С помощью формулы суммы первых членов арифметической прогрессии и бинпоиска найдем номер последнего кольца и длину всех колец до него. Осталось только перебрать 6 типов последнего сделанного перехода и посчитать ответ.Код: 15260879",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22658",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 615\\s*E"
          },
          "content_length": 3265
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "10 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "p(n) = n ^ (d(n) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "1LL * x * x * a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "1LL * x * x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "количество делителей минус один",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "количество делителей % Phi(MOD) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "(количество делителей % Phi(MOD) / 2 + Phi(MOD) / 2) % Phi(MOD)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  for(int i = 0; i < 2100; i++) printf(\"%c\", rand() % 2 + 'a'); printf(\"\\n\");\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 11",
          "code": "powi(LL a, LL b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 12",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 13",
          "code": "for(map<ll int,ll int>::iterator it=m.begin();it!=m.end();it++)\n        divisors *= (it->second + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 14",
          "code": "The tail should be continuous, i.e. consists of some sequence of points,",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 15",
          "code": "such that EVERY TWO neighbouring points are connected by a colored segment;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #338 (Div. 2) - Codeforces - Code 16",
          "code": "x = multi( x , z / 2 );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22619?locale=ru",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 1",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = m; i >= 1; i--)\n     for (int j = n; j >= 1; j--) \n          if (t[i] == s[j])\n              lcp[i][j] = lcp[i + 1][j + 1] + 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 3",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 4",
          "code": "d = 1;\nans = 1;\nfor (int i = 0; i < l; i++) {\n    fp = binPow(p[i], (cnt[i] + 1) * cnt[i] / 2);\n    ans = binPow(ans, (cnt[i] + 1)) * binPow(fp, d) % MOD;\n    d = d * (cnt[i] + 1) % (MOD - 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 5",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 6",
          "code": "lmul[0]=1;\n\trmul[n+1]=1;\n\tfor(int i=1;i<=n;i++)lmul[i]=lmul[i-1]*(cnt[i]+1)%(mod-1);\n\tfor(int i=n;i>=1;i--)rmul[i]=rmul[i+1]*(cnt[i]+1)%(mod-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 7",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 8",
          "code": "lmul[i-1]*rmul[i+1]%(mod-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #338 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < n; i++){\n    ll p; cin >> p;\n    prime[p]++; //cocunt the number of prime 'p'\n}\nfor (int i = 0; i <= 200000; i++){\n    total *= (prime[i] + 1); //calculate the whole possible combination\n    total %= mod;\n}\nfor (ll i = 1; i <= 200000; i++){\n    if (prime[i] != 0){\n       // a/b (% p) = a * b^(p-2) % p\n        ll val = i;\n        ll pw = power(prime[i] + 1, (mod - 2)); //pw is b^(p-2)\n       ll comb = (total * pw) % mod;\n        for (ll c = 1; c <= prime[i]; c++){\n            ll next = power(val, comb); \n            ans = (ans * next) % mod;\n            val *= i;\n            val %= mod;\n        }\n    }\n}\ncout << ans;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22658",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll n = 0;\n\n    if (type == \"random\") {\n        n = rnd.next(0LL, 1000000000000000000LL);\n    }\n    else if (type == \"max\") {\n        n = 1000000000000000000LL;\n    }\n    else if (type == \"min\") {\n        n = 0;\n    }\n    else if (type == \"layer\") {\n        ll k = opt<ll>(\"k\", rnd.next(0LL, 1000000000LL));\n        n = 1 + 3LL * k * (k + 1);\n    }\n    else if (type == \"before_layer\") {\n        ll k = opt<ll>(\"k\", rnd.next(1LL, 1000000000LL));\n        n = 1 + 3LL * k * (k + 1) - 1;\n    }\n    else if (type == \"after_layer\") {\n        ll k = opt<ll>(\"k\", rnd.next(0LL, 1000000000LL));\n        n = 1 + 3LL * k * (k + 1) + 1;\n    }\n    else if (type == \"large_random\") {\n        n = rnd.next(100000000000000000LL, 1000000000000000000LL);\n    }\n    else if (type == \"specific\") {\n        n = opt<ll>(\"n\", 0LL);\n    }\n    else {\n        n = 0;\n    }\n\n    // Ensure n is within 0 ≤ n ≤ 1e18\n    n = max(0LL, min(n, 1000000000000000000LL));\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll n = 0;\n\n    if (type == \"random\") {\n        n = rnd.next(0LL, 1000000000000000000LL);\n    }\n    else if (type == \"max\") {\n        n = 1000000000000000000LL;\n    }\n    else if (type == \"min\") {\n        n = 0;\n    }\n    else if (type == \"layer\") {\n        ll k = opt<ll>(\"k\", rnd.next(0LL, 1000000000LL));\n        n = 1 + 3LL * k * (k + 1);\n    }\n    else if (type == \"before_layer\") {\n        ll k = opt<ll>(\"k\", rnd.next(1LL, 1000000000LL));\n        n = 1 + 3LL * k * (k + 1) - 1;\n    }\n    else if (type == \"after_layer\") {\n        ll k = opt<ll>(\"k\", rnd.next(0LL, 1000000000LL));\n        n = 1 + 3LL * k * (k + 1) + 1;\n    }\n    else if (type == \"large_random\") {\n        n = rnd.next(100000000000000000LL, 1000000000000000000LL);\n    }\n    else if (type == \"specific\") {\n        n = opt<ll>(\"n\", 0LL);\n    }\n    else {\n        n = 0;\n    }\n\n    // Ensure n is within 0 ≤ n ≤ 1e18\n    n = max(0LL, min(n, 1000000000000000000LL));\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type large_random\n./gen -type large_random\n./gen -type large_random\n\n./gen -type layer -k 0\n./gen -type layer -k 1\n./gen -type layer -k 2\n./gen -type layer -k 10\n./gen -type layer -k 100\n./gen -type layer -k 1000\n./gen -type layer -k 1000000\n./gen -type layer -k 100000000\n\n./gen -type before_layer -k 1\n./gen -type before_layer -k 2\n./gen -type before_layer -k 10\n./gen -type before_layer -k 100\n./gen -type before_layer -k 1000\n./gen -type before_layer -k 1000000\n\n./gen -type after_layer -k 0\n./gen -type after_layer -k 1\n./gen -type after_layer -k 2\n./gen -type after_layer -k 10\n./gen -type after_layer -k 100\n./gen -type after_layer -k 1000\n./gen -type after_layer -k 1000000\n\n./gen -type specific -n 0\n./gen -type specific -n 1\n./gen -type specific -n 6\n./gen -type specific -n 7\n./gen -type specific -n 8\n./gen -type specific -n 999999999999999998\n./gen -type specific -n 999999999999999999\n./gen -type specific -n 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:25.323080",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "616/A",
      "title": "A. Comparing Two Long Integers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-negative integer a.The second line contains a non-negative integer b.The numbers a, b may contain leading zeroes. Each of them contains no more than 106 digits.",
      "output_spec": "OutputPrint the symbol \"<\" if a < b and the symbol \">\" if a > b. If the numbers are equal print the symbol \"=\".",
      "sample_tests": "ExamplesInputCopy910OutputCopy<InputCopy1110OutputCopy>InputCopy0001234512345OutputCopy=InputCopy01239OutputCopy>InputCopy0123111OutputCopy>",
      "description": "A. Comparing Two Long Integers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a non-negative integer a.The second line contains a non-negative integer b.The numbers a, b may contain leading zeroes. Each of them contains no more than 106 digits.\n\nOutputPrint the symbol \"<\" if a < b and the symbol \">\" if a > b. If the numbers are equal print the symbol \"=\".\n\nInputCopy910OutputCopy<InputCopy1110OutputCopy>InputCopy0001234512345OutputCopy=InputCopy01239OutputCopy>InputCopy0123111OutputCopy>\n\nInputCopy910\n\nOutputCopy<\n\nInputCopy1110\n\nOutputCopy>\n\nInputCopy0001234512345\n\nOutputCopy=\n\nInputCopy01239\n\nOutputCopy>\n\nInputCopy0123111\n\nOutputCopy>",
      "solutions": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces",
          "content": "Hi, Codeforces!Happy New Year! Holidays and 2015 year have passed and year 2016 is ahead. I wish you good luck in programming competitions and achieving all of your goals this year.Educational Codeforces Round 5 will take place on 11 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<A year has passed, but paragraph remains unchanged.>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</A year has passed, but paragraph remains unchanged.>Thanks a lot to Grigory Reznikow vintage_Vlad_Makeev who prepared a good problem (the problem F in ER 5). You can send to me some ideas of problems or maybe already prepared problems that you can't use in rounds or official competitions.As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements.I think the problems is not difficult (except maybe for problem F). I hope you will enjoy the problems and solve all of them!Good luck and have fun!UPD 1: Coding phase is finished. You can hack other solutions for 24 hours.UPD 2: The editorial is ready.UPD 3: During the phase of hacks we found the following: the same solutions on Python2 and Python3 works differently on different large tests. For example, some of Python3 solutions works very slow on tests with only zeros, but Python2 works very slow on tests with nines. Some of solutions works in around one second so we decided to increase the time limit for the problem A to 2 seconds. All the solutions will be rejudged soon on the complete testset.UPD 4: The round is over. All solutions will be rejudged soon on the complete testset (includes the hacks).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22691",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1973
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces",
          "content": "616A - Comparing Two Long IntegersNote that solutions in Java with BigInteger class or input() function in Python2 will fail in this problem. The reason is the next: standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system. Actually they are working in O(n2), where n is the legth of the number.To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length. After that you should simply compare them alphabetically.С++ solutionPython solutionComplexity: O(n).616B - Dinner with EmmaFirstly you should find the minimum value in each row and after that you should find the maximum value over that minimums. It's corresponding to the strategy of Jack and Emma.C++ solutionComplexity: O(nm).616C - The LabyrinthLet's enumerate all the connected components, store their sizes and for each empty cell store the number of it's component. It can be done with a single dfs. Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components. Adjacent means the components of cells adjacent to the current impassable cell (in general case each unpassable cell has four adjacent cells).C++ solutionComplexity: O(nm).616D - Longest k-Good SegmentThis problem is given because on the Codeforces pages we often see questions like \"What is the method of the two pointers?\". This problem is a typical problem that can be solved using two pointers technique.Let's find for each left end l the maximal right end r that (l, r) is a k-good segment. Note if (l, r) is a k-good segment then (l + 1, r) is also a k-good segment. So the search of the maximal right end for l + 1 we can start from the maximal right end for l. The only thing that we should do is to maintain in the array cntx for each number x the number of it's occurrences in the current segment (l, r) and the number of different numbers in (l, r). We should move the right end until the segment became bad and then move the left end. Each of the ends l, r will be moved exactly n times.C++ solutionComplexity: O(n).616E - Sum of RemaindersUnfortunately my solution for this problem had overflow bug. It was fixed on contest. Even so I hope you enjoyed the problem because I think it's very interesting.Let's transform the sum . Note that the last sum can be accumulated to only value min(n, m), because for i > n all the values will be equal to 0.Note in the last sum either or . Let's carefully accumulate both cases. The first sum can be simply calculated by iterating over all . We will accumulate the second sum independently for all different values . Firstly we should determine for which values i we will have the value . Easy to see that for the values i from the interval . Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time — it's simply a sum of arithmetic progression . So we have solution with complexity .С++ solutionComplexity: .616F - Expensive StringsThis problem was prepared by Grigory Reznikow vintage_Vlad_Makeev. His solution uses suffix array.This problem is a typical problem for some suffix data structure. Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree. My own solution used suffix tree so I'll describe solution with tree (I think it's simple except of the building of the tree).Let's build the new string by concatenation of all strings from input separating them by different separators. The number of separators is O(n) so the alphabet is also O(n). So we should use map<int, int> to store the tree and the complexity is increased by O(logn). Let's build the suffix tree for the new string. Let's match all the separators to the strings from the left of the separator. Let's run dfs on the suffix tree that doesn't move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex. Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex.С++ solutionComplexity: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 616\\s*A"
          },
          "content_length": 4246
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "The First Holy Round For Hackers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "n(n+1) * (mod+1)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[0-9]+\", \"a\");\n    ensuref(a.size() <= 1000000, \"Length of a is %d, but should be at most 1000000\", (int)a.size());\n\n    string b = inf.readLine(\"[0-9]+\", \"b\");\n    ensuref(b.size() <= 1000000, \"Length of b is %d, but should be at most 1000000\", (int)b.size());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[0-9]+\", \"a\");\n    ensuref(a.size() <= 1000000, \"Length of a is %d, but should be at most 1000000\", (int)a.size());\n\n    string b = inf.readLine(\"[0-9]+\", \"b\");\n    ensuref(b.size() <= 1000000, \"Length of b is %d, but should be at most 1000000\", (int)b.size());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[0-9]+\", \"a\");\n    ensuref(a.size() <= 1000000, \"Length of a is %d, but should be at most 1000000\", (int)a.size());\n\n    string b = inf.readLine(\"[0-9]+\", \"b\");\n    ensuref(b.size() <= 1000000, \"Length of b is %d, but should be at most 1000000\", (int)b.size());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Decide lengths\n        int len_total_a = rnd.next(1, n);\n        int len_total_b = rnd.next(1, n);\n        \n        // Decide number of leading zeros\n        int lz_a = rnd.next(0, len_total_a);\n        int lz_b = rnd.next(0, len_total_b);\n        \n        // Number of significant digits\n        int sig_a = len_total_a - lz_a;\n        int sig_b = len_total_b - lz_b;\n        \n        string a = string(lz_a, '0');\n        string b = string(lz_b, '0');\n        \n        // Generate significant digits\n        if (sig_a > 0) {\n            for (int i = 0; i < sig_a; ++i) {\n                char c = '0' + rnd.next(0, 9);\n                a += c;\n            }\n        } else {\n            a += '0'; // number is zero\n        }\n        \n        if (sig_b > 0) {\n            for (int i = 0; i < sig_b; ++i) {\n                char c = '0' + rnd.next(0, 9);\n                b += c;\n            }\n        } else {\n            b += '0'; // number is zero\n        }\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"equal\") {\n        // Decide on sig_len\n        int sig_len = rnd.next(0, n);\n        // Generate sig\n        string sig = \"\";\n        for (int i = 0; i < sig_len; ++i) {\n            sig += '0' + rnd.next(0, 9);\n        }\n        // Handle zero case\n        if (sig_len == 0) sig = \"0\";\n        \n        // Max leading zeros we can have in a and b\n        int max_lz = n - sig_len;\n        int lz_a = rnd.next(0, max_lz);\n        int lz_b = rnd.next(0, max_lz);\n        \n        string a = string(lz_a, '0') + sig;\n        string b = string(lz_b, '0') + sig;\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"leading_zeros\") {\n        // Decide lengths\n        int len_total_a = rnd.next(1, n);\n        int len_total_b = rnd.next(1, n);\n        \n        // Decide number of leading zeros (at least 1)\n        int lz_a = rnd.next(1, len_total_a);\n        int lz_b = rnd.next(1, len_total_b);\n        \n        int sig_a = len_total_a - lz_a;\n        int sig_b = len_total_b - lz_b;\n        \n        string a = string(lz_a, '0');\n        string b = string(lz_b, '0');\n        \n        // Generate significant digits\n        if (sig_a > 0) {\n            a += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < sig_a; ++i) {\n                a += '0' + rnd.next(0, 9);\n            }\n        } else {\n            a += '0'; // number is zero\n        }\n        \n        if (sig_b > 0) {\n            b += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < sig_b; ++i) {\n                b += '0' + rnd.next(0, 9);\n            }\n        } else {\n            b += '0'; // number is zero\n        }\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"zeros\") {\n        // Decide lengths (at least 1)\n        int len_total_a = rnd.next(1, n);\n        int len_total_b = rnd.next(1, n);\n        \n        // The number is zero, so all digits are zeros\n        string a = string(len_total_a, '0');\n        string b = string(len_total_b, '0');\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"max_length\") {\n        int len_total_a = n;\n        int len_total_b = n;\n        \n        // Decide number of leading zeros\n        int lz_a = rnd.next(0, len_total_a);\n        int lz_b = rnd.next(0, len_total_b);\n        \n        int sig_a = len_total_a - lz_a;\n        int sig_b = len_total_b - lz_b;\n        \n        string a = string(lz_a, '0');\n        string b = string(lz_b, '0');\n        \n        // Generate significant digits\n        if (sig_a > 0) {\n            a += '1' + rnd.next(0,8);\n            for (int i = 1; i < sig_a; ++i) {\n                a += '0' + rnd.next(0, 9);\n            }\n        } else {\n            a += '0';\n        }\n        \n        if (sig_b > 0) {\n            b += '1' + rnd.next(0,8);\n            for (int i = 1; i < sig_b; ++i) {\n                b += '0' + rnd.next(0, 9);\n            }\n        } else {\n            b += '0';\n        }\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"identical_strings\") {\n        int len_total = rnd.next(1, n);\n        \n        string s = \"\";\n        for (int i = 0; i < len_total; ++i) {\n            s += '0' + rnd.next(0, 9);\n        }\n        \n        cout << s << '\\n';\n        cout << s << '\\n';\n    } else if (type == \"a_greater\") {\n        // Decide len_a >= len_b\n        int len_a = rnd.next(1, n);\n        int len_b = rnd.next(1, len_a);\n        \n        if (len_a == len_b) {\n            // Generate numbers of same length where a > b\n            string a = \"\", b = \"\";\n            bool a_greater = false;\n            for (int i = 0; i < len_a; ++i) {\n                int digit_b = rnd.next(0, 9);\n                int digit_a = a_greater ? rnd.next(0, 9) : rnd.next(digit_b + 1, 9);\n                a += '0' + digit_a;\n                b += '0' + digit_b;\n                if (digit_a > digit_b) {\n                    a_greater = true;\n                }\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        } else {\n            // len_a > len_b, so a > b\n            string a = \"\";\n            a += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < len_a; ++i) {\n                a += '0' + rnd.next(0, 9);\n            }\n            string b = \"\";\n            if (len_b > 0) {\n                b += '1' + rnd.next(0, 8);\n                for (int i = 1; i < len_b; ++i) {\n                    b += '0' + rnd.next(0, 9);\n                }\n            } else {\n                b = \"0\";\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        }\n    } else if (type == \"b_greater\") {\n        // Similar to \"a_greater\", but swap a and b\n        // Decide len_b >= len_a\n        int len_b = rnd.next(1, n);\n        int len_a = rnd.next(1, len_b);\n        \n        if (len_b == len_a) {\n            // Generate numbers of same length where b > a\n            string a = \"\", b = \"\";\n            bool b_greater = false;\n            for (int i = 0; i < len_a; ++i) {\n                int digit_a = rnd.next(0, 9);\n                int digit_b = b_greater ? rnd.next(0, 9) : rnd.next(digit_a + 1, 9);\n                a += '0' + digit_a;\n                b += '0' + digit_b;\n                if (digit_b > digit_a) {\n                    b_greater = true;\n                }\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        } else {\n            // len_b > len_a, so b > a\n            string b = \"\";\n            b += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < len_b; ++i) {\n                b += '0' + rnd.next(0, 9);\n            }\n            string a = \"\";\n            if (len_a > 0) {\n                a += '1' + rnd.next(0, 8);\n                for (int i = 1; i < len_a; ++i) {\n                    a += '0' + rnd.next(0, 9);\n                }\n            } else {\n                a = \"0\";\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Decide lengths\n        int len_total_a = rnd.next(1, n);\n        int len_total_b = rnd.next(1, n);\n        \n        // Decide number of leading zeros\n        int lz_a = rnd.next(0, len_total_a);\n        int lz_b = rnd.next(0, len_total_b);\n        \n        // Number of significant digits\n        int sig_a = len_total_a - lz_a;\n        int sig_b = len_total_b - lz_b;\n        \n        string a = string(lz_a, '0');\n        string b = string(lz_b, '0');\n        \n        // Generate significant digits\n        if (sig_a > 0) {\n            for (int i = 0; i < sig_a; ++i) {\n                char c = '0' + rnd.next(0, 9);\n                a += c;\n            }\n        } else {\n            a += '0'; // number is zero\n        }\n        \n        if (sig_b > 0) {\n            for (int i = 0; i < sig_b; ++i) {\n                char c = '0' + rnd.next(0, 9);\n                b += c;\n            }\n        } else {\n            b += '0'; // number is zero\n        }\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"equal\") {\n        // Decide on sig_len\n        int sig_len = rnd.next(0, n);\n        // Generate sig\n        string sig = \"\";\n        for (int i = 0; i < sig_len; ++i) {\n            sig += '0' + rnd.next(0, 9);\n        }\n        // Handle zero case\n        if (sig_len == 0) sig = \"0\";\n        \n        // Max leading zeros we can have in a and b\n        int max_lz = n - sig_len;\n        int lz_a = rnd.next(0, max_lz);\n        int lz_b = rnd.next(0, max_lz);\n        \n        string a = string(lz_a, '0') + sig;\n        string b = string(lz_b, '0') + sig;\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"leading_zeros\") {\n        // Decide lengths\n        int len_total_a = rnd.next(1, n);\n        int len_total_b = rnd.next(1, n);\n        \n        // Decide number of leading zeros (at least 1)\n        int lz_a = rnd.next(1, len_total_a);\n        int lz_b = rnd.next(1, len_total_b);\n        \n        int sig_a = len_total_a - lz_a;\n        int sig_b = len_total_b - lz_b;\n        \n        string a = string(lz_a, '0');\n        string b = string(lz_b, '0');\n        \n        // Generate significant digits\n        if (sig_a > 0) {\n            a += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < sig_a; ++i) {\n                a += '0' + rnd.next(0, 9);\n            }\n        } else {\n            a += '0'; // number is zero\n        }\n        \n        if (sig_b > 0) {\n            b += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < sig_b; ++i) {\n                b += '0' + rnd.next(0, 9);\n            }\n        } else {\n            b += '0'; // number is zero\n        }\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"zeros\") {\n        // Decide lengths (at least 1)\n        int len_total_a = rnd.next(1, n);\n        int len_total_b = rnd.next(1, n);\n        \n        // The number is zero, so all digits are zeros\n        string a = string(len_total_a, '0');\n        string b = string(len_total_b, '0');\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"max_length\") {\n        int len_total_a = n;\n        int len_total_b = n;\n        \n        // Decide number of leading zeros\n        int lz_a = rnd.next(0, len_total_a);\n        int lz_b = rnd.next(0, len_total_b);\n        \n        int sig_a = len_total_a - lz_a;\n        int sig_b = len_total_b - lz_b;\n        \n        string a = string(lz_a, '0');\n        string b = string(lz_b, '0');\n        \n        // Generate significant digits\n        if (sig_a > 0) {\n            a += '1' + rnd.next(0,8);\n            for (int i = 1; i < sig_a; ++i) {\n                a += '0' + rnd.next(0, 9);\n            }\n        } else {\n            a += '0';\n        }\n        \n        if (sig_b > 0) {\n            b += '1' + rnd.next(0,8);\n            for (int i = 1; i < sig_b; ++i) {\n                b += '0' + rnd.next(0, 9);\n            }\n        } else {\n            b += '0';\n        }\n        \n        cout << a << '\\n';\n        cout << b << '\\n';\n    } else if (type == \"identical_strings\") {\n        int len_total = rnd.next(1, n);\n        \n        string s = \"\";\n        for (int i = 0; i < len_total; ++i) {\n            s += '0' + rnd.next(0, 9);\n        }\n        \n        cout << s << '\\n';\n        cout << s << '\\n';\n    } else if (type == \"a_greater\") {\n        // Decide len_a >= len_b\n        int len_a = rnd.next(1, n);\n        int len_b = rnd.next(1, len_a);\n        \n        if (len_a == len_b) {\n            // Generate numbers of same length where a > b\n            string a = \"\", b = \"\";\n            bool a_greater = false;\n            for (int i = 0; i < len_a; ++i) {\n                int digit_b = rnd.next(0, 9);\n                int digit_a = a_greater ? rnd.next(0, 9) : rnd.next(digit_b + 1, 9);\n                a += '0' + digit_a;\n                b += '0' + digit_b;\n                if (digit_a > digit_b) {\n                    a_greater = true;\n                }\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        } else {\n            // len_a > len_b, so a > b\n            string a = \"\";\n            a += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < len_a; ++i) {\n                a += '0' + rnd.next(0, 9);\n            }\n            string b = \"\";\n            if (len_b > 0) {\n                b += '1' + rnd.next(0, 8);\n                for (int i = 1; i < len_b; ++i) {\n                    b += '0' + rnd.next(0, 9);\n                }\n            } else {\n                b = \"0\";\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        }\n    } else if (type == \"b_greater\") {\n        // Similar to \"a_greater\", but swap a and b\n        // Decide len_b >= len_a\n        int len_b = rnd.next(1, n);\n        int len_a = rnd.next(1, len_b);\n        \n        if (len_b == len_a) {\n            // Generate numbers of same length where b > a\n            string a = \"\", b = \"\";\n            bool b_greater = false;\n            for (int i = 0; i < len_a; ++i) {\n                int digit_a = rnd.next(0, 9);\n                int digit_b = b_greater ? rnd.next(0, 9) : rnd.next(digit_a + 1, 9);\n                a += '0' + digit_a;\n                b += '0' + digit_b;\n                if (digit_b > digit_a) {\n                    b_greater = true;\n                }\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        } else {\n            // len_b > len_a, so b > a\n            string b = \"\";\n            b += '1' + rnd.next(0, 8); // first non-zero digit\n            for (int i = 1; i < len_b; ++i) {\n                b += '0' + rnd.next(0, 9);\n            }\n            string a = \"\";\n            if (len_a > 0) {\n                a += '1' + rnd.next(0, 8);\n                for (int i = 1; i < len_a; ++i) {\n                    a += '0' + rnd.next(0, 9);\n                }\n            } else {\n                a = \"0\";\n            }\n            cout << a << '\\n';\n            cout << b << '\\n';\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type equal\n./gen -n 10 -type leading_zeros\n./gen -n 10 -type zeros\n./gen -n 10 -type max_length\n./gen -n 10 -type identical_strings\n./gen -n 10 -type a_greater\n./gen -n 10 -type b_greater\n\n./gen -n 100 -type random\n./gen -n 100 -type equal\n./gen -n 100 -type leading_zeros\n./gen -n 100 -type zeros\n./gen -n 100 -type max_length\n./gen -n 100 -type identical_strings\n./gen -n 100 -type a_greater\n./gen -n 100 -type b_greater\n\n./gen -n 1000 -type random\n./gen -n 1000 -type equal\n./gen -n 1000 -type leading_zeros\n./gen -n 1000 -type zeros\n./gen -n 1000 -type max_length\n./gen -n 1000 -type identical_strings\n./gen -n 1000 -type a_greater\n./gen -n 1000 -type b_greater\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type equal\n./gen -n 1000000 -type leading_zeros\n./gen -n 1000000 -type zeros\n./gen -n 1000000 -type max_length\n./gen -n 1000000 -type identical_strings\n./gen -n 1000000 -type a_greater\n./gen -n 1000000 -type b_greater\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:27.678349",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "616/B",
      "title": "B. Dinner with Emma",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 100) — the number of streets and avenues in Munhattan.Each of the next n lines contains m integers cij (1 ≤ cij ≤ 109) — the cost of the dinner in the restaurant on the intersection of the i-th street and the j-th avenue.",
      "output_spec": "OutputPrint the only integer a — the cost of the dinner for Jack and Emma.",
      "sample_tests": "ExamplesInputCopy3 44 1 3 52 2 2 25 4 5 1OutputCopy2InputCopy3 31 2 32 3 13 1 2OutputCopy1",
      "description": "B. Dinner with Emma\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 100) — the number of streets and avenues in Munhattan.Each of the next n lines contains m integers cij (1 ≤ cij ≤ 109) — the cost of the dinner in the restaurant on the intersection of the i-th street and the j-th avenue.\n\nOutputPrint the only integer a — the cost of the dinner for Jack and Emma.\n\nInputCopy3 44 1 3 52 2 2 25 4 5 1OutputCopy2InputCopy3 31 2 32 3 13 1 2OutputCopy1\n\nInputCopy3 44 1 3 52 2 2 25 4 5 1\n\nOutputCopy2\n\nInputCopy3 31 2 32 3 13 1 2\n\nOutputCopy1\n\nNoteIn the first example if Emma chooses the first or the third streets Jack can choose an avenue with the cost of the dinner 1. So she chooses the second street and Jack chooses any avenue. The cost of the dinner is 2.In the second example regardless of Emma's choice Jack can choose a restaurant with the cost of the dinner 1.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces",
          "content": "Hi, Codeforces!Happy New Year! Holidays and 2015 year have passed and year 2016 is ahead. I wish you good luck in programming competitions and achieving all of your goals this year.Educational Codeforces Round 5 will take place on 11 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<A year has passed, but paragraph remains unchanged.>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</A year has passed, but paragraph remains unchanged.>Thanks a lot to Grigory Reznikow vintage_Vlad_Makeev who prepared a good problem (the problem F in ER 5). You can send to me some ideas of problems or maybe already prepared problems that you can't use in rounds or official competitions.As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements.I think the problems is not difficult (except maybe for problem F). I hope you will enjoy the problems and solve all of them!Good luck and have fun!UPD 1: Coding phase is finished. You can hack other solutions for 24 hours.UPD 2: The editorial is ready.UPD 3: During the phase of hacks we found the following: the same solutions on Python2 and Python3 works differently on different large tests. For example, some of Python3 solutions works very slow on tests with only zeros, but Python2 works very slow on tests with nines. Some of solutions works in around one second so we decided to increase the time limit for the problem A to 2 seconds. All the solutions will be rejudged soon on the complete testset.UPD 4: The round is over. All solutions will be rejudged soon on the complete testset (includes the hacks).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22691",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1973
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces",
          "content": "616A - Comparing Two Long IntegersNote that solutions in Java with BigInteger class or input() function in Python2 will fail in this problem. The reason is the next: standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system. Actually they are working in O(n2), where n is the legth of the number.To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length. After that you should simply compare them alphabetically.С++ solutionPython solutionComplexity: O(n).616B - Dinner with EmmaFirstly you should find the minimum value in each row and after that you should find the maximum value over that minimums. It's corresponding to the strategy of Jack and Emma.C++ solutionComplexity: O(nm).616C - The LabyrinthLet's enumerate all the connected components, store their sizes and for each empty cell store the number of it's component. It can be done with a single dfs. Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components. Adjacent means the components of cells adjacent to the current impassable cell (in general case each unpassable cell has four adjacent cells).C++ solutionComplexity: O(nm).616D - Longest k-Good SegmentThis problem is given because on the Codeforces pages we often see questions like \"What is the method of the two pointers?\". This problem is a typical problem that can be solved using two pointers technique.Let's find for each left end l the maximal right end r that (l, r) is a k-good segment. Note if (l, r) is a k-good segment then (l + 1, r) is also a k-good segment. So the search of the maximal right end for l + 1 we can start from the maximal right end for l. The only thing that we should do is to maintain in the array cntx for each number x the number of it's occurrences in the current segment (l, r) and the number of different numbers in (l, r). We should move the right end until the segment became bad and then move the left end. Each of the ends l, r will be moved exactly n times.C++ solutionComplexity: O(n).616E - Sum of RemaindersUnfortunately my solution for this problem had overflow bug. It was fixed on contest. Even so I hope you enjoyed the problem because I think it's very interesting.Let's transform the sum . Note that the last sum can be accumulated to only value min(n, m), because for i > n all the values will be equal to 0.Note in the last sum either or . Let's carefully accumulate both cases. The first sum can be simply calculated by iterating over all . We will accumulate the second sum independently for all different values . Firstly we should determine for which values i we will have the value . Easy to see that for the values i from the interval . Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time — it's simply a sum of arithmetic progression . So we have solution with complexity .С++ solutionComplexity: .616F - Expensive StringsThis problem was prepared by Grigory Reznikow vintage_Vlad_Makeev. His solution uses suffix array.This problem is a typical problem for some suffix data structure. Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree. My own solution used suffix tree so I'll describe solution with tree (I think it's simple except of the building of the tree).Let's build the new string by concatenation of all strings from input separating them by different separators. The number of separators is O(n) so the alphabet is also O(n). So we should use map<int, int> to store the tree and the complexity is increased by O(logn). Let's build the suffix tree for the new string. Let's match all the separators to the strings from the left of the separator. Let's run dfs on the suffix tree that doesn't move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex. Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex.С++ solutionComplexity: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 616\\s*B"
          },
          "content_length": 4246
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "The First Holy Round For Hackers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "n(n+1) * (mod+1)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> c = inf.readInts(m, 1, 1000000000, \"c_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> c = inf.readInts(m, 1, 1000000000, \"c_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> c = inf.readInts(m, 1, 1000000000, \"c_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    int min_c = opt<int>(\"min_c\", 1);\n    int max_c = opt<int>(\"max_c\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate n and m\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n    // Validate min_c and max_c\n    ensure(1 <= min_c && min_c <= max_c && max_c <= 1000000000);\n\n    vector<vector<int>> c(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Fill c_ij with random integers between min_c and max_c inclusive\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(min_c, max_c);\n            }\n        }\n    } else if (type == \"max\") {\n        // Set all c_ij to max_c\n        for (int i = 0; i < n; ++i) {\n            fill(c[i].begin(), c[i].end(), max_c);\n        }\n    } else if (type == \"min\") {\n        // Set all c_ij to min_c\n        for (int i = 0; i < n; ++i) {\n            fill(c[i].begin(), c[i].end(), min_c);\n        }\n    } else if (type == \"constant\") {\n        int const_c = opt<int>(\"const_c\", min_c);\n        // Validate const_c\n        ensure(min_c <= const_c && const_c <= max_c);\n        for (int i = 0; i < n; ++i) {\n            fill(c[i].begin(), c[i].end(), const_c);\n        }\n    } else if (type == \"diagonal_max\") {\n        // One street has c_ij = max_c, others have c_ij = min_c\n        int k = rnd.next(0, n - 1); // Street index with max_c\n        for (int i = 0; i < n; ++i) {\n            if (i == k) {\n                fill(c[i].begin(), c[i].end(), max_c);\n            } else {\n                fill(c[i].begin(), c[i].end(), min_c);\n            }\n        }\n    } else if (type == \"single_max\") {\n        // Only one c_ij is max_c, others are min_c\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, m - 1);\n        for (int k = 0; k < n; ++k) {\n            fill(c[k].begin(), c[k].end(), min_c);\n        }\n        c[i][j] = max_c;\n    } else if (type == \"edge_case\") {\n        // Edge cases where n = 1 or m = 1\n        n = opt<int>(\"n\", n);\n        m = opt<int>(\"m\", m);\n        ensure(1 <= n && n <= 100);\n        ensure(1 <= m && m <= 100);\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            c[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(min_c, max_c);\n            }\n        }\n    } else if (type == \"equal_mins\") {\n        // All streets have the same minimal c_ij\n        int common_min = rnd.next(min_c, max_c);\n        for (int i = 0; i < n; ++i) {\n            int street_min = common_min;\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0, 1))\n                    c[i][j] = rnd.next(street_min, max_c);\n                else\n                    c[i][j] = street_min;\n            }\n        }\n    } else if (type == \"max_min_diff\") {\n        // Emma can choose a street with higher minimal c_ij\n        int k = rnd.next(0, n - 1); // Street with higher minimal c_ij\n        int emma_min = rnd.next(min_c + 1, max_c);\n        for (int i = 0; i < n; ++i) {\n            int street_min = (i == k) ? emma_min : min_c;\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(street_min, max_c);\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(min_c, max_c);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output c_ij\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", c[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    int min_c = opt<int>(\"min_c\", 1);\n    int max_c = opt<int>(\"max_c\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate n and m\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n    // Validate min_c and max_c\n    ensure(1 <= min_c && min_c <= max_c && max_c <= 1000000000);\n\n    vector<vector<int>> c(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Fill c_ij with random integers between min_c and max_c inclusive\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(min_c, max_c);\n            }\n        }\n    } else if (type == \"max\") {\n        // Set all c_ij to max_c\n        for (int i = 0; i < n; ++i) {\n            fill(c[i].begin(), c[i].end(), max_c);\n        }\n    } else if (type == \"min\") {\n        // Set all c_ij to min_c\n        for (int i = 0; i < n; ++i) {\n            fill(c[i].begin(), c[i].end(), min_c);\n        }\n    } else if (type == \"constant\") {\n        int const_c = opt<int>(\"const_c\", min_c);\n        // Validate const_c\n        ensure(min_c <= const_c && const_c <= max_c);\n        for (int i = 0; i < n; ++i) {\n            fill(c[i].begin(), c[i].end(), const_c);\n        }\n    } else if (type == \"diagonal_max\") {\n        // One street has c_ij = max_c, others have c_ij = min_c\n        int k = rnd.next(0, n - 1); // Street index with max_c\n        for (int i = 0; i < n; ++i) {\n            if (i == k) {\n                fill(c[i].begin(), c[i].end(), max_c);\n            } else {\n                fill(c[i].begin(), c[i].end(), min_c);\n            }\n        }\n    } else if (type == \"single_max\") {\n        // Only one c_ij is max_c, others are min_c\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, m - 1);\n        for (int k = 0; k < n; ++k) {\n            fill(c[k].begin(), c[k].end(), min_c);\n        }\n        c[i][j] = max_c;\n    } else if (type == \"edge_case\") {\n        // Edge cases where n = 1 or m = 1\n        n = opt<int>(\"n\", n);\n        m = opt<int>(\"m\", m);\n        ensure(1 <= n && n <= 100);\n        ensure(1 <= m && m <= 100);\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            c[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(min_c, max_c);\n            }\n        }\n    } else if (type == \"equal_mins\") {\n        // All streets have the same minimal c_ij\n        int common_min = rnd.next(min_c, max_c);\n        for (int i = 0; i < n; ++i) {\n            int street_min = common_min;\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0, 1))\n                    c[i][j] = rnd.next(street_min, max_c);\n                else\n                    c[i][j] = street_min;\n            }\n        }\n    } else if (type == \"max_min_diff\") {\n        // Emma can choose a street with higher minimal c_ij\n        int k = rnd.next(0, n - 1); // Street with higher minimal c_ij\n        int emma_min = rnd.next(min_c + 1, max_c);\n        for (int i = 0; i < n; ++i) {\n            int street_min = (i == k) ? emma_min : min_c;\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(street_min, max_c);\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                c[i][j] = rnd.next(min_c, max_c);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output c_ij\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", c[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with various n and m\n./gen -n 5 -m 5 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 50 -m 75 -type random\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type random\n\n# Max cost test cases\n./gen -n 10 -m 10 -type max\n./gen -n 100 -m 100 -type max\n\n# Min cost test cases\n./gen -n 10 -m 10 -type min\n./gen -n 100 -m 100 -type min\n\n# Constant cost test cases\n./gen -n 50 -m 50 -type constant -const_c 42\n./gen -n 100 -m 100 -type constant -const_c 999999999\n\n# Diagonal max test cases\n./gen -n 100 -m 100 -type diagonal_max\n./gen -n 100 -m 100 -type diagonal_max -min_c 1 -max_c 1000000000\n\n# Single max test cases\n./gen -n 100 -m 100 -type single_max\n./gen -n 50 -m 50 -type single_max\n\n# Edge cases with n = 1 or m = 1\n./gen -n 1 -m 100 -type edge_case\n./gen -n 100 -m 1 -type edge_case\n./gen -n 1 -m 1 -type edge_case\n\n# Equal minimums test cases\n./gen -n 50 -m 50 -type equal_mins\n./gen -n 100 -m 100 -type equal_mins\n\n# Maximum difference in minimal c_ij\n./gen -n 100 -m 100 -type max_min_diff\n\n# Minimum size test case\n./gen -n 1 -m 1 -type random\n\n# Test case where minimal c_ij is same across streets\n./gen -n 100 -m 100 -type constant -const_c 1000000000\n\n# Test cases with small min_c and max_c\n./gen -n 100 -m 100 -type random -min_c 1 -max_c 10\n./gen -n 100 -m 100 -type random -min_c 999999990 -max_c 1000000000\n\n# Random test cases with large min_c and max_c\n./gen -n 100 -m 100 -type random -min_c 500000000 -max_c 1000000000\n\n# Edge case where all c_ij are the same minimal value\n./gen -n 50 -m 50 -type constant -const_c 1\n\n# Test cases with min_c equal to max_c\n./gen -n 100 -m 100 -type random -min_c 42 -max_c 42\n\n# Additional random test cases\n./gen -n 60 -m 70 -type random\n./gen -n 90 -m 80 -type random\n\n# Test cases with varying min_c and max_c\n./gen -n 100 -m 100 -type random -min_c 1 -max_c 1000\n./gen -n 100 -m 100 -type random -min_c 999999000 -max_c 1000000000\n\n# Another edge case of single_max\n./gen -n 2 -m 2 -type single_max\n\n# Small constant test case\n./gen -n 10 -m 10 -type constant -const_c 3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:30.043367",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "616/C",
      "title": "C. The Labyrinth",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 1000) — the number of rows and columns in the field.Each of the next n lines contains m symbols: \".\" for empty cells, \"*\" for impassable cells.",
      "output_spec": "OutputPrint the answer as a matrix as described above. See the examples to precise the format of the output.",
      "sample_tests": "ExamplesInputCopy3 3*.*.*.*.*OutputCopy3.3.5.3.3InputCopy4 5**..*..***.*.*.*.*.*OutputCopy46..3..732.6.4.5.4.3",
      "description": "C. The Labyrinth\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 1000) — the number of rows and columns in the field.Each of the next n lines contains m symbols: \".\" for empty cells, \"*\" for impassable cells.\n\nOutputPrint the answer as a matrix as described above. See the examples to precise the format of the output.\n\nInputCopy3 3*.*.*.*.*OutputCopy3.3.5.3.3InputCopy4 5**..*..***.*.*.*.*.*OutputCopy46..3..732.6.4.5.4.3\n\nInputCopy3 3*.*.*.*.*\n\nOutputCopy3.3.5.3.3\n\nInputCopy4 5**..*..***.*.*.*.*.*\n\nOutputCopy46..3..732.6.4.5.4.3\n\nNoteIn first example, if we imagine that the central cell is empty then it will be included to component of size 5 (cross). If any of the corner cell will be empty then it will be included to component of size 3 (corner).",
      "solutions": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces",
          "content": "Hi, Codeforces!Happy New Year! Holidays and 2015 year have passed and year 2016 is ahead. I wish you good luck in programming competitions and achieving all of your goals this year.Educational Codeforces Round 5 will take place on 11 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<A year has passed, but paragraph remains unchanged.>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</A year has passed, but paragraph remains unchanged.>Thanks a lot to Grigory Reznikow vintage_Vlad_Makeev who prepared a good problem (the problem F in ER 5). You can send to me some ideas of problems or maybe already prepared problems that you can't use in rounds or official competitions.As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements.I think the problems is not difficult (except maybe for problem F). I hope you will enjoy the problems and solve all of them!Good luck and have fun!UPD 1: Coding phase is finished. You can hack other solutions for 24 hours.UPD 2: The editorial is ready.UPD 3: During the phase of hacks we found the following: the same solutions on Python2 and Python3 works differently on different large tests. For example, some of Python3 solutions works very slow on tests with only zeros, but Python2 works very slow on tests with nines. Some of solutions works in around one second so we decided to increase the time limit for the problem A to 2 seconds. All the solutions will be rejudged soon on the complete testset.UPD 4: The round is over. All solutions will be rejudged soon on the complete testset (includes the hacks).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22691",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1973
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces",
          "content": "616A - Comparing Two Long IntegersNote that solutions in Java with BigInteger class or input() function in Python2 will fail in this problem. The reason is the next: standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system. Actually they are working in O(n2), where n is the legth of the number.To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length. After that you should simply compare them alphabetically.С++ solutionPython solutionComplexity: O(n).616B - Dinner with EmmaFirstly you should find the minimum value in each row and after that you should find the maximum value over that minimums. It's corresponding to the strategy of Jack and Emma.C++ solutionComplexity: O(nm).616C - The LabyrinthLet's enumerate all the connected components, store their sizes and for each empty cell store the number of it's component. It can be done with a single dfs. Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components. Adjacent means the components of cells adjacent to the current impassable cell (in general case each unpassable cell has four adjacent cells).C++ solutionComplexity: O(nm).616D - Longest k-Good SegmentThis problem is given because on the Codeforces pages we often see questions like \"What is the method of the two pointers?\". This problem is a typical problem that can be solved using two pointers technique.Let's find for each left end l the maximal right end r that (l, r) is a k-good segment. Note if (l, r) is a k-good segment then (l + 1, r) is also a k-good segment. So the search of the maximal right end for l + 1 we can start from the maximal right end for l. The only thing that we should do is to maintain in the array cntx for each number x the number of it's occurrences in the current segment (l, r) and the number of different numbers in (l, r). We should move the right end until the segment became bad and then move the left end. Each of the ends l, r will be moved exactly n times.C++ solutionComplexity: O(n).616E - Sum of RemaindersUnfortunately my solution for this problem had overflow bug. It was fixed on contest. Even so I hope you enjoyed the problem because I think it's very interesting.Let's transform the sum . Note that the last sum can be accumulated to only value min(n, m), because for i > n all the values will be equal to 0.Note in the last sum either or . Let's carefully accumulate both cases. The first sum can be simply calculated by iterating over all . We will accumulate the second sum independently for all different values . Firstly we should determine for which values i we will have the value . Easy to see that for the values i from the interval . Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time — it's simply a sum of arithmetic progression . So we have solution with complexity .С++ solutionComplexity: .616F - Expensive StringsThis problem was prepared by Grigory Reznikow vintage_Vlad_Makeev. His solution uses suffix array.This problem is a typical problem for some suffix data structure. Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree. My own solution used suffix tree so I'll describe solution with tree (I think it's simple except of the building of the tree).Let's build the new string by concatenation of all strings from input separating them by different separators. The number of separators is O(n) so the alphabet is also O(n). So we should use map<int, int> to store the tree and the complexity is increased by O(logn). Let's build the suffix tree for the new string. Let's match all the separators to the strings from the left of the separator. Let's run dfs on the suffix tree that doesn't move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex. Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex.С++ solutionComplexity: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 616\\s*C"
          },
          "content_length": 4246
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "The First Holy Round For Hackers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "n(n+1) * (mod+1)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[\\\\.\\\\*]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        inf.readLine(pattern, \"grid row\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[\\\\.\\\\*]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        inf.readLine(pattern, \"grid row\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[\\\\.\\\\*]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        inf.readLine(pattern, \"grid row\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5); // Probability for random grids\n    \n    vector<string> grid(n, string(m, '.'));\n    \n    if (type == \"empty\") {\n        // All cells are empty '.'\n        // Do nothing, grid is already filled with '.'\n    } else if (type == \"full\") {\n        // All cells are impassable '*'\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '*');\n        }\n    } else if (type == \"random\") {\n        // Each cell is '*' with probability p, '.' otherwise\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next() < p) {\n                    grid[i][j] = '*';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        // Cells are '.' if (i + j) % 2 == 0, '*' otherwise\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = '.';\n                } else {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    } else if (type == \"big_component\") {\n        // Start with all '.', then randomly add some '*' cells\n        int obstacles = opt<int>(\"obstacles\", n * m / 10);\n        set<pair<int, int>> used;\n        while ((int)used.size() < obstacles) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            if (used.count({i, j}) == 0) {\n                grid[i][j] = '*';\n                used.insert({i, j});\n            }\n        }\n    } else if (type == \"small_components\") {\n        // Start with all '*', then place small groups of '.' cells\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '*');\n        }\n        int groups = opt<int>(\"groups\", (n * m) / 10);\n        for (int g = 0; g < groups; ++g) {\n            int size = rnd.next(1, 5);\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            for (int s = 0; s < size; ++s) {\n                int ni = i + rnd.next(-1, 1);\n                int nj = j + rnd.next(-1, 1);\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                    grid[ni][nj] = '.';\n                }\n            }\n        }\n    } else if (type == \"critical_cells\") {\n        // Create two big components separated by a wall of '*', \n        // with one impassable cell that connects them when removed\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '.');\n        }\n        int wall_col = m / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i][wall_col] = '*';\n        }\n        // Place a '*' cell at a random position in the wall\n        int critical_row = rnd.next(0, n - 1);\n        grid[critical_row][wall_col] = '*';\n    } else {\n        // Default to random grid if unknown type\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next() < p) {\n                    grid[i][j] = '*';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5); // Probability for random grids\n    \n    vector<string> grid(n, string(m, '.'));\n    \n    if (type == \"empty\") {\n        // All cells are empty '.'\n        // Do nothing, grid is already filled with '.'\n    } else if (type == \"full\") {\n        // All cells are impassable '*'\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '*');\n        }\n    } else if (type == \"random\") {\n        // Each cell is '*' with probability p, '.' otherwise\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next() < p) {\n                    grid[i][j] = '*';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        // Cells are '.' if (i + j) % 2 == 0, '*' otherwise\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = '.';\n                } else {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    } else if (type == \"big_component\") {\n        // Start with all '.', then randomly add some '*' cells\n        int obstacles = opt<int>(\"obstacles\", n * m / 10);\n        set<pair<int, int>> used;\n        while ((int)used.size() < obstacles) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            if (used.count({i, j}) == 0) {\n                grid[i][j] = '*';\n                used.insert({i, j});\n            }\n        }\n    } else if (type == \"small_components\") {\n        // Start with all '*', then place small groups of '.' cells\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '*');\n        }\n        int groups = opt<int>(\"groups\", (n * m) / 10);\n        for (int g = 0; g < groups; ++g) {\n            int size = rnd.next(1, 5);\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            for (int s = 0; s < size; ++s) {\n                int ni = i + rnd.next(-1, 1);\n                int nj = j + rnd.next(-1, 1);\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                    grid[ni][nj] = '.';\n                }\n            }\n        }\n    } else if (type == \"critical_cells\") {\n        // Create two big components separated by a wall of '*', \n        // with one impassable cell that connects them when removed\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '.');\n        }\n        int wall_col = m / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i][wall_col] = '*';\n        }\n        // Place a '*' cell at a random position in the wall\n        int critical_row = rnd.next(0, n - 1);\n        grid[critical_row][wall_col] = '*';\n    } else {\n        // Default to random grid if unknown type\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next() < p) {\n                    grid[i][j] = '*';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type empty\n./gen -n 1 -m 1 -type full\n./gen -n 3 -m 3 -type checkerboard\n\n./gen -n 10 -m 10 -type empty\n./gen -n 10 -m 10 -type full\n./gen -n 10 -m 10 -type random -p 0.3\n./gen -n 10 -m 10 -type random -p 0.7\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type big_component -obstacles 5\n./gen -n 10 -m 10 -type small_components -groups 10\n./gen -n 10 -m 10 -type critical_cells\n\n./gen -n 100 -m 100 -type random -p 0.5\n./gen -n 100 -m 100 -type big_component -obstacles 200\n./gen -n 100 -m 100 -type small_components -groups 50\n./gen -n 100 -m 100 -type critical_cells\n\n./gen -n 500 -m 500 -type random -p 0.1\n./gen -n 500 -m 500 -type random -p 0.9\n./gen -n 500 -m 500 -type big_component -obstacles 10000\n./gen -n 500 -m 500 -type small_components -groups 500\n./gen -n 500 -m 500 -type critical_cells\n\n./gen -n 1000 -m 1000 -type empty\n./gen -n 1000 -m 1000 -type full\n./gen -n 1000 -m 1000 -type random -p 0.5\n./gen -n 1000 -m 1000 -type big_component -obstacles 50000\n./gen -n 1000 -m 1000 -type small_components -groups 1000\n./gen -n 1000 -m 1000 -type critical_cells\n\n./gen -n 1000 -m 1000 -type checkerboard\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:32.405293",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "616/D",
      "title": "D. Наидлиннейший k-хороший подотрезок",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится пара целых чисел n, k (1 ≤ k ≤ n ≤ 5·105) — количество элементов в массиве и параметр k.Во второй строке находятся n целых чисел ai (0 ≤ ai ≤ 106) — элементы массива a.",
      "output_spec": "Выходные данныеВыведите два целых числа l, r (l ≤ r) — номер самого левого и самого правого элементов k-хорошего подотрезка наибольшей длины. Если существует несколько хороших подотрезков наибольшей длины разрешается вывести любой из них. Элементы массива пронумерованы от 1 до n слева направо.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 51 2 3 4 5Выходные данныеСкопировать1 5Входные данныеСкопировать9 36 5 1 2 3 2 1 4 5Выходные данныеСкопировать3 7Входные данныеСкопировать3 11 2 3Выходные данныеСкопировать1 1",
      "description": "D. Наидлиннейший k-хороший подотрезок\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится пара целых чисел n, k (1 ≤ k ≤ n ≤ 5·105) — количество элементов в массиве и параметр k.Во второй строке находятся n целых чисел ai (0 ≤ ai ≤ 106) — элементы массива a.\n\nВходные данные\n\nВыходные данныеВыведите два целых числа l, r (l ≤ r) — номер самого левого и самого правого элементов k-хорошего подотрезка наибольшей длины. Если существует несколько хороших подотрезков наибольшей длины разрешается вывести любой из них. Элементы массива пронумерованы от 1 до n слева направо.\n\nВыходные данные\n\nВходные данныеСкопировать5 51 2 3 4 5Выходные данныеСкопировать1 5Входные данныеСкопировать9 36 5 1 2 3 2 1 4 5Выходные данныеСкопировать3 7Входные данныеСкопировать3 11 2 3Выходные данныеСкопировать1 1\n\nВходные данныеСкопировать5 51 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 36 5 1 2 3 2 1 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 11 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces",
          "content": "Привет, Codeforces!Поздравляю вас с наступившим новым годом! Позади остались праздники и 2015-й год, а впереди 2016-й. Желаю вам достижения всех поставленных целей и конечно удачных выступлений на соревнованиях по программированию.11 января 2015 года в 18:00 MSK состоится пятый учебный раунд Educational Codeforces Round 5 для участников из первого и второго дивизионов.<Год прошёл два абзаца остались>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день в течении, которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.</Год прошёл два абзаца остались>Большое спасибо Григорию Резникову vintage_Vlad_Makeev, который предложил и подготовил хорошую задачу (она будет под буквой F). Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.Подготовкой задач как всегда занимался я (Эдвард Давтян). Благодарю MikeMirzayanov мы вместе придумывали задачи (в этот раз по телефону). Также заранее благодарю Машу Белову Delinur, которая скоро вычитает английские тексты условий.На этом раунде вам по традиции будет предложено шесть задач. На мой взгляд в этот раз задачи проще, чем в прошлый. Исключением можно считать лишь последнюю задачу. Надеюсь комплект вам понравится и вы хорошо порешаете задачи!Good luck and have fun!UPD 1: Первая фаза соревнования закончена. Открыта фаза взломов.UPD 2: Разбор задач на русском языке готов.UPD 3: На этапе открытых взломов был обнаружен следующий спецэффект: решения на языках Python2 и Python3 имеют значительную разницу во времени выполнения в разных максимальных тестах. Например, решение на Python3 работает очень медленно на тесте из всех нулей, а на Python2 на тесте из всех девяток. Некоторые решения работают чуть больше или чуть меньше секунды, поэтому было принято решение поднять ограничение по времени в задаче А до двух секунд. Вскоре закончится фаза открытых взломов и все решения будут перетестированы.UPD 4: Соревнование завершено. Вскоре все решения будут перетестированы на полном наборе тестов, включающем в себя взломы.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22691",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2714
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces",
          "content": "616A - Сравнение длинных чиселЗамечу, что в этой задаче решения, использующие стандартные типы длинной арифметики (класс BigInteger в Java, стандартные длинные числа в Pyhon) не должны проходить. Это связано с тем, что они хранят число не в десятичной системе счиления и соответственно при создании длинного числа происходит его конвертация из десятичной системы счисления, которая является тяжёлой операцией и работает обычно за O(n2), где n — длина числа.Для решения задачи можно просто добавить лидирующих нулей к более короткому числу, а далее сравнить, получившиеся строки в лексикографическом порядке (алфавитном).С++ solutionPython solutionСложность: O(n).616B - Ужин с НаташейВ этой задаче нужно было сначала найти в каждой строке минимум, а далее взять максимум, получившихся минимумов. Это соответствует стратегии Павла и Наташи.C++ solutionСложность: O(nm).616C - ЛабиринтДавайте сначала пронумеруем все компоненты связности, запомним для каждой её размер, а также для каждой свободной клетки запомним номер её компоненты. Это можно сделать с помощью одного обхода в глубину. Теперь ответ для непроходимой клетки будет равен единице плюс размеры всех соседних различных компонент. Соседних в смысле компонент всех соседних клеток (в общем случае четырёх).C++ solutionСложность: O(nm).616D - Наидлиннейший k-хороший подотрезокЭту задачу мы решили дать поскольку на страницах Codeforces часто видим вопрос \"Что такое метод двух указателей?\". Эта задача является типичным примером задачи, решаемой этим методом.Будем искать для каждой левой границы l наибольшую границу r такую, что отрезок (l, r) k-хороший. Заметим следующее: если некоторый отрезок (l, r) k-хороший, то отрезок (l + 1, r), тоже является хорошим. Таким образом, поиск максимальной правой границы для левого конца l + 1 мы можем начинать с максимальной правой границы для левого конца l. Далее просто будем поддерживать в массиве cntx для каждого числа x количество его вхождений в текущий отрезок (l, r), а также количество различных чисел. Будем пытаться двигать правую границу пока можем, далее двигать на единицу левую границу. Итого два указателя l, r вместе передвинутся 2n раз.C++ solutionСложность: O(n).616E - Сумма остатковК сожалению в этой задаче в моём решении происходило переполнение. Ошибка была исправлена во время соревнования, надеюсь это не сильно убавило вам удовольствие от решения этой задачи, поскольку она мне кажется очень интересной и красивой (идея решения, конечно, является известной для искушённых пользователей).Сначала преобразуем сумму, которую нужно посчитать . Также заметим, что последнюю сумму можно суммировать до min(n, m), поскольку при i > n все слагаемые будут равны 0.Заметим, что в последней сумме либо , либо . Будем аккуратно суммировать эти два случая так, чтобы ничего не посчитать два раза. Первую сумму посчитать легко, просто нужно пройти циклом по всем таким i. Вторую сумму будем считать отдельно для всех различных значений . Для этого во-первых нужно определить при каких i значение будет достигаться. Легко видеть, что это полуинтервал . Также нужно понять, что сумма вторых сомножителей в при постоянном первом сомножителе легко считается за константное время — это просто сумма арифметической прогрессии . Таким образом решение работает за .С++ solutionСложность: .616F - Дорогие строкиЭта задача была предложена и подготовлена Григорием Резниковым vintage_Vlad_Makeev. Его решение использовало суффиксный массив.Вообще задача является типичным примером задачи на суффиксную структуру. Четверо из пяти участников сдавших задачу в основное время соревнования использовали суффиксный автомат, один использовал суффиксное дерево. Моё решение использовало суффиксное дерево, поэтому я расскажу решение с деревом (оно мне кажется простым, не считая построения самого дерева).Построим новую строку, расположив друг за другом все строки из набора, разделив их различными разделителями. Количество разделителей порядка O(n), поэтому алфавит в суффиксном дереве тоже порядка O(n). Соответственно нужно использовать map<int, int> для хранения дерева и в асимптотике выходит O(logn). Построим для получившейся строки суффиксное дерево. Поставим в соответствие каждому разделителю строку слева от него. Теперь запустим на этом дереве обход в глубину, который никогда не переходит через разделитель и возвращает сумму цен строк, соответствующих множеству разделителей в поддереве вершины обхода в глубину. Легко видеть, что ответ это просто произведение глубины текущей вершины на сумму в поддереве этой вершины.С++ solutionСложность: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 616\\s*D"
          },
          "content_length": 4565
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "The First Holy Round For Hackers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "n(n+1) * (mod+1)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <cstring>\n#include <algorithm>\n\n// Maximum constraints from the problem statement.\nstatic const int MAXN = 500000;   // Max size of n\nstatic const int MAXA = 1000000;  // Max value of a[i]\n\n// We'll store inputs in these static arrays to avoid overhead.\nstatic int a[MAXN + 1];\nstatic int freq[MAXA + 1];\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read n, k, and the array a[1..n].\n    int n = inf.readInt(1, MAXN);\n    int k = inf.readInt(1, n);\n    for (int i = 1; i <= n; i++) {\n        a[i] = inf.readInt(0, MAXA);\n    }\n\n    // 2) Compute maxLen for any k-good subarray using a sliding window in O(n).\n    std::memset(freq, 0, sizeof(freq));\n    int distinct = 0;\n    int left = 1;\n    long long maxLen = 0;\n    for (int right = 1; right <= n; right++) {\n        if (freq[a[right]] == 0) {\n            distinct++;\n        }\n        freq[a[right]]++;\n        while (distinct > k) {\n            freq[a[left]]--;\n            if (freq[a[left]] == 0) {\n                distinct--;\n            }\n            left++;\n        }\n        maxLen = std::max(maxLen, (long long)(right - left + 1));\n    }\n\n    // 3) Read the contestant's output (l, r).\n    int l = ouf.readInt(1, n);\n    int r = ouf.readInt(l, n);\n\n    long long lengthOut = (long long)(r - l + 1);\n\n    // 4) Check length immediately: if != maxLen, no need to scan subarray.\n    if (lengthOut < maxLen) {\n        ouf.quitf(_wa, \"\");\n    }\n    if (lengthOut > maxLen) {\n        ouf.quitf(_wa, \"\");\n    }\n\n    // 5) Verify the subarray [l..r] has <= k distinct values.\n    std::memset(freq, 0, sizeof(freq));\n    distinct = 0;\n    for (int i = l; i <= r; i++) {\n        if (freq[a[i]] == 0) {\n            distinct++;\n            if (distinct > k) {\n                ouf.quitf(_wa, \"\");\n            }\n        }\n        freq[a[i]]++;\n    }\n\n    // 6) If everything is valid, accept.\n    ouf.quitf(_ok, \"\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= k && k <= n && n <= 500000);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000);\n        }\n    } else if (type == \"constant\") {\n        int val = rnd.next(0, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"consecutive\") {\n        int max_start = max(0, 1000000 - n + 1);\n        int start = rnd.next(0, max_start);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"limited_values\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = values[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"long_k_good_at_start\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        int segment_length = n - 1;\n        for (int i = 0; i < segment_length; ++i) {\n            a[i] = values[i % num_values];\n        }\n        int new_val = rnd.next(0, 1000000);\n        while (value_set.count(new_val)) {\n            new_val = rnd.next(0, 1000000);\n        }\n        a[segment_length] = new_val;\n    } else if (type == \"long_k_good_at_end\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        int different_value = rnd.next(0, 1000000);\n        while (value_set.count(different_value)) {\n            different_value = rnd.next(0, 1000000);\n        }\n        a[0] = different_value;\n        for (int i = 1; i < n; ++i) {\n            a[i] = values[(i - 1) % num_values];\n        }\n    } else if (type == \"multiple_longest\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        int segment_length = n / 2;\n        int i = 0;\n        for (; i < segment_length; ++i) {\n            a[i] = values[i % num_values];\n        }\n        int new_val = rnd.next(0, 1000000);\n        while (value_set.count(new_val)) {\n            new_val = rnd.next(0, 1000000);\n        }\n        a[i] = new_val;\n        ++i;\n        for (; i < n; ++i) {\n            a[i] = values[(i - segment_length - 1) % num_values];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= k && k <= n && n <= 500000);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000);\n        }\n    } else if (type == \"constant\") {\n        int val = rnd.next(0, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"consecutive\") {\n        int max_start = max(0, 1000000 - n + 1);\n        int start = rnd.next(0, max_start);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"limited_values\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = values[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"long_k_good_at_start\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        int segment_length = n - 1;\n        for (int i = 0; i < segment_length; ++i) {\n            a[i] = values[i % num_values];\n        }\n        int new_val = rnd.next(0, 1000000);\n        while (value_set.count(new_val)) {\n            new_val = rnd.next(0, 1000000);\n        }\n        a[segment_length] = new_val;\n    } else if (type == \"long_k_good_at_end\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        int different_value = rnd.next(0, 1000000);\n        while (value_set.count(different_value)) {\n            different_value = rnd.next(0, 1000000);\n        }\n        a[0] = different_value;\n        for (int i = 1; i < n; ++i) {\n            a[i] = values[(i - 1) % num_values];\n        }\n    } else if (type == \"multiple_longest\") {\n        int num_values = k;\n        vector<int> values;\n        set<int> value_set;\n        while ((int)values.size() < num_values) {\n            int val = rnd.next(0, 1000000);\n            if (value_set.count(val) == 0) {\n                values.push_back(val);\n                value_set.insert(val);\n            }\n        }\n        int segment_length = n / 2;\n        int i = 0;\n        for (; i < segment_length; ++i) {\n            a[i] = values[i % num_values];\n        }\n        int new_val = rnd.next(0, 1000000);\n        while (value_set.count(new_val)) {\n            new_val = rnd.next(0, 1000000);\n        }\n        a[i] = new_val;\n        ++i;\n        for (; i < n; ++i) {\n            a[i] = values[(i - segment_length - 1) % num_values];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type random\n./gen -n 5 -k 1 -type constant\n./gen -n 10 -k 5 -type consecutive\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 1 -type constant\n./gen -n 10000 -k 10000 -type random\n./gen -n 10000 -k 1 -type random\n./gen -n 500000 -k 500000 -type max_ai\n./gen -n 500000 -k 1 -type min_ai\n./gen -n 500000 -k 5 -type limited_values\n./gen -n 500000 -k 5 -type long_k_good_at_start\n./gen -n 500000 -k 5 -type long_k_good_at_end\n./gen -n 500000 -k 5 -type multiple_longest\n./gen -n 500000 -k 500000 -type min_ai\n./gen -n 500000 -k 1 -type max_ai\n./gen -n 100000 -k 2 -type random\n./gen -n 100000 -k 99999 -type random\n./gen -n 500000 -k 100000 -type consecutive\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 1 -type random\n./gen -n 200000 -k 100000 -type random\n./gen -n 20 -k 3 -type multiple_longest\n./gen -n 20 -k 3 -type long_k_good_at_end\n./gen -n 500000 -k 1000 -type limited_values\n./gen -n 500000 -k 250000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:34.390842",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "616/E",
      "title": "E. Sum of Remainders",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains two integers n, m (1 ≤ n, m ≤ 1013) — the parameters of the sum.",
      "output_spec": "OutputPrint integer s — the value of the required sum modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy3 4OutputCopy4InputCopy4 4OutputCopy1InputCopy1 1OutputCopy0",
      "description": "E. Sum of Remainders\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains two integers n, m (1 ≤ n, m ≤ 1013) — the parameters of the sum.\n\nOutputPrint integer s — the value of the required sum modulo 109 + 7.\n\nInputCopy3 4OutputCopy4InputCopy4 4OutputCopy1InputCopy1 1OutputCopy0\n\nInputCopy3 4\n\nOutputCopy4\n\nInputCopy4 4\n\nOutputCopy1\n\nInputCopy1 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces",
          "content": "Hi, Codeforces!Happy New Year! Holidays and 2015 year have passed and year 2016 is ahead. I wish you good luck in programming competitions and achieving all of your goals this year.Educational Codeforces Round 5 will take place on 11 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<A year has passed, but paragraph remains unchanged.>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.</A year has passed, but paragraph remains unchanged.>Thanks a lot to Grigory Reznikow vintage_Vlad_Makeev who prepared a good problem (the problem F in ER 5). You can send to me some ideas of problems or maybe already prepared problems that you can't use in rounds or official competitions.As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov for helping to invent the problems. Also thanks in advance to Maria Belova Delinur who will check English statements.I think the problems is not difficult (except maybe for problem F). I hope you will enjoy the problems and solve all of them!Good luck and have fun!UPD 1: Coding phase is finished. You can hack other solutions for 24 hours.UPD 2: The editorial is ready.UPD 3: During the phase of hacks we found the following: the same solutions on Python2 and Python3 works differently on different large tests. For example, some of Python3 solutions works very slow on tests with only zeros, but Python2 works very slow on tests with nines. Some of solutions works in around one second so we decided to increase the time limit for the problem A to 2 seconds. All the solutions will be rejudged soon on the complete testset.UPD 4: The round is over. All solutions will be rejudged soon on the complete testset (includes the hacks).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22691",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1973
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces",
          "content": "616A - Comparing Two Long IntegersNote that solutions in Java with BigInteger class or input() function in Python2 will fail in this problem. The reason is the next: standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system. Actually they are working in O(n2), where n is the legth of the number.To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length. After that you should simply compare them alphabetically.С++ solutionPython solutionComplexity: O(n).616B - Dinner with EmmaFirstly you should find the minimum value in each row and after that you should find the maximum value over that minimums. It's corresponding to the strategy of Jack and Emma.C++ solutionComplexity: O(nm).616C - The LabyrinthLet's enumerate all the connected components, store their sizes and for each empty cell store the number of it's component. It can be done with a single dfs. Now the answer for some impassable cell is equal to one plus the sizes of all different adjacent connected components. Adjacent means the components of cells adjacent to the current impassable cell (in general case each unpassable cell has four adjacent cells).C++ solutionComplexity: O(nm).616D - Longest k-Good SegmentThis problem is given because on the Codeforces pages we often see questions like \"What is the method of the two pointers?\". This problem is a typical problem that can be solved using two pointers technique.Let's find for each left end l the maximal right end r that (l, r) is a k-good segment. Note if (l, r) is a k-good segment then (l + 1, r) is also a k-good segment. So the search of the maximal right end for l + 1 we can start from the maximal right end for l. The only thing that we should do is to maintain in the array cntx for each number x the number of it's occurrences in the current segment (l, r) and the number of different numbers in (l, r). We should move the right end until the segment became bad and then move the left end. Each of the ends l, r will be moved exactly n times.C++ solutionComplexity: O(n).616E - Sum of RemaindersUnfortunately my solution for this problem had overflow bug. It was fixed on contest. Even so I hope you enjoyed the problem because I think it's very interesting.Let's transform the sum . Note that the last sum can be accumulated to only value min(n, m), because for i > n all the values will be equal to 0.Note in the last sum either or . Let's carefully accumulate both cases. The first sum can be simply calculated by iterating over all . We will accumulate the second sum independently for all different values . Firstly we should determine for which values i we will have the value . Easy to see that for the values i from the interval . Also we can note that the sum of the second factors in with fixed first factor can be calculaed in constant time — it's simply a sum of arithmetic progression . So we have solution with complexity .С++ solutionComplexity: .616F - Expensive StringsThis problem was prepared by Grigory Reznikow vintage_Vlad_Makeev. His solution uses suffix array.This problem is a typical problem for some suffix data structure. Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree. My own solution used suffix tree so I'll describe solution with tree (I think it's simple except of the building of the tree).Let's build the new string by concatenation of all strings from input separating them by different separators. The number of separators is O(n) so the alphabet is also O(n). So we should use map<int, int> to store the tree and the complexity is increased by O(logn). Let's build the suffix tree for the new string. Let's match all the separators to the strings from the left of the separator. Let's run dfs on the suffix tree that doesn't move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex. Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex.С++ solutionComplexity: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 616\\s*E"
          },
          "content_length": 4246
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "The First Holy Round For Hackers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "n(n+1) * (mod+1)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 10000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1, 10000000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 10000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1, 10000000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 10000000000000LL, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(1, 10000000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long n_max = opt<long long>(\"n_max\", 10000000000000LL); // default 1e13\n    long long m_max = opt<long long>(\"m_max\", 10000000000000LL); // default 1e13\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n, m;\n\n    if (type == \"random\") {\n        n = rnd.next(1LL, n_max);\n        m = rnd.next(1LL, m_max);\n    } else if (type == \"n_equals_m\") {\n        n = rnd.next(1LL, min(n_max, m_max));\n        m = n;\n    } else if (type == \"n_less_than_m\") {\n        n = rnd.next(1LL, min(n_max, m_max - 1));\n        m = rnd.next(n + 1, m_max);\n    } else if (type == \"n_greater_than_m\") {\n        m = rnd.next(1LL, min(m_max, n_max - 1));\n        n = rnd.next(m + 1, n_max);\n    } else if (type == \"n_is_1\") {\n        n = 1;\n        m = rnd.next(1LL, m_max);\n    } else if (type == \"m_is_1\") {\n        n = rnd.next(1LL, n_max);\n        m = 1;\n    } else if (type == \"n_and_m_are_max\") {\n        n = n_max;\n        m = m_max;\n    } else if (type == \"n_is_max_m_is_1\") {\n        n = n_max;\n        m = 1;\n    } else if (type == \"n_is_1_m_is_max\") {\n        n = 1;\n        m = m_max;\n    } else if (type == \"small\") {\n        n = rnd.next(1LL, 100LL);\n        m = rnd.next(1LL, 100LL);\n    } else if (type == \"n_is_big_m_is_small\") {\n        n = rnd.next(max(1LL, n_max - 1000), n_max);\n        m = rnd.next(1LL, 100LL);\n    } else if (type == \"n_is_small_m_is_big\") {\n        n = rnd.next(1LL, 100LL);\n        m = rnd.next(max(1LL, m_max - 1000), m_max);\n    } else {\n        // Default to random\n        n = rnd.next(1LL, n_max);\n        m = rnd.next(1LL, m_max);\n    }\n\n    // Output\n    printf(\"%lld %lld\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long n_max = opt<long long>(\"n_max\", 10000000000000LL); // default 1e13\n    long long m_max = opt<long long>(\"m_max\", 10000000000000LL); // default 1e13\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n, m;\n\n    if (type == \"random\") {\n        n = rnd.next(1LL, n_max);\n        m = rnd.next(1LL, m_max);\n    } else if (type == \"n_equals_m\") {\n        n = rnd.next(1LL, min(n_max, m_max));\n        m = n;\n    } else if (type == \"n_less_than_m\") {\n        n = rnd.next(1LL, min(n_max, m_max - 1));\n        m = rnd.next(n + 1, m_max);\n    } else if (type == \"n_greater_than_m\") {\n        m = rnd.next(1LL, min(m_max, n_max - 1));\n        n = rnd.next(m + 1, n_max);\n    } else if (type == \"n_is_1\") {\n        n = 1;\n        m = rnd.next(1LL, m_max);\n    } else if (type == \"m_is_1\") {\n        n = rnd.next(1LL, n_max);\n        m = 1;\n    } else if (type == \"n_and_m_are_max\") {\n        n = n_max;\n        m = m_max;\n    } else if (type == \"n_is_max_m_is_1\") {\n        n = n_max;\n        m = 1;\n    } else if (type == \"n_is_1_m_is_max\") {\n        n = 1;\n        m = m_max;\n    } else if (type == \"small\") {\n        n = rnd.next(1LL, 100LL);\n        m = rnd.next(1LL, 100LL);\n    } else if (type == \"n_is_big_m_is_small\") {\n        n = rnd.next(max(1LL, n_max - 1000), n_max);\n        m = rnd.next(1LL, 100LL);\n    } else if (type == \"n_is_small_m_is_big\") {\n        n = rnd.next(1LL, 100LL);\n        m = rnd.next(max(1LL, m_max - 1000), m_max);\n    } else {\n        // Default to random\n        n = rnd.next(1LL, n_max);\n        m = rnd.next(1LL, m_max);\n    }\n\n    // Output\n    printf(\"%lld %lld\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type n_equals_m\n./gen -type n_equals_m\n./gen -type n_equals_m -n_max 1000000000000\n\n./gen -type n_less_than_m\n./gen -type n_less_than_m\n./gen -type n_less_than_m -n_max 1000000 -m_max 10000000000000\n\n./gen -type n_greater_than_m\n./gen -type n_greater_than_m\n./gen -type n_greater_than_m -n_max 10000000000000 -m_max 1000000\n\n./gen -type n_is_1\n./gen -type n_is_1 -m_max 1000000000000\n./gen -type m_is_1\n./gen -type m_is_1 -n_max 1000000000000\n\n./gen -type n_and_m_are_max -n_max 10000000000000 -m_max 10000000000000\n./gen -type n_is_max_m_is_1 -n_max 10000000000000\n./gen -type n_is_1_m_is_max -m_max 10000000000000\n\n# Random test cases\n./gen -type random -n_max 10000000000000 -m_max 10000000000000\n./gen -type random -n_max 10000000000000 -m_max 10000000000000\n./gen -type random -n_max 10000000000000 -m_max 10000000000000\n./gen -type random -n_max 10000000000000 -m_max 10000000000000\n./gen -type random -n_max 10000000000000 -m_max 10000000000000\n\n# Special cases\n./gen -type n_is_big_m_is_small\n./gen -type n_is_big_m_is_small\n./gen -type n_is_big_m_is_small -n_max 10000000000000 -m_max 100\n\n./gen -type n_is_small_m_is_big\n./gen -type n_is_small_m_is_big\n./gen -type n_is_small_m_is_big -n_max 100 -m_max 10000000000000\n\n# Edge cases\n./gen -type n_equals_m -n_max 1\n./gen -type n_equals_m -n_max 10000000000000\n\n# Another random test cases\n./gen -type random -n_max 100000 -m_max 100000\n./gen -type random -n_max 1000000000 -m_max 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:36.259561",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "616/F",
      "title": "F. Дорогие строки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест6 секунд",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке входного файла задано единственное целое число n (1 ≤ n ≤ 105) — количество строк в наборе.Далее заданы n непустых строк — строки ti из набора. Строки ti состоят только из строчных букв английского алфавита.Гарантируется, что суммарная длина всех строк не превосходит 5·105.В последней строке находится n целых чисел ci ( - 107 ≤ ci ≤ 107) — стоимость i-й строки.",
      "output_spec": "Выходные данныеВ единственной строке выходного файла выведите целое число a — наибольшее значение функции f(s) по всем строкам s. Обращаем еще раз внимание, что строка s не обязательно из заданного набора t.",
      "sample_tests": "ПримерыВходные данныеСкопировать2aabb2 1Выходные данныеСкопировать4Входные данныеСкопировать2aaab2 1Выходные данныеСкопировать5",
      "description": "F. Дорогие строки\n\nограничение по времени на тест6 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входного файла задано единственное целое число n (1 ≤ n ≤ 105) — количество строк в наборе.Далее заданы n непустых строк — строки ti из набора. Строки ti состоят только из строчных букв английского алфавита.Гарантируется, что суммарная длина всех строк не превосходит 5·105.В последней строке находится n целых чисел ci ( - 107 ≤ ci ≤ 107) — стоимость i-й строки.\n\nВходные данные\n\nВыходные данныеВ единственной строке выходного файла выведите целое число a — наибольшее значение функции f(s) по всем строкам s. Обращаем еще раз внимание, что строка s не обязательно из заданного набора t.\n\nВыходные данные\n\nВходные данныеСкопировать2aabb2 1Выходные данныеСкопировать4Входные данныеСкопировать2aaab2 1Выходные данныеСкопировать5\n\nВходные данныеСкопировать2aabb2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2aaab2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces",
          "content": "Привет, Codeforces!Поздравляю вас с наступившим новым годом! Позади остались праздники и 2015-й год, а впереди 2016-й. Желаю вам достижения всех поставленных целей и конечно удачных выступлений на соревнованиях по программированию.11 января 2015 года в 18:00 MSK состоится пятый учебный раунд Educational Codeforces Round 5 для участников из первого и второго дивизионов.<Год прошёл два абзаца остались>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день в течении, которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.</Год прошёл два абзаца остались>Большое спасибо Григорию Резникову vintage_Vlad_Makeev, который предложил и подготовил хорошую задачу (она будет под буквой F). Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.Подготовкой задач как всегда занимался я (Эдвард Давтян). Благодарю MikeMirzayanov мы вместе придумывали задачи (в этот раз по телефону). Также заранее благодарю Машу Белову Delinur, которая скоро вычитает английские тексты условий.На этом раунде вам по традиции будет предложено шесть задач. На мой взгляд в этот раз задачи проще, чем в прошлый. Исключением можно считать лишь последнюю задачу. Надеюсь комплект вам понравится и вы хорошо порешаете задачи!Good luck and have fun!UPD 1: Первая фаза соревнования закончена. Открыта фаза взломов.UPD 2: Разбор задач на русском языке готов.UPD 3: На этапе открытых взломов был обнаружен следующий спецэффект: решения на языках Python2 и Python3 имеют значительную разницу во времени выполнения в разных максимальных тестах. Например, решение на Python3 работает очень медленно на тесте из всех нулей, а на Python2 на тесте из всех девяток. Некоторые решения работают чуть больше или чуть меньше секунды, поэтому было принято решение поднять ограничение по времени в задаче А до двух секунд. Вскоре закончится фаза открытых взломов и все решения будут перетестированы.UPD 4: Соревнование завершено. Вскоре все решения будут перетестированы на полном наборе тестов, включающем в себя взломы.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22691",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2714
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces",
          "content": "616A - Сравнение длинных чиселЗамечу, что в этой задаче решения, использующие стандартные типы длинной арифметики (класс BigInteger в Java, стандартные длинные числа в Pyhon) не должны проходить. Это связано с тем, что они хранят число не в десятичной системе счиления и соответственно при создании длинного числа происходит его конвертация из десятичной системы счисления, которая является тяжёлой операцией и работает обычно за O(n2), где n — длина числа.Для решения задачи можно просто добавить лидирующих нулей к более короткому числу, а далее сравнить, получившиеся строки в лексикографическом порядке (алфавитном).С++ solutionPython solutionСложность: O(n).616B - Ужин с НаташейВ этой задаче нужно было сначала найти в каждой строке минимум, а далее взять максимум, получившихся минимумов. Это соответствует стратегии Павла и Наташи.C++ solutionСложность: O(nm).616C - ЛабиринтДавайте сначала пронумеруем все компоненты связности, запомним для каждой её размер, а также для каждой свободной клетки запомним номер её компоненты. Это можно сделать с помощью одного обхода в глубину. Теперь ответ для непроходимой клетки будет равен единице плюс размеры всех соседних различных компонент. Соседних в смысле компонент всех соседних клеток (в общем случае четырёх).C++ solutionСложность: O(nm).616D - Наидлиннейший k-хороший подотрезокЭту задачу мы решили дать поскольку на страницах Codeforces часто видим вопрос \"Что такое метод двух указателей?\". Эта задача является типичным примером задачи, решаемой этим методом.Будем искать для каждой левой границы l наибольшую границу r такую, что отрезок (l, r) k-хороший. Заметим следующее: если некоторый отрезок (l, r) k-хороший, то отрезок (l + 1, r), тоже является хорошим. Таким образом, поиск максимальной правой границы для левого конца l + 1 мы можем начинать с максимальной правой границы для левого конца l. Далее просто будем поддерживать в массиве cntx для каждого числа x количество его вхождений в текущий отрезок (l, r), а также количество различных чисел. Будем пытаться двигать правую границу пока можем, далее двигать на единицу левую границу. Итого два указателя l, r вместе передвинутся 2n раз.C++ solutionСложность: O(n).616E - Сумма остатковК сожалению в этой задаче в моём решении происходило переполнение. Ошибка была исправлена во время соревнования, надеюсь это не сильно убавило вам удовольствие от решения этой задачи, поскольку она мне кажется очень интересной и красивой (идея решения, конечно, является известной для искушённых пользователей).Сначала преобразуем сумму, которую нужно посчитать . Также заметим, что последнюю сумму можно суммировать до min(n, m), поскольку при i > n все слагаемые будут равны 0.Заметим, что в последней сумме либо , либо . Будем аккуратно суммировать эти два случая так, чтобы ничего не посчитать два раза. Первую сумму посчитать легко, просто нужно пройти циклом по всем таким i. Вторую сумму будем считать отдельно для всех различных значений . Для этого во-первых нужно определить при каких i значение будет достигаться. Легко видеть, что это полуинтервал . Также нужно понять, что сумма вторых сомножителей в при постоянном первом сомножителе легко считается за константное время — это просто сумма арифметической прогрессии . Таким образом решение работает за .С++ solutionСложность: .616F - Дорогие строкиЭта задача была предложена и подготовлена Григорием Резниковым vintage_Vlad_Makeev. Его решение использовало суффиксный массив.Вообще задача является типичным примером задачи на суффиксную структуру. Четверо из пяти участников сдавших задачу в основное время соревнования использовали суффиксный автомат, один использовал суффиксное дерево. Моё решение использовало суффиксное дерево, поэтому я расскажу решение с деревом (оно мне кажется простым, не считая построения самого дерева).Построим новую строку, расположив друг за другом все строки из набора, разделив их различными разделителями. Количество разделителей порядка O(n), поэтому алфавит в суффиксном дереве тоже порядка O(n). Соответственно нужно использовать map<int, int> для хранения дерева и в асимптотике выходит O(logn). Построим для получившейся строки суффиксное дерево. Поставим в соответствие каждому разделителю строку слева от него. Теперь запустим на этом дереве обход в глубину, который никогда не переходит через разделитель и возвращает сумму цен строк, соответствующих множеству разделителей в поддереве вершины обхода в глубину. Легко видеть, что ответ это просто произведение глубины текущей вершины на сумму в поддереве этой вершины.С++ solutionСложность: O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 616\\s*F"
          },
          "content_length": 4565
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "The First Holy Round For Hackers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "ll mul(ll a, ll b) {\n    a %= mod, b %= mod;\n    a *= b;\n    a %= mod;\n    if (a < 0) a += mod;\n    return a;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "from math import sqrt\n\ndef get_sum(x):\n\treturn int(x*(x+1)/2)\ndef range_sum(l,r):\n\treturn get_sum(r) &mdash; get_sum(l-1)\n\nif __name__ == '__main__':\n\t# MOD = 1000000000 + 7\n\tMOD = 1\n\tmod = 1000000000 + 7\n\tMOD = mod\n\tN = int(input())\n\tM = int(input())\n\t# N = 10000000000000 \n\t# M = 10000000000000\n\n\tprint(N)\n\tprint(M)\n\n\tminMN = min(N, M)\n\t# lim = int(sqrt(minMN))\n\tlim = int(sqrt(N))\n\t# total = (M % MOD )*N % MOD\n\ttotal = M*N\n\treduce = 0\n\n\tfor i in range(1, lim):\n\t\tif i > minMN:\n\t\t\tbreak\n\n\t\ta_pair = int(N / i )\n\t\tb_pair = int(N / (i+1))\n\n\t\tif b_pair+1 <= minMN:\n\t\t\tthis_range = range_sum(b_pair+1, min(a_pair, minMN))\n\t\t\tdiv = i\n\t\t\t# red = (this_range % MOD * div) % MOD\n\t\t\tred = int(this_range ) * div\n\n\t\t\treduce += red\n\t\t\t# reduce %= MOD\n\n\t\treduce += int(N/i)*i # % MOD\n\t\t# reduce %= MOD\n\n\tprint(\"Reduce is \" + str(reduce))\n\n\tlim_pair = int(N/lim)\n\tfor i in range(lim, lim_pair+1):\n\t\tif i > minMN:\n\t\t\tbreak\n\t\treduce += int(N/i) * i\n\t\t# reduce %= MOD\n\n\tprint(total % MOD)\n\t# total %= MOD\n\tprint(\"Total is \" + str(total))\n\tprint(\"Getting from \" + str(lim) + \" to \" + str(lim_pair))\n\tprint(\"Reduce is now \" + str(reduce))\n\n\tans = total - reduce\n\tprint( (total % MOD) - (reduce % MOD) )\n\tprint( ((total % MOD) - (reduce % MOD) ) % MOD)\n\n\tprint(ans)\n\tprint(ans % mod)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/22691",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 1",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 2",
          "code": "StringBuilder sb = new StringBuilder();\nsb.append(appendWhatYouNeedHere);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 3",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 4",
          "code": "inline li sum(li n) { return mul(mul(n, n + 1), (mod + 1) / 2); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 5 - Codeforces - Code 5",
          "code": "n(n+1) * (mod+1)/2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22712",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isLowercaseLetters(const string &s) {\n    for (char c : s) {\n        if (!('a' <= c && c <= 'z')) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string ti = inf.readLine();\n        int len_ti = ti.length();\n\n        ensuref(len_ti >= 1, \"String ti[%d] is empty\", i+1);\n\n        ensuref(isLowercaseLetters(ti), \"String ti[%d] contains invalid character\", i+1);\n\n        total_length += len_ti;\n    }\n\n    ensuref(total_length <= 500000, \"Total length of strings ti exceeds 5e5\");\n\n    vector<int> ci = inf.readInts(n, -10000000, 10000000, \"ci\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isLowercaseLetters(const string &s) {\n    for (char c : s) {\n        if (!('a' <= c && c <= 'z')) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string ti = inf.readLine();\n        int len_ti = ti.length();\n\n        ensuref(len_ti >= 1, \"String ti[%d] is empty\", i+1);\n\n        ensuref(isLowercaseLetters(ti), \"String ti[%d] contains invalid character\", i+1);\n\n        total_length += len_ti;\n    }\n\n    ensuref(total_length <= 500000, \"Total length of strings ti exceeds 5e5\");\n\n    vector<int> ci = inf.readInts(n, -10000000, 10000000, \"ci\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isLowercaseLetters(const string &s) {\n    for (char c : s) {\n        if (!('a' <= c && c <= 'z')) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string ti = inf.readLine();\n        int len_ti = ti.length();\n\n        ensuref(len_ti >= 1, \"String ti[%d] is empty\", i+1);\n\n        ensuref(isLowercaseLetters(ti), \"String ti[%d] contains invalid character\", i+1);\n\n        total_length += len_ti;\n    }\n\n    ensuref(total_length <= 500000, \"Total length of strings ti exceeds 5e5\");\n\n    vector<int> ci = inf.readInts(n, -10000000, 10000000, \"ci\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to generate random positive integers summing up to total, with minimum value min_val\nvector<int> generate_random_partition(int n, int total, int min_val = 1) {\n    vector<int> positions;\n    for (int i = 0; i < n - 1; ++i) {\n        int pos = rnd.next(0, total - min_val * n);\n        positions.push_back(pos);\n    }\n    positions.push_back(total - min_val * n); // Add the last position\n    positions.push_back(0); // Add starting point\n    sort(positions.begin(), positions.end());\n    vector<int> partition;\n    for (int i = 1; i < positions.size(); ++i) {\n        int segment_length = positions[i] - positions[i - 1];\n        partition.push_back(segment_length + min_val);\n    }\n    return partition;\n}\n\n// Function to generate a random string of given length\nstring generate_random_string(int length) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        s += (char)('a' + rnd.next(0, 25));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int sumlen = opt<int>(\"sumlen\", 500000);\n    string t_type = opt<string>(\"ttype\", \"random\");\n    string c_type = opt<string>(\"ctype\", \"random\");\n\n    ensure(sumlen >= n); // Each string must be at least length 1\n\n    vector<string> t(n);\n    vector<int> c(n);\n\n    vector<int> lengths(n);\n\n    // Generate lengths for the strings t_i\n    if (t_type == \"random\" || t_type == \"long_strings\" || t_type == \"max_length_strings\") {\n        lengths = generate_random_partition(n, sumlen);\n    }\n\n    if (t_type == \"random\") {\n        // Generate random strings with lengths lengths[i]\n        for (int i = 0; i < n; ++i) {\n            t[i] = generate_random_string(lengths[i]);\n        }\n    } else if (t_type == \"same_string\") {\n        // Generate a random string and assign it to all t_i\n        int length_per_string = sumlen / n;\n        if (length_per_string == 0) length_per_string = 1;\n        string s = generate_random_string(length_per_string);\n        for (int i = 0; i < n; ++i) {\n            t[i] = s;\n        }\n    } else if (t_type == \"long_strings\" || t_type == \"max_length_strings\") {\n        // Generate long strings to test efficiency\n        for (int i = 0; i < n; ++i) {\n            t[i] = generate_random_string(lengths[i]);\n        }\n    } else if (t_type == \"repeated_patterns\") {\n        // Generate strings with repeated patterns\n        string pattern = generate_random_string(rnd.next(1, 10));\n        for (int i = 0; i < n; ++i) {\n            int repeats = lengths[i] / pattern.size();\n            int remaining = lengths[i] % pattern.size();\n            t[i] = \"\";\n            for (int j = 0; j < repeats; ++j) {\n                t[i] += pattern;\n            }\n            t[i] += pattern.substr(0, remaining);\n        }\n    } else {\n        // Default to random strings if type not recognized\n        for (int i = 0; i < n; ++i) {\n            t[i] = generate_random_string(lengths[i]);\n        }\n    }\n\n    // Generate c_i according to c_type\n    if (c_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(-10000000, 10000000);\n        }\n    } else if (c_type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    } else if (c_type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(-10000000, -1);\n        }\n    } else if (c_type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = 0;\n        }\n    } else if (c_type == \"all_same\") {\n        int value = rnd.next(-10000000, 10000000);\n        for (int i = 0; i < n; ++i) {\n            c[i] = value;\n        }\n    } else if (c_type == \"alternating_signs\") {\n        int positive = rnd.next(1, 10000000);\n        int negative = rnd.next(-10000000, -1);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                c[i] = positive;\n            } else {\n                c[i] = negative;\n            }\n        }\n    } else {\n        // Default to random c_i if type not recognized\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(-10000000, 10000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output t_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", t[i].c_str());\n    }\n    // Output c_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to generate random positive integers summing up to total, with minimum value min_val\nvector<int> generate_random_partition(int n, int total, int min_val = 1) {\n    vector<int> positions;\n    for (int i = 0; i < n - 1; ++i) {\n        int pos = rnd.next(0, total - min_val * n);\n        positions.push_back(pos);\n    }\n    positions.push_back(total - min_val * n); // Add the last position\n    positions.push_back(0); // Add starting point\n    sort(positions.begin(), positions.end());\n    vector<int> partition;\n    for (int i = 1; i < positions.size(); ++i) {\n        int segment_length = positions[i] - positions[i - 1];\n        partition.push_back(segment_length + min_val);\n    }\n    return partition;\n}\n\n// Function to generate a random string of given length\nstring generate_random_string(int length) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        s += (char)('a' + rnd.next(0, 25));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int sumlen = opt<int>(\"sumlen\", 500000);\n    string t_type = opt<string>(\"ttype\", \"random\");\n    string c_type = opt<string>(\"ctype\", \"random\");\n\n    ensure(sumlen >= n); // Each string must be at least length 1\n\n    vector<string> t(n);\n    vector<int> c(n);\n\n    vector<int> lengths(n);\n\n    // Generate lengths for the strings t_i\n    if (t_type == \"random\" || t_type == \"long_strings\" || t_type == \"max_length_strings\") {\n        lengths = generate_random_partition(n, sumlen);\n    }\n\n    if (t_type == \"random\") {\n        // Generate random strings with lengths lengths[i]\n        for (int i = 0; i < n; ++i) {\n            t[i] = generate_random_string(lengths[i]);\n        }\n    } else if (t_type == \"same_string\") {\n        // Generate a random string and assign it to all t_i\n        int length_per_string = sumlen / n;\n        if (length_per_string == 0) length_per_string = 1;\n        string s = generate_random_string(length_per_string);\n        for (int i = 0; i < n; ++i) {\n            t[i] = s;\n        }\n    } else if (t_type == \"long_strings\" || t_type == \"max_length_strings\") {\n        // Generate long strings to test efficiency\n        for (int i = 0; i < n; ++i) {\n            t[i] = generate_random_string(lengths[i]);\n        }\n    } else if (t_type == \"repeated_patterns\") {\n        // Generate strings with repeated patterns\n        string pattern = generate_random_string(rnd.next(1, 10));\n        for (int i = 0; i < n; ++i) {\n            int repeats = lengths[i] / pattern.size();\n            int remaining = lengths[i] % pattern.size();\n            t[i] = \"\";\n            for (int j = 0; j < repeats; ++j) {\n                t[i] += pattern;\n            }\n            t[i] += pattern.substr(0, remaining);\n        }\n    } else {\n        // Default to random strings if type not recognized\n        for (int i = 0; i < n; ++i) {\n            t[i] = generate_random_string(lengths[i]);\n        }\n    }\n\n    // Generate c_i according to c_type\n    if (c_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(-10000000, 10000000);\n        }\n    } else if (c_type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 10000000);\n        }\n    } else if (c_type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(-10000000, -1);\n        }\n    } else if (c_type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            c[i] = 0;\n        }\n    } else if (c_type == \"all_same\") {\n        int value = rnd.next(-10000000, 10000000);\n        for (int i = 0; i < n; ++i) {\n            c[i] = value;\n        }\n    } else if (c_type == \"alternating_signs\") {\n        int positive = rnd.next(1, 10000000);\n        int negative = rnd.next(-10000000, -1);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                c[i] = positive;\n            } else {\n                c[i] = negative;\n            }\n        }\n    } else {\n        // Default to random c_i if type not recognized\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(-10000000, 10000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output t_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", t[i].c_str());\n    }\n    // Output c_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test case\n./gen -n 1 -sumlen 1 -ttype random -ctype random\n\n# Small test case with same strings and same costs\n./gen -n 5 -sumlen 10 -ttype same_string -ctype all_same\n\n# Small test case with alternating costs\n./gen -n 10 -sumlen 50 -ttype random -ctype alternating_signs\n\n# Test case with all positive costs\n./gen -n 50 -sumlen 200 -ttype random -ctype all_positive\n\n# Test case with all negative costs\n./gen -n 50 -sumlen 200 -ttype random -ctype all_negative\n\n# Test case with zero costs\n./gen -n 100 -sumlen 300 -ttype random -ctype zeros\n\n# Test case with repeated patterns\n./gen -n 100 -sumlen 1000 -ttype repeated_patterns -ctype random\n\n# Medium test case with long strings\n./gen -n 1000 -sumlen 10000 -ttype long_strings -ctype random\n\n# Medium test case with maximum length strings\n./gen -n 5000 -sumlen 500000 -ttype max_length_strings -ctype random\n\n# Test case with same strings and alternating costs\n./gen -n 10000 -sumlen 500000 -ttype same_string -ctype alternating_signs\n\n# Large test case with random strings and costs\n./gen -n 50000 -sumlen 500000 -ttype random -ctype random\n\n# Large test case with repeated patterns and same costs\n./gen -n 50000 -sumlen 500000 -ttype repeated_patterns -ctype all_same\n\n# Large test case with all positive costs\n./gen -n 100000 -sumlen 500000 -ttype random -ctype all_positive\n\n# Large test case with all negative costs\n./gen -n 100000 -sumlen 500000 -ttype random -ctype all_negative\n\n# Edge case with minimum n and maximum sumlen\n./gen -n 1 -sumlen 500000 -ttype random -ctype random\n\n# Edge case with maximum n and minimum sumlen\n./gen -n 100000 -sumlen 100000 -ttype same_string -ctype random\n\n# Edge case with all costs zero\n./gen -n 100000 -sumlen 500000 -ttype random -ctype zeros\n\n# Edge case with maximum lengths and alternating signs\n./gen -n 100000 -sumlen 500000 -ttype max_length_strings -ctype alternating_signs\n\n# Test case with only one very long string\n./gen -n 1 -sumlen 500000 -ttype long_strings -ctype random\n\n# Test case with strings of length one\n./gen -n 500000 -sumlen 500000 -ttype random -ctype random\n\n# Test case with repeated patterns and negative costs\n./gen -n 50000 -sumlen 500000 -ttype repeated_patterns -ctype all_negative\n\n# Test case with same string and positive costs\n./gen -n 100000 -sumlen 500000 -ttype same_string -ctype all_positive\n\n# Test case with random strings and zero costs\n./gen -n 100000 -sumlen 500000 -ttype random -ctype zeros\n\n# Stress test with maximum allowed parameters\n./gen -n 100000 -sumlen 500000 -ttype random -ctype random\n\n# Stress test with maximum parameters and same strings\n./gen -n 100000 -sumlen 500000 -ttype same_string -ctype random\n\n# Stress test with maximum parameters and long strings\n./gen -n 100000 -sumlen 500000 -ttype long_strings -ctype random\n\n# Stress test with maximum parameters and repeated patterns\n./gen -n 100000 -sumlen 500000 -ttype repeated_patterns -ctype random\n\n# Edge case with alternating signs and sumlen equal to n\n./gen -n 500000 -sumlen 500000 -ttype random -ctype alternating_signs\n\n# Edge case with minimum length strings and c_i all same\n./gen -n 500000 -sumlen 500000 -ttype random -ctype all_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:38.209282",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "617/A",
      "title": "A. Elephant",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer x (1 ≤ x ≤ 1 000 000) — The coordinate of the friend's house.",
      "output_spec": "OutputPrint the minimum number of steps that elephant needs to make to get from point 0 to point x.",
      "sample_tests": "ExamplesInputCopy5OutputCopy1InputCopy12OutputCopy3",
      "description": "A. Elephant\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains an integer x (1 ≤ x ≤ 1 000 000) — The coordinate of the friend's house.\n\nOutputPrint the minimum number of steps that elephant needs to make to get from point 0 to point x.\n\nInputCopy5OutputCopy1InputCopy12OutputCopy3\n\nOutputCopy1\n\nInputCopy12\n\nOutputCopy3\n\nNoteIn the first sample the elephant needs to make one step of length 5 to reach the point x.In the second sample the elephant can get to point x if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach x in less than three moves.",
      "solutions": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces",
          "content": "Hi!Tomorrow, on 23rd of January at 18:35 MSK Codeforces Round #340 (Div. 2) will take place. It's my first round, hope you enjoy the problems.Thanks to GlebsHP for his help in preparing the problems, Delinur for translations of statements and MikeMirzayanov for Codeforces and Polygon.Good luck!UPD Scoring 500-1000-1250-1750-2750UPD EditorialUPD Congrats to winners!Div. 2 AReesha kpw29 I_love_Varechka zhaoxinyi thatday Div. 1 anta dreamoon_love_AA uwi Um_nik I_love_Tanya_Romanova",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22950",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 483
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces",
          "content": "617A - ElephantIt's optimal to do the biggest possible step everytime. So elephant should do several steps by distance 5 and one or zero step by smaller distance. Answer equals to Solution 15550796617B - ChocolateWe are given array which contains only ones and zeroes. We must divide it on parts with only one 1.Tricky case: when array contains only zeroes answer equals to 0.In general. Between two adjacent ones we must have only one separation. So, answer equals to product of values posi - posi - 1 where posi is position of i-th one.Bonus: what's the maximal possible answer for n < 100?Solution 15550806617C - Watering FlowersFirst radius equals to zero or distance from first fountain to some flower. Let's iterate over this numbers. Second radius equals to maximal distance from second fountain to flower which doesn't belong to circle with first radius. Now we should choose variant with minimal r12 + r22.Bonus: It's O(n2) solution. Can you solve problem in O(nlogn)?Solution O(n2) 15550812Solution O(nlogn) 15550822617D - PolylineAnswer equals to one if all coordinates x or y of points are same.When answer equals to two? Let's iterate over all pairs of points. Let first point in pair is beginning of polyline, second point is end. Only one or two such polylines with answer two exist. If third point is on the polyline it belongs to rectangle with corners in first two points. We can just check it.Else answer equals to three. We can build vertical lines which contains the most left and the most right point and horizontal line through third point. If we erase some excess rays we will get polyline.Solution 15550843617E - XOR and Favorite NumberWe have array a.Let's calculate array pref (pref[0] = 0, ).Xor of subarray a[l...r] equals to .So query (l, r) is counting number of pairs i, j (l - 1 ≤ i < j ≤ r) .Let we know answer for query (l, r) and know for all v cnt[v] — count of v in a[l - 1...r]. We can update in O(1) answer and cnt if we move left or right border of query on 1. So we can solve problem offline in with sqrt-decomposion (Mo's algorithm).Solution 15550846",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 617\\s*A"
          },
          "content_length": 2093
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 1",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 2",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 3",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 4",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 5",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 6",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 7",
          "code": "vector<int> a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 8",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 9",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "sum = r1^2 + r2^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "dist.push_back({0, 0})",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "A     B\n    -----.-----.\n   |\n   |\n   . C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string x_str = inf.readToken(\"(?:1000000|[1-9][0-9]{0,5})\", \"x\");\n    inf.readEoln();\n    inf.readEof();\n\n    int x = stoi(x_str);\n    ensuref(1 <= x && x <= 1000000, \"x must be between 1 and 1,000,000\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string x_str = inf.readToken(\"(?:1000000|[1-9][0-9]{0,5})\", \"x\");\n    inf.readEoln();\n    inf.readEof();\n\n    int x = stoi(x_str);\n    ensuref(1 <= x && x <= 1000000, \"x must be between 1 and 1,000,000\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string x_str = inf.readToken(\"(?:1000000|[1-9][0-9]{0,5})\", \"x\");\n    inf.readEoln();\n    inf.readEof();\n\n    int x = stoi(x_str);\n    ensuref(1 <= x && x <= 1000000, \"x must be between 1 and 1,000,000\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int min_x = opt<int>(\"min_x\", 1);\n    int max_x = opt<int>(\"max_x\", 1000000);\n    string type = opt<string>(\"type\", \"random\"); // default type is random\n\n    int x;\n    \n    if (type == \"min\") {\n        x = min_x;\n    } else if (type == \"max\") {\n        x = max_x;\n    } else if (type == \"edge\") {\n        // Generate test cases where x is close to min_x or max_x\n        int options[] = {min_x, min_x + 1, max_x - 1, max_x};\n        x = options[rnd.next(4)];\n    } else if (type == \"small\") {\n        x = rnd.next(min_x, min(max_x, 10));\n    } else if (type == \"medium\") {\n        x = rnd.next(max(min_x, 10), min(max_x, 1000));\n    } else if (type == \"large\") {\n        x = rnd.next(max(min_x, 100000), max_x);\n    } else if (type == \"random_mod_5\") {\n        // Generate x such that x mod 5 is random\n        x = rnd.next(min_x, max_x);\n    } else if (type == \"mod_5_eq_0\") {\n        // x divisible by 5\n        int min_div = (min_x + 4) / 5;\n        int max_div = max_x / 5;\n        if (min_div > max_div) min_div = max_div; // Adjust if out of range\n        x = rnd.next(min_div, max_div) * 5;\n    } else if (type == \"mod_5_eq_1\") {\n        int min_div = (min_x + 4) / 5;\n        int max_div = (max_x - 1) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 1;\n    } else if (type == \"mod_5_eq_2\") {\n        int min_div = (min_x + 3) / 5;\n        int max_div = (max_x - 2) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 2;\n    } else if (type == \"mod_5_eq_3\") {\n        int min_div = (min_x + 2) / 5;\n        int max_div = (max_x - 3) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 3;\n    } else if (type == \"mod_5_eq_4\") {\n        int min_div = (min_x + 1) / 5;\n        int max_div = (max_x - 4) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 4;\n    } else {\n        // Random x between min_x and max_x\n        x = rnd.next(min_x, max_x);\n    }\n    \n    // Ensure x is within [min_x, max_x]\n    x = max(min_x, min(max_x, x));\n\n    // Output x\n    printf(\"%d\\n\", x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int min_x = opt<int>(\"min_x\", 1);\n    int max_x = opt<int>(\"max_x\", 1000000);\n    string type = opt<string>(\"type\", \"random\"); // default type is random\n\n    int x;\n    \n    if (type == \"min\") {\n        x = min_x;\n    } else if (type == \"max\") {\n        x = max_x;\n    } else if (type == \"edge\") {\n        // Generate test cases where x is close to min_x or max_x\n        int options[] = {min_x, min_x + 1, max_x - 1, max_x};\n        x = options[rnd.next(4)];\n    } else if (type == \"small\") {\n        x = rnd.next(min_x, min(max_x, 10));\n    } else if (type == \"medium\") {\n        x = rnd.next(max(min_x, 10), min(max_x, 1000));\n    } else if (type == \"large\") {\n        x = rnd.next(max(min_x, 100000), max_x);\n    } else if (type == \"random_mod_5\") {\n        // Generate x such that x mod 5 is random\n        x = rnd.next(min_x, max_x);\n    } else if (type == \"mod_5_eq_0\") {\n        // x divisible by 5\n        int min_div = (min_x + 4) / 5;\n        int max_div = max_x / 5;\n        if (min_div > max_div) min_div = max_div; // Adjust if out of range\n        x = rnd.next(min_div, max_div) * 5;\n    } else if (type == \"mod_5_eq_1\") {\n        int min_div = (min_x + 4) / 5;\n        int max_div = (max_x - 1) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 1;\n    } else if (type == \"mod_5_eq_2\") {\n        int min_div = (min_x + 3) / 5;\n        int max_div = (max_x - 2) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 2;\n    } else if (type == \"mod_5_eq_3\") {\n        int min_div = (min_x + 2) / 5;\n        int max_div = (max_x - 3) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 3;\n    } else if (type == \"mod_5_eq_4\") {\n        int min_div = (min_x + 1) / 5;\n        int max_div = (max_x - 4) / 5;\n        if (min_div > max_div) min_div = max_div;\n        x = rnd.next(min_div, max_div) * 5 + 4;\n    } else {\n        // Random x between min_x and max_x\n        x = rnd.next(min_x, max_x);\n    }\n    \n    // Ensure x is within [min_x, max_x]\n    x = max(min_x, min(max_x, x));\n\n    // Output x\n    printf(\"%d\\n\", x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -min_x 1 -max_x 1 -type min\n./gen -min_x 1000000 -max_x 1000000 -type max\n\n./gen -min_x 1 -max_x 10 -type edge\n./gen -min_x 999990 -max_x 1000000 -type edge\n\n./gen -min_x 1 -max_x 10 -type small\n./gen -min_x 1 -max_x 20 -type small\n./gen -min_x 1 -max_x 50 -type small\n\n./gen -min_x 1 -max_x 1000 -type medium\n./gen -min_x 500 -max_x 1500 -type medium\n\n./gen -min_x 100000 -max_x 200000 -type large\n./gen -min_x 800000 -max_x 1000000 -type large\n\n./gen -min_x 1 -max_x 1000000 -type random\n./gen -min_x 1 -max_x 100000 -type random\n./gen -min_x 500000 -max_x 600000 -type random\n\n./gen -min_x 1 -max_x 1000000 -type mod_5_eq_0\n./gen -min_x 1 -max_x 1000000 -type mod_5_eq_1\n./gen -min_x 1 -max_x 1000000 -type mod_5_eq_2\n./gen -min_x 1 -max_x 1000000 -type mod_5_eq_3\n./gen -min_x 1 -max_x 1000000 -type mod_5_eq_4\n\n./gen -min_x 1 -max_x 1000 -type mod_5_eq_0\n./gen -min_x 1 -max_x 1000 -type mod_5_eq_1\n./gen -min_x 1 -max_x 1000 -type mod_5_eq_2\n./gen -min_x 1 -max_x 1000 -type mod_5_eq_3\n./gen -min_x 1 -max_x 1000 -type mod_5_eq_4\n\n./gen -min_x 999995 -max_x 1000000 -type mod_5_eq_0\n./gen -min_x 999996 -max_x 1000000 -type mod_5_eq_1\n./gen -min_x 999997 -max_x 1000000 -type mod_5_eq_2\n./gen -min_x 999998 -max_x 1000000 -type mod_5_eq_3\n./gen -min_x 999999 -max_x 1000000 -type mod_5_eq_4\n\n./gen -min_x 1 -max_x 1 -type random\n./gen -min_x 1000000 -max_x 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:40.050281",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "617/B",
      "title": "B. Chocolate",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 100) — the number of pieces in the chocolate bar.The second line contains n integers ai (0 ≤ ai ≤ 1), where 0 represents a piece without the nut and 1 stands for a piece with the nut.",
      "output_spec": "OutputPrint the number of ways to break the chocolate into multiple parts so that each part would contain exactly one nut.",
      "sample_tests": "ExamplesInputCopy30 1 0OutputCopy1InputCopy51 0 1 0 1OutputCopy4",
      "description": "B. Chocolate\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 100) — the number of pieces in the chocolate bar.The second line contains n integers ai (0 ≤ ai ≤ 1), where 0 represents a piece without the nut and 1 stands for a piece with the nut.\n\nOutputPrint the number of ways to break the chocolate into multiple parts so that each part would contain exactly one nut.\n\nInputCopy30 1 0OutputCopy1InputCopy51 0 1 0 1OutputCopy4\n\nInputCopy30 1 0\n\nOutputCopy1\n\nInputCopy51 0 1 0 1\n\nOutputCopy4\n\nNoteIn the first sample there is exactly one nut, so the number of ways equals 1 — Bob shouldn't make any breaks.In the second sample you can break the bar in four ways:10|10|11|010|110|1|011|01|01",
      "solutions": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces",
          "content": "Hi!Tomorrow, on 23rd of January at 18:35 MSK Codeforces Round #340 (Div. 2) will take place. It's my first round, hope you enjoy the problems.Thanks to GlebsHP for his help in preparing the problems, Delinur for translations of statements and MikeMirzayanov for Codeforces and Polygon.Good luck!UPD Scoring 500-1000-1250-1750-2750UPD EditorialUPD Congrats to winners!Div. 2 AReesha kpw29 I_love_Varechka zhaoxinyi thatday Div. 1 anta dreamoon_love_AA uwi Um_nik I_love_Tanya_Romanova",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22950",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 483
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces",
          "content": "617A - ElephantIt's optimal to do the biggest possible step everytime. So elephant should do several steps by distance 5 and one or zero step by smaller distance. Answer equals to Solution 15550796617B - ChocolateWe are given array which contains only ones and zeroes. We must divide it on parts with only one 1.Tricky case: when array contains only zeroes answer equals to 0.In general. Between two adjacent ones we must have only one separation. So, answer equals to product of values posi - posi - 1 where posi is position of i-th one.Bonus: what's the maximal possible answer for n < 100?Solution 15550806617C - Watering FlowersFirst radius equals to zero or distance from first fountain to some flower. Let's iterate over this numbers. Second radius equals to maximal distance from second fountain to flower which doesn't belong to circle with first radius. Now we should choose variant with minimal r12 + r22.Bonus: It's O(n2) solution. Can you solve problem in O(nlogn)?Solution O(n2) 15550812Solution O(nlogn) 15550822617D - PolylineAnswer equals to one if all coordinates x or y of points are same.When answer equals to two? Let's iterate over all pairs of points. Let first point in pair is beginning of polyline, second point is end. Only one or two such polylines with answer two exist. If third point is on the polyline it belongs to rectangle with corners in first two points. We can just check it.Else answer equals to three. We can build vertical lines which contains the most left and the most right point and horizontal line through third point. If we erase some excess rays we will get polyline.Solution 15550843617E - XOR and Favorite NumberWe have array a.Let's calculate array pref (pref[0] = 0, ).Xor of subarray a[l...r] equals to .So query (l, r) is counting number of pairs i, j (l - 1 ≤ i < j ≤ r) .Let we know answer for query (l, r) and know for all v cnt[v] — count of v in a[l - 1...r]. We can update in O(1) answer and cnt if we move left or right border of query on 1. So we can solve problem offline in with sqrt-decomposion (Mo's algorithm).Solution 15550846",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 617\\s*B"
          },
          "content_length": 2093
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 1",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 2",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 3",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 4",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 5",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 6",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 7",
          "code": "vector<int> a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 8",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 9",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "sum = r1^2 + r2^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "dist.push_back({0, 0})",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "A     B\n    -----.-----.\n   |\n   |\n   . C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n, 0); // initialize all zeros\n\n    if (type == \"no_nut\") {\n        // All zeros, no nuts\n    } else if (type == \"single_nut_begin\") {\n        a[0] = 1; // Nut at the beginning\n    } else if (type == \"single_nut_end\") {\n        a[n-1] = 1; // Nut at the end\n    } else if (type == \"single_nut_middle\") {\n        a[n/2] = 1; // Nut in the middle\n    } else if (type == \"all_nuts\") {\n        // All ones, every piece has a nut\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating\") {\n        // Alternating nuts and no nuts\n        for(int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"max_distance\") {\n        // Nuts at the first and last positions\n        a[0] = 1;\n        a[n-1] = 1;\n    } else if (type == \"adjacent_nuts\") {\n        // Nuts are adjacent in a random position\n        int k = rnd.next(2, n); // number of adjacent nuts, at least 2\n        int start = rnd.next(0, n - k); // start position of nuts\n        for(int i = start; i < start + k; ++i)\n            a[i] = 1;\n    } else { // default is \"random\"\n        // Random placement of nuts\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n, 0); // initialize all zeros\n\n    if (type == \"no_nut\") {\n        // All zeros, no nuts\n    } else if (type == \"single_nut_begin\") {\n        a[0] = 1; // Nut at the beginning\n    } else if (type == \"single_nut_end\") {\n        a[n-1] = 1; // Nut at the end\n    } else if (type == \"single_nut_middle\") {\n        a[n/2] = 1; // Nut in the middle\n    } else if (type == \"all_nuts\") {\n        // All ones, every piece has a nut\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating\") {\n        // Alternating nuts and no nuts\n        for(int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"max_distance\") {\n        // Nuts at the first and last positions\n        a[0] = 1;\n        a[n-1] = 1;\n    } else if (type == \"adjacent_nuts\") {\n        // Nuts are adjacent in a random position\n        int k = rnd.next(2, n); // number of adjacent nuts, at least 2\n        int start = rnd.next(0, n - k); // start position of nuts\n        for(int i = start; i < start + k; ++i)\n            a[i] = 1;\n    } else { // default is \"random\"\n        // Random placement of nuts\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type no_nut\n./gen -n 1 -type single_nut_begin\n\n./gen -n 2 -type no_nut\n./gen -n 2 -type single_nut_begin\n./gen -n 2 -type single_nut_end\n\n./gen -n 3 -type single_nut_middle\n./gen -n 3 -type all_nuts\n\n./gen -n 4 -type alternating\n./gen -n 5 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type max_distance\n./gen -n 10 -type adjacent_nuts\n\n./gen -n 20 -type random\n./gen -n 30 -type random\n\n./gen -n 50 -type no_nut\n./gen -n 50 -type all_nuts\n\n./gen -n 60 -type random\n./gen -n 70 -type random\n\n./gen -n 80 -type random\n./gen -n 90 -type random\n\n./gen -n 100 -type random\n./gen -n 100 -type single_nut_begin\n./gen -n 100 -type single_nut_end\n./gen -n 100 -type single_nut_middle\n./gen -n 100 -type max_distance\n./gen -n 100 -type adjacent_nuts\n./gen -n 100 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:41.776887",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "617/C",
      "title": "C. Поливка цветов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находятся пять целых чисел n, x1, y1, x2, y2 (1 ≤ n ≤ 2000,  - 107 ≤ x1, y1, x2, y2 ≤ 107) — количество цветов на клумбе и координаты первого и второго фонтанчиков соответственно.Далее идут n строк. В i-й из них записаны два целых числа xi и yi ( - 107 ≤ xi, yi ≤ 107) — координаты i-го цветка.Гарантируется, что все n + 2 точки во входных данных различны.",
      "output_spec": "Выходные данныеВыведите минимально возможное значение r12 + r22. Обратите внимание, что в данной задаче оптимальный ответ всегда выражается целым числом.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 -1 0 5 30 25 2Выходные данныеСкопировать6Входные данныеСкопировать4 0 0 5 09 48 3-1 01 4Выходные данныеСкопировать33",
      "description": "C. Поливка цветов\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находятся пять целых чисел n, x1, y1, x2, y2 (1 ≤ n ≤ 2000,  - 107 ≤ x1, y1, x2, y2 ≤ 107) — количество цветов на клумбе и координаты первого и второго фонтанчиков соответственно.Далее идут n строк. В i-й из них записаны два целых числа xi и yi ( - 107 ≤ xi, yi ≤ 107) — координаты i-го цветка.Гарантируется, что все n + 2 точки во входных данных различны.\n\nВходные данные\n\nВыходные данныеВыведите минимально возможное значение r12 + r22. Обратите внимание, что в данной задаче оптимальный ответ всегда выражается целым числом.\n\nВыходные данные\n\nВходные данныеСкопировать2 -1 0 5 30 25 2Выходные данныеСкопировать6Входные данныеСкопировать4 0 0 5 09 48 3-1 01 4Выходные данныеСкопировать33\n\nВходные данныеСкопировать2 -1 0 5 30 25 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 0 0 5 09 48 3-1 01 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать33\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый пример (r12 = 5, r22 = 1):  Второй пример (r12 = 1, r22 = 32):",
      "solutions": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces",
          "content": "Привет!Завтра, 23 января в 18:35 MSK состоится Codeforces Round #340 (Div. 2). Это мой первый раунд, надеюсь, вам понравятся задачи.Спасибо GlebsHP за помощь при подготовке задач, Delinur за перевод условий и MikeMirzayanov за Codeforces и Polygon.Всем удачи!UPD Разбалловка 500-1000-1250-1750-2750UPD РазборUPD Поздравляем победителей!Div. 2 AReesha kpw29 I_love_Varechka zhaoxinyi thatday Div. 1 anta dreamoon_love_AA uwi Um_nik I_love_Tanya_Romanova",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22950",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 452
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces",
          "content": "617A - СлоникОптимально делать наибольший возможный шаг каждый раз. Поэтому слоник должен сделать сначала некоторое количество шагов на расстояние 5, а затем один или ноль шагов на меньшее расстояние. Следовательно, ответ равен .Решение 15550796617B - ШоколадНам дан массив, состоящий только из нулей и единиц. Мы должны разделить его на части, в каждой из которых ровно одна единица.Особый случай: когда массив состоит только из нулей ответ равен нулю.Рассмотрим общий случай. Во-первых нули на префиксе относятся к первому куску, нули на суффиксе относятся ко второму куску. Во-вторых, между каждой парой соседних единиц должно быть одно и только одно разделение частей. Между соседними единицами с индексами a < b всего b - a вариантов разделения. Поэтому мы должны перемножить эти значения для всех пар соседних единиц.Бонус: каким является максимальный ответ при n ≤ 100?Решение 15550806617C - Поливка цветовПервый радиус равен нулю или расстоянию от первого фонтана до какого-то цветка. Переберем все эти числа. Второй радиус будет равен максимальному из расстояний от второго фонтана до цветка, который не принадлежит кругу с первым радиусом. Теперь мы должны выбрать вариант с минимальным r12 + r22Бонус: Я описал решение за O(n2). Можете ли вы решить задачу за O(nlogn)?Решение за O(n2) 15550812Решение за O(nlogn) 15550822617D - ЛоманаяОтвет равен одному, когда все координаты x или все координаты y совпадают.Когда ответ равен двум? Переберем все пары точек. Пусть первая точка является началом ломаной, вторая концом ломаной. Только одна или две таких ломаных с двумя звеньями существуют. Они образуют прямоугольник с противоположными углами в первой и второй точке. Мы можем просто проверить принадлежность третьей точки прямоугольнику.Иначе ответ всегда равен трем. Давайте построим вертикальные прямые через самую левую и через самую правую точки. Через третью точку построим горизонтальную прямую. Теперь, если мы удалим некоторые лишние лучи, получим подходящую ломаную.Решение 15550843617E - XOR и любимое числоУ нас есть массив aДавайте посчитаем массив (, ).Xor подмассива равен .Теперь запрос (l, r) заключается в подсчете количества пар i, j (l - 1 ≤ i < j ≤ r) .Пусть мы знаем ответ на запрос (l, r) и знаем для всех v cnt[v] — количество вхождений v в .Мы можем обновить за O(1) ответ и cnt если мы изменим правую или левую границу запроса на 1.Поэтому мы можем решить задачу оффлайн за с помощью корневой эвристики (алгоритм Мо).Решение 15550846",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 617\\s*C"
          },
          "content_length": 2470
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 1",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 2",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 3",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 4",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 5",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 6",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 7",
          "code": "vector<int> a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 8",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 9",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 10",
          "code": "-931665727 768789996\n234859675 808326671\n-931665727 879145023",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 11",
          "code": "-931665727 768789996\n234859675 808326671\n-931665727 879145023",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "sum = r1^2 + r2^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "dist.push_back({0, 0})",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "A     B\n    -----.-----.\n   |\n   |\n   . C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int x1 = inf.readInt(-10000000, 10000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000000, 10000000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000000, 10000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000000, 10000000, \"y2\");\n    inf.readEoln();\n\n    set<pair<int, int> > points;\n    points.insert(make_pair(x1, y1));\n    points.insert(make_pair(x2, y2));\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000000, 10000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000000, 10000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int x1 = inf.readInt(-10000000, 10000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000000, 10000000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000000, 10000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000000, 10000000, \"y2\");\n    inf.readEoln();\n\n    set<pair<int, int> > points;\n    points.insert(make_pair(x1, y1));\n    points.insert(make_pair(x2, y2));\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000000, 10000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000000, 10000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int x1 = inf.readInt(-10000000, 10000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000000, 10000000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000000, 10000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000000, 10000000, \"y2\");\n    inf.readEoln();\n\n    set<pair<int, int> > points;\n    points.insert(make_pair(x1, y1));\n    points.insert(make_pair(x2, y2));\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000000, 10000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000000, 10000000, \"yi\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int COORD_MIN = -10000000;\n    const int COORD_MAX = 10000000;\n\n    set<pair<int, int>> points; // To keep track of used positions\n\n    // Generate fountains\n    int x1, y1, x2, y2;\n\n    do {\n        x1 = rnd.next(COORD_MIN, COORD_MAX);\n        y1 = rnd.next(COORD_MIN, COORD_MAX);\n    } while (points.count(make_pair(x1, y1)));\n    points.insert(make_pair(x1, y1));\n\n    do {\n        x2 = rnd.next(COORD_MIN, COORD_MAX);\n        y2 = rnd.next(COORD_MIN, COORD_MAX);\n    } while (points.count(make_pair(x2, y2)) || (x2 == x1 && y2 == y1));\n    points.insert(make_pair(x2, y2));\n\n    vector<pair<int, int>> flowers;\n\n    if (type == \"random\") {\n        // Generate random positions for flowers\n        while ((int)flowers.size() < n) {\n            int xi = rnd.next(COORD_MIN, COORD_MAX);\n            int yi = rnd.next(COORD_MIN, COORD_MAX);\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"cluster1\") {\n        // Flowers clustered around fountain 1\n        int radius = COORD_MAX / 1000; // Small radius\n        while ((int)flowers.size() < n) {\n            int xi = x1 + rnd.next(-radius, radius);\n            int yi = y1 + rnd.next(-radius, radius);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"cluster2\") {\n        // Flowers clustered around fountain 2\n        int radius = COORD_MAX / 1000; // Small radius\n        while ((int)flowers.size() < n) {\n            int xi = x2 + rnd.next(-radius, radius);\n            int yi = y2 + rnd.next(-radius, radius);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"line\") {\n        // Flowers along the line between fountains\n        while ((int)flowers.size() < n) {\n            double t = rnd.next(0.0, 1.0);\n            int xi = (int)round(x1 + t * (x2 - x1));\n            int yi = (int)round(y1 + t * (y2 - y1));\n            xi += rnd.next(-10, 10); // Small deviation\n            yi += rnd.next(-10, 10);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"same_point\") {\n        // All flowers at the same point (ensure it's not overlapping with fountains)\n        int xi, yi;\n        do {\n            xi = rnd.next(COORD_MIN, COORD_MAX);\n            yi = rnd.next(COORD_MIN, COORD_MAX);\n        } while (points.count(make_pair(xi, yi)));\n        for (int i = 0; i < n; ++i) {\n            flowers.push_back(make_pair(xi, yi));\n        }\n        points.insert(make_pair(xi, yi));\n    } else if (type == \"max_distance\") {\n        // Flowers at maximal distance from fountains\n        while ((int)flowers.size() < n) {\n            int xi = (x1 < 0 ? COORD_MAX : COORD_MIN) + rnd.next(-1000, 1000);\n            int yi = (y1 < 0 ? COORD_MAX : COORD_MIN) + rnd.next(-1000, 1000);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"worst_case\") {\n        // Coordinates near integer limits to test for overflows\n        while ((int)flowers.size() < n) {\n            int xi = COORD_MAX - rnd.next(0, 1000);\n            int yi = COORD_MAX - rnd.next(0, 1000);\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else {\n        // Default to random\n        while ((int)flowers.size() < n) {\n            int xi = rnd.next(COORD_MIN, COORD_MAX);\n            int yi = rnd.next(COORD_MIN, COORD_MAX);\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d %d %d\\n\", n, x1, y1, x2, y2);\n    for (auto p : flowers) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int COORD_MIN = -10000000;\n    const int COORD_MAX = 10000000;\n\n    set<pair<int, int>> points; // To keep track of used positions\n\n    // Generate fountains\n    int x1, y1, x2, y2;\n\n    do {\n        x1 = rnd.next(COORD_MIN, COORD_MAX);\n        y1 = rnd.next(COORD_MIN, COORD_MAX);\n    } while (points.count(make_pair(x1, y1)));\n    points.insert(make_pair(x1, y1));\n\n    do {\n        x2 = rnd.next(COORD_MIN, COORD_MAX);\n        y2 = rnd.next(COORD_MIN, COORD_MAX);\n    } while (points.count(make_pair(x2, y2)) || (x2 == x1 && y2 == y1));\n    points.insert(make_pair(x2, y2));\n\n    vector<pair<int, int>> flowers;\n\n    if (type == \"random\") {\n        // Generate random positions for flowers\n        while ((int)flowers.size() < n) {\n            int xi = rnd.next(COORD_MIN, COORD_MAX);\n            int yi = rnd.next(COORD_MIN, COORD_MAX);\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"cluster1\") {\n        // Flowers clustered around fountain 1\n        int radius = COORD_MAX / 1000; // Small radius\n        while ((int)flowers.size() < n) {\n            int xi = x1 + rnd.next(-radius, radius);\n            int yi = y1 + rnd.next(-radius, radius);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"cluster2\") {\n        // Flowers clustered around fountain 2\n        int radius = COORD_MAX / 1000; // Small radius\n        while ((int)flowers.size() < n) {\n            int xi = x2 + rnd.next(-radius, radius);\n            int yi = y2 + rnd.next(-radius, radius);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"line\") {\n        // Flowers along the line between fountains\n        while ((int)flowers.size() < n) {\n            double t = rnd.next(0.0, 1.0);\n            int xi = (int)round(x1 + t * (x2 - x1));\n            int yi = (int)round(y1 + t * (y2 - y1));\n            xi += rnd.next(-10, 10); // Small deviation\n            yi += rnd.next(-10, 10);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"same_point\") {\n        // All flowers at the same point (ensure it's not overlapping with fountains)\n        int xi, yi;\n        do {\n            xi = rnd.next(COORD_MIN, COORD_MAX);\n            yi = rnd.next(COORD_MIN, COORD_MAX);\n        } while (points.count(make_pair(xi, yi)));\n        for (int i = 0; i < n; ++i) {\n            flowers.push_back(make_pair(xi, yi));\n        }\n        points.insert(make_pair(xi, yi));\n    } else if (type == \"max_distance\") {\n        // Flowers at maximal distance from fountains\n        while ((int)flowers.size() < n) {\n            int xi = (x1 < 0 ? COORD_MAX : COORD_MIN) + rnd.next(-1000, 1000);\n            int yi = (y1 < 0 ? COORD_MAX : COORD_MIN) + rnd.next(-1000, 1000);\n            if (xi < COORD_MIN || xi > COORD_MAX || yi < COORD_MIN || yi > COORD_MAX) continue;\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else if (type == \"worst_case\") {\n        // Coordinates near integer limits to test for overflows\n        while ((int)flowers.size() < n) {\n            int xi = COORD_MAX - rnd.next(0, 1000);\n            int yi = COORD_MAX - rnd.next(0, 1000);\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    } else {\n        // Default to random\n        while ((int)flowers.size() < n) {\n            int xi = rnd.next(COORD_MIN, COORD_MAX);\n            int yi = rnd.next(COORD_MIN, COORD_MAX);\n            if (!points.count(make_pair(xi, yi))) {\n                points.insert(make_pair(xi, yi));\n                flowers.push_back(make_pair(xi, yi));\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d %d %d\\n\", n, x1, y1, x2, y2);\n    for (auto p : flowers) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_point\n./gen -n 1 -type cluster1\n\n./gen -n 2 -type random\n./gen -n 2 -type same_point\n./gen -n 2 -type cluster2\n\n./gen -n 5 -type random\n./gen -n 5 -type line\n./gen -n 5 -type max_distance\n\n./gen -n 10 -type random\n./gen -n 10 -type cluster1\n./gen -n 10 -type cluster2\n./gen -n 10 -type line\n./gen -n 10 -type same_point\n./gen -n 10 -type worst_case\n\n./gen -n 50 -type random\n./gen -n 50 -type line\n./gen -n 50 -type cluster1\n./gen -n 50 -type cluster2\n\n./gen -n 100 -type random\n./gen -n 100 -type cluster1\n./gen -n 100 -type cluster2\n./gen -n 100 -type line\n./gen -n 100 -type same_point\n\n./gen -n 200 -type random\n./gen -n 200 -type line\n./gen -n 200 -type cluster1\n./gen -n 200 -type cluster2\n\n./gen -n 500 -type random\n./gen -n 500 -type max_distance\n./gen -n 500 -type worst_case\n\n./gen -n 1000 -type random\n./gen -n 1000 -type cluster1\n./gen -n 1000 -type cluster2\n./gen -n 1000 -type line\n\n./gen -n 1999 -type random\n./gen -n 1999 -type line\n./gen -n 1999 -type cluster1\n./gen -n 1999 -type cluster2\n\n./gen -n 2000 -type random\n./gen -n 2000 -type cluster1\n./gen -n 2000 -type cluster2\n./gen -n 2000 -type max_distance\n./gen -n 2000 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:43.703481",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "617/D",
      "title": "D. Ломаная",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ каждой из трёх строк входных данных записано по два целых числа. В i-й строке находятся числа xi, yi ( - 109 ≤ xi, yi ≤ 109) — координаты i-й точки. Гарантируется, что все точки различны.",
      "output_spec": "Выходные данныеВыведите одно число — минимальное возможное количество звеньев подходящей ломаной.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 -11 11 2Выходные данныеСкопировать1Входные данныеСкопировать-1 -1-1 34 3Выходные данныеСкопировать2Входные данныеСкопировать1 12 33 2Выходные данныеСкопировать3",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ каждой из трёх строк входных данных записано по два целых числа. В i-й строке находятся числа xi, yi ( - 109 ≤ xi, yi ≤ 109) — координаты i-й точки. Гарантируется, что все точки различны.\n\nВходные данные\n\nВыходные данныеВыведите одно число — минимальное возможное количество звеньев подходящей ломаной.\n\nВыходные данные\n\nВходные данныеСкопировать1 -11 11 2Выходные данныеСкопировать1Входные данныеСкопировать-1 -1-1 34 3Выходные данныеСкопировать2Входные данныеСкопировать1 12 33 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать1 -11 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать-1 -1-1 34 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 12 33 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВариант ломаной в первом примере:  Вариант ломаной во втором примере:  Вариант ломаной в третьем примере:",
      "solutions": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces",
          "content": "Привет!Завтра, 23 января в 18:35 MSK состоится Codeforces Round #340 (Div. 2). Это мой первый раунд, надеюсь, вам понравятся задачи.Спасибо GlebsHP за помощь при подготовке задач, Delinur за перевод условий и MikeMirzayanov за Codeforces и Polygon.Всем удачи!UPD Разбалловка 500-1000-1250-1750-2750UPD РазборUPD Поздравляем победителей!Div. 2 AReesha kpw29 I_love_Varechka zhaoxinyi thatday Div. 1 anta dreamoon_love_AA uwi Um_nik I_love_Tanya_Romanova",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22950",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 452
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces",
          "content": "617A - СлоникОптимально делать наибольший возможный шаг каждый раз. Поэтому слоник должен сделать сначала некоторое количество шагов на расстояние 5, а затем один или ноль шагов на меньшее расстояние. Следовательно, ответ равен .Решение 15550796617B - ШоколадНам дан массив, состоящий только из нулей и единиц. Мы должны разделить его на части, в каждой из которых ровно одна единица.Особый случай: когда массив состоит только из нулей ответ равен нулю.Рассмотрим общий случай. Во-первых нули на префиксе относятся к первому куску, нули на суффиксе относятся ко второму куску. Во-вторых, между каждой парой соседних единиц должно быть одно и только одно разделение частей. Между соседними единицами с индексами a < b всего b - a вариантов разделения. Поэтому мы должны перемножить эти значения для всех пар соседних единиц.Бонус: каким является максимальный ответ при n ≤ 100?Решение 15550806617C - Поливка цветовПервый радиус равен нулю или расстоянию от первого фонтана до какого-то цветка. Переберем все эти числа. Второй радиус будет равен максимальному из расстояний от второго фонтана до цветка, который не принадлежит кругу с первым радиусом. Теперь мы должны выбрать вариант с минимальным r12 + r22Бонус: Я описал решение за O(n2). Можете ли вы решить задачу за O(nlogn)?Решение за O(n2) 15550812Решение за O(nlogn) 15550822617D - ЛоманаяОтвет равен одному, когда все координаты x или все координаты y совпадают.Когда ответ равен двум? Переберем все пары точек. Пусть первая точка является началом ломаной, вторая концом ломаной. Только одна или две таких ломаных с двумя звеньями существуют. Они образуют прямоугольник с противоположными углами в первой и второй точке. Мы можем просто проверить принадлежность третьей точки прямоугольнику.Иначе ответ всегда равен трем. Давайте построим вертикальные прямые через самую левую и через самую правую точки. Через третью точку построим горизонтальную прямую. Теперь, если мы удалим некоторые лишние лучи, получим подходящую ломаную.Решение 15550843617E - XOR и любимое числоУ нас есть массив aДавайте посчитаем массив (, ).Xor подмассива равен .Теперь запрос (l, r) заключается в подсчете количества пар i, j (l - 1 ≤ i < j ≤ r) .Пусть мы знаем ответ на запрос (l, r) и знаем для всех v cnt[v] — количество вхождений v в .Мы можем обновить за O(1) ответ и cnt если мы изменим правую или левую границу запроса на 1.Поэтому мы можем решить задачу оффлайн за с помощью корневой эвристики (алгоритм Мо).Решение 15550846",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 617\\s*D"
          },
          "content_length": 2470
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 1",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 2",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 3",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 4",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 5",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 6",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 7",
          "code": "vector<int> a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 8",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 9",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 10",
          "code": "-931665727 768789996\n234859675 808326671\n-931665727 879145023",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 11",
          "code": "-931665727 768789996\n234859675 808326671\n-931665727 879145023",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "sum = r1^2 + r2^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "dist.push_back({0, 0})",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "A     B\n    -----.-----.\n   |\n   |\n   . C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<pair<int,int>> points;\n\n    for (int i = 0; i < 3; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        auto p = make_pair(xi, yi);\n\n        ensuref(points.count(p) == 0, \"All points must be distinct\");\n\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<pair<int,int>> points;\n\n    for (int i = 0; i < 3; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        auto p = make_pair(xi, yi);\n\n        ensuref(points.count(p) == 0, \"All points must be distinct\");\n\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<pair<int,int>> points;\n\n    for (int i = 0; i < 3; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n\n        auto p = make_pair(xi, yi);\n\n        ensuref(points.count(p) == 0, \"All points must be distinct\");\n\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int64_t max_coord = opt<int64_t>(\"max_coord\", 1000000000);\n\n    // Coordinate range\n    int64_t min_coord = -max_coord;\n    \n    int64_t x1, y1, x2, y2, x3, y3;\n\n    if (type == \"aligned_x\" || type == \"aligned\") {\n        // All points share same y-coordinate\n        int64_t y = rnd.next(min_coord, max_coord);\n        set<int64_t> xs;\n        while ((int)xs.size() < 3) {\n            xs.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = xs.begin();\n        x1 = *it++; x2 = *it++; x3 = *it++;\n        y1 = y2 = y3 = y;\n    } else if (type == \"aligned_y\") {\n        // All points share same x-coordinate\n        int64_t x = rnd.next(min_coord, max_coord);\n        set<int64_t> ys;\n        while ((int)ys.size() < 3) {\n            ys.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = ys.begin();\n        y1 = *it++; y2 = *it++; y3 = *it++;\n        x1 = x2 = x3 = x;\n    } else if (type == \"two_same_x\") {\n        x1 = x2 = rnd.next(min_coord, max_coord);\n        do {\n            x3 = rnd.next(min_coord, max_coord);\n        } while (x3 == x1);\n        set<int64_t> ys;\n        while ((int)ys.size() < 3) {\n            ys.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = ys.begin();\n        y1 = *it++; y2 = *it++; y3 = *it++;\n    } else if (type == \"two_same_y\") {\n        y1 = y2 = rnd.next(min_coord, max_coord);\n        do {\n            y3 = rnd.next(min_coord, max_coord);\n        } while (y3 == y1);\n        set<int64_t> xs;\n        while ((int)xs.size() < 3) {\n            xs.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = xs.begin();\n        x1 = *it++; x2 = *it++; x3 = *it++;\n    } else if (type == \"minimal_1_segment\") {\n        // All points aligned along x or y axis\n        if (rnd.next(2) == 0) {\n            // aligned_x\n            int64_t y = rnd.next(min_coord, max_coord);\n            set<int64_t> xs;\n            while ((int)xs.size() < 3) {\n                xs.insert(rnd.next(min_coord, max_coord));\n            }\n            auto it = xs.begin();\n            x1 = *it++; x2 = *it++; x3 = *it++;\n            y1 = y2 = y3 = y;\n        } else {\n            // aligned_y\n            int64_t x = rnd.next(min_coord, max_coord);\n            set<int64_t> ys;\n            while ((int)ys.size() < 3) {\n                ys.insert(rnd.next(min_coord, max_coord));\n            }\n            auto it = ys.begin();\n            y1 = *it++; y2 = *it++; y3 = *it++;\n            x1 = x2 = x3 = x;\n        }\n    } else if (type == \"minimal_2_segments\") {\n        // Two points share x-coordinate, third shares y-coordinate with one of them\n        x1 = x2 = rnd.next(min_coord, max_coord);\n        do {\n            x3 = rnd.next(min_coord, max_coord);\n        } while (x3 == x1);\n        y1 = rnd.next(min_coord, max_coord);\n        do {\n            y2 = rnd.next(min_coord, max_coord);\n        } while (y2 == y1);\n        y3 = y2; // (x3, y3) shares y-coordinate with (x2, y2)\n    } else if (type == \"minimal_3_segments\") {\n        // Three points with distinct x and y coordinates\n        set<int64_t> xs, ys;\n        while ((int)xs.size() < 3) xs.insert(rnd.next(min_coord, max_coord));\n        while ((int)ys.size() < 3) ys.insert(rnd.next(min_coord, max_coord));\n        auto itx = xs.begin(); auto ity = ys.begin();\n        x1 = *itx++; x2 = *itx++; x3 = *itx++;\n        y1 = *ity++; y2 = *ity++; y3 = *ity++;\n    } else if (type == \"random\") {\n        // Random points\n        set<pair<int64_t, int64_t>> points;\n        while ((int)points.size() < 3) {\n            int64_t x = rnd.next(min_coord, max_coord);\n            int64_t y = rnd.next(min_coord, max_coord);\n            points.insert({x, y});\n        }\n        auto it = points.begin();\n        x1 = it->first; y1 = it->second; ++it;\n        x2 = it->first; y2 = it->second; ++it;\n        x3 = it->first; y3 = it->second;\n    } else {\n        // Default to random\n        set<pair<int64_t, int64_t>> points;\n        while ((int)points.size() < 3) {\n            int64_t x = rnd.next(min_coord, max_coord);\n            int64_t y = rnd.next(min_coord, max_coord);\n            points.insert({x, y});\n        }\n        auto it = points.begin();\n        x1 = it->first; y1 = it->second; ++it;\n        x2 = it->first; y2 = it->second; ++it;\n        x3 = it->first; y3 = it->second;\n    }\n\n    // Output the points\n    printf(\"%lld %lld\\n\", x1, y1);\n    printf(\"%lld %lld\\n\", x2, y2);\n    printf(\"%lld %lld\\n\", x3, y3);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int64_t max_coord = opt<int64_t>(\"max_coord\", 1000000000);\n\n    // Coordinate range\n    int64_t min_coord = -max_coord;\n    \n    int64_t x1, y1, x2, y2, x3, y3;\n\n    if (type == \"aligned_x\" || type == \"aligned\") {\n        // All points share same y-coordinate\n        int64_t y = rnd.next(min_coord, max_coord);\n        set<int64_t> xs;\n        while ((int)xs.size() < 3) {\n            xs.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = xs.begin();\n        x1 = *it++; x2 = *it++; x3 = *it++;\n        y1 = y2 = y3 = y;\n    } else if (type == \"aligned_y\") {\n        // All points share same x-coordinate\n        int64_t x = rnd.next(min_coord, max_coord);\n        set<int64_t> ys;\n        while ((int)ys.size() < 3) {\n            ys.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = ys.begin();\n        y1 = *it++; y2 = *it++; y3 = *it++;\n        x1 = x2 = x3 = x;\n    } else if (type == \"two_same_x\") {\n        x1 = x2 = rnd.next(min_coord, max_coord);\n        do {\n            x3 = rnd.next(min_coord, max_coord);\n        } while (x3 == x1);\n        set<int64_t> ys;\n        while ((int)ys.size() < 3) {\n            ys.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = ys.begin();\n        y1 = *it++; y2 = *it++; y3 = *it++;\n    } else if (type == \"two_same_y\") {\n        y1 = y2 = rnd.next(min_coord, max_coord);\n        do {\n            y3 = rnd.next(min_coord, max_coord);\n        } while (y3 == y1);\n        set<int64_t> xs;\n        while ((int)xs.size() < 3) {\n            xs.insert(rnd.next(min_coord, max_coord));\n        }\n        auto it = xs.begin();\n        x1 = *it++; x2 = *it++; x3 = *it++;\n    } else if (type == \"minimal_1_segment\") {\n        // All points aligned along x or y axis\n        if (rnd.next(2) == 0) {\n            // aligned_x\n            int64_t y = rnd.next(min_coord, max_coord);\n            set<int64_t> xs;\n            while ((int)xs.size() < 3) {\n                xs.insert(rnd.next(min_coord, max_coord));\n            }\n            auto it = xs.begin();\n            x1 = *it++; x2 = *it++; x3 = *it++;\n            y1 = y2 = y3 = y;\n        } else {\n            // aligned_y\n            int64_t x = rnd.next(min_coord, max_coord);\n            set<int64_t> ys;\n            while ((int)ys.size() < 3) {\n                ys.insert(rnd.next(min_coord, max_coord));\n            }\n            auto it = ys.begin();\n            y1 = *it++; y2 = *it++; y3 = *it++;\n            x1 = x2 = x3 = x;\n        }\n    } else if (type == \"minimal_2_segments\") {\n        // Two points share x-coordinate, third shares y-coordinate with one of them\n        x1 = x2 = rnd.next(min_coord, max_coord);\n        do {\n            x3 = rnd.next(min_coord, max_coord);\n        } while (x3 == x1);\n        y1 = rnd.next(min_coord, max_coord);\n        do {\n            y2 = rnd.next(min_coord, max_coord);\n        } while (y2 == y1);\n        y3 = y2; // (x3, y3) shares y-coordinate with (x2, y2)\n    } else if (type == \"minimal_3_segments\") {\n        // Three points with distinct x and y coordinates\n        set<int64_t> xs, ys;\n        while ((int)xs.size() < 3) xs.insert(rnd.next(min_coord, max_coord));\n        while ((int)ys.size() < 3) ys.insert(rnd.next(min_coord, max_coord));\n        auto itx = xs.begin(); auto ity = ys.begin();\n        x1 = *itx++; x2 = *itx++; x3 = *itx++;\n        y1 = *ity++; y2 = *ity++; y3 = *ity++;\n    } else if (type == \"random\") {\n        // Random points\n        set<pair<int64_t, int64_t>> points;\n        while ((int)points.size() < 3) {\n            int64_t x = rnd.next(min_coord, max_coord);\n            int64_t y = rnd.next(min_coord, max_coord);\n            points.insert({x, y});\n        }\n        auto it = points.begin();\n        x1 = it->first; y1 = it->second; ++it;\n        x2 = it->first; y2 = it->second; ++it;\n        x3 = it->first; y3 = it->second;\n    } else {\n        // Default to random\n        set<pair<int64_t, int64_t>> points;\n        while ((int)points.size() < 3) {\n            int64_t x = rnd.next(min_coord, max_coord);\n            int64_t y = rnd.next(min_coord, max_coord);\n            points.insert({x, y});\n        }\n        auto it = points.begin();\n        x1 = it->first; y1 = it->second; ++it;\n        x2 = it->first; y2 = it->second; ++it;\n        x3 = it->first; y3 = it->second;\n    }\n\n    // Output the points\n    printf(\"%lld %lld\\n\", x1, y1);\n    printf(\"%lld %lld\\n\", x2, y2);\n    printf(\"%lld %lld\\n\", x3, y3);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type aligned_x  -max_coord 10\n./gen -type aligned_y  -max_coord 10\n./gen -type two_same_x  -max_coord 10\n./gen -type two_same_y  -max_coord 10\n./gen -type minimal_1_segment  -max_coord 10\n./gen -type minimal_2_segments  -max_coord 10\n./gen -type minimal_3_segments  -max_coord 10\n./gen -type random  -max_coord 10\n\n./gen -type minimal_3_segments  -max_coord 1000000000\n./gen -type random  -max_coord 1000000000\n\n./gen -type aligned_x\n./gen -type aligned_y\n./gen -type two_same_x\n./gen -type two_same_y\n./gen -type minimal_2_segments\n./gen -type minimal_3_segments\n./gen -type random\n\n./gen -type aligned_x  -max_coord 1000000\n./gen -type two_same_x  -max_coord 1000000\n./gen -type minimal_1_segment  -max_coord 1000000\n./gen -type minimal_2_segments  -max_coord 1000000\n./gen -type minimal_3_segments  -max_coord 1000000\n./gen -type random  -max_coord 1000000\n\n./gen -type aligned_y  -max_coord 1000000000\n./gen -type two_same_y  -max_coord 1000000000\n./gen -type minimal_1_segment  -max_coord 1000000000\n./gen -type minimal_2_segments  -max_coord 1000000000\n\n./gen -type minimal_3_segments\n./gen -type random\n./gen -type minimal_3_segments\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:45.573252",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "617/E",
      "title": "E. XOR and Favorite Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n, m and k (1 ≤ n, m ≤ 100 000, 0 ≤ k ≤ 1 000 000) — the length of the array, the number of queries and Bob's favorite number respectively.The second line contains n integers ai (0 ≤ ai ≤ 1 000 000) — Bob's array.Then m lines follow. The i-th line contains integers li and ri (1 ≤ li ≤ ri ≤ n) — the parameters of the i-th query.",
      "output_spec": "OutputPrint m lines, answer the queries in the order they appear in the input.",
      "sample_tests": "ExamplesInputCopy6 2 31 2 1 1 0 31 63 5OutputCopy70InputCopy5 3 11 1 1 1 11 52 41 3OutputCopy944",
      "description": "E. XOR and Favorite Number\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers n, m and k (1 ≤ n, m ≤ 100 000, 0 ≤ k ≤ 1 000 000) — the length of the array, the number of queries and Bob's favorite number respectively.The second line contains n integers ai (0 ≤ ai ≤ 1 000 000) — Bob's array.Then m lines follow. The i-th line contains integers li and ri (1 ≤ li ≤ ri ≤ n) — the parameters of the i-th query.\n\nOutputPrint m lines, answer the queries in the order they appear in the input.\n\nInputCopy6 2 31 2 1 1 0 31 63 5OutputCopy70InputCopy5 3 11 1 1 1 11 52 41 3OutputCopy944\n\nInputCopy6 2 31 2 1 1 0 31 63 5\n\nOutputCopy70\n\nInputCopy5 3 11 1 1 1 11 52 41 3\n\nOutputCopy944\n\nNoteIn the first sample the suitable pairs of i and j for the first query are: (1, 2), (1, 4), (1, 5), (2, 3), (3, 6), (5, 6), (6, 6). Not a single of these pairs is suitable for the second query.In the second sample xor equals 1 for all subarrays of an odd length.",
      "solutions": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces",
          "content": "Hi!Tomorrow, on 23rd of January at 18:35 MSK Codeforces Round #340 (Div. 2) will take place. It's my first round, hope you enjoy the problems.Thanks to GlebsHP for his help in preparing the problems, Delinur for translations of statements and MikeMirzayanov for Codeforces and Polygon.Good luck!UPD Scoring 500-1000-1250-1750-2750UPD EditorialUPD Congrats to winners!Div. 2 AReesha kpw29 I_love_Varechka zhaoxinyi thatday Div. 1 anta dreamoon_love_AA uwi Um_nik I_love_Tanya_Romanova",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22950",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 483
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces",
          "content": "617A - ElephantIt's optimal to do the biggest possible step everytime. So elephant should do several steps by distance 5 and one or zero step by smaller distance. Answer equals to Solution 15550796617B - ChocolateWe are given array which contains only ones and zeroes. We must divide it on parts with only one 1.Tricky case: when array contains only zeroes answer equals to 0.In general. Between two adjacent ones we must have only one separation. So, answer equals to product of values posi - posi - 1 where posi is position of i-th one.Bonus: what's the maximal possible answer for n < 100?Solution 15550806617C - Watering FlowersFirst radius equals to zero or distance from first fountain to some flower. Let's iterate over this numbers. Second radius equals to maximal distance from second fountain to flower which doesn't belong to circle with first radius. Now we should choose variant with minimal r12 + r22.Bonus: It's O(n2) solution. Can you solve problem in O(nlogn)?Solution O(n2) 15550812Solution O(nlogn) 15550822617D - PolylineAnswer equals to one if all coordinates x or y of points are same.When answer equals to two? Let's iterate over all pairs of points. Let first point in pair is beginning of polyline, second point is end. Only one or two such polylines with answer two exist. If third point is on the polyline it belongs to rectangle with corners in first two points. We can just check it.Else answer equals to three. We can build vertical lines which contains the most left and the most right point and horizontal line through third point. If we erase some excess rays we will get polyline.Solution 15550843617E - XOR and Favorite NumberWe have array a.Let's calculate array pref (pref[0] = 0, ).Xor of subarray a[l...r] equals to .So query (l, r) is counting number of pairs i, j (l - 1 ≤ i < j ≤ r) .Let we know answer for query (l, r) and know for all v cnt[v] — count of v in a[l - 1...r]. We can update in O(1) answer and cnt if we move left or right border of query on 1. So we can solve problem offline in with sqrt-decomposion (Mo's algorithm).Solution 15550846",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 617\\s*E"
          },
          "content_length": 2093
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 1",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 2",
          "code": "0 0\n0 2\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 3",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 4",
          "code": "0 0\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 5",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 6",
          "code": "if x1 == x2 and (y3 == y1 or y3 == y2):\n    print(2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 7",
          "code": "vector<int> a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 8",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) - Codeforces - Code 9",
          "code": "100\n1 0 1 0 1 0 1 0...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22950",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "sum = r1^2 + r2^2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "dist.push_back({0, 0})",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #340 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "A     B\n    -----.-----.\n   |\n   |\n   . C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N_MAX = 100000;\n    const int M_MAX = 100000;\n    const int K_MAX = 1000000;\n    const int AI_MAX = 1000000;\n\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, M_MAX, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, K_MAX, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, AI_MAX, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N_MAX = 100000;\n    const int M_MAX = 100000;\n    const int K_MAX = 1000000;\n    const int AI_MAX = 1000000;\n\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, M_MAX, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, K_MAX, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, AI_MAX, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N_MAX = 100000;\n    const int M_MAX = 100000;\n    const int K_MAX = 1000000;\n    const int AI_MAX = 1000000;\n\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, M_MAX, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, K_MAX, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, AI_MAX, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n    \n    vector<int> a(n);\n    if (a_type == \"zeros\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (a_type == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (a_type == \"same\") {\n        int v = opt<int>(\"v\", 0); // default value\n        fill(a.begin(), a.end(), v);\n    } else if (a_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (a_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (a_type == \"random\") {\n        int max_ai = opt<int>(\"max_ai\", 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_ai);\n    } else if (a_type == \"random_small\") {\n        int max_ai = opt<int>(\"max_ai\", 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_ai);\n    } else if (a_type == \"pattern\") {\n        // Implement your specific pattern here\n        // Example: alternating between k and 0\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? k : 0;\n    }\n\n    vector<pair<int, int>> queries(m);\n    if (q_type == \"full\") {\n        for (int i = 0; i < m; ++i)\n            queries[i] = make_pair(1, n);\n    } else if (q_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (q_type == \"single\") {\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(1, n);\n            queries[i] = make_pair(idx, idx);\n        }\n    } else if (q_type == \"prefix\") {\n        for (int i = 0; i < m; ++i) {\n            int r = rnd.next(1, n);\n            queries[i] = make_pair(1, r);\n        }\n    } else if (q_type == \"suffix\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            queries[i] = make_pair(l, n);\n        }\n    } else if (q_type == \"overlapping\") {\n        int seg_size = max(1, n / m);\n        int overlap = max(1, seg_size / 2);\n        int start = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = start;\n            int r = min(n, start + seg_size - 1);\n            queries[i] = make_pair(l, r);\n            start = start + seg_size - overlap;\n            if (start > n) start = n;\n        }\n    } else if (q_type == \"non_overlapping\") {\n        int seg_size = max(1, n / m);\n        int start = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = start;\n            int r = min(n, start + seg_size - 1);\n            queries[i] = make_pair(l, r);\n            start = r + 1;\n            if (start > n) start = n;\n        }\n    } else if (q_type == \"random_big\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n    \n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n    \n    vector<int> a(n);\n    if (a_type == \"zeros\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (a_type == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (a_type == \"same\") {\n        int v = opt<int>(\"v\", 0); // default value\n        fill(a.begin(), a.end(), v);\n    } else if (a_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (a_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (a_type == \"random\") {\n        int max_ai = opt<int>(\"max_ai\", 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_ai);\n    } else if (a_type == \"random_small\") {\n        int max_ai = opt<int>(\"max_ai\", 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_ai);\n    } else if (a_type == \"pattern\") {\n        // Implement your specific pattern here\n        // Example: alternating between k and 0\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? k : 0;\n    }\n\n    vector<pair<int, int>> queries(m);\n    if (q_type == \"full\") {\n        for (int i = 0; i < m; ++i)\n            queries[i] = make_pair(1, n);\n    } else if (q_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (q_type == \"single\") {\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(1, n);\n            queries[i] = make_pair(idx, idx);\n        }\n    } else if (q_type == \"prefix\") {\n        for (int i = 0; i < m; ++i) {\n            int r = rnd.next(1, n);\n            queries[i] = make_pair(1, r);\n        }\n    } else if (q_type == \"suffix\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            queries[i] = make_pair(l, n);\n        }\n    } else if (q_type == \"overlapping\") {\n        int seg_size = max(1, n / m);\n        int overlap = max(1, seg_size / 2);\n        int start = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = start;\n            int r = min(n, start + seg_size - 1);\n            queries[i] = make_pair(l, r);\n            start = start + seg_size - overlap;\n            if (start > n) start = n;\n        }\n    } else if (q_type == \"non_overlapping\") {\n        int seg_size = max(1, n / m);\n        int start = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = start;\n            int r = min(n, start + seg_size - 1);\n            queries[i] = make_pair(l, r);\n            start = r + 1;\n            if (start > n) start = n;\n        }\n    } else if (q_type == \"random_big\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n    \n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size input\n./gen -n 1 -m 1 -k 0 -a_type zeros -q_type single\n\n# Maximal size input, all zeros, k=0\n./gen -n 100000 -m 100000 -k 0 -a_type zeros -q_type full\n\n# Maximal size input, all ones, k=1\n./gen -n 100000 -m 100000 -k 1 -a_type ones -q_type full\n\n# Maximal size input, random a_i, k=0, random queries\n./gen -n 100000 -m 100000 -k 0 -a_type random -q_type random\n\n# Maximal size input, random a_i, k=123456, random queries\n./gen -n 100000 -m 100000 -k 123456 -a_type random -q_type random\n\n# Maximal size input, random small a_i, k=10, random queries\n./gen -n 100000 -m 100000 -k 10 -a_type random_small -max_ai 10 -q_type random\n\n# Maximal size input, a_i increasing, k=0, random queries\n./gen -n 100000 -m 100000 -k 0 -a_type increasing -q_type random\n\n# Maximal size input, a_i decreasing, k=0, random queries\n./gen -n 100000 -m 100000 -k 0 -a_type decreasing -q_type random\n\n# Maximal size input, random a_i, k=0, single-element queries\n./gen -n 100000 -m 100000 -k 0 -a_type random -q_type single\n\n# Maximal size input, random a_i, k=0, prefix queries\n./gen -n 100000 -m 100000 -k 0 -a_type random -q_type prefix\n\n# Maximal size input, random a_i, k=0, suffix queries\n./gen -n 100000 -m 100000 -k 0 -a_type random -q_type suffix\n\n# Maximal size input, random a_i, k=12345, overlapping queries\n./gen -n 100000 -m 100000 -k 12345 -a_type random -q_type overlapping\n\n# Maximal size input, random a_i, k=12345, non-overlapping queries\n./gen -n 100000 -m 100000 -k 12345 -a_type random -q_type non_overlapping\n\n# Maximal size input, random a_i, k=1000000, maximum a_i values\n./gen -n 100000 -m 100000 -k 1000000 -a_type random -max_ai 1000000 -q_type random\n\n# Smaller input, random small a_i, k=5, random queries\n./gen -n 5000 -m 5000 -k 5 -a_type random_small -max_ai 5 -q_type random\n\n# Single-element array with high number of queries\n./gen -n 1 -m 100000 -k 0 -a_type random -q_type single\n\n# Large array with single query covering full range\n./gen -n 100000 -m 1 -k 0 -a_type random -q_type full\n\n# Medium-sized input with a pattern in a_i\n./gen -n 50000 -m 50000 -k 7 -a_type pattern -q_type random\n\n# Maximal size input, random a_i, k=0, large random ranges\n./gen -n 100000 -m 100000 -k 0 -a_type random -q_type random_big\n\n# Edge case: All a_i equal to k\n./gen -n 100000 -m 100000 -k 0 -a_type same -v 0 -q_type random\n\n# Edge case: Alternating a_i between k and 0\n./gen -n 100000 -m 100000 -k 1 -a_type pattern -q_type random\n\n# Maximal size input, random a_i, k=123456, full-range queries\n./gen -n 100000 -m 100000 -k 123456 -a_type random -max_ai 1000000 -q_type full\n\n# Minimal size input with n=2, m=2\n./gen -n 2 -m 2 -k 1 -a_type random -q_type random\n\n# Maximal size input, small random a_i, small k\n./gen -n 100000 -m 100000 -k 3 -a_type random_small -max_ai 5 -q_type random\n\n# Maximal input size, all a_i maximum value, k maximum value\n./gen -n 100000 -m 100000 -k 1000000 -a_type same -v 1000000 -q_type random\n\n# Maximal size input, zeros in a_i, single full-range query\n./gen -n 100000 -m 1 -k 0 -a_type zeros -q_type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:47.710649",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/A",
      "title": "A. Slime Combining",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input will contain a single integer, n (1 ≤ n ≤ 100 000).",
      "output_spec": "OutputOutput a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy2OutputCopy2InputCopy3OutputCopy2 1InputCopy8OutputCopy4",
      "description": "A. Slime Combining\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input will contain a single integer, n (1 ≤ n ≤ 100 000).\n\nOutputOutput a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.\n\nInputCopy1OutputCopy1InputCopy2OutputCopy2InputCopy3OutputCopy2 1InputCopy8OutputCopy4\n\nOutputCopy1\n\nOutputCopy2\n\nOutputCopy2 1\n\nOutputCopy4\n\nNoteIn the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.In the second sample, we perform the following steps:Initially we place a single slime in a row by itself. Thus, row is initially 1.Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.In the last sample, the steps look as follows:   1  2  2 1  3  3 1  3 2  3 2 1  4",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in a special Codeforces round. It will take place on 29 Jan, 17:05 UTC. It will not be a usual round. Thanks to Wunder Fund, the best participants will win prizes and souvenirs. Here are some words from Wunder Fund: Our company is situated in the center of Moscow. We are engaged in high-frequency trading — developing high-performance systems and algorithms for automated trading in financial markets. In this area algorithms and data structures (that you love to invent and implement) are vital. Our systems should process transactions in milliseconds! High-frequency trading is a continuous competition of the best programmers and mathematicians around the world. By joining us, you will become a part of this exciting challenge.We offer interesting and challenging tasks for the development of low latency for enthusiastic researchers and programmers. Flexible and no bureaucracy, decisions are taken quickly and implemented. We are a small team, so you will immediately become a significant part of it. Understand the economics and finance is not required, but the algorithms and data structures is what we need.Are Russian speaking and ready to live in Moscow? Join us! Visit our website for more information.We will be happy to give participants prizes and gifts: 1 place — PlayStation 4 2 place — Xbox One 3-5 places — Sega MegaDrive 16bit with games 1-50 places — Wunder Fund T-Shirts! 51-500 places — 50 T-Shirts to random participants! Interested in the work on Wunder Fund? I want to thank the following people for helping me with this round: GlebsHP for his help in reviewing problems and assistance in preparation for the round. LiChenKoh, AlexFetisov, and winger for testing problems. Delinur for translations. MikeMirzayanov for Codeforces and Polygon systems. and of course Wunder Fund for sponsoring the round. I hope to see you all at the round. Good luck and have fun! :)If you'd like some practice before the round, you can look over some of my past rounds that I've written (links here: A B C). I will try to give you all some more interesting problems to solve.UPD1: The round will be 2 hours and 7 problems. Unfortunately, there are some time conflicts, so we are unable to extend the duration of the round. The score distribution will be 500-1000-1500-1750-2500-2750-3500. Note that some problems that we thought are harder may actually be easier for you, so I encourage you to read all problems.UPD2: The editorial is published. Congratulations to the winners Egor Petr Um_nik RomaWhite Sampson",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2572
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100000); // default n is 100000\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // Optional parameter k\n\n    if (type == \"max_merge\") {\n        // If k is specified, use k, else find max k such that (1 << k) - 1 <= n\n        if (k != -1) {\n            n = (1 << k) - 1;\n            if (n > 100000) n = 100000;\n        } else {\n            k = 0;\n            while ((1 << k) - 1 <= n && (1 << k) - 1 <= 100000)\n                k++;\n            k--;\n            n = (1 << k) - 1;\n        }\n        printf(\"%d\\n\", n);\n    } else if (type == \"min_merge\") {\n        // Output n as is\n        printf(\"%d\\n\", n);\n    } else if (type == \"max_n\") {\n        n = 100000;\n        printf(\"%d\\n\", n);\n    } else if (type == \"random\") {\n        n = rnd.next(1, n);\n        printf(\"%d\\n\", n);\n    } else {\n        // Default case\n        printf(\"%d\\n\", n);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100000); // default n is 100000\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // Optional parameter k\n\n    if (type == \"max_merge\") {\n        // If k is specified, use k, else find max k such that (1 << k) - 1 <= n\n        if (k != -1) {\n            n = (1 << k) - 1;\n            if (n > 100000) n = 100000;\n        } else {\n            k = 0;\n            while ((1 << k) - 1 <= n && (1 << k) - 1 <= 100000)\n                k++;\n            k--;\n            n = (1 << k) - 1;\n        }\n        printf(\"%d\\n\", n);\n    } else if (type == \"min_merge\") {\n        // Output n as is\n        printf(\"%d\\n\", n);\n    } else if (type == \"max_n\") {\n        n = 100000;\n        printf(\"%d\\n\", n);\n    } else if (type == \"random\") {\n        n = rnd.next(1, n);\n        printf(\"%d\\n\", n);\n    } else {\n        // Default case\n        printf(\"%d\\n\", n);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n's with different types\n./gen -n 10 -type max_merge\n./gen -n 10 -type min_merge\n./gen -n 10 -type random\n\n# Medium n's\n./gen -n 100 -type max_merge\n./gen -n 100 -type min_merge\n./gen -n 100 -type random\n\n# Larger n's\n./gen -n 1000 -type max_merge\n./gen -n 1000 -type min_merge\n./gen -n 1000 -type random\n\n./gen -n 10000 -type max_merge\n./gen -n 10000 -type min_merge\n./gen -n 10000 -type random\n\n./gen -n 100000 -type max_merge\n./gen -n 100000 -type min_merge\n./gen -n 100000 -type random\n\n# Test with n as powers of 2 minus 1\n./gen -n 7 -type max_merge\n./gen -n 15 -type max_merge\n./gen -n 31 -type max_merge\n./gen -n 63 -type max_merge\n./gen -n 127 -type max_merge\n./gen -n 255 -type max_merge\n./gen -n 511 -type max_merge\n./gen -n 1023 -type max_merge\n./gen -n 2047 -type max_merge\n./gen -n 4095 -type max_merge\n\n# Testing random n's\n./gen -n 50000 -type random\n./gen -n 75000 -type random\n./gen -n 99999 -type random\n\n# Test maximum n\n./gen -type max_n\n\n# Default parameters\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:49.868521",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/B",
      "title": "B. Guess the Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input will contain a single integer n (2 ≤ n ≤ 50).The next n lines will contain the values of ai, j. The j-th number on the i-th line will represent ai, j. The i-th number on the i-th line will be 0. It's guaranteed that ai, j = aj, i and there is at least one solution consistent with the information given.",
      "output_spec": "OutputPrint n space separated integers, which represents a permutation that could have generated these values. If there are multiple possible solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy20 11 0OutputCopy2 1InputCopy50 2 2 1 22 0 4 1 32 4 0 1 31 1 1 0 12 3 3 1 0OutputCopy2 5 4 1 3",
      "description": "B. Guess the Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input will contain a single integer n (2 ≤ n ≤ 50).The next n lines will contain the values of ai, j. The j-th number on the i-th line will represent ai, j. The i-th number on the i-th line will be 0. It's guaranteed that ai, j = aj, i and there is at least one solution consistent with the information given.\n\nOutputPrint n space separated integers, which represents a permutation that could have generated these values. If there are multiple possible solutions, print any of them.\n\nInputCopy20 11 0OutputCopy2 1InputCopy50 2 2 1 22 0 4 1 32 4 0 1 31 1 1 0 12 3 3 1 0OutputCopy2 5 4 1 3\n\nInputCopy20 11 0\n\nOutputCopy2 1\n\nInputCopy50 2 2 1 22 0 4 1 32 4 0 1 31 1 1 0 12 3 3 1 0\n\nOutputCopy2 5 4 1 3\n\nNoteIn the first case, the answer can be {1, 2} or {2, 1}.In the second case, another possible answer is {2, 4, 5, 1, 3}.",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in a special Codeforces round. It will take place on 29 Jan, 17:05 UTC. It will not be a usual round. Thanks to Wunder Fund, the best participants will win prizes and souvenirs. Here are some words from Wunder Fund: Our company is situated in the center of Moscow. We are engaged in high-frequency trading — developing high-performance systems and algorithms for automated trading in financial markets. In this area algorithms and data structures (that you love to invent and implement) are vital. Our systems should process transactions in milliseconds! High-frequency trading is a continuous competition of the best programmers and mathematicians around the world. By joining us, you will become a part of this exciting challenge.We offer interesting and challenging tasks for the development of low latency for enthusiastic researchers and programmers. Flexible and no bureaucracy, decisions are taken quickly and implemented. We are a small team, so you will immediately become a significant part of it. Understand the economics and finance is not required, but the algorithms and data structures is what we need.Are Russian speaking and ready to live in Moscow? Join us! Visit our website for more information.We will be happy to give participants prizes and gifts: 1 place — PlayStation 4 2 place — Xbox One 3-5 places — Sega MegaDrive 16bit with games 1-50 places — Wunder Fund T-Shirts! 51-500 places — 50 T-Shirts to random participants! Interested in the work on Wunder Fund? I want to thank the following people for helping me with this round: GlebsHP for his help in reviewing problems and assistance in preparation for the round. LiChenKoh, AlexFetisov, and winger for testing problems. Delinur for translations. MikeMirzayanov for Codeforces and Polygon systems. and of course Wunder Fund for sponsoring the round. I hope to see you all at the round. Good luck and have fun! :)If you'd like some practice before the round, you can look over some of my past rounds that I've written (links here: A B C). I will try to give you all some more interesting problems to solve.UPD1: The round will be 2 hours and 7 problems. Unfortunately, there are some time conflicts, so we are unable to extend the duration of the round. The score distribution will be 500-1000-1500-1750-2500-2750-3500. Note that some problems that we thought are harder may actually be easier for you, so I encourage you to read all problems.UPD2: The editorial is published. Congratulations to the winners Egor Petr Um_nik RomaWhite Sampson",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2572
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readEoln();\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, 0, n, \"ai_j\");\n        inf.readEoln();\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                ensuref(row[j] == 0, \"ai[%d][%d] should be 0, but found %d\", i+1, j+1, row[j]);\n            } else {\n                ensuref(1 <= row[j] && row[j] <= n, \"ai[%d][%d] should be between 1 and n (inclusive), but found %d\", i+1, j+1, row[j]);\n            }\n            a[i][j] = row[j];\n        }\n    }\n    // Check symmetry\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            ensuref(a[i][j] == a[j][i], \"ai[%d][%d] != ai[%d][%d] (%d != %d)\", i+1, j+1, j+1, i+1, a[i][j], a[j][i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readEoln();\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, 0, n, \"ai_j\");\n        inf.readEoln();\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                ensuref(row[j] == 0, \"ai[%d][%d] should be 0, but found %d\", i+1, j+1, row[j]);\n            } else {\n                ensuref(1 <= row[j] && row[j] <= n, \"ai[%d][%d] should be between 1 and n (inclusive), but found %d\", i+1, j+1, row[j]);\n            }\n            a[i][j] = row[j];\n        }\n    }\n    // Check symmetry\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            ensuref(a[i][j] == a[j][i], \"ai[%d][%d] != ai[%d][%d] (%d != %d)\", i+1, j+1, j+1, i+1, a[i][j], a[j][i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readEoln();\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, 0, n, \"ai_j\");\n        inf.readEoln();\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                ensuref(row[j] == 0, \"ai[%d][%d] should be 0, but found %d\", i+1, j+1, row[j]);\n            } else {\n                ensuref(1 <= row[j] && row[j] <= n, \"ai[%d][%d] should be between 1 and n (inclusive), but found %d\", i+1, j+1, row[j]);\n            }\n            a[i][j] = row[j];\n        }\n    }\n    // Check symmetry\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            ensuref(a[i][j] == a[j][i], \"ai[%d][%d] != ai[%d][%d] (%d != %d)\", i+1, j+1, j+1, i+1, a[i][j], a[j][i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include <bits/stdc++.h>\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt();\n\n    // Read the matrix a_{i,j} from the input file\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInts(n, 0, n); // a_{i,j} values are between 0 and n\n    }\n\n    // Read the permutation p from the contestant's output\n    vector<int> p = ouf.readInts(n, 1, n);\n\n    // Check that p is a valid permutation of numbers from 1 to n\n    vector<bool> used(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int value = p[i];\n        if (used[value]) {\n            quitf(_wa, \"Number %d occurs more than once in the permutation\", value);\n        }\n        used[value] = true;\n    }\n\n    // Check that min(p_i, p_j) == a_{i,j} for all pairs where i != j\n    for (int i = 0; i < n; ++i) {\n        // No need to check when i == j since a_{i,i} = 0 and min(p_i, p_i) = p_i ≠ 0\n        for (int j = i + 1; j < n; ++j) {\n            int expected = a[i][j];\n            int actual = min(p[i], p[j]);\n            if (actual != expected) {\n                quitf(_wa, \"Mismatch at position (%d, %d): expected %d, found min(%d, %d) = %d\",\n                      i + 1, j + 1, expected, p[i], p[j], actual);\n            }\n        }\n    }\n\n    // If all checks passed, the answer is correct\n    quitf(_ok, \"Participant's permutation is valid\");\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"ascending\") {\n        // p = [1, 2, 3, ..., n]\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"descending\") {\n        // p = [n, n-1, ..., 1]\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"smallFirst\") {\n        // p[0] = 1, rest are random\n        p[0] = 1;\n        for (int i = 1; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin() + 1, p.end());\n    } else if (type == \"largeFirst\") {\n        // p[0] = n, rest are random\n        p[0] = n;\n        for (int i = 1; i < n; ++i)\n            p[i] = i;\n        shuffle(p.begin() + 1, p.end());\n    } else if (type == \"smallLast\") {\n        // p[n-1] = 1, rest are random\n        p[n - 1] = 1;\n        for (int i = 0; i < n - 1; ++i)\n            p[i] = i + 2;\n        shuffle(p.begin(), p.begin() + n - 1);\n    } else if (type == \"largeLast\") {\n        // p[n-1] = n, rest are random\n        p[n - 1] = n;\n        for (int i = 0; i < n - 1; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.begin() + n - 1);\n    } else if (type == \"alternating\") {\n        // p alternates between small and large numbers\n        vector<int> smalls, larges;\n        for (int i = 1; i <= n / 2; ++i)\n            smalls.push_back(i);\n        for (int i = n / 2 + 1; i <= n; ++i)\n            larges.push_back(i);\n        shuffle(smalls.begin(), smalls.end());\n        shuffle(larges.begin(), larges.end());\n        int s = 0, l = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0 && s < smalls.size())\n                p[i] = smalls[s++];\n            else if (l < larges.size())\n                p[i] = larges[l++];\n            else if (s < smalls.size())\n                p[i] = smalls[s++];\n        }\n    } else {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Compute a_{i,j}\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        a[i][i] = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            a[i][j] = a[j][i] = min(p[i], p[j]);\n        }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j < n - 1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"ascending\") {\n        // p = [1, 2, 3, ..., n]\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"descending\") {\n        // p = [n, n-1, ..., 1]\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"smallFirst\") {\n        // p[0] = 1, rest are random\n        p[0] = 1;\n        for (int i = 1; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin() + 1, p.end());\n    } else if (type == \"largeFirst\") {\n        // p[0] = n, rest are random\n        p[0] = n;\n        for (int i = 1; i < n; ++i)\n            p[i] = i;\n        shuffle(p.begin() + 1, p.end());\n    } else if (type == \"smallLast\") {\n        // p[n-1] = 1, rest are random\n        p[n - 1] = 1;\n        for (int i = 0; i < n - 1; ++i)\n            p[i] = i + 2;\n        shuffle(p.begin(), p.begin() + n - 1);\n    } else if (type == \"largeLast\") {\n        // p[n-1] = n, rest are random\n        p[n - 1] = n;\n        for (int i = 0; i < n - 1; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.begin() + n - 1);\n    } else if (type == \"alternating\") {\n        // p alternates between small and large numbers\n        vector<int> smalls, larges;\n        for (int i = 1; i <= n / 2; ++i)\n            smalls.push_back(i);\n        for (int i = n / 2 + 1; i <= n; ++i)\n            larges.push_back(i);\n        shuffle(smalls.begin(), smalls.end());\n        shuffle(larges.begin(), larges.end());\n        int s = 0, l = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0 && s < smalls.size())\n                p[i] = smalls[s++];\n            else if (l < larges.size())\n                p[i] = larges[l++];\n            else if (s < smalls.size())\n                p[i] = smalls[s++];\n        }\n    } else {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Compute a_{i,j}\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        a[i][i] = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            a[i][j] = a[j][i] = min(p[i], p[j]);\n        }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j < n - 1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type ascending\n./gen -n 2 -type descending\n./gen -n 2 -type random\n./gen -n 2 -type smallFirst\n./gen -n 2 -type largeFirst\n./gen -n 2 -type smallLast\n./gen -n 2 -type largeLast\n./gen -n 2 -type alternating\n\n./gen -n 3 -type ascending\n./gen -n 3 -type descending\n./gen -n 3 -type random\n./gen -n 3 -type smallFirst\n./gen -n 3 -type largeFirst\n./gen -n 3 -type smallLast\n./gen -n 3 -type largeLast\n./gen -n 3 -type alternating\n\n./gen -n 5 -type ascending\n./gen -n 5 -type descending\n./gen -n 5 -type random\n./gen -n 5 -type smallFirst\n./gen -n 5 -type largeFirst\n./gen -n 5 -type smallLast\n./gen -n 5 -type largeLast\n./gen -n 5 -type alternating\n\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type random\n./gen -n 10 -type smallFirst\n./gen -n 10 -type largeFirst\n./gen -n 10 -type smallLast\n./gen -n 10 -type largeLast\n./gen -n 10 -type alternating\n\n./gen -n 20 -type ascending\n./gen -n 20 -type descending\n./gen -n 20 -type random\n./gen -n 20 -type smallFirst\n./gen -n 20 -type largeFirst\n./gen -n 20 -type smallLast\n./gen -n 20 -type largeLast\n./gen -n 20 -type alternating\n\n./gen -n 30 -type random\n./gen -n 40 -type random\n./gen -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:52.180460",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/C",
      "title": "C. Constellation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (3 ≤ n ≤ 100 000).Each of the next n lines contains two integers xi and yi ( - 109 ≤ xi, yi ≤ 109).It is guaranteed that no two stars lie at the same point, and there does not exist a line such that all stars lie on that line.",
      "output_spec": "OutputPrint three distinct integers on a single line — the indices of the three points that form a triangle that satisfies the conditions stated in the problem.If there are multiple possible answers, you may print any of them.",
      "sample_tests": "ExamplesInputCopy30 11 01 1OutputCopy1 2 3InputCopy50 00 22 02 21 1OutputCopy1 3 5",
      "description": "C. Constellation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (3 ≤ n ≤ 100 000).Each of the next n lines contains two integers xi and yi ( - 109 ≤ xi, yi ≤ 109).It is guaranteed that no two stars lie at the same point, and there does not exist a line such that all stars lie on that line.\n\nOutputPrint three distinct integers on a single line — the indices of the three points that form a triangle that satisfies the conditions stated in the problem.If there are multiple possible answers, you may print any of them.\n\nInputCopy30 11 01 1OutputCopy1 2 3InputCopy50 00 22 02 21 1OutputCopy1 3 5\n\nInputCopy30 11 01 1\n\nOutputCopy1 2 3\n\nInputCopy50 00 22 02 21 1\n\nOutputCopy1 3 5\n\nNoteIn the first sample, we can print the three indices in any order.In the second sample, we have the following picture.   Note that the triangle formed by starts 1, 4 and 3 doesn't satisfy the conditions stated in the problem, as point 5 is not strictly outside of this triangle (it lies on it's border).",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in a special Codeforces round. It will take place on 29 Jan, 17:05 UTC. It will not be a usual round. Thanks to Wunder Fund, the best participants will win prizes and souvenirs. Here are some words from Wunder Fund: Our company is situated in the center of Moscow. We are engaged in high-frequency trading — developing high-performance systems and algorithms for automated trading in financial markets. In this area algorithms and data structures (that you love to invent and implement) are vital. Our systems should process transactions in milliseconds! High-frequency trading is a continuous competition of the best programmers and mathematicians around the world. By joining us, you will become a part of this exciting challenge.We offer interesting and challenging tasks for the development of low latency for enthusiastic researchers and programmers. Flexible and no bureaucracy, decisions are taken quickly and implemented. We are a small team, so you will immediately become a significant part of it. Understand the economics and finance is not required, but the algorithms and data structures is what we need.Are Russian speaking and ready to live in Moscow? Join us! Visit our website for more information.We will be happy to give participants prizes and gifts: 1 place — PlayStation 4 2 place — Xbox One 3-5 places — Sega MegaDrive 16bit with games 1-50 places — Wunder Fund T-Shirts! 51-500 places — 50 T-Shirts to random participants! Interested in the work on Wunder Fund? I want to thank the following people for helping me with this round: GlebsHP for his help in reviewing problems and assistance in preparation for the round. LiChenKoh, AlexFetisov, and winger for testing problems. Delinur for translations. MikeMirzayanov for Codeforces and Polygon systems. and of course Wunder Fund for sponsoring the round. I hope to see you all at the round. Good luck and have fun! :)If you'd like some practice before the round, you can look over some of my past rounds that I've written (links here: A B C). I will try to give you all some more interesting problems to solve.UPD1: The round will be 2 hours and 7 problems. Unfortunately, there are some time conflicts, so we are unable to extend the duration of the round. The score distribution will be 500-1000-1500-1750-2500-2750-3500. Note that some problems that we thought are harder may actually be easier for you, so I encourage you to read all problems.UPD2: The editorial is published. Congratulations to the winners Egor Petr Um_nik RomaWhite Sampson",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2572
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<pair<int64_t, int64_t>> points;\n    set<pair<int64_t, int64_t>> pointSet;\n    for (int i = 0; i < n; i++) {\n        int64_t xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int64_t yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n        pair<int64_t, int64_t> p = {xi, yi};\n        ensuref(pointSet.count(p) == 0, \"Point (%lld, %lld) occurs more than once\", xi, yi);\n        pointSet.insert(p);\n        points.push_back(p);\n    }\n    if (n > 2) {\n        auto p0 = points[0];\n        auto p1 = points[1];\n        int64_t x0 = p0.first;\n        int64_t y0 = p0.second;\n        int64_t x1 = p1.first;\n        int64_t y1 = p1.second;\n        bool all_colinear = true;\n        for (int i = 2; i < n; ++i) {\n            int64_t xi = points[i].first;\n            int64_t yi = points[i].second;\n            int64_t cross = (x1 - x0)*(yi - y0) - (xi - x0)*(y1 - y0);\n            if (cross != 0) {\n                all_colinear = false;\n                break;\n            }\n        }\n        ensuref(!all_colinear, \"All points lie on a single line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<pair<int64_t, int64_t>> points;\n    set<pair<int64_t, int64_t>> pointSet;\n    for (int i = 0; i < n; i++) {\n        int64_t xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int64_t yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n        pair<int64_t, int64_t> p = {xi, yi};\n        ensuref(pointSet.count(p) == 0, \"Point (%lld, %lld) occurs more than once\", xi, yi);\n        pointSet.insert(p);\n        points.push_back(p);\n    }\n    if (n > 2) {\n        auto p0 = points[0];\n        auto p1 = points[1];\n        int64_t x0 = p0.first;\n        int64_t y0 = p0.second;\n        int64_t x1 = p1.first;\n        int64_t y1 = p1.second;\n        bool all_colinear = true;\n        for (int i = 2; i < n; ++i) {\n            int64_t xi = points[i].first;\n            int64_t yi = points[i].second;\n            int64_t cross = (x1 - x0)*(yi - y0) - (xi - x0)*(y1 - y0);\n            if (cross != 0) {\n                all_colinear = false;\n                break;\n            }\n        }\n        ensuref(!all_colinear, \"All points lie on a single line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<pair<int64_t, int64_t>> points;\n    set<pair<int64_t, int64_t>> pointSet;\n    for (int i = 0; i < n; i++) {\n        int64_t xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int64_t yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n        pair<int64_t, int64_t> p = {xi, yi};\n        ensuref(pointSet.count(p) == 0, \"Point (%lld, %lld) occurs more than once\", xi, yi);\n        pointSet.insert(p);\n        points.push_back(p);\n    }\n    if (n > 2) {\n        auto p0 = points[0];\n        auto p1 = points[1];\n        int64_t x0 = p0.first;\n        int64_t y0 = p0.second;\n        int64_t x1 = p1.first;\n        int64_t y1 = p1.second;\n        bool all_colinear = true;\n        for (int i = 2; i < n; ++i) {\n            int64_t xi = points[i].first;\n            int64_t yi = points[i].second;\n            int64_t cross = (x1 - x0)*(yi - y0) - (xi - x0)*(y1 - y0);\n            if (cross != 0) {\n                all_colinear = false;\n                break;\n            }\n        }\n        ensuref(!all_colinear, \"All points lie on a single line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    vector<pll> points(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        ll x = inf.readInt(-1000000000, 1000000000, format(\"x[%d]\", i).c_str());\n        ll y = inf.readInt(-1000000000, 1000000000, format(\"y[%d]\", i).c_str());\n        points[i] = {x, y};\n    }\n\n    // Read the contestant's output\n    vector<int> indices;\n    for (int i = 0; i < 3; ++i) {\n        indices.push_back(ouf.readInt(1, n, format(\"index%d\", i + 1).c_str()));\n    }\n    // Check for extra output\n    if (!ouf.seekEof()) {\n        ouf.quitf(_wa, \"Unexpected extra output after reading three indices\");\n    }\n    // Check indices are distinct\n    set<int> index_set(indices.begin(), indices.end());\n    if (index_set.size() != 3) {\n        quitf(_wa, \"Indices are not distinct\");\n    }\n\n    // Get the points\n    pll p1 = points[indices[0]];\n    pll p2 = points[indices[1]];\n    pll p3 = points[indices[2]];\n\n    // Compute the area (twice the actual area to keep it integer)\n    ll area2 = abs((p2.first - p1.first)*(p3.second - p1.second) - (p3.first - p1.first)*(p2.second - p1.second));\n    if (area2 == 0) {\n        quitf(_wa, \"The area of the triangle is zero\");\n    }\n\n    // Now check other points\n    set<int> triangle_indices(indices.begin(), indices.end());\n    for (int i = 1; i <= n; ++i) {\n        if (triangle_indices.count(i)) continue;\n        pll pt = points[i];\n        // Check if pt is inside or on the edge of triangle formed by p1, p2, p3\n        auto cross = [](pll a, pll b, pll c) {\n            // Return cross product of vectors ab x ac\n            ll x1 = b.first - a.first;\n            ll y1 = b.second - a.second;\n            ll x2 = c.first - a.first;\n            ll y2 = c.second - a.second;\n            return x1 * y2 - x2 * y1;\n        };\n        ll d1 = cross(p1, p2, pt);\n        ll d2 = cross(p2, p3, pt);\n        ll d3 = cross(p3, p1, pt);\n\n        bool has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n        bool has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n\n        // Point is inside or on the edge if not (has_neg and has_pos)\n        if (!(has_neg && has_pos)) {\n            quitf(_wa, \"Point %d lies inside or on the edge of the triangle\", i);\n        }\n    }\n    // All checks passed\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_coord = opt<int>(\"max_coord\", 1000000000);\n\n    set<pair<int, int>> points_set;\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        while ((int)points.size() < n) {\n            int x = rnd.next(-max_coord, max_coord);\n            int y = rnd.next(-max_coord, max_coord);\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"line_with_outlier\") {\n        // Generate n-1 points on a line y = mx + c\n        int m = rnd.next(-10000, 10000);\n        int c = rnd.next(-max_coord, max_coord);\n        int x0 = rnd.next(-max_coord, max_coord);\n        int y0 = m * x0 + c;\n        int dx = rnd.next(1, 1000);\n        int dy = m * dx;\n        for (int i = 0; i < n - 1; ++i) {\n            ll x = x0 + dx * i;\n            ll y = y0 + dy * i;\n            if (abs(x) > max_coord || abs(y) > max_coord) continue;\n            if (points_set.insert({(int)x, (int)y}).second) {\n                points.push_back({(int)x, (int)y});\n            }\n        }\n        // Add one outlier point not on the line\n        while ((int)points.size() < n) {\n            int x = rnd.next(-max_coord, max_coord);\n            int y = rnd.next(-max_coord, max_coord);\n            // ensure point not on line y = m x + c\n            if (y == m * x + c) continue;\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"circle\") {\n        int xc = rnd.next(-max_coord/2, max_coord/2);\n        int yc = rnd.next(-max_coord/2, max_coord/2);\n        int r = rnd.next(1, max_coord / 2);\n        while ((int)points.size() < n) {\n            double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n            int x = xc + (int)(r * cos(angle));\n            int y = yc + (int)(r * sin(angle));\n            if (abs(x) > max_coord || abs(y) > max_coord) continue;\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"grid\") {\n        int gridSize = sqrt(n) + 1;\n        for (int i = 0; i < gridSize && (int)points.size() < n; ++i) {\n            for (int j = 0; j < gridSize && (int)points.size() < n; ++j) {\n                int x = -max_coord + i * (2 * max_coord / gridSize);\n                int y = -max_coord + j * (2 * max_coord / gridSize);\n                if (abs(x) > max_coord || abs(y) > max_coord) continue;\n                if (points_set.insert({x, y}).second) {\n                    points.push_back({x, y});\n                }\n            }\n        }\n        // Add random points if not enough\n        while ((int)points.size() < n) {\n            int x = rnd.next(-max_coord, max_coord);\n            int y = rnd.next(-max_coord, max_coord);\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"cluster\") {\n        int xc = rnd.next(-max_coord/2, max_coord/2);\n        int yc = rnd.next(-max_coord/2, max_coord/2);\n        int r = max(1, max_coord / 1000000);\n        while ((int)points.size() < n) {\n            int x = xc + rnd.next(-r, r);\n            int y = yc + rnd.next(-r, r);\n            if (abs(x) > max_coord || abs(y) > max_coord) continue;\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that not all points are colinear.\n\n    // We need to check if points are colinear and adjust if so.\n\n    // Let's check.\n\n    auto are_colinear = [&](pair<int, int> a, pair<int, int> b, pair<int, int> c) -> bool {\n        ll x1 = a.first, y1 = a.second;\n        ll x2 = b.first, y2 = b.second;\n        ll x3 = c.first, y3 = c.second;\n        return (x2 - x1)*(y3 - y1) == (x3 - x1)*(y2 - y1);\n    };\n\n    bool all_colinear = true;\n    for (int i = 2; i < (int)points.size(); ++i) {\n        if (!are_colinear(points[0], points[1], points[i])) {\n            all_colinear = false;\n            break;\n        }\n    }\n\n    if (all_colinear) {\n        // Adjust one point\n        points[0].second += 1;\n    }\n\n    // Output\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_coord = opt<int>(\"max_coord\", 1000000000);\n\n    set<pair<int, int>> points_set;\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        while ((int)points.size() < n) {\n            int x = rnd.next(-max_coord, max_coord);\n            int y = rnd.next(-max_coord, max_coord);\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"line_with_outlier\") {\n        // Generate n-1 points on a line y = mx + c\n        int m = rnd.next(-10000, 10000);\n        int c = rnd.next(-max_coord, max_coord);\n        int x0 = rnd.next(-max_coord, max_coord);\n        int y0 = m * x0 + c;\n        int dx = rnd.next(1, 1000);\n        int dy = m * dx;\n        for (int i = 0; i < n - 1; ++i) {\n            ll x = x0 + dx * i;\n            ll y = y0 + dy * i;\n            if (abs(x) > max_coord || abs(y) > max_coord) continue;\n            if (points_set.insert({(int)x, (int)y}).second) {\n                points.push_back({(int)x, (int)y});\n            }\n        }\n        // Add one outlier point not on the line\n        while ((int)points.size() < n) {\n            int x = rnd.next(-max_coord, max_coord);\n            int y = rnd.next(-max_coord, max_coord);\n            // ensure point not on line y = m x + c\n            if (y == m * x + c) continue;\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"circle\") {\n        int xc = rnd.next(-max_coord/2, max_coord/2);\n        int yc = rnd.next(-max_coord/2, max_coord/2);\n        int r = rnd.next(1, max_coord / 2);\n        while ((int)points.size() < n) {\n            double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n            int x = xc + (int)(r * cos(angle));\n            int y = yc + (int)(r * sin(angle));\n            if (abs(x) > max_coord || abs(y) > max_coord) continue;\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"grid\") {\n        int gridSize = sqrt(n) + 1;\n        for (int i = 0; i < gridSize && (int)points.size() < n; ++i) {\n            for (int j = 0; j < gridSize && (int)points.size() < n; ++j) {\n                int x = -max_coord + i * (2 * max_coord / gridSize);\n                int y = -max_coord + j * (2 * max_coord / gridSize);\n                if (abs(x) > max_coord || abs(y) > max_coord) continue;\n                if (points_set.insert({x, y}).second) {\n                    points.push_back({x, y});\n                }\n            }\n        }\n        // Add random points if not enough\n        while ((int)points.size() < n) {\n            int x = rnd.next(-max_coord, max_coord);\n            int y = rnd.next(-max_coord, max_coord);\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else if (type == \"cluster\") {\n        int xc = rnd.next(-max_coord/2, max_coord/2);\n        int yc = rnd.next(-max_coord/2, max_coord/2);\n        int r = max(1, max_coord / 1000000);\n        while ((int)points.size() < n) {\n            int x = xc + rnd.next(-r, r);\n            int y = yc + rnd.next(-r, r);\n            if (abs(x) > max_coord || abs(y) > max_coord) continue;\n            if (points_set.insert({x, y}).second) {\n                points.push_back({x, y});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that not all points are colinear.\n\n    // We need to check if points are colinear and adjust if so.\n\n    // Let's check.\n\n    auto are_colinear = [&](pair<int, int> a, pair<int, int> b, pair<int, int> c) -> bool {\n        ll x1 = a.first, y1 = a.second;\n        ll x2 = b.first, y2 = b.second;\n        ll x3 = c.first, y3 = c.second;\n        return (x2 - x1)*(y3 - y1) == (x3 - x1)*(y2 - y1);\n    };\n\n    bool all_colinear = true;\n    for (int i = 2; i < (int)points.size(); ++i) {\n        if (!are_colinear(points[0], points[1], points[i])) {\n            all_colinear = false;\n            break;\n        }\n    }\n\n    if (all_colinear) {\n        // Adjust one point\n        points[0].second += 1;\n    }\n\n    // Output\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n\n./gen -n 3 -type line_with_outlier\n./gen -n 5 -type line_with_outlier\n./gen -n 10 -type line_with_outlier\n./gen -n 1000 -type line_with_outlier\n./gen -n 100000 -type line_with_outlier\n\n./gen -n 3 -type circle\n./gen -n 5 -type circle\n./gen -n 10 -type circle\n./gen -n 1000 -type circle\n./gen -n 100000 -type circle\n\n./gen -n 3 -type grid\n./gen -n 10 -type grid\n./gen -n 100 -type grid\n./gen -n 1000 -type grid\n./gen -n 10000 -type grid\n\n./gen -n 3 -type cluster\n./gen -n 10 -type cluster\n./gen -n 100 -type cluster\n./gen -n 1000 -type cluster\n./gen -n 10000 -type cluster\n./gen -n 100000 -type cluster\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:54.332697",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/D",
      "title": "D. Hamiltonian Spanning Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, x and y (2 ≤ n ≤ 200 000, 1 ≤ x, y ≤ 109).Each of the next n - 1 lines contains a description of a road in the spanning tree. The i-th of these lines contains two integers ui and vi (1 ≤ ui, vi ≤ n) — indices of the cities connected by the i-th road. It is guaranteed that these roads form a spanning tree.",
      "output_spec": "OutputPrint a single integer — the minimum number of seconds one needs to spend in order to visit all the cities exactly once.",
      "sample_tests": "ExamplesInputCopy5 2 31 21 33 45 3OutputCopy9InputCopy5 3 21 21 33 45 3OutputCopy8",
      "description": "D. Hamiltonian Spanning Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three integers n, x and y (2 ≤ n ≤ 200 000, 1 ≤ x, y ≤ 109).Each of the next n - 1 lines contains a description of a road in the spanning tree. The i-th of these lines contains two integers ui and vi (1 ≤ ui, vi ≤ n) — indices of the cities connected by the i-th road. It is guaranteed that these roads form a spanning tree.\n\nOutputPrint a single integer — the minimum number of seconds one needs to spend in order to visit all the cities exactly once.\n\nInputCopy5 2 31 21 33 45 3OutputCopy9InputCopy5 3 21 21 33 45 3OutputCopy8\n\nInputCopy5 2 31 21 33 45 3\n\nOutputCopy9\n\nInputCopy5 3 21 21 33 45 3\n\nOutputCopy8\n\nNoteIn the first sample, roads of the spanning tree have cost 2, while other roads have cost 3. One example of an optimal path is .In the second sample, we have the same spanning tree, but roads in the spanning tree cost 3, while other roads cost 2. One example of an optimal path is .",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in a special Codeforces round. It will take place on 29 Jan, 17:05 UTC. It will not be a usual round. Thanks to Wunder Fund, the best participants will win prizes and souvenirs. Here are some words from Wunder Fund: Our company is situated in the center of Moscow. We are engaged in high-frequency trading — developing high-performance systems and algorithms for automated trading in financial markets. In this area algorithms and data structures (that you love to invent and implement) are vital. Our systems should process transactions in milliseconds! High-frequency trading is a continuous competition of the best programmers and mathematicians around the world. By joining us, you will become a part of this exciting challenge.We offer interesting and challenging tasks for the development of low latency for enthusiastic researchers and programmers. Flexible and no bureaucracy, decisions are taken quickly and implemented. We are a small team, so you will immediately become a significant part of it. Understand the economics and finance is not required, but the algorithms and data structures is what we need.Are Russian speaking and ready to live in Moscow? Join us! Visit our website for more information.We will be happy to give participants prizes and gifts: 1 place — PlayStation 4 2 place — Xbox One 3-5 places — Sega MegaDrive 16bit with games 1-50 places — Wunder Fund T-Shirts! 51-500 places — 50 T-Shirts to random participants! Interested in the work on Wunder Fund? I want to thank the following people for helping me with this round: GlebsHP for his help in reviewing problems and assistance in preparation for the round. LiChenKoh, AlexFetisov, and winger for testing problems. Delinur for translations. MikeMirzayanov for Codeforces and Polygon systems. and of course Wunder Fund for sponsoring the round. I hope to see you all at the round. Good luck and have fun! :)If you'd like some practice before the round, you can look over some of my past rounds that I've written (links here: A B C). I will try to give you all some more interesting problems to solve.UPD1: The round will be 2 hours and 7 problems. Unfortunately, there are some time conflicts, so we are unable to extend the duration of the round. The score distribution will be 500-1000-1500-1750-2500-2750-3500. Note that some problems that we thought are harder may actually be easier for you, so I encourage you to read all problems.UPD2: The editorial is published. Congratulations to the winners Egor Petr Um_nik RomaWhite Sampson",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2572
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\nvector<int> rank;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]); // Path compression\n    return parent[x];\n}\n\nbool union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b)\n        return false; // Cycle detected\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loops are not allowed (u_i != v_i)\");\n\n        bool united = union_sets(u, v);\n        ensuref(united, \"Graph contains a cycle\");\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\nvector<int> rank;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]); // Path compression\n    return parent[x];\n}\n\nbool union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b)\n        return false; // Cycle detected\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loops are not allowed (u_i != v_i)\");\n\n        bool united = union_sets(u, v);\n        ensuref(united, \"Graph contains a cycle\");\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\nvector<int> rank;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]); // Path compression\n    return parent[x];\n}\n\nbool union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b)\n        return false; // Cycle detected\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loops are not allowed (u_i != v_i)\");\n\n        bool united = union_sets(u, v);\n        ensuref(united, \"Graph contains a cycle\");\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output first line: n x y\n    printf(\"%d %d %d\\n\", n, x, y);\n\n    // Generate the tree edges\n    vector<int> p(n); // parent of node i\n\n    if (type == \"chain\") {\n        // Create a chain tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = i - 1;\n    } else if (type == \"star\") {\n        // Create a star tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = 0;\n    } else if (type == \"balanced\") {\n        // Create a balanced binary tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = (i - 1) / 2;\n    } else {\n        // Random tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = rnd.next(i);\n    }\n\n    // Optional: shuffle node labels\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Build the edges\n    vector<pair<int,int> > edges;\n    for (int i = 1; i < n; i++) {\n        int u = perm[i];\n        int v = perm[p[i]];\n        edges.push_back(make_pair(u + 1, v + 1));\n    }\n\n    // Optional: shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output first line: n x y\n    printf(\"%d %d %d\\n\", n, x, y);\n\n    // Generate the tree edges\n    vector<int> p(n); // parent of node i\n\n    if (type == \"chain\") {\n        // Create a chain tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = i - 1;\n    } else if (type == \"star\") {\n        // Create a star tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = 0;\n    } else if (type == \"balanced\") {\n        // Create a balanced binary tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = (i - 1) / 2;\n    } else {\n        // Random tree\n        for(int i = 0; i < n; ++i)\n            if (i > 0)\n                p[i] = rnd.next(i);\n    }\n\n    // Optional: shuffle node labels\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    // Build the edges\n    vector<pair<int,int> > edges;\n    for (int i = 1; i < n; i++) {\n        int u = perm[i];\n        int v = perm[p[i]];\n        edges.push_back(make_pair(u + 1, v + 1));\n    }\n\n    // Optional: shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, x < y\n./gen -n 2 -x 1 -y 2 -type chain\n./gen -n 2 -x 2 -y 2 -type chain\n./gen -n 2 -x 2 -y 1 -type chain\n\n# Medium n\n./gen -n 100 -x 1 -y 1000000000 -type chain\n./gen -n 100 -x 1000000000 -y 1 -type chain\n./gen -n 100 -x 1000000000 -y 1000000000 -type chain\n\n# Different tree types\n./gen -n 1000 -x 2 -y 3 -type chain\n./gen -n 1000 -x 2 -y 3 -type star\n./gen -n 1000 -x 2 -y 3 -type balanced\n./gen -n 1000 -x 2 -y 3 -type random\n\n# Max n\n./gen -n 200000 -x 1 -y 1000000000 -type chain\n./gen -n 200000 -x 1000000000 -y 1 -type chain\n./gen -n 200000 -x 1 -y 1 -type chain\n\n# x == y\n./gen -n 100000 -x 123456789 -y 123456789 -type random\n\n# x < y\n./gen -n 200000 -x 1 -y 2 -type random\n\n# x > y\n./gen -n 200000 -x 2 -y 1 -type random\n\n# Various x and y\n./gen -n 200000 -x 987654321 -y 123456789 -type random\n./gen -n 200000 -x 123456789 -y 987654321 -type random\n\n# Using star (flower) tree\n./gen -n 200000 -x 1 -y 2 -type star\n./gen -n 200000 -x 2 -y 1 -type star\n\n# Mix of small x and big y, and vice versa\n./gen -n 200000 -x 1 -y 1000000000 -type balanced\n./gen -n 200000 -x 1000000000 -y 1 -type balanced\n\n# x and y are maximum\n./gen -n 200000 -x 1000000000 -y 1000000000 -type random\n\n# Random small n\n./gen -n 10 -x 5 -y 7 -type random\n./gen -n 10 -x 7 -y 5 -type random\n\n# Edge cases\n./gen -n 199999 -x 999999999 -y 999999999 -type chain\n./gen -n 199999 -x 1 -y 1 -type star\n\n# All types of tree at n = max\n./gen -n 200000 -x 5 -y 10 -type chain\n./gen -n 200000 -x 5 -y 10 -type star\n./gen -n 200000 -x 5 -y 10 -type balanced\n./gen -n 200000 -x 5 -y 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:56.547916",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/E",
      "title": "E. Рука робота",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест8 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано два целых числа n и m (1 ≤ n, m ≤ 300 000) — количество отрезков, составляющих руку, и количество движений, сделанных Роджером, соответственно.В каждой из следующих m строк записано по три целых числа xi, yi и zi, описывающих соответствующий ход. Если xi = 1, это описывает ход 1-го типа, где yi обозначает номер отрезка, а zi обозначает увеличение длины. Если xi = 2, то это описание хода второго типа, где yi обозначает номер отрезка, а zi обозначает угол в градусах (1 ≤ xi ≤ 2, 1 ≤ yi ≤ n, 1 ≤ zi ≤ 359).",
      "output_spec": "Выходные данныеВыведите m строк. В i-ой строке должны быть записаны два вещественных числа, обозначающие координаты синего конца последнего отрезка после завершения операций 1, ..., i. Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не будет превосходить 10 - 4. А именно: пусть ваш ответ равен a, а ответ жюри — b. Проверяющая программа будет считать ваш ответ правильным, если .",
      "sample_tests": "ПримерыВходные данныеСкопировать5 41 1 32 3 902 5 481 4 1Выходные данныеСкопировать8.0000000000 0.00000000005.0000000000 -3.00000000004.2568551745 -2.66913060644.2568551745 -3.6691306064",
      "description": "E. Рука робота\n\nограничение по времени на тест8 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано два целых числа n и m (1 ≤ n, m ≤ 300 000) — количество отрезков, составляющих руку, и количество движений, сделанных Роджером, соответственно.В каждой из следующих m строк записано по три целых числа xi, yi и zi, описывающих соответствующий ход. Если xi = 1, это описывает ход 1-го типа, где yi обозначает номер отрезка, а zi обозначает увеличение длины. Если xi = 2, то это описание хода второго типа, где yi обозначает номер отрезка, а zi обозначает угол в градусах (1 ≤ xi ≤ 2, 1 ≤ yi ≤ n, 1 ≤ zi ≤ 359).\n\nВходные данные\n\nВыходные данныеВыведите m строк. В i-ой строке должны быть записаны два вещественных числа, обозначающие координаты синего конца последнего отрезка после завершения операций 1, ..., i. Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не будет превосходить 10 - 4. А именно: пусть ваш ответ равен a, а ответ жюри — b. Проверяющая программа будет считать ваш ответ правильным, если .\n\nВыходные данные\n\nВходные данныеСкопировать5 41 1 32 3 902 5 481 4 1Выходные данныеСкопировать8.0000000000 0.00000000005.0000000000 -3.00000000004.2568551745 -2.66913060644.2568551745 -3.6691306064\n\nВходные данныеСкопировать5 41 1 32 3 902 5 481 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8.0000000000 0.00000000005.0000000000 -3.00000000004.2568551745 -2.66913060644.2568551745 -3.6691306064\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеСледующие картинки иллюстрируют пример и показывают состояние руки после каждой операции. Координаты точки F выведены после применения каждой операции. Для простоты мы показываем только синие концы отрезка (за исключением красного конца первого). Например, точка, помеченная В, является синим концом отрезка 1, а также красным концом отрезка 2.Начальное состояние:    Увеличить длину отрезка 1 на 3.    Повернуть отрезок 3 на 90 градусов по часовой стрелке.    Повернуть отрезок 5 на 48 градусов по часовой стрелке.    Увеличить длину отрезка 4 на 1.",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Привет, Codeforces!Приглашаю вас принять участие в особом раунде Codeforces, который начнется 29-го января в 20:05 (московское время). Спасибо, Wunder Fund — лучшие участники получат призы и сувениры! Вот несколько слов непосредственно от компании Wunder Fund: Мы работаем в центре Москвы и занимаемся высокочастотным трейдингом — разрабатываем высокопроизводительные системы и алгоритмы автоматизированной торговли на финансовых рынках. Именно здесь оказываются важны алгоритмы, которые вы так любите придумывать и реализовывать — нужно быть быстрее других, сделки совершаются за доли секунд! На Codeforces разделяют нашу любовь к высокой производительности, поэтому мы и решили провести раунд. Высокочастотная торговля — это непрерывное соревнование лучших программистов и математиков всего мира. Присоединившись к нам, вы станете частью этой увлекательной схватки.Мы предлагаем интересные и сложные задачи по low latency разработке для увлеченных исследователей и программистов. Гибкий график и никакой бюрократии, решения быстро принимаются и воплощаются в жизнь. У нас небольшая команда, поэтому вы сразу станете ее значительной частью. Разбираться в экономике и финансах не требуется, а вот алгоритмы и структуры данных это то, что нам нужно.Заинтересовались? Присоединяйтесь к нам! Про вакансии можно почитать на нашем cайте.Мы будем рады подарить участникам призы и подарки: 1 место — PlayStation 4 2 место — Xbox One 3-5 места — Sega MegaDrive 16bit c играми 1-50 места — сувенирные футболки Wunder Fund 51-500 места — 50 футболок будут распределены случайным образом! Заинтересовались работой в Wunder Fund? А я хочу поблагодарить всех тех, кто помогал с подготовкой раунда: GlebsHP за ревью и помощь в подготовку задач, LiChenKoh и ??? за тестирование задач, Delinur за переводы, MikeMirzayanov за существование систем Codeforces и Polygon, и, конечно, Wunder Fund за инициативу выступить спонсором раунда! Надеюсь всех вас увидеть на раунде. Желаю удачи и удовольствия от раунда! Если вы хотите чуток потренироваться перед раундом, вы можете взглянуть на задачи моих предыдущих раундов (по ссылкам: A, B, C). Очень постараюсь порадовать вас интересными задачами.UPD: Опубликован разбор задач.",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2204
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, 2, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        long long zi = inf.readLong(1LL, LLONG_MAX, \"zi\");\n        inf.readEoln();\n\n        if (xi == 2) {\n            ensuref(zi >= 1 && zi <= 359, \"When xi=2, zi must be in [1,359], but zi=%lld\", zi);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, 2, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        long long zi = inf.readLong(1LL, LLONG_MAX, \"zi\");\n        inf.readEoln();\n\n        if (xi == 2) {\n            ensuref(zi >= 1 && zi <= 359, \"When xi=2, zi must be in [1,359], but zi=%lld\", zi);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, 2, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        long long zi = inf.readLong(1LL, LLONG_MAX, \"zi\");\n        inf.readEoln();\n\n        if (xi == 2) {\n            ensuref(zi >= 1 && zi <= 359, \"When xi=2, zi must be in [1,359], but zi=%lld\", zi);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_l = opt<int>(\"max_l\", 1000000000); // Maximum length increment\n    int max_a = opt<int>(\"max_a\", 359);        // Maximum angle in degrees\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    vector<tuple<int, int, int>> operations;\n\n    if (type == \"all_extends\") {\n        // All operations are type 1 (extensions)\n        for (int i = 0; i < m; i++) {\n            int xi = 1;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(1, max_l);\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"all_rotations\") {\n        // All operations are type 2 (rotations)\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(1, max_a);\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"small_angles\") {\n        // All rotations with small angles (e.g., 1 degree)\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(1, 5);  // Small angles between 1 and 5 degrees\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"large_angles\") {\n        // All rotations with large angles (e.g., 355 to 359 degrees)\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(355, max_a);  // Large angles between 355 and 359 degrees\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"random\") {\n        // Random mix of operations\n        for (int i = 0; i < m; i++) {\n            int xi = rnd.next(1, 2);\n            int yi = rnd.next(1, n);\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"chain_extends\") {\n        // Always extend the first segment\n        for (int i = 0; i < m; i++) {\n            int xi = 1;\n            int yi = 1;\n            int zi = rnd.next(1, max_l);\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"single_segment\") {\n        // All operations on the same segment\n        int fixed_yi = rnd.next(1, n);\n        for (int i = 0; i < m; i++) {\n            int xi = rnd.next(1, 2);\n            int yi = fixed_yi;\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"corner_angles\") {\n        // Angles that might cause precision issues (90, 180, 270 degrees)\n        vector<int> angles = {90, 180, 270};\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = angles[rnd.next(0, (int)angles.size() - 1)];\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between extension and rotation\n        for (int i = 0; i < m; i++) {\n            int xi = i % 2 + 1;  // xi = 1 or 2 alternately\n            int yi = rnd.next(1, n);\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else {\n        // Default to random mix of operations\n        for (int i = 0; i < m; i++) {\n            int xi = rnd.next(1, 2);\n            int yi = rnd.next(1, n);\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    }\n\n    // Output the operations\n    for (auto op : operations) {\n        int xi, yi, zi;\n        tie(xi, yi, zi) = op;\n        printf(\"%d %d %d\\n\", xi, yi, zi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_l = opt<int>(\"max_l\", 1000000000); // Maximum length increment\n    int max_a = opt<int>(\"max_a\", 359);        // Maximum angle in degrees\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    vector<tuple<int, int, int>> operations;\n\n    if (type == \"all_extends\") {\n        // All operations are type 1 (extensions)\n        for (int i = 0; i < m; i++) {\n            int xi = 1;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(1, max_l);\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"all_rotations\") {\n        // All operations are type 2 (rotations)\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(1, max_a);\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"small_angles\") {\n        // All rotations with small angles (e.g., 1 degree)\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(1, 5);  // Small angles between 1 and 5 degrees\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"large_angles\") {\n        // All rotations with large angles (e.g., 355 to 359 degrees)\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = rnd.next(355, max_a);  // Large angles between 355 and 359 degrees\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"random\") {\n        // Random mix of operations\n        for (int i = 0; i < m; i++) {\n            int xi = rnd.next(1, 2);\n            int yi = rnd.next(1, n);\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"chain_extends\") {\n        // Always extend the first segment\n        for (int i = 0; i < m; i++) {\n            int xi = 1;\n            int yi = 1;\n            int zi = rnd.next(1, max_l);\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"single_segment\") {\n        // All operations on the same segment\n        int fixed_yi = rnd.next(1, n);\n        for (int i = 0; i < m; i++) {\n            int xi = rnd.next(1, 2);\n            int yi = fixed_yi;\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"corner_angles\") {\n        // Angles that might cause precision issues (90, 180, 270 degrees)\n        vector<int> angles = {90, 180, 270};\n        for (int i = 0; i < m; i++) {\n            int xi = 2;\n            int yi = rnd.next(1, n);\n            int zi = angles[rnd.next(0, (int)angles.size() - 1)];\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between extension and rotation\n        for (int i = 0; i < m; i++) {\n            int xi = i % 2 + 1;  // xi = 1 or 2 alternately\n            int yi = rnd.next(1, n);\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    } else {\n        // Default to random mix of operations\n        for (int i = 0; i < m; i++) {\n            int xi = rnd.next(1, 2);\n            int yi = rnd.next(1, n);\n            int zi;\n            if (xi == 1) {\n                zi = rnd.next(1, max_l);\n            } else {\n                zi = rnd.next(1, max_a);\n            }\n            operations.emplace_back(xi, yi, zi);\n        }\n    }\n\n    // Output the operations\n    for (auto op : operations) {\n        int xi, yi, zi;\n        tie(xi, yi, zi) = op;\n        printf(\"%d %d %d\\n\", xi, yi, zi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest test case: n = 1, m = 1\n./gen -n 1 -m 1 -type all_extends\n\n# Only one segment, only rotations\n./gen -n 1 -m 10 -type all_rotations\n\n# Small n, mix of operations\n./gen -n 5 -m 10 -type random\n\n# Small n, all rotations with small angles\n./gen -n 5 -m 10 -type small_angles\n\n# Small n, all rotations with large angles\n./gen -n 5 -m 10 -type large_angles\n\n# Medium n, all extensions\n./gen -n 1000 -m 1000 -type all_extends\n\n# Medium n, all rotations with small angles\n./gen -n 1000 -m 1000 -type small_angles\n\n# Medium n, all rotations with large angles\n./gen -n 1000 -m 1000 -type large_angles\n\n# Medium n, operations that might cause precision issues\n./gen -n 1000 -m 1000 -type corner_angles\n\n# Maximum n and m, random operations\n./gen -n 300000 -m 300000 -type random\n\n# Maximum n and m, all extensions\n./gen -n 300000 -m 300000 -type all_extends\n\n# Maximum n and m, all rotations\n./gen -n 300000 -m 300000 -type all_rotations\n\n# Maximum n and m, all rotations with small angles\n./gen -n 300000 -m 300000 -type small_angles\n\n# Maximum n and m, all rotations with large angles\n./gen -n 300000 -m 300000 -type large_angles\n\n# Maximum n and m, rotations that might cause precision issues\n./gen -n 300000 -m 300000 -type corner_angles\n\n# Operations on the first segment only\n./gen -n 100000 -m 100000 -type chain_extends\n\n# Operations on the same random segment\n./gen -n 100000 -m 100000 -type single_segment\n\n# Random operations with fixed maximum length and angle\n./gen -n 100000 -m 100000 -type random -max_l 1000000 -max_a 359\n\n# All extensions with maximum length increment\n./gen -n 100000 -m 100000 -type all_extends -max_l 1000000000\n\n# All extensions with minimal length increment\n./gen -n 100000 -m 100000 -type all_extends -max_l 1\n\n# All rotations with 180 degrees\n./gen -n 1000 -m 1000 -type all_rotations -max_a 180\n\n# Rotations with angles 90, 180, 270 degrees\n./gen -n 1000 -m 1000 -type corner_angles\n\n# Mixed operations, small n\n./gen -n 10 -m 100 -type random\n\n# Mixed operations, large n\n./gen -n 100000 -m 100000 -type random\n\n# All operations on the last segment\n./gen -n 100000 -m 100000 -type single_segment\n\n# Maximum n, m = 1, single extension\n./gen -n 300000 -m 1 -type all_extends\n\n# Maximum n, m = 1, single rotation\n./gen -n 300000 -m 1 -type all_rotations\n\n# Maximum n, alternate operations\n./gen -n 300000 -m 300000 -type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:59:58.305457",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/F",
      "title": "F. Двойной рюкзак",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных будет записано единственное целое число n (1 ≤ n ≤ 1 000 000).Во второй строке содержатся n целых чисел от 1 до n — элементы A. В третьей строке содержатся n целых чисел от 1 до n — элементы B.",
      "output_spec": "Выходные данныеЕсли решения не существует, то выведите -1. В противном случае выведите своё решение на четырёх строках.Первая строка должна содержать единственное целое число ka, определяющее размер соответствующего подмножества A. Вторая строка должна содержать ka различных чисел — индексы элементов подмножества A.Третья строка должна содержать единственное целое число kb, определяющее размер соответствующего подмножества B. Четвёртая строка должна содержать kb различных чисел — индексы подмножества B.Элементы обоих мультимножеств нумеруются от 1 до n. Если возможных решений несколько, то выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать1010 10 10 10 10 10 10 10 10 1010 9 8 7 6 5 4 3 2 1Выходные данныеСкопировать1235 8 10Входные данныеСкопировать54 4 3 3 32 2 2 2 5Выходные данныеСкопировать22 323 5",
      "description": "F. Двойной рюкзак\n\nограничение по времени на тест2.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных будет записано единственное целое число n (1 ≤ n ≤ 1 000 000).Во второй строке содержатся n целых чисел от 1 до n — элементы A. В третьей строке содержатся n целых чисел от 1 до n — элементы B.\n\nВходные данные\n\nВыходные данныеЕсли решения не существует, то выведите -1. В противном случае выведите своё решение на четырёх строках.Первая строка должна содержать единственное целое число ka, определяющее размер соответствующего подмножества A. Вторая строка должна содержать ka различных чисел — индексы элементов подмножества A.Третья строка должна содержать единственное целое число kb, определяющее размер соответствующего подмножества B. Четвёртая строка должна содержать kb различных чисел — индексы подмножества B.Элементы обоих мультимножеств нумеруются от 1 до n. Если возможных решений несколько, то выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать1010 10 10 10 10 10 10 10 10 1010 9 8 7 6 5 4 3 2 1Выходные данныеСкопировать1235 8 10Входные данныеСкопировать54 4 3 3 32 2 2 2 5Выходные данныеСкопировать22 323 5\n\nВходные данныеСкопировать1010 10 10 10 10 10 10 10 10 1010 9 8 7 6 5 4 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1235 8 10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать54 4 3 3 32 2 2 2 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать22 323 5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Привет, Codeforces!Приглашаю вас принять участие в особом раунде Codeforces, который начнется 29-го января в 20:05 (московское время). Спасибо, Wunder Fund — лучшие участники получат призы и сувениры! Вот несколько слов непосредственно от компании Wunder Fund: Мы работаем в центре Москвы и занимаемся высокочастотным трейдингом — разрабатываем высокопроизводительные системы и алгоритмы автоматизированной торговли на финансовых рынках. Именно здесь оказываются важны алгоритмы, которые вы так любите придумывать и реализовывать — нужно быть быстрее других, сделки совершаются за доли секунд! На Codeforces разделяют нашу любовь к высокой производительности, поэтому мы и решили провести раунд. Высокочастотная торговля — это непрерывное соревнование лучших программистов и математиков всего мира. Присоединившись к нам, вы станете частью этой увлекательной схватки.Мы предлагаем интересные и сложные задачи по low latency разработке для увлеченных исследователей и программистов. Гибкий график и никакой бюрократии, решения быстро принимаются и воплощаются в жизнь. У нас небольшая команда, поэтому вы сразу станете ее значительной частью. Разбираться в экономике и финансах не требуется, а вот алгоритмы и структуры данных это то, что нам нужно.Заинтересовались? Присоединяйтесь к нам! Про вакансии можно почитать на нашем cайте.Мы будем рады подарить участникам призы и подарки: 1 место — PlayStation 4 2 место — Xbox One 3-5 места — Sega MegaDrive 16bit c играми 1-50 места — сувенирные футболки Wunder Fund 51-500 места — 50 футболок будут распределены случайным образом! Заинтересовались работой в Wunder Fund? А я хочу поблагодарить всех тех, кто помогал с подготовкой раунда: GlebsHP за ревью и помощь в подготовку задач, LiChenKoh и ??? за тестирование задач, Delinur за переводы, MikeMirzayanov за существование систем Codeforces и Polygon, и, конечно, Wunder Fund за инициативу выступить спонсором раунда! Надеюсь всех вас увидеть на раунде. Желаю удачи и удовольствия от раунда! Если вы хотите чуток потренироваться перед раундом, вы можете взглянуть на задачи моих предыдущих раундов (по ссылкам: A, B, C). Очень постараюсь порадовать вас интересными задачами.UPD: Опубликован разбор задач.",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2204
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> A = inf.readInts(n, 1, n, \"A_i\");\n    inf.readEoln();\n\n    vector<int> B = inf.readInts(n, 1, n, \"B_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> A = inf.readInts(n, 1, n, \"A_i\");\n    inf.readEoln();\n\n    vector<int> B = inf.readInts(n, 1, n, \"B_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> A = inf.readInts(n, 1, n, \"A_i\");\n    inf.readEoln();\n\n    vector<int> B = inf.readInts(n, 1, n, \"B_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // Read n, A and B from input (inf)\n    int n = inf.readInt(1, 1000000, \"n\");\n    vector<int> A(n), B(n);\n    for (int i = 0; i < n; ++i)\n        A[i] = inf.readInt(1, n, \"A[i]\");\n    for (int i = 0; i < n; ++i)\n        B[i] = inf.readInt(1, n, \"B[i]\");\n\n    // Read contestant's output\n    if (ouf.seekEof())\n        quitf(_wa, \"Contestant's output is empty\");\n\n    string first_token = ouf.readToken();\n    if (first_token == \"-1\") {\n        // Accept the answer\n        quitf(_ok, \"No solution provided by contestant\");\n    } else {\n        // Try to parse the first token as integer ka\n        int ka = stoi(first_token);\n        if (ka < 1 || ka > n)\n            quitf(_wa, \"Invalid ka: %d\", ka);\n        vector<int> indicesA;\n        for (int i = 0; i < ka; ++i) {\n            int idx = ouf.readInt(1, n, format(\"indicesA[%d]\", i+1).c_str());\n            indicesA.push_back(idx);\n        }\n        int kb = ouf.readInt(1, n, \"kb\");\n        if (kb < 1 || kb > n)\n            quitf(_wa, \"Invalid kb: %d\", kb);\n        vector<int> indicesB;\n        for (int i = 0; i < kb; ++i) {\n            int idx = ouf.readInt(1, n, format(\"indicesB[%d]\", i+1).c_str());\n            indicesB.push_back(idx);\n        }\n        // Check that indices are distinct within each list\n        set<int> setA(indicesA.begin(), indicesA.end());\n        set<int> setB(indicesB.begin(), indicesB.end());\n        if ((int)setA.size() != ka)\n            quitf(_wa, \"Duplicate indices in subset of A\");\n        if ((int)setB.size() != kb)\n            quitf(_wa, \"Duplicate indices in subset of B\");\n        // Compute sums\n        long long sumA = 0, sumB = 0;\n        for (int idx : indicesA)\n            sumA += A[idx - 1];\n        for (int idx : indicesB)\n            sumB += B[idx - 1];\n        if (sumA != sumB)\n            quitf(_wa, \"Sum of subsets are not equal: sumA=%lld, sumB=%lld\", sumA, sumB);\n\n        // Ensure there is no extra output\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra output found\");\n\n        quitf(_ok, \"Valid solution found, sum = %lld\", sumA);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> A(n), B(n);\n\n    if (type == \"random\") {\n        // Random elements for A and B\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            B[i] = rnd.next(1, n);\n    } else if (type == \"equal\") {\n        // Both A and B have the same sum\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        // Copy A to B\n        B = A;\n        // Shuffle B\n        shuffle(B.begin(), B.end());\n    } else if (type == \"nosolution\") {\n        if (n == 1) {\n            // No solution when n = 1 and elements are different\n            A[0] = 1;\n            B[0] = 2;\n        } else {\n            // Try to make sums of subsets of A and B not overlap\n            for (int i = 0; i < n; ++i)\n                A[i] = 1; // All ones\n            for (int i = 0; i < n; ++i)\n                B[i] = 2; // All twos\n            if (n % 2 == 0) {\n                // Adjust A to avoid overlapping sums\n                A[0] = 2;\n            }\n        }\n    } else if (type == \"equal_elements\") {\n        // All elements in A and B are the same\n        int val = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            A[i] = val;\n        B = A;\n    } else if (type == \"ones\") {\n        // All elements are 1\n        for (int i = 0; i < n; ++i)\n            A[i] = 1;\n        for (int i = 0; i < n; ++i)\n            B[i] = 1;\n    } else if (type == \"maxn\") {\n        // n is maximum, elements are random\n        n = 1000000;\n        A.resize(n);\n        B.resize(n);\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            B[i] = rnd.next(1, n);\n    } else if (type == \"smalln\") {\n        // n is small, elements are random\n        n = 1;\n        A.resize(n);\n        B.resize(n);\n        A[0] = rnd.next(1, n);\n        B[0] = rnd.next(1, n);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            B[i] = rnd.next(1, n);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", A[i], \" \\n\"[i == n - 1]);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", B[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> A(n), B(n);\n\n    if (type == \"random\") {\n        // Random elements for A and B\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            B[i] = rnd.next(1, n);\n    } else if (type == \"equal\") {\n        // Both A and B have the same sum\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        // Copy A to B\n        B = A;\n        // Shuffle B\n        shuffle(B.begin(), B.end());\n    } else if (type == \"nosolution\") {\n        if (n == 1) {\n            // No solution when n = 1 and elements are different\n            A[0] = 1;\n            B[0] = 2;\n        } else {\n            // Try to make sums of subsets of A and B not overlap\n            for (int i = 0; i < n; ++i)\n                A[i] = 1; // All ones\n            for (int i = 0; i < n; ++i)\n                B[i] = 2; // All twos\n            if (n % 2 == 0) {\n                // Adjust A to avoid overlapping sums\n                A[0] = 2;\n            }\n        }\n    } else if (type == \"equal_elements\") {\n        // All elements in A and B are the same\n        int val = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            A[i] = val;\n        B = A;\n    } else if (type == \"ones\") {\n        // All elements are 1\n        for (int i = 0; i < n; ++i)\n            A[i] = 1;\n        for (int i = 0; i < n; ++i)\n            B[i] = 1;\n    } else if (type == \"maxn\") {\n        // n is maximum, elements are random\n        n = 1000000;\n        A.resize(n);\n        B.resize(n);\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            B[i] = rnd.next(1, n);\n    } else if (type == \"smalln\") {\n        // n is small, elements are random\n        n = 1;\n        A.resize(n);\n        B.resize(n);\n        A[0] = rnd.next(1, n);\n        B[0] = rnd.next(1, n);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            A[i] = rnd.next(1, n);\n        for (int i = 0; i < n; ++i)\n            B[i] = rnd.next(1, n);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", A[i], \" \\n\"[i == n - 1]);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", B[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type nosolution\n./gen -n 1 -type random\n./gen -n 2 -type nosolution\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 10 -type equal\n./gen -n 10 -type ones\n./gen -n 10 -type equal_elements\n./gen -n 100 -type random\n./gen -n 100 -type equal\n./gen -n 100 -type ones\n./gen -n 100 -type equal_elements\n./gen -n 1000 -type random\n./gen -n 1000 -type equal\n./gen -n 1000 -type ones\n./gen -n 1000 -type equal_elements\n./gen -n 100000 -type random\n./gen -n 100000 -type equal\n./gen -n 100000 -type ones\n./gen -n 100000 -type equal_elements\n./gen -n 1000000 -type random\n./gen -n 1000000 -type equal\n./gen -n 1000000 -type ones\n./gen -n 1000000 -type equal_elements\n./gen -n 1000000 -type maxn\n./gen -n 1 -type smalln\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:00.671986",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "618/G",
      "title": "G. Combining Slimes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input will contain two integers n, p (1 ≤ n ≤ 109, 1 ≤ p < 109).",
      "output_spec": "OutputPrint the expected sum of all slimes on the board after the game finishes. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 4.Namely, let's assume that your answer is a and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy2 500000000OutputCopy3.562500000000000InputCopy10 1OutputCopy64.999983360007620InputCopy100 123456789OutputCopy269.825611298854770",
      "description": "G. Combining Slimes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input will contain two integers n, p (1 ≤ n ≤ 109, 1 ≤ p < 109).\n\nOutputPrint the expected sum of all slimes on the board after the game finishes. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 4.Namely, let's assume that your answer is a and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy2 500000000OutputCopy3.562500000000000InputCopy10 1OutputCopy64.999983360007620InputCopy100 123456789OutputCopy269.825611298854770\n\nInputCopy2 500000000\n\nOutputCopy3.562500000000000\n\nInputCopy10 1\n\nOutputCopy64.999983360007620\n\nInputCopy100 123456789\n\nOutputCopy269.825611298854770\n\nNoteIn the first sample, we have a board with two squares, and there is a 0.5 probability of a 1 appearing and a 0.5 probability of a 2 appearing.Our final board states can be 1 2 with probability 0.25, 2 1 with probability 0.375, 3 2 with probability 0.1875, 3 1 with probability 0.1875. The expected value is thus (1 + 2)·0.25 + (2 + 1)·0.375 + (3 + 2)·0.1875 + (3 + 1)·0.1875 = 3.5625.",
      "solutions": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in a special Codeforces round. It will take place on 29 Jan, 17:05 UTC. It will not be a usual round. Thanks to Wunder Fund, the best participants will win prizes and souvenirs. Here are some words from Wunder Fund: Our company is situated in the center of Moscow. We are engaged in high-frequency trading — developing high-performance systems and algorithms for automated trading in financial markets. In this area algorithms and data structures (that you love to invent and implement) are vital. Our systems should process transactions in milliseconds! High-frequency trading is a continuous competition of the best programmers and mathematicians around the world. By joining us, you will become a part of this exciting challenge.We offer interesting and challenging tasks for the development of low latency for enthusiastic researchers and programmers. Flexible and no bureaucracy, decisions are taken quickly and implemented. We are a small team, so you will immediately become a significant part of it. Understand the economics and finance is not required, but the algorithms and data structures is what we need.Are Russian speaking and ready to live in Moscow? Join us! Visit our website for more information.We will be happy to give participants prizes and gifts: 1 place — PlayStation 4 2 place — Xbox One 3-5 places — Sega MegaDrive 16bit with games 1-50 places — Wunder Fund T-Shirts! 51-500 places — 50 T-Shirts to random participants! Interested in the work on Wunder Fund? I want to thank the following people for helping me with this round: GlebsHP for his help in reviewing problems and assistance in preparation for the round. LiChenKoh, AlexFetisov, and winger for testing problems. Delinur for translations. MikeMirzayanov for Codeforces and Polygon systems. and of course Wunder Fund for sponsoring the round. I hope to see you all at the round. Good luck and have fun! :)If you'd like some practice before the round, you can look over some of my past rounds that I've written (links here: A B C). I will try to give you all some more interesting problems to solve.UPD1: The round will be 2 hours and 7 problems. Unfortunately, there are some time conflicts, so we are unable to extend the duration of the round. The score distribution will be 500-1000-1500-1750-2500-2750-3500. Note that some problems that we thought are harder may actually be easier for you, so I encourage you to read all problems.UPD2: The editorial is published. Congratulations to the winners Egor Petr Um_nik RomaWhite Sampson",
          "author": "Lewin",
          "url": "https://codeforces.com/blog/entry/23084",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2572
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces",
          "content": "I hope you enjoyed the contest! Let me know if you find any errors below. Thanks for participating.Short solutions: Slime Combining: You can just do what's described in the statement. Or, maybe you can do something with the binary representation of the number. Guess the permutation: Find out where 1 should go. Then, find out where 2 should go, and so on. Constellation: Start with a triangle and break it up. Or, choose a point and look at angles. Or, sort by x coordinate. Hamiltonian Spanning Tree: Two cases: X > Y and X <= Y. For X > Y we can almost always avoid the spanning tree edges. For X <= Y we can do something greedy. Robot Arm: Make a segment tree on segments. A segment is basically just a linear transformation, which can be described with three numbers. Double Knapsack: Make the problem harder. Let's say I want a consecutive sublist of both lists that have equal sums. Then use pigeonhole principle to get an answer. Combining Slimes: Use conditional expectations. Define E[value of squares i .. n | i-th square has value j, and will not be merged with anything]. Notice that it's almost impossible for us to get a slime with value >= 50. Then, somehow generalize to large values of n (either by linear interpoloation or matrix exponentiation). Long solutions:Slime CombiningWe can simulate the process described in the problem statement. There are many possible implementations of this, so see the example code for one possible implementation. This method can take O(n) time.However, there is a faster method. It can be shown that the answer is simply the 1-based indices of the one bits in the binary representation of n. So, we can just do this in O(log n) time. Example code (for simulation): http://codeforces.com/contest/618/submission/15669470Example code (for faster method): http://codeforces.com/contest/618/submission/15669458Guess the PermutationOne solution is to look for the column/row that contains only 1s and 0s. We know that this index must be the index for the element 1. Then, we can repeat this for 2 through n. See the example code for more details. The runtime of this solution is O(n^3).However, there is an easier solution. One answer is to just take the max of each row, which gives us a permutation. Of course, the element n-1 will appear twice, but we can replace either occurrence with n and be done. See the other code for detailsExample code (for first): http://codeforces.com/contest/618/submission/15669492Example code (for second): http://codeforces.com/contest/618/submission/15669483Comment: Originally, I wanted to set it so it wasn't guaranteed that there was a solution. But this seemed a bit tedious to me, so I didn't include this case.ConstellationThere are many possible solutions to this problem.The first solution is to choose any nondegenerate triangle. Then, for each other point, if it is inside the triangle, we can replace one of our three triangle points and continue. We only need to make a single pass through the points. We need to be a bit careful about collinear points in this case. Another solution is as follows. Let's choose an arbitrary point. Then, sort all other points by angle about this point. Then, we can just choose any two other points that have different angles, breaking ties by distance to the chosen point. (or breaking ties by two adjacent angles).Example code (by breaking up triangles): http://codeforces.com/contest/618/submission/15669502Example code (by angles): http://codeforces.com/contest/618/submission/15669511Comment: Except for the second sample, all pretests didn't have collinear points. So many hacking cases are cases with collinear points.Hamiltonian Spanning TreeThis is two separate problems: One where X > Y and when X <= Y.Suppose X > Y. Then, we can almost always choose a path that avoides any spanning tree edges. There is one tricky case, which is the case of a star graph.To prove the above statement, we know a tree is bipartite, so let's choose a bipartition X,Y. As long as there is exists a pair x in X and y in Y such that there isn't an edge between x and y, we can form a hamiltonian path without visiting any spanning tree edges (i.e. travel through all vertices in X and end at x, then go to y, then travel through all vertices in Y). We can see that this happens as long as it is not a complete bipartite graph, which can only happen when |X| = 1 or |Y| = 1 (which is the case of a star graph).For the other case, X <= Y. Some intuition is that you want to maximize the number of edges that you use within the spanning tree. So, you might think along the lines of a \"maximum path cover\". Restating the problem is a good idea at this point.Here's a restated version of the problem. You're given a tree. Choose the maximum number of edges such that all nodes are incident to at most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly, the intuition is that a 2-matching is a path cover, and vice versa. This can be done with a tree dp, but here is a greedy solution for this problem. Root the tree arbitrarily. Then, let's perform a dfs so we process all of a node's children before processing a node. To process a node, let's count the number of \"available\" children. If this number is 0, then mark the node as available. If this number is 1, draw an edge from the node to its only available child and mark the node as available. Otherwise, if this number is 2 or greater, choose two arbitrary children and use those edges. Do not mark the node as available in this case.Now, let U be the number of edges that we used from the above greedy algorithm. Then, the final answer is (n-1-U)*y + U*x).(Proof may be added later, as mine is a bit long, unless someone has an easier proof they want to post).Example code: http://codeforces.com/contest/618/submission/15669516Comment: The case where X > Y and the tree is a star was not included in pretests. Thus, this could have been used to hack.Robot ArmWe can view a segment as a linear transformation in two stages, first a rotation, then a translation.We can describe a linear transformation with a 3x3 matrix, so for example, a rotation by theta is given by the matrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0, 0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0, 1}} (these can also be found by searching on google). So, we can create a segment tree on the segments, where a node in the segment tree describes the 3x3 matrix of a range of nodes. Thus updating takes O(log n) time, and getting the coordinates of the last blue point can be taken.Some speedups. There is no need to store a 3x3 matrix. You can instead store the x,y, and angle at each node, and combine them appropriately (see code for details). Also, another simple speedup is to precompute cos/sin for all 360 degrees so we don't repeatedly call these functions.Example code (Java): http://codeforces.com/contest/618/submission/15669521Example code (C++): http://codeforces.com/contest/618/submission/15669530Comment: I'm very sorry about precision issues. We realized this at the last minute, and I didn't expect so many solutions to fail because of this. I have checked my own answers against a BigDecimal implementation in Java, so try to use long doubles. Also, as a side note, this is the first ever data structure question that I've written.Double KnapsackLet's replace \"set\" with \"array\", and \"subset\" with \"consecutive subarray\".Let ai denote the sum of the first i elements of A and bj be the sum of the first j elements of B. WLOG, let's assume an ≤ bn. For each ai, we can find the largest j such that bj ≤ ai. Then, the difference ai - bj will be between 0 and n - 1 inclusive. There are (n + 1) such differences (including a0 - b0), but only n integers it can take on, so by pigeon hole principle, at least two of them are the same.So, we have ai - bj = ai' - bj'. Suppose that i' < i. It can be shown that j' < j. So, we rearranging our equation, we have ai - ai' = bj - bj', which allows us to extract the indices.Example code: http://codeforces.com/contest/618/submission/15669546Comment: It seemed difficult for me to generate strong cases. Is there an easy way to do it? I tried my best, but there may be some weird solutions that can pass that I just overloooked.Combining SlimesThe probability that we form a slime with value i roughly satisfies the recurrence p(i) = p(i-1)^2, where p(1) and p(2) are given as base cases, where they are at most 999999999/1000000000. Thus, for i bigger than 50, p(i) will be extremely small (about 1e-300), so we can ignore values bigger than 50.Let a[k][i] be the probability that a sequence of 1s and 2s can create i given that we have k squares to work with, and b[k][i] be the same thing, except we also add the constraint that the first element is a 2.Then, we have the recurrence a[k][i] = a[k][i-1] * a[k-1][i-1], b[i][k] = b[k][i-1] * b[k-1][i-1] Note that as k gets to 50 or bigger a[k] will be approximately a[k-1] and b[k] will be approximately b[k-1] so we only need to compute this for the first 50 rows.We can compute the probability that the square at i will have value exactly k as a[n-i][k] * (1 — a[n-i-1][k]).Let dp[i][j] denote the expected value of the board from square i to n given that there is currently a slime with value j at index i and this slime is not going to be combined with anything else.The final answer is just We can compute dp[i][j] using 2 cases: First, we compute this dp manually from n to n-50. After that, we can notice that since a[k] is equal to a[k-1] and b[k] is equal to b[k-1] for k large enough, this dp can be written as a matrix exponentiation with 50 states. Thus, this takes O(50^3 * log(n)). Another approach that would also work is that after a large number of squares, the probabiltiy distribution of a particular square seems to converge (I'm not able to prove this though, though it seems to be true). So, by linearty of expectation, adding a square will add the same amount. So, you can do this dp up to maybe 500 or 1000, and then do linear interpolation from there.Example code (with matrix exponentiation): http://codeforces.com/contest/618/submission/15669558Example code (with linear interpolation): http://codeforces.com/contest/618/submission/15669560Comments; This problem is inspired from the game 2048. The way I discovered these formulas was through some trial and error and comparing versus a bitmask dp. Try to come up with the bitmask dp solution first if you are having trouble with understanding the editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 618 和字母"
          },
          "content_length": 10538
        }
      ],
      "code_examples": [
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 1",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 2",
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    vector<int> places;\n    for (int i = 51; i <= 500; i++)\n        places.push_back(i);\n    shuffle(places.begin(), places.end());\n\n    cout << \"T-Shirt Random Winners:\";\n    for (int i = 0; i < 50; i++)\n        cout << \" \" << places[i];\n    cout << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 3",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 4",
          "code": "6 1 2\n1 2\n2 3\n3 5\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 5",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 6",
          "code": "3 2 1\n1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 7",
          "code": "sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 8",
          "code": "<< fixed << setprecision",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 9",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 10",
          "code": "0 1\n0 3\n0 2\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 12",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 13",
          "code": "height[v] = 1 + dfs(node[v][1].first);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 14",
          "code": "Integer.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 - Codeforces - Code 15",
          "code": "Long.compare(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23084",
          "author": "Lewin"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 1",
          "code": "for (int i = 0; i < N; i++)\n    if (!visited[i])\n        total += diameter(i)*X + Y;\nreturn total - Y;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 2",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 3",
          "code": "*   *\n|   |\n*   *\n|   |\n* - *\n|   |\n*   *\n|   |\n*   *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 4",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        },
        {
          "title": "Wunder Fund Round 2016 Editorials - Codeforces - Code 5",
          "code": "if (ccw(a,b,i) >= 0 & ccw(b,c,i) >= 0 && ccw(c,a,i) >= 0) {\n        if (ccw(a,b,i) != 0) c = i;\n        else if (ccw(b,c,i) != 0) a = i;\n        else if (ccw(c,a,i) != 0) b = i;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23142",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, 999999999, \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, 999999999, \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, 999999999, \"p\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int p = opt<int>(\"p\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"max_n\") {\n        n = int(1e9);\n        p = rnd.next(1, int(1e9) - 1);\n    } else if (type == \"max_p\") {\n        n = rnd.next(1, int(1e9));\n        p = int(1e9) - 1;\n    } else if (type == \"min_values\") {\n        n = 1;\n        p = 1;\n    } else if (type == \"small_n_small_p\") {\n        n = rnd.next(1, 10);\n        p = rnd.next(1, 10);\n    } else if (type == \"large_n_small_p\") {\n        n = int(1e9);\n        p = rnd.next(1, 10);\n    } else if (type == \"small_n_large_p\") {\n        n = rnd.next(1, 10);\n        p = int(1e9) - 1;\n    } else if (type == \"n_equals_p\") {\n        int val = rnd.next(1, int(1e9) - 1);\n        n = val;\n        p = val;\n    } else if (type == \"random\") {\n        n = rnd.next(1, int(1e9));\n        p = rnd.next(1, int(1e9) - 1);\n    } else {\n        // If n and p are provided, check constraints\n        if (n == -1 || p == -1) {\n            fprintf(stderr, \"Error: n and p must be provided or use a predefined type.\\n\");\n            return 1;\n        }\n    }\n\n    // Ensure n and p are within constraints\n    n = max(1, min(n, int(1e9)));\n    p = max(1, min(p, int(1e9) - 1));\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int p = opt<int>(\"p\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"max_n\") {\n        n = int(1e9);\n        p = rnd.next(1, int(1e9) - 1);\n    } else if (type == \"max_p\") {\n        n = rnd.next(1, int(1e9));\n        p = int(1e9) - 1;\n    } else if (type == \"min_values\") {\n        n = 1;\n        p = 1;\n    } else if (type == \"small_n_small_p\") {\n        n = rnd.next(1, 10);\n        p = rnd.next(1, 10);\n    } else if (type == \"large_n_small_p\") {\n        n = int(1e9);\n        p = rnd.next(1, 10);\n    } else if (type == \"small_n_large_p\") {\n        n = rnd.next(1, 10);\n        p = int(1e9) - 1;\n    } else if (type == \"n_equals_p\") {\n        int val = rnd.next(1, int(1e9) - 1);\n        n = val;\n        p = val;\n    } else if (type == \"random\") {\n        n = rnd.next(1, int(1e9));\n        p = rnd.next(1, int(1e9) - 1);\n    } else {\n        // If n and p are provided, check constraints\n        if (n == -1 || p == -1) {\n            fprintf(stderr, \"Error: n and p must be provided or use a predefined type.\\n\");\n            return 1;\n        }\n    }\n\n    // Ensure n and p are within constraints\n    n = max(1, min(n, int(1e9)));\n    p = max(1, min(p, int(1e9) - 1));\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_values\n./gen -type max_n\n./gen -type max_p\n./gen -type small_n_small_p\n./gen -type large_n_small_p\n./gen -type small_n_large_p\n./gen -type n_equals_p\n./gen -type random\n\n./gen -n 1 -p 1\n./gen -n 1 -p 999999999\n./gen -n 2 -p 500000000\n./gen -n 10 -p 1\n./gen -n 10 -p 999999999\n./gen -n 100 -p 500000000\n./gen -n 1000 -p 123456789\n./gen -n 10000 -p 987654321\n./gen -n 100000 -p 111111111\n./gen -n 1000000 -p 222222222\n./gen -n 10000000 -p 333333333\n./gen -n 100000000 -p 444444444\n./gen -n 999999999 -p 555555555\n./gen -n 1000000000 -p 666666666\n./gen -n 1000000000 -p 999999998\n./gen -n 1000000000 -p 999999999\n./gen -n 999999999 -p 1\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:02.764196",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "62/A",
      "title": "A. A Student's Dream",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two positive integers not exceeding 100. They are the number of fingers on the Venusian girl's left and right hand correspondingly. The second line contains two integers not exceeding 100. They are the number of fingers on the Marsian boy's left and right hands correspondingly.",
      "output_spec": "OutputPrint YES or NO, that is, the answer to Petr Palych's question.",
      "sample_tests": "ExamplesInputCopy5 110 5OutputCopyYESInputCopy4 53 3OutputCopyYESInputCopy1 211 6OutputCopyNO",
      "description": "A. A Student's Dream\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two positive integers not exceeding 100. They are the number of fingers on the Venusian girl's left and right hand correspondingly. The second line contains two integers not exceeding 100. They are the number of fingers on the Marsian boy's left and right hands correspondingly.\n\nOutputPrint YES or NO, that is, the answer to Petr Palych's question.\n\nInputCopy5 110 5OutputCopyYESInputCopy4 53 3OutputCopyYESInputCopy1 211 6OutputCopyNO\n\nInputCopy5 110 5\n\nOutputCopyYES\n\nInputCopy4 53 3\n\nOutputCopyYES\n\nInputCopy1 211 6\n\nOutputCopyNO\n\nNoteThe boy and the girl don't really care who goes to the left.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #58 - Codeforces",
          "content": "Good evening!Glad to see you at the 58-th beta round. Problems for today's contest are prepared by Orel STU and NNSU teams.Good luck everyone!Unfortunately, statement of problem A was incorrect in English. Russian statement was OK. I'm sorry for this mistake.Results and ratings were updated.Thanks for everybody who solve this contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1356",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 336
        },
        {
          "title": "Codeforces Beta Round #58 tutorial - Codeforces",
          "content": "Problem A. A Student's Dream.There was a lot of troubles because of incorrect statement. Now I hope statement is ok. Let's solve it. =)If boy will goes to the left he will take her left hand with his right one and boy's left hand and girl's right hand will be unused. Situation is looks like the same if we swap them vice versa. So, we need to check two situations and choose the best one.There is a simple way to check comfortableness, let's assume that boy has B fingers on active hand and girl has G fingers on active hand, so: If B < G they will be happy only when B = G - 1, you may see a pattern GBGBGBG...GBGBG. In this pattern you can add no girl's finger for save the condition in statementIf B > G the worst but correct situation for them is a pattern BBGBBGBB...BBGBB. As you may see this way must be satisfy 2G + 2 >  = B conditionSimple situation is B = G, obviously answer is \"yes\"Problem B. Tyndex.Brome.Let's define p as total length of all potential addresses c. In this problem obvious solution has O(p· k) difficulty and it is getting a TLE verdict. Let's speed up it by next way: we will save all position of letters 'a', 'b', ..., 'z' in address entered by user s separately in increasing order. After this step we can find closest position of letter ci in s for logarithmic time by binary search. This solution has O(p · logk) difficulty that gives \"accepted\".Look carefully for length of potential address (it can be more than 105). Answer can be too big and asks you for using integer 64-bit type.Problem C. Inquisition.All triangles are located strickly inside of square. It makes problem more simplify, because you don't need to check situations of touching sides.Let's save all segments of every triangle and cross them in pairs. There are many points at every segment - the results of crossing. Look at the every subsegment which do not contain any points of crossing inside. There are two situations: this subsegment completely lie on the side of some triangle or this subsegment completely lie inside of some triangle.We may check what is situation by this way: let's take a point at the middle of subsegment. If this point is strickly inside of some triangle then all subsegment is located inside and vice versa. We should calculate only subsegments located on the side of triangles and print their total length.If you are using integer numbers you should be careful for some operations like vector multiplication because it may leave 32-bit type.If you are using real numbers you should change you types for as large as possible for good precision (long long in c++, extended in pascal).Problem D. Wormhouse.In this problem you asks to find lexicographically next euler cycle or say that there is no way. Let's solve this problem backwards.We should repeat way of Arnie. Now it needs to rollback every his step and add edges for empty graph (graph without edges). Let's assume we had rollback edge from some vertix x to vertix y. We need to check is there some vertix z that is connected to x by an edge and value of z is more than y? Besides edge (x; z) shouldn't be a bridge because our component needs to be connected. No solution answer if it's impossible to find such z at any step.But if edge (x; z) satisfied to conditions upper is exists let's change it to move and after this step our problem is to find lexicographically smallest euler way. It is possible to find only in unbreaked component of graph so every next step must going along non-brigde edges in vertix with as low number as possible. Of course, we must destroy unachievable vertices and do not destroy initial vertix.We can check is edge a bridge for O(E) time by depth first search. Total difficulty of algorithm represented above is O(N· E2).Problem E. World Evil.Author of this problem is Vasily Vadimov, NNSU. He wrote her own tutorial for you.In this problem you were to find the maximal flow in network with a cyllinder structure. The dynamic solution with complexity O(mn2n) was considered.It's well known that the maximal flow is equal to value of the minimal cut. Also all the sources must belong to one part of the cut and all the drains --- to the other part. Then we look over all the vertices from the left to the right, from the top to the bottom and append to the one or the other part of the cut, recalculating the answer during the process. The trivial solution has complexity O(2mn) and doesn't fit the time limit.But we can notice the number add to the answer after appending a new vertice to some part of the cut depends only on what parts of the cut the vertices in the current and the previous columns belong to. So we can calculate such a value using dynamic programming: what is the minimal cut can be obtained by adding i columns and the mask of belongings of vertices of the ith column to the parts of the cut is mask. Then we have 2n conversions because there are 2n different states of the i - 1th column. So we have the O(mn22n) solution.But this solution also can be improved. We calculate the minimal cut, if i - 1 columns are added completely and j vertices from the ith column are added, and mask of belongings of vertices that have no neighbours on the right is mask. Then we append j-th vertice to one of the parts, recalculate the value of the cut and do the conversion. So we have mn2n conditions and O(1) conversions from the every condition and the solution's complexity is O(mn2n).Also congratulations to the participants rng_58 and Ra16bit who solved this problem during the contest!Thanks to boys from NNSU (Vladislav Epifanov, Alexey Shmelev) who helps us with alternating solutions and etc.Sorry for poor english",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5660
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int al = inf.readInt(1, 100, \"al\");\n    inf.readSpace();\n    int ar = inf.readInt(1, 100, \"ar\");\n    inf.readEoln();\n\n    int bl = inf.readInt(1, 100, \"bl\");\n    inf.readSpace();\n    int br = inf.readInt(1, 100, \"br\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int al = inf.readInt(1, 100, \"al\");\n    inf.readSpace();\n    int ar = inf.readInt(1, 100, \"ar\");\n    inf.readEoln();\n\n    int bl = inf.readInt(1, 100, \"bl\");\n    inf.readSpace();\n    int br = inf.readInt(1, 100, \"br\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int al = inf.readInt(1, 100, \"al\");\n    inf.readSpace();\n    int ar = inf.readInt(1, 100, \"ar\");\n    inf.readEoln();\n\n    int bl = inf.readInt(1, 100, \"bl\");\n    inf.readSpace();\n    int br = inf.readInt(1, 100, \"br\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to check if it's possible to arrange 'G's and 'B's\n   satisfying the constraints of the problem */\nbool isPossible(int g, int b) {\n    if (g == 0) {\n        return b <= 2; // Can't have three 'B's in a row\n    }\n    if (b == 0) {\n        return g <= 1; // Can't have two 'G's in a row\n    }\n    int min_b = g - 1; // Need at least one 'B' between 'G's\n    if (b < min_b) return false;\n    int max_b = 2 * (g + 1); // Maximum 'B's without having three in a row\n    return b <= max_b;\n}\n\n/* Function to check if holding hands is possible in either option */\nbool checkOption(int al, int ar, int bl, int br) {\n    // Option 1: Girl's left hand with boy's right hand\n    int g = al, b = br;\n    if (isPossible(g, b)) return true;\n    // Option 2: Girl's right hand with boy's left hand\n    g = ar; b = bl;\n    if (isPossible(g, b)) return true;\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_n = opt<int>(\"max\", 100);\n\n    int al, ar, bl, br;\n\n    if (type == \"random\") {\n        // Generate random values for al, ar, bl, br within 1..max_n (YES cases)\n        do {\n            al = rnd.next(1, max_n);\n            ar = rnd.next(1, max_n);\n            bl = rnd.next(1, max_n);\n            br = rnd.next(1, max_n);\n        } while (!checkOption(al, ar, bl, br)); // Ensure the answer is YES\n    } else if (type == \"random_no\") {\n        // Generate random values for al, ar, bl, br within 1..max_n (NO cases)\n        do {\n            al = rnd.next(1, max_n);\n            ar = rnd.next(1, max_n);\n            bl = rnd.next(1, max_n);\n            br = rnd.next(1, max_n);\n        } while (checkOption(al, ar, bl, br)); // Ensure the answer is NO\n    } else if (type == \"max_yes\") {\n        // Maximum counts with YES answer\n        al = max_n;\n        ar = max_n;\n        bl = max_n;\n        br = max_n;\n    } else if (type == \"max_no\") {\n        // Maximum counts with NO answer\n        al = max_n;\n        ar = max_n;\n        bl = 1;\n        br = 1;\n    } else if (type == \"min_yes\") {\n        // Minimum counts with YES answer\n        al = 1;\n        ar = 1;\n        bl = 2;\n        br = 2;\n    } else if (type == \"min_no\") {\n        // Minimum counts with NO answer\n        al = 1;\n        ar = 1;\n        bl = 1;\n        br = 1;\n    } else if (type == \"one_option_yes\") {\n        // Only one option results in YES\n        al = rnd.next(1, max_n / 2);\n        ar = rnd.next(max_n / 2, max_n);\n        bl = rnd.next(1, max_n / 2);\n        br = rnd.next(max_n / 2, max_n);\n        // Adjust counts to ensure only one option gives YES\n        if (checkOption(al, ar, bl, br)) {\n            if (isPossible(al, br) && !isPossible(ar, bl)) {\n                // Option 1 is YES\n            } else if (!isPossible(al, br) && isPossible(ar, bl)) {\n                // Option 2 is YES\n            } else {\n                // Adjust counts\n                ar = 1;\n                bl = 1;\n            }\n        } else {\n            ar = 1;\n            bl = 1;\n        }\n    } else if (type == \"one_option_no\") {\n        // Both options result in NO\n        al = max_n;\n        ar = max_n;\n        bl = 1;\n        br = 1;\n    } else if (type == \"special\") {\n        // Generate specific test case from parameters\n        al = opt<int>(\"al\");\n        ar = opt<int>(\"ar\");\n        bl = opt<int>(\"bl\");\n        br = opt<int>(\"br\");\n    } else {\n        // Default random YES case\n        do {\n            al = rnd.next(1, max_n);\n            ar = rnd.next(1, max_n);\n            bl = rnd.next(1, max_n);\n            br = rnd.next(1, max_n);\n        } while (!checkOption(al, ar, bl, br));\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", al, ar);\n    printf(\"%d %d\\n\", bl, br);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to check if it's possible to arrange 'G's and 'B's\n   satisfying the constraints of the problem */\nbool isPossible(int g, int b) {\n    if (g == 0) {\n        return b <= 2; // Can't have three 'B's in a row\n    }\n    if (b == 0) {\n        return g <= 1; // Can't have two 'G's in a row\n    }\n    int min_b = g - 1; // Need at least one 'B' between 'G's\n    if (b < min_b) return false;\n    int max_b = 2 * (g + 1); // Maximum 'B's without having three in a row\n    return b <= max_b;\n}\n\n/* Function to check if holding hands is possible in either option */\nbool checkOption(int al, int ar, int bl, int br) {\n    // Option 1: Girl's left hand with boy's right hand\n    int g = al, b = br;\n    if (isPossible(g, b)) return true;\n    // Option 2: Girl's right hand with boy's left hand\n    g = ar; b = bl;\n    if (isPossible(g, b)) return true;\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_n = opt<int>(\"max\", 100);\n\n    int al, ar, bl, br;\n\n    if (type == \"random\") {\n        // Generate random values for al, ar, bl, br within 1..max_n (YES cases)\n        do {\n            al = rnd.next(1, max_n);\n            ar = rnd.next(1, max_n);\n            bl = rnd.next(1, max_n);\n            br = rnd.next(1, max_n);\n        } while (!checkOption(al, ar, bl, br)); // Ensure the answer is YES\n    } else if (type == \"random_no\") {\n        // Generate random values for al, ar, bl, br within 1..max_n (NO cases)\n        do {\n            al = rnd.next(1, max_n);\n            ar = rnd.next(1, max_n);\n            bl = rnd.next(1, max_n);\n            br = rnd.next(1, max_n);\n        } while (checkOption(al, ar, bl, br)); // Ensure the answer is NO\n    } else if (type == \"max_yes\") {\n        // Maximum counts with YES answer\n        al = max_n;\n        ar = max_n;\n        bl = max_n;\n        br = max_n;\n    } else if (type == \"max_no\") {\n        // Maximum counts with NO answer\n        al = max_n;\n        ar = max_n;\n        bl = 1;\n        br = 1;\n    } else if (type == \"min_yes\") {\n        // Minimum counts with YES answer\n        al = 1;\n        ar = 1;\n        bl = 2;\n        br = 2;\n    } else if (type == \"min_no\") {\n        // Minimum counts with NO answer\n        al = 1;\n        ar = 1;\n        bl = 1;\n        br = 1;\n    } else if (type == \"one_option_yes\") {\n        // Only one option results in YES\n        al = rnd.next(1, max_n / 2);\n        ar = rnd.next(max_n / 2, max_n);\n        bl = rnd.next(1, max_n / 2);\n        br = rnd.next(max_n / 2, max_n);\n        // Adjust counts to ensure only one option gives YES\n        if (checkOption(al, ar, bl, br)) {\n            if (isPossible(al, br) && !isPossible(ar, bl)) {\n                // Option 1 is YES\n            } else if (!isPossible(al, br) && isPossible(ar, bl)) {\n                // Option 2 is YES\n            } else {\n                // Adjust counts\n                ar = 1;\n                bl = 1;\n            }\n        } else {\n            ar = 1;\n            bl = 1;\n        }\n    } else if (type == \"one_option_no\") {\n        // Both options result in NO\n        al = max_n;\n        ar = max_n;\n        bl = 1;\n        br = 1;\n    } else if (type == \"special\") {\n        // Generate specific test case from parameters\n        al = opt<int>(\"al\");\n        ar = opt<int>(\"ar\");\n        bl = opt<int>(\"bl\");\n        br = opt<int>(\"br\");\n    } else {\n        // Default random YES case\n        do {\n            al = rnd.next(1, max_n);\n            ar = rnd.next(1, max_n);\n            bl = rnd.next(1, max_n);\n            br = rnd.next(1, max_n);\n        } while (!checkOption(al, ar, bl, br));\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", al, ar);\n    printf(\"%d %d\\n\", bl, br);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random_no\n./gen -type random_no\n./gen -type random_no\n\n./gen -type max_yes\n./gen -type max_no\n\n./gen -type min_yes\n./gen -type min_no\n\n./gen -type one_option_yes\n./gen -type one_option_no\n\n./gen -type random -max 50\n./gen -type random_no -max 50\n\n./gen -type random -max 1\n\n./gen -type special -al 50 -ar 50 -bl 1 -br 1\n./gen -type special -al 1 -ar 1 -bl 50 -br 50\n./gen -type special -al 50 -ar 1 -bl 1 -br 50\n\n./gen -type random -max 100\n./gen -type random_no -max 100\n\n# Additional random test cases\n./gen -type random\n./gen -type random_no\n./gen -type random\n./gen -type random_no\n\n# Edge cases with specific counts\n./gen -type special -al 100 -ar 1 -bl 2 -br 2   # Only one option gives YES\n./gen -type special -al 1 -ar 100 -bl 2 -br 2   # Only one option gives YES\n./gen -type special -al 50 -ar 50 -bl 50 -br 50 # Random counts, likely YES\n./gen -type special -al 100 -ar 100 -bl 1 -br 2 # Likely only one option gives YES\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:05.031506",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "62/B",
      "title": "B. Тындекс.Бром",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке дано два целых числа n и k (1 ≤ n ≤ 105, 1 ≤ k ≤ 105) — количество потенциальных адресов и длина введённого пользователем адреса. В следующей строке записано k строчных латинских букв — введённый пользователем адрес s. В каждой последующей i-ой (1 ≤ i ≤ n) строке дана непустая последовательность из строчных латинских букв — собственно потенциальный адрес. Гарантируется, что суммарная длина всех строк не превышает 2·105.",
      "output_spec": "Выходные данныеВ каждой из n строк выходного файла выведите одно число: значение функции ошибки при выборе текущего потенциального адреса.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 10codeforcescodeforcescodehorsesВыходные данныеСкопировать012Входные данныеСкопировать9 9vkontaktevcontactevkontraktevkollapsevkrokodilevtopkevkapustevpechkevkvcodeforceseВыходные данныеСкопировать18143647142930084",
      "description": "B. Тындекс.Бром\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке дано два целых числа n и k (1 ≤ n ≤ 105, 1 ≤ k ≤ 105) — количество потенциальных адресов и длина введённого пользователем адреса. В следующей строке записано k строчных латинских букв — введённый пользователем адрес s. В каждой последующей i-ой (1 ≤ i ≤ n) строке дана непустая последовательность из строчных латинских букв — собственно потенциальный адрес. Гарантируется, что суммарная длина всех строк не превышает 2·105.\n\nВходные данные\n\nВыходные данныеВ каждой из n строк выходного файла выведите одно число: значение функции ошибки при выборе текущего потенциального адреса.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).\n\nВыходные данные\n\nВходные данныеСкопировать2 10codeforcescodeforcescodehorsesВыходные данныеСкопировать012Входные данныеСкопировать9 9vkontaktevcontactevkontraktevkollapsevkrokodilevtopkevkapustevpechkevkvcodeforceseВыходные данныеСкопировать18143647142930084\n\nВходные данныеСкопировать2 10codeforcescodeforcescodehorses\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать012\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 9vkontaktevcontactevkontraktevkollapsevkrokodilevtopkevkapustevpechkevkvcodeforcese\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18143647142930084\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #58 - Codeforces",
          "content": "Добрый вечер!Рад всех приветствовать на 58-м раунде. Задачи к сегодняшнему контесту готовили коллективы команд Orel STU и NNSU.Задачи тура будут посвящены забавным жизненным ситуациям: вы встретитесь с самым суровым преподавателем в мире, вернётесь в средние века, разрешите противоборство крупных IT-компаний, выпустите Вселенское Зло из Большого Адронного Коллайдера и решите проблему червяка Арни, про которого обычно говорят: \"Арни огорчает твой жим\". =)Спасибо коллективу Codeforces, который помог подготовить предстоящий контест.Надеюсь, что раунд вам понравится! Удачи!К сожалению, раунд прошёл не так гладко, как хотелось бы. В задаче A русское условие оказалось более полным, чем аналогичное на английском языке. Мы приносим извинения за эту промашку.Подведены результаты контеста. И снова Геннадий одержал! =)Спасибо всем, кто участвовал в раунде!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1356",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 857
        },
        {
          "title": "Разбор задач Codeforces Beta Round #58 - Codeforces",
          "content": "Задача A. Сон Студента.В русской версии условия фразу \"между любыми двумя пальцами девочки есть палец мальчика\" нужно было читать как \"между любыми двумя соседними пальцами девочки есть палец мальчика\".Если мальчик пойдёт слева от девочки, то он возьмёт своей правой рукой её левую руку, а оставшиеся руки (левая мальчика и правая девочки) окажутся незадействованными. Если наоборот, мальчик пойдёт справа, то он возьмёт своей левой рукой правую руку девочки. Это написано в условии. Осталось проверить, \"совместимы\" ли руки для прогулки хотя бы в одном из этих случаев. Проверить это очень просто: пусть у мальчика B, а у девочки G пальцев, тогда:Если B < G, то им будет удобно, только если B = G - 1; это паттерн GBGBGBG...GBGBG. В этом паттерне нельзя добавить ни один палец девочки так, чтобы не нарушить требования условия.Если B > G, то наихудшая ситуация - это паттерн BBGBBGBB...BBGBB. Отсюда заметим, что должно выполняться 2G + 2 >  = B для возможности прогулки вдвоём.Чтобы не затуманивать логику первых двух случаев, третьим случаем вынесем B = G, но тут всё тривиально: очевидно, что взяться за руки они могут.Задача B. Тындекс.Бром.Обозначим за p суммарную длину всех потенциальных адресов c. В этой задаче ограничения были выбраны таким образом, чтобы очевидное решение с асимптотикой O(p· k) не проходило. Ускорять будем следующим образом: для каждой буквы из введённой пользователем строки s сохраним отдельно все позиции букв 'a', 'b', ..., 'z' в отсортированном порядке. Обладая этой информацией, можно искать для текущего символа потенциального адреса ci ближайший из s за логарифмическое время бинарным поиском. Таким образом, получается асимптотика O(p · logk), которая прекрасно проходит по времени. Важно было обратить внимание на ограничения и учесть, что длина потенциального адреса может быть больше, чем 105, а ответ не всегда помещается в 32-битный тип.Задача C. Инквизиция.Заметим, что, согласно ограничениям, все треугольники лежат строго внутри квадрата. Это упрощает задачу - не нужно рассматривать дополнительно случаи касания границ шкуры.Сохраним все отрезки каждого треугольника и все попарно пересечём. После этой операции на каждом отрезке может остаться много точек - результаты пересечения с другими отрезками. Рассмотрим каждый подотрезок этого отрезка такой, который не содержит внутри себя других точек. Этот подотрезок либо целиком лежит на границе пятна, либо целиком лежит внутри пятна.Чтобы проверить этот факт, можно взять середину подотрезка и проверить её на принадлежность исходным треугольникам. Если эта точка - середина подотрезка - лежит строго внутри некоторого пятна, то и весь отрезок будет лежать внутри, и прибавлять его длину к ответу не нужно. В противном случае, добавим эту длину к ответу и, после обработки всех отрезков таким образом, выведем накопившийся ответ.Если вы работаете с целыми числами, то учтите, что с заданными ограничениями до 105 вычисление, например, векторного произведения, может превысить 32-битный тип.Если вы работаете с вещественными числами, то используйте максимально большой тип данных (long double в c++, extended в паскале).Задача D. Дом для червя.В этой задаче требуется найти следующий лексикографически эйлеров цикл, заданный из некоторой точки - входа - или сказать, что такого пути не существует. Будем решать эту задачу с конца.Повторим маршрут Арни. Теперь будем откатываться назад по коридорам, которые он прогрыз, и добавлять рёбра к пустому графу (графу без рёбер). Пусть мы откатили на некотором шаге ребро, которое шло из комнаты x в комнату y. Проверим, существует ли вершина z такая, что есть ребро из x в z и номер вершины z больше номера вершины y. Кроме того, нужно проверить, что ребро (x; z) не является мостом - иначе мы разобьём компоненту связности на несколько и не сможем прогрызть все оставшиеся коридоры.No solution получается тогда, когда ни на каком шаге нельзя найти требуемую вершину z.Но когда такое ребро (x; z) оказалось найдено, то мы пройдём по нему и после этого будем искать лексикографически наименьший эйлеров путь. Для этого из каждой текущей вершины будем пытаться идти в вершину с минимально возможным номером. Пойти в вершину с минимально возможным номером можно только тогда, когда ребро, соединяющее эти вершины, не является мостом. Разумеется, нужно выбрасывать недостижимые вершины из графа и не считать их за отдельные компоненты, и не нужно выбрасывать начальную вершину, из которой Арни начал свой путь, иначе есть риск в неё уже не вернуться.Проверку на то, является ли ребро мостом, можно делать поиском в глубину за O(E). Соответственно, суммарная сложность алгоритма O(N· E2).Задача E. Вселенское ЗлоАвтор этой задачи - Василий Вадимов, ННГУ. Выкладываю его собственный разбор этой задачи и благодарю за помощь в проведении раунда.В этой задаче требовалось найти максимальный поток в сети со структурой в виде цилиндра. Предполагалось динамическое решение за O(mn2n). Известно, что максимальный поток в сети равен величине минимального разреза. Причем все истоки должны принадлежать одной доле разреза, а все стоки --- другой. Тогда будем перебирать вершины слева направо, сверху вниз и добавлять в ту или иную долю разреза, по ходу пересчитывая ответ. Тривиальное решение имеет асимптотику O(2mn) и, очевидно, не укладывается по времени.Но можно заметить, что то число, которое мы добавим ответу при добавлении новой вершины в какую-либо долю разреза, зависит только от того, к каким долям принадлежат вершины в предыдущем столбце и в том, которому принадлежит добавляемая вершина. Поэтому можно считать такую динамику: какой минимальный разрез можно получить, добавив i столбцов и в последнем столбце маска принадлежности вершин к долям разреза mask. Тогда имеется всего 2n переходов, т.к. различных состояний i - 1-го столбца 2n. Так решение оптимизируется до O(mn22n).Но и это решение можно улучшить, если динамику считать по изломанному профилю. Будем искать минимальный разрез, если мы добавили i - 1 столбцов полностью и добавили j вершин из i-го столбца и маска принадлежности вершин, у которых соседи справа еще не добавлены, mask. Тогда добавляем j-ю вершину, определяем в какую долю ее поместим, считаем, насколько увеличится величина разреза и делаем переход. Итого mn2n состояний, O(1) переходов из каждого состояния и сложность алгоритма O(mn2n). Поздравляем участников rng_58 и Ra16bit, решивших эту задачу во время контеста!Выражаю благодарность ребятам из ННГУ (Владиславу Епифанову, Алексею Шмелёву), которые писали альтернативные решения и задавали вопросы по условиям. Спасибо вам!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6550
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    long long total_length = 0;\n\n    std::string pattern = \"[a-z]{\" + std::to_string(k) + \"}\";\n    std::string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    total_length += k;\n\n    for (int i = 0; i < n; i++) {\n        std::string c_i = inf.readToken(\"[a-z]+\", \"potential_address\");\n        inf.readEoln();\n        total_length += c_i.length();\n    }\n\n    ensuref(total_length <= 200000, \"Total length of s and potential addresses must not exceed 200000, but is %lld\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    long long total_length = 0;\n\n    std::string pattern = \"[a-z]{\" + std::to_string(k) + \"}\";\n    std::string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    total_length += k;\n\n    for (int i = 0; i < n; i++) {\n        std::string c_i = inf.readToken(\"[a-z]+\", \"potential_address\");\n        inf.readEoln();\n        total_length += c_i.length();\n    }\n\n    ensuref(total_length <= 200000, \"Total length of s and potential addresses must not exceed 200000, but is %lld\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    long long total_length = 0;\n\n    std::string pattern = \"[a-z]{\" + std::to_string(k) + \"}\";\n    std::string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    total_length += k;\n\n    for (int i = 0; i < n; i++) {\n        std::string c_i = inf.readToken(\"[a-z]+\", \"potential_address\");\n        inf.readEoln();\n        total_length += c_i.length();\n    }\n\n    ensuref(total_length <= 200000, \"Total length of s and potential addresses must not exceed 200000, but is %lld\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random string of length len from an alphabet\nstring random_string(int len, const string& alphabet) {\n    string s = \"\";\n    int m = alphabet.size();\n    for (int i = 0; i < len; ++i) {\n        int idx = rnd.next(0, m - 1);\n        s += alphabet[idx];\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= k && k <= 100000);\n\n    // Compute max total length allowed for potential addresses\n    int max_total_length = 200000; // total length allowed\n    int remaining_length = max_total_length - k; // total length - length of s\n    ensure(remaining_length >= n); // Ensure at least length 1 for each address\n\n    // Generate s of length k\n    string s;\n\n    if (type == \"no_common\") {\n        // Create an alphabet that has no letters in common with potential addresses\n        string alphabet_s = \"abcdefghijklm\";\n        s = random_string(k, alphabet_s);\n\n    } else if (type == \"repetitive\") {\n        // s will be the same letter repeated\n        char c = 'a' + rnd.next(0, 25);\n        s = string(k, c);\n\n    } else {\n        // Random s\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        s = random_string(k, alphabet);\n    }\n\n    vector<string> addresses;\n    int total_address_length = 0; // Total length of potential addresses\n\n    // Need to ensure total_length = k + total_address_length ≤ max_total_length\n    int avg_length = remaining_length / n;\n\n    for (int i = 0; i < n; ++i) {\n        int len;\n        string addr;\n\n        if (type == \"same\") {\n            addr = s;\n\n        } else if (type == \"no_common\") {\n            // Potential addresses have no letters in common with s\n            len = avg_length;\n            len = max(1, len);\n            string alphabet_c = \"nopqrstuvwxyz\";\n            addr = random_string(len, alphabet_c);\n\n        } else if (type == \"subset\") {\n            // Potential addresses are subsets of s\n            len = avg_length;\n            len = max(1, min(len, (int)s.size()));\n            addr = \"\";\n            for (int j = 0; j < len; ++j) {\n                int idx = rnd.next(0, k - 1);\n                addr += s[idx];\n            }\n\n        } else if (type == \"superset\") {\n            // Potential addresses contain s and extra letters\n            len = avg_length;\n            len = max(len, k + 1);\n            len = min(len, remaining_length - total_address_length);\n            string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n            addr = s;\n            int extra_len = len - k;\n            for (int j = 0; j < extra_len; ++j) {\n                addr += alphabet[rnd.next(0, 25)];\n            }\n            shuffle(addr.begin(), addr.end());\n\n        } else if (type == \"repetitive\") {\n            // Addresses with repetitive letters\n            len = avg_length;\n            len = max(1, len);\n            char c = 'a' + rnd.next(0, 25);\n            addr = string(len, c);\n\n        } else {\n            // Random\n            len = avg_length;\n            len = max(1, len);\n            string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n            addr = random_string(len, alphabet);\n        }\n\n        if (total_address_length + addr.size() > remaining_length) {\n            // Cannot add more addresses without exceeding total length\n            break;\n        }\n\n        addresses.push_back(addr);\n        total_address_length += addr.size();\n    }\n\n    int actual_n = addresses.size();\n\n    // Output n, k, s, and the addresses\n    printf(\"%d %d\\n\", actual_n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    for (int i = 0; i < actual_n; ++i) {\n        printf(\"%s\\n\", addresses[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random string of length len from an alphabet\nstring random_string(int len, const string& alphabet) {\n    string s = \"\";\n    int m = alphabet.size();\n    for (int i = 0; i < len; ++i) {\n        int idx = rnd.next(0, m - 1);\n        s += alphabet[idx];\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= k && k <= 100000);\n\n    // Compute max total length allowed for potential addresses\n    int max_total_length = 200000; // total length allowed\n    int remaining_length = max_total_length - k; // total length - length of s\n    ensure(remaining_length >= n); // Ensure at least length 1 for each address\n\n    // Generate s of length k\n    string s;\n\n    if (type == \"no_common\") {\n        // Create an alphabet that has no letters in common with potential addresses\n        string alphabet_s = \"abcdefghijklm\";\n        s = random_string(k, alphabet_s);\n\n    } else if (type == \"repetitive\") {\n        // s will be the same letter repeated\n        char c = 'a' + rnd.next(0, 25);\n        s = string(k, c);\n\n    } else {\n        // Random s\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        s = random_string(k, alphabet);\n    }\n\n    vector<string> addresses;\n    int total_address_length = 0; // Total length of potential addresses\n\n    // Need to ensure total_length = k + total_address_length ≤ max_total_length\n    int avg_length = remaining_length / n;\n\n    for (int i = 0; i < n; ++i) {\n        int len;\n        string addr;\n\n        if (type == \"same\") {\n            addr = s;\n\n        } else if (type == \"no_common\") {\n            // Potential addresses have no letters in common with s\n            len = avg_length;\n            len = max(1, len);\n            string alphabet_c = \"nopqrstuvwxyz\";\n            addr = random_string(len, alphabet_c);\n\n        } else if (type == \"subset\") {\n            // Potential addresses are subsets of s\n            len = avg_length;\n            len = max(1, min(len, (int)s.size()));\n            addr = \"\";\n            for (int j = 0; j < len; ++j) {\n                int idx = rnd.next(0, k - 1);\n                addr += s[idx];\n            }\n\n        } else if (type == \"superset\") {\n            // Potential addresses contain s and extra letters\n            len = avg_length;\n            len = max(len, k + 1);\n            len = min(len, remaining_length - total_address_length);\n            string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n            addr = s;\n            int extra_len = len - k;\n            for (int j = 0; j < extra_len; ++j) {\n                addr += alphabet[rnd.next(0, 25)];\n            }\n            shuffle(addr.begin(), addr.end());\n\n        } else if (type == \"repetitive\") {\n            // Addresses with repetitive letters\n            len = avg_length;\n            len = max(1, len);\n            char c = 'a' + rnd.next(0, 25);\n            addr = string(len, c);\n\n        } else {\n            // Random\n            len = avg_length;\n            len = max(1, len);\n            string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n            addr = random_string(len, alphabet);\n        }\n\n        if (total_address_length + addr.size() > remaining_length) {\n            // Cannot add more addresses without exceeding total length\n            break;\n        }\n\n        addresses.push_back(addr);\n        total_address_length += addr.size();\n    }\n\n    int actual_n = addresses.size();\n\n    // Output n, k, s, and the addresses\n    printf(\"%d %d\\n\", actual_n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    for (int i = 0; i < actual_n; ++i) {\n        printf(\"%s\\n\", addresses[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type same\n./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type no_common\n./gen -n 1 -k 1 -type subset\n\n./gen -n 2 -k 10 -type same\n./gen -n 2 -k 10 -type random\n./gen -n 2 -k 10 -type superset\n./gen -n 2 -k 10 -type repetitive\n\n./gen -n 1000 -k 1000 -type same\n./gen -n 1000 -k 1000 -type random\n./gen -n 1000 -k 1000 -type subset\n./gen -n 1000 -k 1000 -type superset\n./gen -n 1000 -k 1000 -type no_common\n./gen -n 1000 -k 1000 -type repetitive\n\n./gen -n 50000 -k 100000 -type same\n./gen -n 50000 -k 100000 -type random\n./gen -n 50000 -k 100000 -type subset\n./gen -n 50000 -k 100000 -type superset\n./gen -n 50000 -k 100000 -type no_common\n./gen -n 50000 -k 100000 -type repetitive\n\n./gen -n 100000 -k 1 -type same\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 1 -type subset\n./gen -n 100000 -k 1 -type superset\n./gen -n 100000 -k 1 -type no_common\n./gen -n 100000 -k 1 -type repetitive\n\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 50000 -type subset\n./gen -n 100000 -k 50000 -type superset\n\n./gen -n 100000 -k 100000 -type random\n./gen -n 100000 -k 100000 -type subset\n./gen -n 100000 -k 100000 -type superset\n./gen -n 100000 -k 100000 -type no_common\n./gen -n 100000 -k 100000 -type repetitive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:06.713858",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "62/C",
      "title": "C. Inquisition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains a single integer n (0 ≤ n ≤ 100). It is the number of spots on the cat's fur. The i-th of the last n lines contains 6 integers: x1i, y1i, x2i, y2i, x3i, y3i. They are the coordinates of the i-th triangular spot (0 < xji, yji < 105).",
      "output_spec": "OutputPrint a single number, the answer to the problem, perimeter of the union of triangles. Your answer should differ from the correct one in no more than 10 - 6.",
      "sample_tests": "ExamplesInputCopy11 1 2 1 1 2OutputCopy3.4142135624InputCopy33 3 10 3 3 101 1 9 4 5 62 2 11 7 6 11OutputCopy37.7044021497",
      "description": "C. Inquisition\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains a single integer n (0 ≤ n ≤ 100). It is the number of spots on the cat's fur. The i-th of the last n lines contains 6 integers: x1i, y1i, x2i, y2i, x3i, y3i. They are the coordinates of the i-th triangular spot (0 < xji, yji < 105).\n\nOutputPrint a single number, the answer to the problem, perimeter of the union of triangles. Your answer should differ from the correct one in no more than 10 - 6.\n\nInputCopy11 1 2 1 1 2OutputCopy3.4142135624InputCopy33 3 10 3 3 101 1 9 4 5 62 2 11 7 6 11OutputCopy37.7044021497\n\nInputCopy11 1 2 1 1 2\n\nOutputCopy3.4142135624\n\nInputCopy33 3 10 3 3 101 1 9 4 5 62 2 11 7 6 11\n\nOutputCopy37.7044021497",
      "solutions": [
        {
          "title": "Codeforces Beta Round #58 - Codeforces",
          "content": "Good evening!Glad to see you at the 58-th beta round. Problems for today's contest are prepared by Orel STU and NNSU teams.Good luck everyone!Unfortunately, statement of problem A was incorrect in English. Russian statement was OK. I'm sorry for this mistake.Results and ratings were updated.Thanks for everybody who solve this contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1356",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 336
        },
        {
          "title": "Codeforces Beta Round #58 tutorial - Codeforces",
          "content": "Problem A. A Student's Dream.There was a lot of troubles because of incorrect statement. Now I hope statement is ok. Let's solve it. =)If boy will goes to the left he will take her left hand with his right one and boy's left hand and girl's right hand will be unused. Situation is looks like the same if we swap them vice versa. So, we need to check two situations and choose the best one.There is a simple way to check comfortableness, let's assume that boy has B fingers on active hand and girl has G fingers on active hand, so: If B < G they will be happy only when B = G - 1, you may see a pattern GBGBGBG...GBGBG. In this pattern you can add no girl's finger for save the condition in statementIf B > G the worst but correct situation for them is a pattern BBGBBGBB...BBGBB. As you may see this way must be satisfy 2G + 2 >  = B conditionSimple situation is B = G, obviously answer is \"yes\"Problem B. Tyndex.Brome.Let's define p as total length of all potential addresses c. In this problem obvious solution has O(p· k) difficulty and it is getting a TLE verdict. Let's speed up it by next way: we will save all position of letters 'a', 'b', ..., 'z' in address entered by user s separately in increasing order. After this step we can find closest position of letter ci in s for logarithmic time by binary search. This solution has O(p · logk) difficulty that gives \"accepted\".Look carefully for length of potential address (it can be more than 105). Answer can be too big and asks you for using integer 64-bit type.Problem C. Inquisition.All triangles are located strickly inside of square. It makes problem more simplify, because you don't need to check situations of touching sides.Let's save all segments of every triangle and cross them in pairs. There are many points at every segment - the results of crossing. Look at the every subsegment which do not contain any points of crossing inside. There are two situations: this subsegment completely lie on the side of some triangle or this subsegment completely lie inside of some triangle.We may check what is situation by this way: let's take a point at the middle of subsegment. If this point is strickly inside of some triangle then all subsegment is located inside and vice versa. We should calculate only subsegments located on the side of triangles and print their total length.If you are using integer numbers you should be careful for some operations like vector multiplication because it may leave 32-bit type.If you are using real numbers you should change you types for as large as possible for good precision (long long in c++, extended in pascal).Problem D. Wormhouse.In this problem you asks to find lexicographically next euler cycle or say that there is no way. Let's solve this problem backwards.We should repeat way of Arnie. Now it needs to rollback every his step and add edges for empty graph (graph without edges). Let's assume we had rollback edge from some vertix x to vertix y. We need to check is there some vertix z that is connected to x by an edge and value of z is more than y? Besides edge (x; z) shouldn't be a bridge because our component needs to be connected. No solution answer if it's impossible to find such z at any step.But if edge (x; z) satisfied to conditions upper is exists let's change it to move and after this step our problem is to find lexicographically smallest euler way. It is possible to find only in unbreaked component of graph so every next step must going along non-brigde edges in vertix with as low number as possible. Of course, we must destroy unachievable vertices and do not destroy initial vertix.We can check is edge a bridge for O(E) time by depth first search. Total difficulty of algorithm represented above is O(N· E2).Problem E. World Evil.Author of this problem is Vasily Vadimov, NNSU. He wrote her own tutorial for you.In this problem you were to find the maximal flow in network with a cyllinder structure. The dynamic solution with complexity O(mn2n) was considered.It's well known that the maximal flow is equal to value of the minimal cut. Also all the sources must belong to one part of the cut and all the drains --- to the other part. Then we look over all the vertices from the left to the right, from the top to the bottom and append to the one or the other part of the cut, recalculating the answer during the process. The trivial solution has complexity O(2mn) and doesn't fit the time limit.But we can notice the number add to the answer after appending a new vertice to some part of the cut depends only on what parts of the cut the vertices in the current and the previous columns belong to. So we can calculate such a value using dynamic programming: what is the minimal cut can be obtained by adding i columns and the mask of belongings of vertices of the ith column to the parts of the cut is mask. Then we have 2n conversions because there are 2n different states of the i - 1th column. So we have the O(mn22n) solution.But this solution also can be improved. We calculate the minimal cut, if i - 1 columns are added completely and j vertices from the ith column are added, and mask of belongings of vertices that have no neighbours on the right is mask. Then we append j-th vertice to one of the parts, recalculate the value of the cut and do the conversion. So we have mn2n conditions and O(1) conversions from the every condition and the solution's complexity is O(mn2n).Also congratulations to the participants rng_58 and Ra16bit who solved this problem during the contest!Thanks to boys from NNSU (Vladislav Epifanov, Alexey Shmelev) who helps us with alternating solutions and etc.Sorry for poor english",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5660
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nstruct Side {\n    Point p1, p2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100, \"n\");\n    inf.readEoln();\n\n    vector<Side> sides;\n\n    for (int i = 0; i < n; i++) {\n        long long x1 = inf.readInt(1, 99999, \"x1\");\n        inf.readSpace();\n        long long y1 = inf.readInt(1, 99999, \"y1\");\n        inf.readSpace();\n        long long x2 = inf.readInt(1, 99999, \"x2\");\n        inf.readSpace();\n        long long y2 = inf.readInt(1, 99999, \"y2\");\n        inf.readSpace();\n        long long x3 = inf.readInt(1, 99999, \"x3\");\n        inf.readSpace();\n        long long y3 = inf.readInt(1, 99999, \"y3\");\n        inf.readEoln();\n\n        // Check that the triangle is non-degenerate\n        long long S = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n        ensuref(S != 0, \"Triangle %d is degenerate\", i + 1);\n\n        // Add sides\n        Point p1 = {x1, y1};\n        Point p2 = {x2, y2};\n        Point p3 = {x3, y3};\n\n        sides.push_back({p1, p2});\n        sides.push_back({p2, p3});\n        sides.push_back({p3, p1});\n    }\n\n    int m = sides.size();\n    for (int i = 0; i < m; ++i) {\n        Side s1 = sides[i];\n        for (int j = i + 1; j < m; ++j) {\n            Side s2 = sides[j];\n\n            // Check if sides are colinear\n            long long x1 = s1.p1.x, y1 = s1.p1.y;\n            long long x2 = s1.p2.x, y2 = s1.p2.y;\n            long long x3 = s2.p1.x, y3 = s2.p1.y;\n            long long x4 = s2.p2.x, y4 = s2.p2.y;\n\n            long long dx1 = x2 - x1;\n            long long dy1 = y2 - y1;\n\n            long long S1 = dx1 * (y3 - y1) - dy1 * (x3 - x1);\n            long long S2 = dx1 * (y4 - y1) - dy1 * (x4 - x1);\n\n            if (S1 == 0 && S2 == 0) {\n                // Sides are colinear\n                // Check for overlapping projections\n                if (dx1 != 0) {\n                    // Project onto x-axis\n                    long long x_min1 = min(x1, x2);\n                    long long x_max1 = max(x1, x2);\n                    long long x_min2 = min(x3, x4);\n                    long long x_max2 = max(x3, x4);\n\n                    long long overlap = min(x_max1, x_max2) - max(x_min1, x_min2);\n                    if (overlap > 0) {\n                        ensuref(false, \"Sides %d and %d overlap in more than one point\", i + 1, j + 1);\n                    }\n                } else {\n                    // dx1 == 0, vertical line, project onto y-axis\n                    long long y_min1 = min(y1, y2);\n                    long long y_max1 = max(y1, y2);\n                    long long y_min2 = min(y3, y4);\n                    long long y_max2 = max(y3, y4);\n\n                    long long overlap = min(y_max1, y_max2) - max(y_min1, y_min2);\n                    if (overlap > 0) {\n                        ensuref(false, \"Sides %d and %d overlap in more than one point\", i + 1, j + 1);\n                    }\n                }\n            }\n            // Else: sides are not colinear, no need to check further\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nstruct Side {\n    Point p1, p2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100, \"n\");\n    inf.readEoln();\n\n    vector<Side> sides;\n\n    for (int i = 0; i < n; i++) {\n        long long x1 = inf.readInt(1, 99999, \"x1\");\n        inf.readSpace();\n        long long y1 = inf.readInt(1, 99999, \"y1\");\n        inf.readSpace();\n        long long x2 = inf.readInt(1, 99999, \"x2\");\n        inf.readSpace();\n        long long y2 = inf.readInt(1, 99999, \"y2\");\n        inf.readSpace();\n        long long x3 = inf.readInt(1, 99999, \"x3\");\n        inf.readSpace();\n        long long y3 = inf.readInt(1, 99999, \"y3\");\n        inf.readEoln();\n\n        // Check that the triangle is non-degenerate\n        long long S = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n        ensuref(S != 0, \"Triangle %d is degenerate\", i + 1);\n\n        // Add sides\n        Point p1 = {x1, y1};\n        Point p2 = {x2, y2};\n        Point p3 = {x3, y3};\n\n        sides.push_back({p1, p2});\n        sides.push_back({p2, p3});\n        sides.push_back({p3, p1});\n    }\n\n    int m = sides.size();\n    for (int i = 0; i < m; ++i) {\n        Side s1 = sides[i];\n        for (int j = i + 1; j < m; ++j) {\n            Side s2 = sides[j];\n\n            // Check if sides are colinear\n            long long x1 = s1.p1.x, y1 = s1.p1.y;\n            long long x2 = s1.p2.x, y2 = s1.p2.y;\n            long long x3 = s2.p1.x, y3 = s2.p1.y;\n            long long x4 = s2.p2.x, y4 = s2.p2.y;\n\n            long long dx1 = x2 - x1;\n            long long dy1 = y2 - y1;\n\n            long long S1 = dx1 * (y3 - y1) - dy1 * (x3 - x1);\n            long long S2 = dx1 * (y4 - y1) - dy1 * (x4 - x1);\n\n            if (S1 == 0 && S2 == 0) {\n                // Sides are colinear\n                // Check for overlapping projections\n                if (dx1 != 0) {\n                    // Project onto x-axis\n                    long long x_min1 = min(x1, x2);\n                    long long x_max1 = max(x1, x2);\n                    long long x_min2 = min(x3, x4);\n                    long long x_max2 = max(x3, x4);\n\n                    long long overlap = min(x_max1, x_max2) - max(x_min1, x_min2);\n                    if (overlap > 0) {\n                        ensuref(false, \"Sides %d and %d overlap in more than one point\", i + 1, j + 1);\n                    }\n                } else {\n                    // dx1 == 0, vertical line, project onto y-axis\n                    long long y_min1 = min(y1, y2);\n                    long long y_max1 = max(y1, y2);\n                    long long y_min2 = min(y3, y4);\n                    long long y_max2 = max(y3, y4);\n\n                    long long overlap = min(y_max1, y_max2) - max(y_min1, y_min2);\n                    if (overlap > 0) {\n                        ensuref(false, \"Sides %d and %d overlap in more than one point\", i + 1, j + 1);\n                    }\n                }\n            }\n            // Else: sides are not colinear, no need to check further\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nstruct Side {\n    Point p1, p2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100, \"n\");\n    inf.readEoln();\n\n    vector<Side> sides;\n\n    for (int i = 0; i < n; i++) {\n        long long x1 = inf.readInt(1, 99999, \"x1\");\n        inf.readSpace();\n        long long y1 = inf.readInt(1, 99999, \"y1\");\n        inf.readSpace();\n        long long x2 = inf.readInt(1, 99999, \"x2\");\n        inf.readSpace();\n        long long y2 = inf.readInt(1, 99999, \"y2\");\n        inf.readSpace();\n        long long x3 = inf.readInt(1, 99999, \"x3\");\n        inf.readSpace();\n        long long y3 = inf.readInt(1, 99999, \"y3\");\n        inf.readEoln();\n\n        // Check that the triangle is non-degenerate\n        long long S = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n        ensuref(S != 0, \"Triangle %d is degenerate\", i + 1);\n\n        // Add sides\n        Point p1 = {x1, y1};\n        Point p2 = {x2, y2};\n        Point p3 = {x3, y3};\n\n        sides.push_back({p1, p2});\n        sides.push_back({p2, p3});\n        sides.push_back({p3, p1});\n    }\n\n    int m = sides.size();\n    for (int i = 0; i < m; ++i) {\n        Side s1 = sides[i];\n        for (int j = i + 1; j < m; ++j) {\n            Side s2 = sides[j];\n\n            // Check if sides are colinear\n            long long x1 = s1.p1.x, y1 = s1.p1.y;\n            long long x2 = s1.p2.x, y2 = s1.p2.y;\n            long long x3 = s2.p1.x, y3 = s2.p1.y;\n            long long x4 = s2.p2.x, y4 = s2.p2.y;\n\n            long long dx1 = x2 - x1;\n            long long dy1 = y2 - y1;\n\n            long long S1 = dx1 * (y3 - y1) - dy1 * (x3 - x1);\n            long long S2 = dx1 * (y4 - y1) - dy1 * (x4 - x1);\n\n            if (S1 == 0 && S2 == 0) {\n                // Sides are colinear\n                // Check for overlapping projections\n                if (dx1 != 0) {\n                    // Project onto x-axis\n                    long long x_min1 = min(x1, x2);\n                    long long x_max1 = max(x1, x2);\n                    long long x_min2 = min(x3, x4);\n                    long long x_max2 = max(x3, x4);\n\n                    long long overlap = min(x_max1, x_max2) - max(x_min1, x_min2);\n                    if (overlap > 0) {\n                        ensuref(false, \"Sides %d and %d overlap in more than one point\", i + 1, j + 1);\n                    }\n                } else {\n                    // dx1 == 0, vertical line, project onto y-axis\n                    long long y_min1 = min(y1, y2);\n                    long long y_max1 = max(y1, y2);\n                    long long y_min2 = min(y3, y4);\n                    long long y_max2 = max(y3, y4);\n\n                    long long overlap = min(y_max1, y_max2) - max(y_min1, y_min2);\n                    if (overlap > 0) {\n                        ensuref(false, \"Sides %d and %d overlap in more than one point\", i + 1, j + 1);\n                    }\n                }\n            }\n            // Else: sides are not colinear, no need to check further\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random non-degenerate triangle\nvoid generate_random_triangle(int &x1, int &y1, int &x2, int &y2, int &x3, int &y3) {\n    while (true) {\n        x1 = rnd.next(1, 99999);\n        y1 = rnd.next(1, 99999);\n        x2 = rnd.next(1, 99999);\n        y2 = rnd.next(1, 99999);\n        x3 = rnd.next(1, 99999);\n        y3 = rnd.next(1, 99999);\n        // Check if points are not colinear\n        long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n        if (area2 != 0) {\n            break;\n        }\n        // Else, try again\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 0 || n > 100) {\n        cerr << \"Error: n should be between 0 and 100 inclusive.\" << endl;\n        return 1;\n    }\n\n    if (type == \"empty\") {\n        printf(\"0\\n\");\n    } else if (type == \"single\") {\n        printf(\"1\\n\");\n        int x1 = 1, y1 = 1;\n        int x2 = 2, y2 = 1;\n        int x3 = 1, y3 = 2;\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n    } else if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2, x3, y3;\n            generate_random_triangle(x1, y1, x2, y2, x3, y3);\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"no_overlap\") {\n        printf(\"%d\\n\", n);\n        int grid_size = ceil(sqrt(n));\n        int cell_size = 100000 / grid_size;\n        int cnt = 0;\n        for (int i = 0; i < grid_size && cnt < n; ++i) {\n            for (int j = 0; j < grid_size && cnt < n; ++j) {\n                // cell boundaries: x from x_left to x_right, y from y_bottom to y_top\n                int x_left = i * cell_size + 1;\n                int x_right = (i + 1) * cell_size - 1;\n                int y_bottom = j * cell_size + 1;\n                int y_top = (j + 1) * cell_size - 1;\n                // generate triangle within this cell\n                int x1 = rnd.next(x_left, x_right);\n                int y1 = rnd.next(y_bottom, y_top);\n                int x2 = rnd.next(x_left, x_right);\n                int y2 = rnd.next(y_bottom, y_top);\n                int x3 = rnd.next(x_left, x_right);\n                int y3 = rnd.next(y_bottom, y_top);\n                // check for non-degenerate\n                long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n                if (area2 == 0) {\n                    // adjust one coordinate slightly\n                    x3 = (x3 + 1) <= x_right ? x3 + 1 : x3 - 1;\n                    y3 = (y3 + 1) <= y_top ? y3 + 1 : y3 - 1;\n                }\n                printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n                cnt++;\n            }\n        }\n    } else if (type == \"overlap\") {\n        printf(\"%d\\n\", n);\n        int base_x = 50000;\n        int base_y = 50000;\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(-1000, 1000);\n            int x1 = base_x + delta;\n            int y1 = base_y + delta;\n            int x2 = base_x + delta + rnd.next(1, 1000);\n            int y2 = base_y + delta + rnd.next(1, 1000);\n            int x3 = base_x + delta + rnd.next(1, 1000);\n            int y3 = base_y + delta - rnd.next(1, 1000);\n            // check for non-degenerate\n            long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n            if (area2 == 0) {\n                x3 += 1;\n            }\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"touching_points\") {\n        printf(\"%d\\n\", n);\n        int common_x = 50000;\n        int common_y = 50000;\n        for (int i = 0; i < n; ++i) {\n            int x1 = common_x;\n            int y1 = common_y;\n            int x2 = common_x + rnd.next(1, 10000);\n            int y2 = common_y + rnd.next(1, 10000);\n            int x3 = common_x + rnd.next(1, 10000);\n            int y3 = common_y - rnd.next(1, 10000);\n            // check for non-degenerate\n            long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n            if (area2 == 0) {\n                y3 += 1;\n            }\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"nested\") {\n        printf(\"%d\\n\", n);\n        int center_x = 50000;\n        int center_y = 50000;\n        int size = 40000;\n        for (int i = 0; i < n; ++i) {\n            int x1 = center_x - size;\n            int y1 = center_y;\n            int x2 = center_x + size;\n            int y2 = center_y;\n            int x3 = center_x;\n            int y3 = center_y + size;\n            // Ensure coordinates are within limits\n            x1 = max(1, min(99999, x1));\n            y1 = max(1, min(99999, y1));\n            x2 = max(1, min(99999, x2));\n            y2 = max(1, min(99999, y2));\n            x3 = max(1, min(99999, x3));\n            y3 = max(1, min(99999, y3));\n            // Output triangle\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n            size = size * 9 / 10;  // decrease size by 10%\n            if (size <= 0) size = 1;\n        }\n    } else if (type == \"large_coordinates\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(90000, 99999);\n            int y1 = rnd.next(90000, 99999);\n            int x2 = rnd.next(90000, 99999);\n            int y2 = rnd.next(90000, 99999);\n            int x3 = rnd.next(90000, 99999);\n            int y3 = rnd.next(90000, 99999);\n            // check for non-degenerate\n            long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n            if (area2 == 0) {\n                x3 += 1;\n                x3 = min(x3, 99999);\n            }\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"precision\") {\n        printf(\"%d\\n\", n);\n        int base_x = 1;\n        int base_y = 1;\n        for (int i = 0; i < n; ++i) {\n            int side = rnd.next(1, min(10000, 100000 / n));\n            int x1 = base_x;\n            int y1 = base_y;\n            int x2 = base_x + side;\n            int y2 = base_y;\n            int x3 = base_x;\n            int y3 = base_y + side;\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n            base_x += side + 10;\n            base_y += side + 10;\n            if (base_x > 99999 || base_y > 99999) {\n                base_x = 1;\n                base_y = 1;\n            }\n        }\n    } else {\n        // Default is random\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2, x3, y3;\n            generate_random_triangle(x1, y1, x2, y2, x3, y3);\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random non-degenerate triangle\nvoid generate_random_triangle(int &x1, int &y1, int &x2, int &y2, int &x3, int &y3) {\n    while (true) {\n        x1 = rnd.next(1, 99999);\n        y1 = rnd.next(1, 99999);\n        x2 = rnd.next(1, 99999);\n        y2 = rnd.next(1, 99999);\n        x3 = rnd.next(1, 99999);\n        y3 = rnd.next(1, 99999);\n        // Check if points are not colinear\n        long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n        if (area2 != 0) {\n            break;\n        }\n        // Else, try again\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 0 || n > 100) {\n        cerr << \"Error: n should be between 0 and 100 inclusive.\" << endl;\n        return 1;\n    }\n\n    if (type == \"empty\") {\n        printf(\"0\\n\");\n    } else if (type == \"single\") {\n        printf(\"1\\n\");\n        int x1 = 1, y1 = 1;\n        int x2 = 2, y2 = 1;\n        int x3 = 1, y3 = 2;\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n    } else if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2, x3, y3;\n            generate_random_triangle(x1, y1, x2, y2, x3, y3);\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"no_overlap\") {\n        printf(\"%d\\n\", n);\n        int grid_size = ceil(sqrt(n));\n        int cell_size = 100000 / grid_size;\n        int cnt = 0;\n        for (int i = 0; i < grid_size && cnt < n; ++i) {\n            for (int j = 0; j < grid_size && cnt < n; ++j) {\n                // cell boundaries: x from x_left to x_right, y from y_bottom to y_top\n                int x_left = i * cell_size + 1;\n                int x_right = (i + 1) * cell_size - 1;\n                int y_bottom = j * cell_size + 1;\n                int y_top = (j + 1) * cell_size - 1;\n                // generate triangle within this cell\n                int x1 = rnd.next(x_left, x_right);\n                int y1 = rnd.next(y_bottom, y_top);\n                int x2 = rnd.next(x_left, x_right);\n                int y2 = rnd.next(y_bottom, y_top);\n                int x3 = rnd.next(x_left, x_right);\n                int y3 = rnd.next(y_bottom, y_top);\n                // check for non-degenerate\n                long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n                if (area2 == 0) {\n                    // adjust one coordinate slightly\n                    x3 = (x3 + 1) <= x_right ? x3 + 1 : x3 - 1;\n                    y3 = (y3 + 1) <= y_top ? y3 + 1 : y3 - 1;\n                }\n                printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n                cnt++;\n            }\n        }\n    } else if (type == \"overlap\") {\n        printf(\"%d\\n\", n);\n        int base_x = 50000;\n        int base_y = 50000;\n        for (int i = 0; i < n; ++i) {\n            int delta = rnd.next(-1000, 1000);\n            int x1 = base_x + delta;\n            int y1 = base_y + delta;\n            int x2 = base_x + delta + rnd.next(1, 1000);\n            int y2 = base_y + delta + rnd.next(1, 1000);\n            int x3 = base_x + delta + rnd.next(1, 1000);\n            int y3 = base_y + delta - rnd.next(1, 1000);\n            // check for non-degenerate\n            long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n            if (area2 == 0) {\n                x3 += 1;\n            }\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"touching_points\") {\n        printf(\"%d\\n\", n);\n        int common_x = 50000;\n        int common_y = 50000;\n        for (int i = 0; i < n; ++i) {\n            int x1 = common_x;\n            int y1 = common_y;\n            int x2 = common_x + rnd.next(1, 10000);\n            int y2 = common_y + rnd.next(1, 10000);\n            int x3 = common_x + rnd.next(1, 10000);\n            int y3 = common_y - rnd.next(1, 10000);\n            // check for non-degenerate\n            long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n            if (area2 == 0) {\n                y3 += 1;\n            }\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"nested\") {\n        printf(\"%d\\n\", n);\n        int center_x = 50000;\n        int center_y = 50000;\n        int size = 40000;\n        for (int i = 0; i < n; ++i) {\n            int x1 = center_x - size;\n            int y1 = center_y;\n            int x2 = center_x + size;\n            int y2 = center_y;\n            int x3 = center_x;\n            int y3 = center_y + size;\n            // Ensure coordinates are within limits\n            x1 = max(1, min(99999, x1));\n            y1 = max(1, min(99999, y1));\n            x2 = max(1, min(99999, x2));\n            y2 = max(1, min(99999, y2));\n            x3 = max(1, min(99999, x3));\n            y3 = max(1, min(99999, y3));\n            // Output triangle\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n            size = size * 9 / 10;  // decrease size by 10%\n            if (size <= 0) size = 1;\n        }\n    } else if (type == \"large_coordinates\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(90000, 99999);\n            int y1 = rnd.next(90000, 99999);\n            int x2 = rnd.next(90000, 99999);\n            int y2 = rnd.next(90000, 99999);\n            int x3 = rnd.next(90000, 99999);\n            int y3 = rnd.next(90000, 99999);\n            // check for non-degenerate\n            long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n            if (area2 == 0) {\n                x3 += 1;\n                x3 = min(x3, 99999);\n            }\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    } else if (type == \"precision\") {\n        printf(\"%d\\n\", n);\n        int base_x = 1;\n        int base_y = 1;\n        for (int i = 0; i < n; ++i) {\n            int side = rnd.next(1, min(10000, 100000 / n));\n            int x1 = base_x;\n            int y1 = base_y;\n            int x2 = base_x + side;\n            int y2 = base_y;\n            int x3 = base_x;\n            int y3 = base_y + side;\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n            base_x += side + 10;\n            base_y += side + 10;\n            if (base_x > 99999 || base_y > 99999) {\n                base_x = 1;\n                base_y = 1;\n            }\n        }\n    } else {\n        // Default is random\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int x1, y1, x2, y2, x3, y3;\n            generate_random_triangle(x1, y1, x2, y2, x3, y3);\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Empty test case\n./gen -n 0 -type empty\n\n# Single triangle test case\n./gen -n 1 -type single\n\n# Random test cases with increasing n\n./gen -n 5 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n# No overlap test cases\n./gen -n 10 -type no_overlap\n./gen -n 25 -type no_overlap\n./gen -n 50 -type no_overlap\n./gen -n 100 -type no_overlap\n\n# Overlap test cases\n./gen -n 10 -type overlap\n./gen -n 50 -type overlap\n./gen -n 100 -type overlap\n\n# Touching points test cases\n./gen -n 5 -type touching_points\n./gen -n 20 -type touching_points\n./gen -n 50 -type touching_points\n\n# Nested triangles test cases\n./gen -n 5 -type nested\n./gen -n 10 -type nested\n./gen -n 20 -type nested\n\n# Large coordinates test cases\n./gen -n 10 -type large_coordinates\n./gen -n 50 -type large_coordinates\n./gen -n 100 -type large_coordinates\n\n# Precision test cases\n./gen -n 5 -type precision\n./gen -n 20 -type precision\n./gen -n 50 -type precision\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:08.930221",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "62/D",
      "title": "D. Wormhouse",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (3 ≤ n ≤ 100, 3 ≤ m ≤ 2000). It is the number of rooms and corridors in Arnie's house correspondingly. The next line contains m + 1 positive integers that do not exceed n. They are the description of Arnie's old path represented as a list of rooms he visited during the gnawing. It is guaranteed that the last number in the list coincides with the first one.The first room described in the list is the main entrance, that's why Arnie should begin gnawing from it.You may assume that there is no room which is connected to itself and there is at most one corridor between any pair of rooms. However, it is possible to find some isolated rooms which are disconnected from others.",
      "output_spec": "OutputPrint m + 1 positive integers that do not exceed n. Those numbers are the description of the new path, according to which Arnie should gnaw out his new house. If it is impossible to find new path you should print out No solution. The first number in your answer should be equal to the last one. Also it should be equal to the main entrance.",
      "sample_tests": "ExamplesInputCopy3 31 2 3 1OutputCopy1 3 2 1 InputCopy3 31 3 2 1OutputCopyNo solution",
      "description": "D. Wormhouse\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (3 ≤ n ≤ 100, 3 ≤ m ≤ 2000). It is the number of rooms and corridors in Arnie's house correspondingly. The next line contains m + 1 positive integers that do not exceed n. They are the description of Arnie's old path represented as a list of rooms he visited during the gnawing. It is guaranteed that the last number in the list coincides with the first one.The first room described in the list is the main entrance, that's why Arnie should begin gnawing from it.You may assume that there is no room which is connected to itself and there is at most one corridor between any pair of rooms. However, it is possible to find some isolated rooms which are disconnected from others.\n\nOutputPrint m + 1 positive integers that do not exceed n. Those numbers are the description of the new path, according to which Arnie should gnaw out his new house. If it is impossible to find new path you should print out No solution. The first number in your answer should be equal to the last one. Also it should be equal to the main entrance.\n\nInputCopy3 31 2 3 1OutputCopy1 3 2 1 InputCopy3 31 3 2 1OutputCopyNo solution\n\nInputCopy3 31 2 3 1\n\nOutputCopy1 3 2 1\n\nInputCopy3 31 3 2 1\n\nOutputCopyNo solution",
      "solutions": [
        {
          "title": "Codeforces Beta Round #58 - Codeforces",
          "content": "Good evening!Glad to see you at the 58-th beta round. Problems for today's contest are prepared by Orel STU and NNSU teams.Good luck everyone!Unfortunately, statement of problem A was incorrect in English. Russian statement was OK. I'm sorry for this mistake.Results and ratings were updated.Thanks for everybody who solve this contest!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1356",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 336
        },
        {
          "title": "Codeforces Beta Round #58 tutorial - Codeforces",
          "content": "Problem A. A Student's Dream.There was a lot of troubles because of incorrect statement. Now I hope statement is ok. Let's solve it. =)If boy will goes to the left he will take her left hand with his right one and boy's left hand and girl's right hand will be unused. Situation is looks like the same if we swap them vice versa. So, we need to check two situations and choose the best one.There is a simple way to check comfortableness, let's assume that boy has B fingers on active hand and girl has G fingers on active hand, so: If B < G they will be happy only when B = G - 1, you may see a pattern GBGBGBG...GBGBG. In this pattern you can add no girl's finger for save the condition in statementIf B > G the worst but correct situation for them is a pattern BBGBBGBB...BBGBB. As you may see this way must be satisfy 2G + 2 >  = B conditionSimple situation is B = G, obviously answer is \"yes\"Problem B. Tyndex.Brome.Let's define p as total length of all potential addresses c. In this problem obvious solution has O(p· k) difficulty and it is getting a TLE verdict. Let's speed up it by next way: we will save all position of letters 'a', 'b', ..., 'z' in address entered by user s separately in increasing order. After this step we can find closest position of letter ci in s for logarithmic time by binary search. This solution has O(p · logk) difficulty that gives \"accepted\".Look carefully for length of potential address (it can be more than 105). Answer can be too big and asks you for using integer 64-bit type.Problem C. Inquisition.All triangles are located strickly inside of square. It makes problem more simplify, because you don't need to check situations of touching sides.Let's save all segments of every triangle and cross them in pairs. There are many points at every segment - the results of crossing. Look at the every subsegment which do not contain any points of crossing inside. There are two situations: this subsegment completely lie on the side of some triangle or this subsegment completely lie inside of some triangle.We may check what is situation by this way: let's take a point at the middle of subsegment. If this point is strickly inside of some triangle then all subsegment is located inside and vice versa. We should calculate only subsegments located on the side of triangles and print their total length.If you are using integer numbers you should be careful for some operations like vector multiplication because it may leave 32-bit type.If you are using real numbers you should change you types for as large as possible for good precision (long long in c++, extended in pascal).Problem D. Wormhouse.In this problem you asks to find lexicographically next euler cycle or say that there is no way. Let's solve this problem backwards.We should repeat way of Arnie. Now it needs to rollback every his step and add edges for empty graph (graph without edges). Let's assume we had rollback edge from some vertix x to vertix y. We need to check is there some vertix z that is connected to x by an edge and value of z is more than y? Besides edge (x; z) shouldn't be a bridge because our component needs to be connected. No solution answer if it's impossible to find such z at any step.But if edge (x; z) satisfied to conditions upper is exists let's change it to move and after this step our problem is to find lexicographically smallest euler way. It is possible to find only in unbreaked component of graph so every next step must going along non-brigde edges in vertix with as low number as possible. Of course, we must destroy unachievable vertices and do not destroy initial vertix.We can check is edge a bridge for O(E) time by depth first search. Total difficulty of algorithm represented above is O(N· E2).Problem E. World Evil.Author of this problem is Vasily Vadimov, NNSU. He wrote her own tutorial for you.In this problem you were to find the maximal flow in network with a cyllinder structure. The dynamic solution with complexity O(mn2n) was considered.It's well known that the maximal flow is equal to value of the minimal cut. Also all the sources must belong to one part of the cut and all the drains --- to the other part. Then we look over all the vertices from the left to the right, from the top to the bottom and append to the one or the other part of the cut, recalculating the answer during the process. The trivial solution has complexity O(2mn) and doesn't fit the time limit.But we can notice the number add to the answer after appending a new vertice to some part of the cut depends only on what parts of the cut the vertices in the current and the previous columns belong to. So we can calculate such a value using dynamic programming: what is the minimal cut can be obtained by adding i columns and the mask of belongings of vertices of the ith column to the parts of the cut is mask. Then we have 2n conversions because there are 2n different states of the i - 1th column. So we have the O(mn22n) solution.But this solution also can be improved. We calculate the minimal cut, if i - 1 columns are added completely and j vertices from the ith column are added, and mask of belongings of vertices that have no neighbours on the right is mask. Then we append j-th vertice to one of the parts, recalculate the value of the cut and do the conversion. So we have mn2n conditions and O(1) conversions from the every condition and the solution's complexity is O(mn2n).Also congratulations to the participants rng_58 and Ra16bit who solved this problem during the contest!Thanks to boys from NNSU (Vladislav Epifanov, Alexey Shmelev) who helps us with alternating solutions and etc.Sorry for poor english",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5660
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> path = inf.readInts(m + 1, 1, n, \"path\");\n    inf.readEoln();\n\n    ensuref(path[0] == path[m], \"The last number in the list must coincide with the first one.\");\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int u = path[i];\n        int v = path[i + 1];\n        ensuref(u != v, \"No self-loop allowed between room %d and %d at position %d\", u, v, i);\n        int pu = min(u, v);\n        int pv = max(u, v);\n        pair<int, int> edge = make_pair(pu, pv);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between rooms %d and %d\", pu, pv);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> path = inf.readInts(m + 1, 1, n, \"path\");\n    inf.readEoln();\n\n    ensuref(path[0] == path[m], \"The last number in the list must coincide with the first one.\");\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int u = path[i];\n        int v = path[i + 1];\n        ensuref(u != v, \"No self-loop allowed between room %d and %d at position %d\", u, v, i);\n        int pu = min(u, v);\n        int pv = max(u, v);\n        pair<int, int> edge = make_pair(pu, pv);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between rooms %d and %d\", pu, pv);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> path = inf.readInts(m + 1, 1, n, \"path\");\n    inf.readEoln();\n\n    ensuref(path[0] == path[m], \"The last number in the list must coincide with the first one.\");\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int u = path[i];\n        int v = path[i + 1];\n        ensuref(u != v, \"No self-loop allowed between room %d and %d at position %d\", u, v, i);\n        int pu = min(u, v);\n        int pv = max(u, v);\n        pair<int, int> edge = make_pair(pu, pv);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between rooms %d and %d\", pu, pv);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nstring type;\nvector<int> path;\nvector<pair<int,int>> edges;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\", 3);\n    m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"cycle\");\n\n    ensure(3 <= n && n <=100);\n    ensure(3 <= m && m <=2000);\n\n    edges.clear();\n    path.clear();\n\n    if (type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        // Initial path is 1->2->...->n->1\n        for (int i = 1; i <= n; ++i)\n            path.push_back(i);\n        path.push_back(1); // Return to start\n        m = n;\n    } else if (type == \"reverse_cycle\") {\n        // Create a cycle\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        // Initial path is 1->n->n-1->...->2->1\n        path.push_back(1);\n        for (int i = n; i >= 2; --i)\n            path.push_back(i);\n        path.push_back(1); // Return to start\n        m = n;\n    } else if (type == \"no_solution\") {\n        // Similar to reverse_cycle\n        // The path is the lexographically maximum\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        path.push_back(1);\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i)\n            nodes.push_back(i);\n        sort(nodes.begin(), nodes.end(), greater<int>());\n        for (int i = 0; i < n; ++i)\n            if (nodes[i] != 1)\n                path.push_back(nodes[i]);\n        path.push_back(1);\n        m = n;\n    } else if (type == \"random\") {\n        // Generate a random connected Eulerian graph\n        // Start with a random spanning tree\n        vector<pair<int,int>> tree_edges;\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            tree_edges.push_back({u, v});\n        }\n        edges = tree_edges;\n        m = n - 1;\n\n        vector<int> deg(n+1, 0);\n        for (auto e : edges) {\n            deg[e.first]++;\n            deg[e.second]++;\n        }\n\n        // Collect nodes with odd degree\n        vector<int> odd_degree_nodes;\n        for (int i = 1; i <= n; ++i)\n            if (deg[i] % 2 == 1)\n                odd_degree_nodes.push_back(i);\n\n        // Pair up odd degree nodes to make degrees even\n        while (odd_degree_nodes.size() >= 2 && m < 2000) {\n            int u = odd_degree_nodes.back(); odd_degree_nodes.pop_back();\n            int v = odd_degree_nodes.back(); odd_degree_nodes.pop_back();\n            edges.push_back({u, v});\n            deg[u]++;\n            deg[v]++;\n            m++;\n        }\n        // Build adjacency list\n        vector<vector<int>> adj(n+1);\n        for (auto e : edges) {\n            adj[e.first].push_back(e.second);\n            adj[e.second].push_back(e.first);\n        }\n        // Generate an Eulerian circuit starting from node 1\n        vector<int> circuit;\n        stack<int> curr_path;\n        map<pair<int,int>, int> edge_count;\n        for (auto e : edges) {\n            if (e.first > e.second)\n                swap(e.first, e.second);\n            edge_count[{e.first, e.second}] = 1; // Only one edge between any two nodes\n        }\n        curr_path.push(1);\n        int curr_v = 1;\n        while (!curr_path.empty()) {\n            if (!adj[curr_v].empty()) {\n                curr_path.push(curr_v);\n                int next_v = adj[curr_v].back();\n                adj[curr_v].pop_back();\n                // Remove edge from next_v to curr_v\n                auto it = find(adj[next_v].begin(), adj[next_v].end(), curr_v);\n                if (it != adj[next_v].end())\n                    adj[next_v].erase(it);\n                curr_v = next_v;\n            } else {\n                circuit.push_back(curr_v);\n                curr_v = curr_path.top();\n                curr_path.pop();\n            }\n        }\n        // The circuit is in reverse order\n        reverse(circuit.begin(), circuit.end());\n        path = circuit;\n        // Ensure path starts and ends at node 1\n        if (path[0] != 1 || path.back() != 1) {\n            // Find where node 1 appears in path\n            auto it = find(path.begin(), path.end(), 1);\n            // Rotate path to start at node 1\n            rotate(path.begin(), it, path.end());\n            if (path.back()!=1)\n                path.push_back(1);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output the path\n    for(int i = 0; i < path.size(); ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", path[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nstring type;\nvector<int> path;\nvector<pair<int,int>> edges;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\", 3);\n    m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"cycle\");\n\n    ensure(3 <= n && n <=100);\n    ensure(3 <= m && m <=2000);\n\n    edges.clear();\n    path.clear();\n\n    if (type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        // Initial path is 1->2->...->n->1\n        for (int i = 1; i <= n; ++i)\n            path.push_back(i);\n        path.push_back(1); // Return to start\n        m = n;\n    } else if (type == \"reverse_cycle\") {\n        // Create a cycle\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        // Initial path is 1->n->n-1->...->2->1\n        path.push_back(1);\n        for (int i = n; i >= 2; --i)\n            path.push_back(i);\n        path.push_back(1); // Return to start\n        m = n;\n    } else if (type == \"no_solution\") {\n        // Similar to reverse_cycle\n        // The path is the lexographically maximum\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        path.push_back(1);\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i)\n            nodes.push_back(i);\n        sort(nodes.begin(), nodes.end(), greater<int>());\n        for (int i = 0; i < n; ++i)\n            if (nodes[i] != 1)\n                path.push_back(nodes[i]);\n        path.push_back(1);\n        m = n;\n    } else if (type == \"random\") {\n        // Generate a random connected Eulerian graph\n        // Start with a random spanning tree\n        vector<pair<int,int>> tree_edges;\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            tree_edges.push_back({u, v});\n        }\n        edges = tree_edges;\n        m = n - 1;\n\n        vector<int> deg(n+1, 0);\n        for (auto e : edges) {\n            deg[e.first]++;\n            deg[e.second]++;\n        }\n\n        // Collect nodes with odd degree\n        vector<int> odd_degree_nodes;\n        for (int i = 1; i <= n; ++i)\n            if (deg[i] % 2 == 1)\n                odd_degree_nodes.push_back(i);\n\n        // Pair up odd degree nodes to make degrees even\n        while (odd_degree_nodes.size() >= 2 && m < 2000) {\n            int u = odd_degree_nodes.back(); odd_degree_nodes.pop_back();\n            int v = odd_degree_nodes.back(); odd_degree_nodes.pop_back();\n            edges.push_back({u, v});\n            deg[u]++;\n            deg[v]++;\n            m++;\n        }\n        // Build adjacency list\n        vector<vector<int>> adj(n+1);\n        for (auto e : edges) {\n            adj[e.first].push_back(e.second);\n            adj[e.second].push_back(e.first);\n        }\n        // Generate an Eulerian circuit starting from node 1\n        vector<int> circuit;\n        stack<int> curr_path;\n        map<pair<int,int>, int> edge_count;\n        for (auto e : edges) {\n            if (e.first > e.second)\n                swap(e.first, e.second);\n            edge_count[{e.first, e.second}] = 1; // Only one edge between any two nodes\n        }\n        curr_path.push(1);\n        int curr_v = 1;\n        while (!curr_path.empty()) {\n            if (!adj[curr_v].empty()) {\n                curr_path.push(curr_v);\n                int next_v = adj[curr_v].back();\n                adj[curr_v].pop_back();\n                // Remove edge from next_v to curr_v\n                auto it = find(adj[next_v].begin(), adj[next_v].end(), curr_v);\n                if (it != adj[next_v].end())\n                    adj[next_v].erase(it);\n                curr_v = next_v;\n            } else {\n                circuit.push_back(curr_v);\n                curr_v = curr_path.top();\n                curr_path.pop();\n            }\n        }\n        // The circuit is in reverse order\n        reverse(circuit.begin(), circuit.end());\n        path = circuit;\n        // Ensure path starts and ends at node 1\n        if (path[0] != 1 || path.back() != 1) {\n            // Find where node 1 appears in path\n            auto it = find(path.begin(), path.end(), 1);\n            // Rotate path to start at node 1\n            rotate(path.begin(), it, path.end());\n            if (path.back()!=1)\n                path.push_back(1);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output the path\n    for(int i = 0; i < path.size(); ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", path[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type cycle\n./gen -n 3 -type reverse_cycle\n./gen -n 3 -type no_solution\n./gen -n 3 -type random\n\n./gen -n 4 -type cycle\n./gen -n 4 -type reverse_cycle\n./gen -n 4 -type no_solution\n./gen -n 4 -type random\n\n./gen -n 5 -type cycle\n./gen -n 5 -type reverse_cycle\n./gen -n 5 -type no_solution\n./gen -n 5 -type random\n\n./gen -n 10 -type cycle\n./gen -n 10 -type reverse_cycle\n./gen -n 10 -type no_solution\n./gen -n 10 -type random\n\n./gen -n 50 -type cycle\n./gen -n 50 -type reverse_cycle\n./gen -n 50 -type no_solution\n./gen -n 50 -type random\n\n./gen -n 100 -type cycle\n./gen -n 100 -type reverse_cycle\n./gen -n 100 -type no_solution\n./gen -n 100 -type random\n\n./gen -n 100 -type random -m 2000\n./gen -n 100 -type random -m 1000\n./gen -n 100 -type random -m 500\n\n./gen -n 100 -type random\n./gen -n 80 -type random -m 1500\n./gen -n 70 -type random -m 500\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:11.119386",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "62/E",
      "title": "E. Вселенское Зло",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входного файла дано два целых числа n и m (2 ≤ n ≤ 5, 2 ≤ m ≤ 105) — размеры сетки Большого Адронного Колайдера. В последующих m - 1 строках записано по n чисел: пропускные способности горизонтально расположенных коридоров. В последующих m строках записано по n чисел: пропускные способности вертикально расположенных коридоров. Коридоры описываются слева направо, сверху вниз. Каждый n-ый вертикальный коридор соединяет узлы n-ой и 1-ой строк. Пропускная способность коридора — неотрицательное целое число, не превосходящее 109.",
      "output_spec": "Выходные данныеВыведите одно число — количество щупалец Вселенского Зла, которыми будут повелевать Пинки и Брейн.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 44 4 41 1 55 5 34 1 21 3 13 5 41 4 3Выходные данныеСкопировать7Входные данныеСкопировать2 29 22 36 1Выходные данныеСкопировать11",
      "description": "E. Вселенское Зло\n\nограничение по времени на тест5 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла дано два целых числа n и m (2 ≤ n ≤ 5, 2 ≤ m ≤ 105) — размеры сетки Большого Адронного Колайдера. В последующих m - 1 строках записано по n чисел: пропускные способности горизонтально расположенных коридоров. В последующих m строках записано по n чисел: пропускные способности вертикально расположенных коридоров. Коридоры описываются слева направо, сверху вниз. Каждый n-ый вертикальный коридор соединяет узлы n-ой и 1-ой строк. Пропускная способность коридора — неотрицательное целое число, не превосходящее 109.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество щупалец Вселенского Зла, которыми будут повелевать Пинки и Брейн.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).\n\nВыходные данные\n\nВходные данныеСкопировать3 44 4 41 1 55 5 34 1 21 3 13 5 41 4 3Выходные данныеСкопировать7Входные данныеСкопировать2 29 22 36 1Выходные данныеСкопировать11\n\nВходные данныеСкопировать3 44 4 41 1 55 5 34 1 21 3 13 5 41 4 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 29 22 36 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #58 - Codeforces",
          "content": "Добрый вечер!Рад всех приветствовать на 58-м раунде. Задачи к сегодняшнему контесту готовили коллективы команд Orel STU и NNSU.Задачи тура будут посвящены забавным жизненным ситуациям: вы встретитесь с самым суровым преподавателем в мире, вернётесь в средние века, разрешите противоборство крупных IT-компаний, выпустите Вселенское Зло из Большого Адронного Коллайдера и решите проблему червяка Арни, про которого обычно говорят: \"Арни огорчает твой жим\". =)Спасибо коллективу Codeforces, который помог подготовить предстоящий контест.Надеюсь, что раунд вам понравится! Удачи!К сожалению, раунд прошёл не так гладко, как хотелось бы. В задаче A русское условие оказалось более полным, чем аналогичное на английском языке. Мы приносим извинения за эту промашку.Подведены результаты контеста. И снова Геннадий одержал! =)Спасибо всем, кто участвовал в раунде!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1356",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 857
        },
        {
          "title": "Разбор задач Codeforces Beta Round #58 - Codeforces",
          "content": "Задача A. Сон Студента.В русской версии условия фразу \"между любыми двумя пальцами девочки есть палец мальчика\" нужно было читать как \"между любыми двумя соседними пальцами девочки есть палец мальчика\".Если мальчик пойдёт слева от девочки, то он возьмёт своей правой рукой её левую руку, а оставшиеся руки (левая мальчика и правая девочки) окажутся незадействованными. Если наоборот, мальчик пойдёт справа, то он возьмёт своей левой рукой правую руку девочки. Это написано в условии. Осталось проверить, \"совместимы\" ли руки для прогулки хотя бы в одном из этих случаев. Проверить это очень просто: пусть у мальчика B, а у девочки G пальцев, тогда:Если B < G, то им будет удобно, только если B = G - 1; это паттерн GBGBGBG...GBGBG. В этом паттерне нельзя добавить ни один палец девочки так, чтобы не нарушить требования условия.Если B > G, то наихудшая ситуация - это паттерн BBGBBGBB...BBGBB. Отсюда заметим, что должно выполняться 2G + 2 >  = B для возможности прогулки вдвоём.Чтобы не затуманивать логику первых двух случаев, третьим случаем вынесем B = G, но тут всё тривиально: очевидно, что взяться за руки они могут.Задача B. Тындекс.Бром.Обозначим за p суммарную длину всех потенциальных адресов c. В этой задаче ограничения были выбраны таким образом, чтобы очевидное решение с асимптотикой O(p· k) не проходило. Ускорять будем следующим образом: для каждой буквы из введённой пользователем строки s сохраним отдельно все позиции букв 'a', 'b', ..., 'z' в отсортированном порядке. Обладая этой информацией, можно искать для текущего символа потенциального адреса ci ближайший из s за логарифмическое время бинарным поиском. Таким образом, получается асимптотика O(p · logk), которая прекрасно проходит по времени. Важно было обратить внимание на ограничения и учесть, что длина потенциального адреса может быть больше, чем 105, а ответ не всегда помещается в 32-битный тип.Задача C. Инквизиция.Заметим, что, согласно ограничениям, все треугольники лежат строго внутри квадрата. Это упрощает задачу - не нужно рассматривать дополнительно случаи касания границ шкуры.Сохраним все отрезки каждого треугольника и все попарно пересечём. После этой операции на каждом отрезке может остаться много точек - результаты пересечения с другими отрезками. Рассмотрим каждый подотрезок этого отрезка такой, который не содержит внутри себя других точек. Этот подотрезок либо целиком лежит на границе пятна, либо целиком лежит внутри пятна.Чтобы проверить этот факт, можно взять середину подотрезка и проверить её на принадлежность исходным треугольникам. Если эта точка - середина подотрезка - лежит строго внутри некоторого пятна, то и весь отрезок будет лежать внутри, и прибавлять его длину к ответу не нужно. В противном случае, добавим эту длину к ответу и, после обработки всех отрезков таким образом, выведем накопившийся ответ.Если вы работаете с целыми числами, то учтите, что с заданными ограничениями до 105 вычисление, например, векторного произведения, может превысить 32-битный тип.Если вы работаете с вещественными числами, то используйте максимально большой тип данных (long double в c++, extended в паскале).Задача D. Дом для червя.В этой задаче требуется найти следующий лексикографически эйлеров цикл, заданный из некоторой точки - входа - или сказать, что такого пути не существует. Будем решать эту задачу с конца.Повторим маршрут Арни. Теперь будем откатываться назад по коридорам, которые он прогрыз, и добавлять рёбра к пустому графу (графу без рёбер). Пусть мы откатили на некотором шаге ребро, которое шло из комнаты x в комнату y. Проверим, существует ли вершина z такая, что есть ребро из x в z и номер вершины z больше номера вершины y. Кроме того, нужно проверить, что ребро (x; z) не является мостом - иначе мы разобьём компоненту связности на несколько и не сможем прогрызть все оставшиеся коридоры.No solution получается тогда, когда ни на каком шаге нельзя найти требуемую вершину z.Но когда такое ребро (x; z) оказалось найдено, то мы пройдём по нему и после этого будем искать лексикографически наименьший эйлеров путь. Для этого из каждой текущей вершины будем пытаться идти в вершину с минимально возможным номером. Пойти в вершину с минимально возможным номером можно только тогда, когда ребро, соединяющее эти вершины, не является мостом. Разумеется, нужно выбрасывать недостижимые вершины из графа и не считать их за отдельные компоненты, и не нужно выбрасывать начальную вершину, из которой Арни начал свой путь, иначе есть риск в неё уже не вернуться.Проверку на то, является ли ребро мостом, можно делать поиском в глубину за O(E). Соответственно, суммарная сложность алгоритма O(N· E2).Задача E. Вселенское ЗлоАвтор этой задачи - Василий Вадимов, ННГУ. Выкладываю его собственный разбор этой задачи и благодарю за помощь в проведении раунда.В этой задаче требовалось найти максимальный поток в сети со структурой в виде цилиндра. Предполагалось динамическое решение за O(mn2n). Известно, что максимальный поток в сети равен величине минимального разреза. Причем все истоки должны принадлежать одной доле разреза, а все стоки --- другой. Тогда будем перебирать вершины слева направо, сверху вниз и добавлять в ту или иную долю разреза, по ходу пересчитывая ответ. Тривиальное решение имеет асимптотику O(2mn) и, очевидно, не укладывается по времени.Но можно заметить, что то число, которое мы добавим ответу при добавлении новой вершины в какую-либо долю разреза, зависит только от того, к каким долям принадлежат вершины в предыдущем столбце и в том, которому принадлежит добавляемая вершина. Поэтому можно считать такую динамику: какой минимальный разрез можно получить, добавив i столбцов и в последнем столбце маска принадлежности вершин к долям разреза mask. Тогда имеется всего 2n переходов, т.к. различных состояний i - 1-го столбца 2n. Так решение оптимизируется до O(mn22n).Но и это решение можно улучшить, если динамику считать по изломанному профилю. Будем искать минимальный разрез, если мы добавили i - 1 столбцов полностью и добавили j вершин из i-го столбца и маска принадлежности вершин, у которых соседи справа еще не добавлены, mask. Тогда добавляем j-ю вершину, определяем в какую долю ее поместим, считаем, насколько увеличится величина разреза и делаем переход. Итого mn2n состояний, O(1) переходов из каждого состояния и сложность алгоритма O(mn2n). Поздравляем участников rng_58 и Ra16bit, решивших эту задачу во время контеста!Выражаю благодарность ребятам из ННГУ (Владиславу Епифанову, Алексею Шмелёву), которые писали альтернативные решения и задавали вопросы по условиям. Спасибо вам!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6550
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n; j++) {\n            int cap = inf.readInt(0, 1000000000);\n            if (j + 1 < n) inf.readSpace();\n            else inf.readEoln();\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int cap = inf.readInt(0, 1000000000);\n            if (j + 1 < n) inf.readSpace();\n            else inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n; j++) {\n            int cap = inf.readInt(0, 1000000000);\n            if (j + 1 < n) inf.readSpace();\n            else inf.readEoln();\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int cap = inf.readInt(0, 1000000000);\n            if (j + 1 < n) inf.readSpace();\n            else inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n; j++) {\n            int cap = inf.readInt(0, 1000000000);\n            if (j + 1 < n) inf.readSpace();\n            else inf.readEoln();\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int cap = inf.readInt(0, 1000000000);\n            if (j + 1 < n) inf.readSpace();\n            else inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\"); // number of rows\n    int m = opt<int>(\"m\"); // number of columns\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n    \n    vector<vector<int>> h_caps(m - 1, vector<int>(n)); // horizontal corridors capacities\n    vector<vector<int>> v_caps(m, vector<int>(n)); // vertical corridors capacities\n\n    if (type == \"random\") {\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; j < n; ++j)\n                h_caps[i][j] = rnd.next(1, (int)1e9);\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < n; ++j)\n                v_caps[i][j] = rnd.next(1, (int)1e9);\n    } else if (type == \"max_caps\") {\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; j < n; ++j)\n                h_caps[i][j] = (int)1e9;\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < n; ++j)\n                v_caps[i][j] = (int)1e9;\n    } else if (type == \"min_caps\") {\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; ++j < n;)\n                h_caps[i][j] = 1;\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; ++j < n;)\n                v_caps[i][j] = 1;\n    } else if (type == \"zero_caps\") {\n        // All capacities are zero\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n    } else if (type == \"single_path\") {\n        // All capacities zero, except a single path from left to right\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n        // Let's choose a random path\n        int row = rnd.next(0, n - 1); // Start row\n        for(int i = 0; i < m - 1; ++i) {\n            h_caps[i][row] = rnd.next(1, (int)1e9);\n            // Possibly switch row\n            if (n > 1 && rnd.next(0, 1)) {\n                int dir = rnd.next(0, 1) * 2 -1; // -1 or 1\n                row = (row + dir + n) % n;\n                v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n            }\n        }\n    } else if (type == \"bottleneck\") {\n        // All capacities high, except for one corridor with small capacity\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), (int)1e9);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), (int)1e9);\n        // Place a bottleneck\n        int i = rnd.next(0, m - 2);\n        int j = rnd.next(0, n - 1);\n        h_caps[i][j] = 1; // Bottleneck with capacity 1\n    } else if (type == \"zigzag\") {\n        // All capacities zero\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n        int row = 0;\n        for(int i = 0; i < m - 1; ++i) {\n            h_caps[i][row] = rnd.next(1, (int)1e9);\n            if (n > 1) {\n                int dir = (i % 2 == 0) ? 1 : -1;\n                row = (row + dir + n) % n;\n                v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n            }\n        }\n    } else if (type == \"spiral\") {\n        // All capacities zero\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n        if (n >= 3) {\n            int row = 0;\n            int dir = 1;\n            for(int i = 0; i < m - 1; ++i) {\n                h_caps[i][row] = rnd.next(1, (int)1e9);\n                if ((i / n) % 2 == 0) {\n                    row = (row + dir + n) % n;\n                    v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n                } else {\n                    dir = -dir;\n                    row = (row + dir + n) % n;\n                    v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n                }\n            }\n        } else {\n            // For n < 3, default to single_path\n            int row = 0;\n            for(int i = 0; i < m - 1; ++i) {\n                h_caps[i][row] = rnd.next(1, (int)1e9);\n            }\n        }\n    } else {\n        // Default to random capacities\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; j < n; ++j)\n                h_caps[i][j] = rnd.next(1, (int) 1e9);\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < n; ++j)\n                v_caps[i][j] = rnd.next(1, (int) 1e9);\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    \n    // Output horizontal capacities\n    for(int i = 0; i < m -1; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", h_caps[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    \n    // Output vertical capacities\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", v_caps[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\"); // number of rows\n    int m = opt<int>(\"m\"); // number of columns\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n    \n    vector<vector<int>> h_caps(m - 1, vector<int>(n)); // horizontal corridors capacities\n    vector<vector<int>> v_caps(m, vector<int>(n)); // vertical corridors capacities\n\n    if (type == \"random\") {\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; j < n; ++j)\n                h_caps[i][j] = rnd.next(1, (int)1e9);\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < n; ++j)\n                v_caps[i][j] = rnd.next(1, (int)1e9);\n    } else if (type == \"max_caps\") {\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; j < n; ++j)\n                h_caps[i][j] = (int)1e9;\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < n; ++j)\n                v_caps[i][j] = (int)1e9;\n    } else if (type == \"min_caps\") {\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; ++j < n;)\n                h_caps[i][j] = 1;\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; ++j < n;)\n                v_caps[i][j] = 1;\n    } else if (type == \"zero_caps\") {\n        // All capacities are zero\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n    } else if (type == \"single_path\") {\n        // All capacities zero, except a single path from left to right\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n        // Let's choose a random path\n        int row = rnd.next(0, n - 1); // Start row\n        for(int i = 0; i < m - 1; ++i) {\n            h_caps[i][row] = rnd.next(1, (int)1e9);\n            // Possibly switch row\n            if (n > 1 && rnd.next(0, 1)) {\n                int dir = rnd.next(0, 1) * 2 -1; // -1 or 1\n                row = (row + dir + n) % n;\n                v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n            }\n        }\n    } else if (type == \"bottleneck\") {\n        // All capacities high, except for one corridor with small capacity\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), (int)1e9);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), (int)1e9);\n        // Place a bottleneck\n        int i = rnd.next(0, m - 2);\n        int j = rnd.next(0, n - 1);\n        h_caps[i][j] = 1; // Bottleneck with capacity 1\n    } else if (type == \"zigzag\") {\n        // All capacities zero\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n        int row = 0;\n        for(int i = 0; i < m - 1; ++i) {\n            h_caps[i][row] = rnd.next(1, (int)1e9);\n            if (n > 1) {\n                int dir = (i % 2 == 0) ? 1 : -1;\n                row = (row + dir + n) % n;\n                v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n            }\n        }\n    } else if (type == \"spiral\") {\n        // All capacities zero\n        for(int i = 0; i < m - 1; ++i)\n            fill(h_caps[i].begin(), h_caps[i].end(), 0);\n        for(int i = 0; i < m; ++i)\n            fill(v_caps[i].begin(), v_caps[i].end(), 0);\n        if (n >= 3) {\n            int row = 0;\n            int dir = 1;\n            for(int i = 0; i < m - 1; ++i) {\n                h_caps[i][row] = rnd.next(1, (int)1e9);\n                if ((i / n) % 2 == 0) {\n                    row = (row + dir + n) % n;\n                    v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n                } else {\n                    dir = -dir;\n                    row = (row + dir + n) % n;\n                    v_caps[i + 1][row] = rnd.next(1, (int)1e9);\n                }\n            }\n        } else {\n            // For n < 3, default to single_path\n            int row = 0;\n            for(int i = 0; i < m - 1; ++i) {\n                h_caps[i][row] = rnd.next(1, (int)1e9);\n            }\n        }\n    } else {\n        // Default to random capacities\n        for(int i = 0; i < m - 1; ++i)\n            for(int j = 0; j < n; ++j)\n                h_caps[i][j] = rnd.next(1, (int) 1e9);\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < n; ++j)\n                v_caps[i][j] = rnd.next(1, (int) 1e9);\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    \n    // Output horizontal capacities\n    for(int i = 0; i < m -1; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", h_caps[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    \n    // Output vertical capacities\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            printf(\"%d\", v_caps[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type random\n./gen -n 3 -m 2 -type random\n./gen -n 4 -m 2 -type random\n./gen -n 5 -m 2 -type random\n\n./gen -n 2 -m 10 -type random\n./gen -n 3 -m 10 -type random\n./gen -n 4 -m 10 -type random\n./gen -n 5 -m 10 -type random\n\n./gen -n 2 -m 1000 -type random\n./gen -n 3 -m 1000 -type random\n./gen -n 4 -m 1000 -type random\n./gen -n 5 -m 1000 -type random\n\n./gen -n 2 -m 100000 -type random\n./gen -n 3 -m 100000 -type random\n./gen -n 4 -m 100000 -type random\n./gen -n 5 -m 100000 -type random\n\n./gen -n 2 -m 100000 -type max_caps\n./gen -n 3 -m 100000 -type max_caps\n./gen -n 4 -m 100000 -type max_caps\n./gen -n 5 -m 100000 -type max_caps\n\n./gen -n 2 -m 1000 -type min_caps\n./gen -n 3 -m 1000 -type min_caps\n./gen -n 4 -m 1000 -type min_caps\n\n./gen -n 2 -m 2 -type zero_caps\n\n./gen -n 2 -m 10 -type bottleneck\n./gen -n 3 -m 10 -type bottleneck\n./gen -n 4 -m 10 -type bottleneck\n\n./gen -n 2 -m 10 -type single_path\n./gen -n 3 -m 10 -type single_path\n./gen -n 4 -m 10 -type single_path\n\n./gen -n 2 -m 20 -type zigzag\n./gen -n 3 -m 20 -type zigzag\n./gen -n 4 -m 20 -type zigzag\n\n./gen -n 5 -m 1000 -type spiral\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:12.765699",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "620/A",
      "title": "A. Робот профессора GukiZ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест0.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится пара целых чисел x1, y1 ( - 109 ≤ x1, y1 ≤ 109) — исходное положение робота.Во второй строке находится пара целых чисел x2, y2 ( - 109 ≤ x2, y2 ≤ 109) — конечное положение робота.",
      "output_spec": "Выходные данныеВыведите целое число d — наименьшее количество ходов, необходимое роботу, чтобы попасть в точку назначения.",
      "sample_tests": "ПримерыВходные данныеСкопировать0 04 5Выходные данныеСкопировать5Входные данныеСкопировать3 46 1Выходные данныеСкопировать3",
      "description": "A. Робот профессора GukiZ\n\nограничение по времени на тест0.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится пара целых чисел x1, y1 ( - 109 ≤ x1, y1 ≤ 109) — исходное положение робота.Во второй строке находится пара целых чисел x2, y2 ( - 109 ≤ x2, y2 ≤ 109) — конечное положение робота.\n\nВходные данные\n\nВыходные данныеВыведите целое число d — наименьшее количество ходов, необходимое роботу, чтобы попасть в точку назначения.\n\nВыходные данные\n\nВходные данныеСкопировать0 04 5Выходные данныеСкопировать5Входные данныеСкопировать3 46 1Выходные данныеСкопировать3\n\nВходные данныеСкопировать0 04 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 46 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере робот должен четыре раза увеличить обе свои координаты на единицу, оказавшись в точке (4, 4). Затем он должен увеличить только координату y на единицу. Таким образом, он попадёт в точку (4, 5).Во втором примере робот должен три раза одновременно увеличивать координату x и уменьшать координату y.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces",
          "content": "Привет, Codeforces!21 января 2016 года в 18:00 MSK состоится шестой учебный раунд Educational Codeforces Round 6 для участников из первого и второго дивизионов.<Здесь могла быть ваша реклама>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день, в течение которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.</Здесь могла быть ваша реклама>Большое спасибо Aleksa Plavsic allllekssssa, который предложил несколько отличных задач, две из них вы увидите на раунде (задачи D и F). Также большое пользователям Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A, они совместно (через Aleksa Plavsic) предложили несколько задач. Две из них вы увидите на раунде (задачи B и E).Подготовкой задач как всегда занимался я (Эдвард Давтян). Благодарю MikeMirzayanov мы вместе придумывали задачи A и C. Спасибо Маше Беловой Delinur за проверку английских текстов условий. Также большое спасибо Aleksa Plavsic allllekssssa, который тестировал задачи и постоянно был на связи.На этом раунде вам по традиции будет предложено шесть задач. Первая задача в этот раз проще, чем обычно (я надеюсь на очень быстрые сабмиты по ней от вас), а последняя, на мой взгляд, очень сложная (респект участникам, которые смогут её сдать). Надеюсь комплект задач вам понравится и вы хорошо их порешаете!Good luck and have fun!UPD 1: Забыл поблагодарить всех ребят, которые мне уже прислали идеи задач, но мы их ещё не взяли в раунд. Я постараюсь поскорее их дать.UPD 2: Основная часть соревнования закончилась. Фаза открытых взломов открыта.UPD 3: Разбор задач готов.UPD 4: Соревнование закончено, результаты окончательные.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22925",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2410
        },
        {
          "title": "Разбор задач Educational Codeforces Round 6 - Codeforces",
          "content": "620A - Робот профессора GukiZЛегко видеть, что ответ в задаче равен max(|x1 - x2|, |y1 - y2|).С++ solutionСложность: O(1).620B - Калькулятор дедушки ДовлетаВ этой задаче достаточно было пройти по всем числам от a до b и прибавить к ответу количество сегментов, необходимое для отображения очередного числа. Для подсчёта этой величины нужно пройти по всем десятичным цифрам числа и прибавить к ответу количество сегментов, необходимой для отображения очередной цифры. Последние величины можно просто посчитать по картинке и вбить в один массив.C++ solutionСложность: O((b - a)logb).620C - ЖемчужинкиБудем решать задачу жадно. Давайте набирать жемчужинки в самый левый хороший подотрезок по одному, начиная с первой жемчужинки. Как только подотрезок станет хорошим (то есть встретится повторение) начнём набирать новый хороший подотрезок. Если мы не смогли набрать ни одного хорошего подотрезка, то ответ  - 1. В противном случае, в конце массива может остаться некоторое количество различных элементов, их нужно отнести к последнему набранному отрезку. Легко доказать, что такая жадность правильная: нужно рассмотреть первые два отрезка в оптимальном ответе и понять, что второй отрезок можно расширить пока первый не станет размера первого подотрезка в нашем ответе.C++ solutionСложность: O(nlogn).620D - Профессор GukiZ и два массиваСлучаи когда нужно сделать одну операцию или их не нужно делать вовсе легко разобрать в лоб (за O(nm)). Теперь рассмотрим случай когда нужно сделать две операции. Заметим, что можно считать, что после двух операций два элемента первого массива перейдёт во второй массив и наоборот, поскольку в противном случае то же самое можно сделать и за одну операцию и значит мы уже рассмотрели этот случай. Давайте переберём пару чисел, которая перейдёт во второй массив и сложим суммы в некоторую структуру данных (например, можно сложить в map в C++). Далее переберём пару чисел во втором массиве bi, bj и найдём в нашей структуре данных сумму v наиболее близкую к числу x = sa - sb + 2·(bi + bj) и обновим ответ значением |x - v|. Нужную сумму можно искать бинарным поиском по структуре данных (для map есть функция lower_bound).C++ solutionСложность: O((n2 + m2)log(n + m)).620E - Новогодняя ёлкаЗапустим dfs из корня дерева и выпишем вершины в порядке в котором их обойдёт dfs (эта перестановка называется обходом Эйлера). Легко видеть, что поддерево в этой перестановке является подотрезком. Заметим, что цветов всего 60, таким образом, мы можем хранить множество цветов просто как маску двоичных битов в 64-битном типе (*long long* в C++, long в Java). Построим дерево отрезков над Эйлеровым обходом, который поддерживает операцию покраски подотрезка и нахождения маски цветов на подотрезке.С++ solutionСложность: O(nlogn).620F - Ксоры на подотрезкеВ этой задаче неудачно были подобраны ограничения в связи с чем некоторые участники сдали решения со сложностью O(n2 + m).Заметим сначала, что . Значения f(0, x) можно было просто предподсчитать или заметить что в зависимости от остатка числа x по модулю 4 значение функции равно x, 1, x + 1, 0 соответственно.Воспользуемся алгоритмом Мо. Разобьём все запросы на блоков по левому концу. Внутри каждого блока отсортируем запросы по правому концу. Пусть r наибольшая левая граница внутри блока, тогда все левые границы отстоят от r на расстояние не более чем , а правые границы идут в порядке неубывания, поэтому их можно двигать по одному (в сумме на один блок мы сделаем не более n передвижений правой границы). Передвигая правую границу, внутри блока для чисел в позициях от r + 1 до текущей правой границы будем поддерживать два бора: первый для значений f(0, x - 1), второй для значений f(0, x), в первом будем поддерживать наименьшее значение x, во втором — наибольшее. Понятно как добавлять число в боры, после добавлений нужно найти наибольшее значение, которое может образовать текущий x для этого будем спускаться по первому бору, поддерживая инвариант того, что в текущем поддереве минимальное значение не больше x, и по возможности ходить по биту отличному от нашего. Аналогичное нужно делать во втором боре, только нужно поддерживать инвариант, что максимальное значение не меньше x. После того как для текущего запроса мы сдвинули правую границу на сколько нужно, нужно пройти от левой границы запроса до r и, не добавляя значения в бор, обновить ответы. Ещё отдельно для каждого запроса в новом (пустом) боре нужно пройти от левой границы до r добавляя значения в бор и обновляя ответ.С++ solution: в коде 0-й бор соответсвует второму, а 1-й — первому.Сложность: .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22936",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 620\\s*A"
          },
          "content_length": 4557
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "long abs(long)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 2",
          "code": "double abs(long)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 3",
          "code": "#include <cmath>\n#include <iostream>\n\nint main()\n{\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 4",
          "code": "#include <cmath>\n#include <iostream>\n\nint main()\n{\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 5",
          "code": "$ g++ main.cpp --std=c++03 -E -o main.cpp.p && grep labs main.cpp.p -B 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 6",
          "code": "extern int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n--\n\n__extension__ extern long long int llabs (long long int __x)\n--\n  using ::getenv;\n  using ::labs;\n--\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n--\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n--\n\n  using ::llabs;\n--\n\n  using ::__gnu_cxx::llabs;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 7",
          "code": "extern int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n--\n\n__extension__ extern long long int llabs (long long int __x)\n--\n  using ::getenv;\n  using ::labs;\n--\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n--\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n--\n\n  using ::llabs;\n--\n\n  using ::__gnu_cxx::llabs;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 8",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 9",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 10",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 12",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 13",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 14",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 15",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "bit-mask_for_node_i = bitmask_of_right_child | bitmask_of_left_child",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22936",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x1 = inf.readInt(-1000000000, 1000000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000000, 1000000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000000, 1000000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000000, 1000000000, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x1 = inf.readInt(-1000000000, 1000000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000000, 1000000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000000, 1000000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000000, 1000000000, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x1 = inf.readInt(-1000000000, 1000000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000000, 1000000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000000, 1000000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000000, 1000000000, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long coord_limit = opt<long long>(\"coord_limit\", 1000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x1, y1, x2, y2;\n\n    if (type == \"random\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"same_point\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = x1;\n        y2 = y1;\n    } else if (type == \"axis_aligned_x\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = x1;\n        y2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"axis_aligned_y\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = y1;\n    } else if (type == \"diagonal\") {\n        x1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        y1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        long long max_delta = min(coord_limit - max(x1, y1), min(x1, y1) + coord_limit);\n        long long min_delta = max(-coord_limit - max(x1, y1), -coord_limit - min(x1, y1));\n        long long delta = rnd.next(min_delta, max_delta);\n        x2 = x1 + delta;\n        y2 = y1 + delta;\n    } else if (type == \"max_coords\") {\n        x1 = -coord_limit;\n        y1 = -coord_limit;\n        x2 = coord_limit;\n        y2 = coord_limit;\n    } else if (type == \"adjacent\") {\n        x1 = rnd.next(-coord_limit + 1, coord_limit - 1);\n        y1 = rnd.next(-coord_limit + 1, coord_limit - 1);\n        vector<pair<int,int>> moves = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1},{1,0},{1,1}};\n        pair<int,int> move = rnd.any(moves);\n        x2 = x1 + move.first;\n        y2 = y1 + move.second;\n    } else if (type == \"mixed_signs\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = rnd.next(-coord_limit, coord_limit);\n        if (x1 * x2 >= 0) x2 = -x2;\n        if (y1 * y2 >= 0) y2 = -y2;\n    } else if (type == \"delta_x_big\") {\n        x1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        long long delta_x = rnd.next(coord_limit / 2, coord_limit);\n        if (rnd.next(0, 1)) delta_x = -delta_x;\n        x2 = x1 + delta_x;\n        y2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"delta_y_big\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        long long delta_y = rnd.next(coord_limit / 2, coord_limit);\n        if (rnd.next(0, 1)) delta_y = -delta_y;\n        y2 = y1 + delta_y;\n        x2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"max_distance\") {\n        x1 = -coord_limit;\n        y1 = -coord_limit;\n        x2 = coord_limit;\n        y2 = coord_limit;\n    } else if (type == \"min_distance\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        int dx = rnd.next(-1,1);\n        int dy = rnd.next(-1,1);\n        x2 = x1 + dx;\n        y2 = y1 + dy;\n    } else {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = rnd.next(-coord_limit, coord_limit);\n    }\n\n    x2 = max(-coord_limit, min(coord_limit, x2));\n    y2 = max(-coord_limit, min(coord_limit, y2));\n\n    printf(\"%lld %lld\\n\", x1, y1);\n    printf(\"%lld %lld\\n\", x2, y2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long coord_limit = opt<long long>(\"coord_limit\", 1000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x1, y1, x2, y2;\n\n    if (type == \"random\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"same_point\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = x1;\n        y2 = y1;\n    } else if (type == \"axis_aligned_x\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = x1;\n        y2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"axis_aligned_y\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = y1;\n    } else if (type == \"diagonal\") {\n        x1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        y1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        long long max_delta = min(coord_limit - max(x1, y1), min(x1, y1) + coord_limit);\n        long long min_delta = max(-coord_limit - max(x1, y1), -coord_limit - min(x1, y1));\n        long long delta = rnd.next(min_delta, max_delta);\n        x2 = x1 + delta;\n        y2 = y1 + delta;\n    } else if (type == \"max_coords\") {\n        x1 = -coord_limit;\n        y1 = -coord_limit;\n        x2 = coord_limit;\n        y2 = coord_limit;\n    } else if (type == \"adjacent\") {\n        x1 = rnd.next(-coord_limit + 1, coord_limit - 1);\n        y1 = rnd.next(-coord_limit + 1, coord_limit - 1);\n        vector<pair<int,int>> moves = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1},{1,0},{1,1}};\n        pair<int,int> move = rnd.any(moves);\n        x2 = x1 + move.first;\n        y2 = y1 + move.second;\n    } else if (type == \"mixed_signs\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = rnd.next(-coord_limit, coord_limit);\n        if (x1 * x2 >= 0) x2 = -x2;\n        if (y1 * y2 >= 0) y2 = -y2;\n    } else if (type == \"delta_x_big\") {\n        x1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        long long delta_x = rnd.next(coord_limit / 2, coord_limit);\n        if (rnd.next(0, 1)) delta_x = -delta_x;\n        x2 = x1 + delta_x;\n        y2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"delta_y_big\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit / 2, coord_limit / 2);\n        long long delta_y = rnd.next(coord_limit / 2, coord_limit);\n        if (rnd.next(0, 1)) delta_y = -delta_y;\n        y2 = y1 + delta_y;\n        x2 = rnd.next(-coord_limit, coord_limit);\n    } else if (type == \"max_distance\") {\n        x1 = -coord_limit;\n        y1 = -coord_limit;\n        x2 = coord_limit;\n        y2 = coord_limit;\n    } else if (type == \"min_distance\") {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        int dx = rnd.next(-1,1);\n        int dy = rnd.next(-1,1);\n        x2 = x1 + dx;\n        y2 = y1 + dy;\n    } else {\n        x1 = rnd.next(-coord_limit, coord_limit);\n        y1 = rnd.next(-coord_limit, coord_limit);\n        x2 = rnd.next(-coord_limit, coord_limit);\n        y2 = rnd.next(-coord_limit, coord_limit);\n    }\n\n    x2 = max(-coord_limit, min(coord_limit, x2));\n    y2 = max(-coord_limit, min(coord_limit, y2));\n\n    printf(\"%lld %lld\\n\", x1, y1);\n    printf(\"%lld %lld\\n\", x2, y2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Same point (steps = 0)\n./gen -type same_point\n./gen -type same_point -coord_limit 0\n./gen -type same_point -coord_limit 1000000000\n\n# Axis aligned (x1 == x2)\n./gen -type axis_aligned_x\n./gen -type axis_aligned_x -coord_limit 1000000000\n\n# Axis aligned (y1 == y2)\n./gen -type axis_aligned_y\n./gen -type axis_aligned_y -coord_limit 1000000000\n\n# Diagonal movement\n./gen -type diagonal\n./gen -type diagonal -coord_limit 1000000000\n./gen -type diagonal -coord_limit 500000000\n\n# Max coordinate values\n./gen -type max_coords\n\n# Adjacent points (steps should be 1)\n./gen -type adjacent\n\n# Mixed signs (x1 and x2 have different signs)\n./gen -type mixed_signs\n./gen -type mixed_signs -coord_limit 100000\n./gen -type mixed_signs -coord_limit 500000000\n\n# Delta x significantly bigger than delta y\n./gen -type delta_x_big\n./gen -type delta_x_big -coord_limit 1000000000\n\n# Delta y significantly bigger than delta x\n./gen -type delta_y_big\n./gen -type delta_y_big -coord_limit 1000000000\n\n# Max distance\n./gen -type max_distance\n\n# Min distance\n./gen -type min_distance\n./gen -type min_distance -coord_limit 1\n\n# Random again\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:14.629950",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "620/B",
      "title": "B. Grandfather Dovlet’s calculator",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains two integers a, b (1 ≤ a ≤ b ≤ 106) — the first and the last number typed by Max.",
      "output_spec": "OutputPrint the only integer a — the total number of printed segments.",
      "sample_tests": "ExamplesInputCopy1 3OutputCopy12InputCopy10 15OutputCopy39",
      "description": "B. Grandfather Dovlet’s calculator\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains two integers a, b (1 ≤ a ≤ b ≤ 106) — the first and the last number typed by Max.\n\nOutputPrint the only integer a — the total number of printed segments.\n\nInputCopy1 3OutputCopy12InputCopy10 15OutputCopy39\n\nInputCopy1 3\n\nOutputCopy12\n\nInputCopy10 15\n\nOutputCopy39",
      "solutions": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 6 will take place on 21 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<Your Ad Could Be Here>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</Your Ad Could Be Here>Thanks a lot to Aleksa Plavsic allllekssssa who suggested several problems, two of them you will see on the round (the problems D and F). Also thanks to Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. They are together suggested five problems, two of them you will see on the round (the problems B and E).As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A and C together. Also thanks to Maria Belova Delinur who will check English statements and Aleksa Plavsic allllekssssa who help me with problem testing and have constantly been in touch.The first problem is pretty simple, so I'm waiting fast accepteds from you. The last problem is pretty difficult, so respect to all particiants who will solve it. I hope you will enjoy the problems!Good luck and have fun!UPD 1: I forgot to thank all other users who already sent me the ideas for the problems. I'll try to give that problems to the next rounds.UPD 2: The main part of the contest is finished. The phase of hacks is started.UPD 3: The editorial is ready.UPD 4: The round is over, the results is final.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22925",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1790
        },
        {
          "title": "Editorial of Educational Codeforces Round 6 - Codeforces",
          "content": "620A - Professor GukiZ's RobotEasy to see that the answer is max(|x1 - x2|, |y1 - y2|).С++ solutionComplexity: O(1).620B - Grandfather Dovlet’s calculatorLet's simply iterate over all the values from a to b and add to the answer the number of segments of the current value x. To count the number of segments we should iterate over all the digits of the number x and add to the answer the number of segments of the current digit d. These values can be calculated by the image from the problem statement and stored in some array in code.C++ solutionComplexity: O((b - a)logb).620C - Pearls in a RowLet's solve the problem greedily. Let's make the first segment by adding elements until the segment will be good. After that let's make the second segment in the same way and so on. If we couldn't make any good segment then the answer is  - 1. Otherwise let's add all uncovered elements at the end to the last segment. Easy to prove that our construction is optimal: consider the first two segments of the optimal answer, obviously we can extend the second segment until the first segment will be equal to the first segment in our construction.C++ solutionComplexity: O(nlogn).620D - Professor GukiZ and Two ArraysWe can process the cases of zero or one swap in O(nm) time. Consider the case with two swaps. Note we can assume that two swaps will lead to move two elements from a to b and vice versa (in other case it is similar to the case with one swap). Let's iterate over all the pairs of the values in a and store them in some data structure (in C++ we can user map). Now let's iterate over all the pairs bi, bj and find in out data structure the value v closest to the value x = sa - sb + 2·(bi + bj) and update the answer by the value |x - v|. Required sum we can find using binary search by data structure (*map* in C++ has lower_bound function).C++ solutionСложность: O((n2 + m2)log(n + m)).620E - New Year TreeLet's run dfs on the tree and write out the vertices in order of their visisiting by dfs (that permutation is called Euler walk). Easy to see that subtree of any vertex is a subsegment of that permutation. Note that the number of different colours is 60, so we can store the set of colours just as mask of binary bits in 64-bit type (*long long* in C++, long in Java). Let's build the segment tree over the permutation which supports two operations: paint subsegment by some colour and find the mask of colours of some segment.С++ solutionComplexity: O(nlogn).620F - Xors on SegmentsWe gave bad constraints to this problem so some participants solved it in O(n2 + m) time.Note that . The values f(0, x) can be simply precomputed. Also you can notice that the value f(0, x) is equal to x, 1, x + 1, 0 depending on the value x modulo 4.Let's use Mo's algorithm: we should group all the queries to blocks by the left end and sort all the queries in each block by the right end. Let r be the maximal left end inside the current group then all left ends will be in distance not greater than from r and right ends will be in nondecreasing order, so we can move the right end by one (total we will made no more than n movements in each block). During moving of the right end inside some group from the value r + 1 to the value of the current right end we will maintain two tries: the first for the values f(0, x - 1) and the second for the values f(0, x), in the first we will maintain the minimal value of x, in the second — the maximal. After adding some values to the trie we should find the maximal value that can be formed by the current value x. To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than x. Each time we should go by the bit that is not equal to the corresponding bit in x (if we can do that, otherwise we should go by the other bit). In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value x. After moving the right end we should iterate from the left end of the query to r and update the answer (without adding the current value to the tries). Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to r, add the current values to the tries and update the answer.С++ solution: in this code the trie number 0 corresponds to the second trie and the trie number 1 corresponds to the first trie.Complexity: .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/22936",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 620\\s*B"
          },
          "content_length": 4495
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 2",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 3",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 4",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 5",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 6",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 8",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "Qingyu"
        },
        {
          "title": "Editorial of Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "bit-mask_for_node_i = bitmask_of_right_child | bitmask_of_left_child",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22936",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readEoln();\n    \n    ensuref(a <= b, \"a must be less than or equal to b, but a=%d, b=%d\", a, b);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readEoln();\n    \n    ensuref(a <= b, \"a must be less than or equal to b, but a=%d, b=%d\", a, b);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readEoln();\n    \n    ensuref(a <= b, \"a must be less than or equal to b, but a=%d, b=%d\", a, b);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int max_value = 1000000;\n    int min_value = 1;\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    if (a != -1 && b != -1) {\n        // Ensure that input parameters satisfy the constraints\n        if (a < min_value || a > max_value || b < min_value || b > max_value || a > b) {\n            fprintf(stderr, \"Invalid input parameters: a=%d, b=%d\\n\", a, b);\n            exit(1);\n        }\n    } else {\n        if (type == \"minimal\") {\n            a = min_value;\n            b = min_value;\n        } else if (type == \"maximal\") {\n            a = min_value;\n            b = max_value;\n        } else if (type == \"single\") {\n            a = b = rnd.next(min_value, max_value);\n        } else if (type == \"smallrange\") {\n            a = rnd.next(min_value, max_value);\n            int delta = rnd.next(0, 10); // small delta\n            b = min(a + delta, max_value);\n        } else if(type == \"largerange\") {\n            a = rnd.next(min_value, max_value);\n            int delta = rnd.next(0, max_value - a);\n            b = a + delta;\n        } else if (type == \"random\") {\n            a = rnd.next(min_value, max_value);\n            b = rnd.next(a, max_value);\n        } else {\n            // unknown type, default to random\n            a = rnd.next(min_value, max_value);\n            b = rnd.next(a, max_value);\n        }\n    }\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int max_value = 1000000;\n    int min_value = 1;\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    if (a != -1 && b != -1) {\n        // Ensure that input parameters satisfy the constraints\n        if (a < min_value || a > max_value || b < min_value || b > max_value || a > b) {\n            fprintf(stderr, \"Invalid input parameters: a=%d, b=%d\\n\", a, b);\n            exit(1);\n        }\n    } else {\n        if (type == \"minimal\") {\n            a = min_value;\n            b = min_value;\n        } else if (type == \"maximal\") {\n            a = min_value;\n            b = max_value;\n        } else if (type == \"single\") {\n            a = b = rnd.next(min_value, max_value);\n        } else if (type == \"smallrange\") {\n            a = rnd.next(min_value, max_value);\n            int delta = rnd.next(0, 10); // small delta\n            b = min(a + delta, max_value);\n        } else if(type == \"largerange\") {\n            a = rnd.next(min_value, max_value);\n            int delta = rnd.next(0, max_value - a);\n            b = a + delta;\n        } else if (type == \"random\") {\n            a = rnd.next(min_value, max_value);\n            b = rnd.next(a, max_value);\n        } else {\n            // unknown type, default to random\n            a = rnd.next(min_value, max_value);\n            b = rnd.next(a, max_value);\n        }\n    }\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -type maximal\n\n# Single value test cases\n./gen -type single\n./gen -type single\n./gen -type single\n\n# Small range test cases\n./gen -type smallrange\n./gen -type smallrange\n./gen -type smallrange\n./gen -type smallrange\n./gen -type smallrange\n\n# Large range test cases\n./gen -type largerange\n./gen -type largerange\n./gen -type largerange\n./gen -type largerange\n./gen -type largerange\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Custom a and b values to test edge cases\n./gen -a 1 -b 1\n./gen -a 1 -b 2\n./gen -a 1 -b 10\n./gen -a 999990 -b 1000000\n./gen -a 1000000 -b 1000000\n./gen -a 500000 -b 500000\n./gen -a 1 -b 999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:16.624017",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "620/C",
      "title": "C. Pearls in a Row",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of pearls in a row.The second line contains n integers ai (1 ≤ ai ≤ 109) – the type of the i-th pearl.",
      "output_spec": "OutputOn the first line print integer k — the maximal number of segments in a partition of the row.Each of the next k lines should contain two integers lj, rj (1 ≤ lj ≤ rj ≤ n) — the number of the leftmost and the rightmost pearls in the j-th segment.Note you should print the correct partition of the row of the pearls, so each pearl should be in exactly one segment and all segments should contain two pearls of the same type.If there are several optimal solutions print any of them. You can print the segments in any order.If there are no correct partitions of the row print the number \"-1\".",
      "sample_tests": "ExamplesInputCopy51 2 3 4 1OutputCopy11 5InputCopy51 2 3 4 5OutputCopy-1InputCopy71 2 1 3 1 2 1OutputCopy21 34 7",
      "description": "C. Pearls in a Row\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of pearls in a row.The second line contains n integers ai (1 ≤ ai ≤ 109) – the type of the i-th pearl.\n\nOutputOn the first line print integer k — the maximal number of segments in a partition of the row.Each of the next k lines should contain two integers lj, rj (1 ≤ lj ≤ rj ≤ n) — the number of the leftmost and the rightmost pearls in the j-th segment.Note you should print the correct partition of the row of the pearls, so each pearl should be in exactly one segment and all segments should contain two pearls of the same type.If there are several optimal solutions print any of them. You can print the segments in any order.If there are no correct partitions of the row print the number \"-1\".\n\nInputCopy51 2 3 4 1OutputCopy11 5InputCopy51 2 3 4 5OutputCopy-1InputCopy71 2 1 3 1 2 1OutputCopy21 34 7\n\nInputCopy51 2 3 4 1\n\nOutputCopy11 5\n\nInputCopy51 2 3 4 5\n\nOutputCopy-1\n\nInputCopy71 2 1 3 1 2 1\n\nOutputCopy21 34 7",
      "solutions": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 6 will take place on 21 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<Your Ad Could Be Here>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</Your Ad Could Be Here>Thanks a lot to Aleksa Plavsic allllekssssa who suggested several problems, two of them you will see on the round (the problems D and F). Also thanks to Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. They are together suggested five problems, two of them you will see on the round (the problems B and E).As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A and C together. Also thanks to Maria Belova Delinur who will check English statements and Aleksa Plavsic allllekssssa who help me with problem testing and have constantly been in touch.The first problem is pretty simple, so I'm waiting fast accepteds from you. The last problem is pretty difficult, so respect to all particiants who will solve it. I hope you will enjoy the problems!Good luck and have fun!UPD 1: I forgot to thank all other users who already sent me the ideas for the problems. I'll try to give that problems to the next rounds.UPD 2: The main part of the contest is finished. The phase of hacks is started.UPD 3: The editorial is ready.UPD 4: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22925",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1790
        },
        {
          "title": "Editorial of Educational Codeforces Round 6 - Codeforces",
          "content": "620A - Professor GukiZ's RobotEasy to see that the answer is max(|x1 - x2|, |y1 - y2|).С++ solutionComplexity: O(1).620B - Grandfather Dovlet’s calculatorLet's simply iterate over all the values from a to b and add to the answer the number of segments of the current value x. To count the number of segments we should iterate over all the digits of the number x and add to the answer the number of segments of the current digit d. These values can be calculated by the image from the problem statement and stored in some array in code.C++ solutionComplexity: O((b - a)logb).620C - Pearls in a RowLet's solve the problem greedily. Let's make the first segment by adding elements until the segment will be good. After that let's make the second segment in the same way and so on. If we couldn't make any good segment then the answer is  - 1. Otherwise let's add all uncovered elements at the end to the last segment. Easy to prove that our construction is optimal: consider the first two segments of the optimal answer, obviously we can extend the second segment until the first segment will be equal to the first segment in our construction.C++ solutionComplexity: O(nlogn).620D - Professor GukiZ and Two ArraysWe can process the cases of zero or one swap in O(nm) time. Consider the case with two swaps. Note we can assume that two swaps will lead to move two elements from a to b and vice versa (in other case it is similar to the case with one swap). Let's iterate over all the pairs of the values in a and store them in some data structure (in C++ we can user map). Now let's iterate over all the pairs bi, bj and find in out data structure the value v closest to the value x = sa - sb + 2·(bi + bj) and update the answer by the value |x - v|. Required sum we can find using binary search by data structure (*map* in C++ has lower_bound function).C++ solutionСложность: O((n2 + m2)log(n + m)).620E - New Year TreeLet's run dfs on the tree and write out the vertices in order of their visisiting by dfs (that permutation is called Euler walk). Easy to see that subtree of any vertex is a subsegment of that permutation. Note that the number of different colours is 60, so we can store the set of colours just as mask of binary bits in 64-bit type (*long long* in C++, long in Java). Let's build the segment tree over the permutation which supports two operations: paint subsegment by some colour and find the mask of colours of some segment.С++ solutionComplexity: O(nlogn).620F - Xors on SegmentsWe gave bad constraints to this problem so some participants solved it in O(n2 + m) time.Note that . The values f(0, x) can be simply precomputed. Also you can notice that the value f(0, x) is equal to x, 1, x + 1, 0 depending on the value x modulo 4.Let's use Mo's algorithm: we should group all the queries to blocks by the left end and sort all the queries in each block by the right end. Let r be the maximal left end inside the current group then all left ends will be in distance not greater than from r and right ends will be in nondecreasing order, so we can move the right end by one (total we will made no more than n movements in each block). During moving of the right end inside some group from the value r + 1 to the value of the current right end we will maintain two tries: the first for the values f(0, x - 1) and the second for the values f(0, x), in the first we will maintain the minimal value of x, in the second — the maximal. After adding some values to the trie we should find the maximal value that can be formed by the current value x. To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than x. Each time we should go by the bit that is not equal to the corresponding bit in x (if we can do that, otherwise we should go by the other bit). In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value x. After moving the right end we should iterate from the left end of the query to r and update the answer (without adding the current value to the tries). Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to r, add the current values to the tries and update the answer.С++ solution: in this code the trie number 0 corresponds to the second trie and the trie number 1 corresponds to the first trie.Complexity: .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22936",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 620\\s*C"
          },
          "content_length": 4495
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 2",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 3",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 4",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 5",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 6",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 8",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "bit-mask_for_node_i = bitmask_of_right_child | bitmask_of_left_child",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22936",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Check EOF\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Check EOF\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Check EOF\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt(1, 1000000000, format(\"a[%d]\", i+1).c_str());\n    }\n\n    int k_jury = ans.readInt(-1, n, \"k_jury\");\n    int k_participant = ouf.readInt(-1, n, \"k_participant\");\n\n    if (k_jury == -1) {\n        if (k_participant != -1) {\n            quitf(_wa, \"Contestant found a solution but the jury says impossible\");\n        } else {\n            quitf(_ok, \"Correct: no solution exists\");\n        }\n    } else {\n        if (k_participant == -1) {\n            quitf(_wa, \"Contestant says no solution but a solution exists\");\n        } else if (k_participant < k_jury) {\n            quitf(_wa, \"Contestant's number of segments %d is less than optimal %d\", k_participant, k_jury);\n        } else if (k_participant > k_jury) {\n            quitf(_fail, \"Participant has a better solution: segments = %d, jury has %d\", k_participant, k_jury);\n        } else {\n            vector<int> assigned(n, 0);\n            for (int i = 0; i < k_participant; i++) {\n                int lj = ouf.readInt(1, n, format(\"l%d\", i+1).c_str());\n                int rj = ouf.readInt(lj, n, format(\"r%d\", i+1).c_str());\n\n                for (int p = lj - 1; p <= rj - 1; p++) {\n                    if (assigned[p] != 0) {\n                        quitf(_wa, \"Overlap between segments at position %d\", p + 1);\n                    }\n                    assigned[p] = 1;\n                }\n\n                unordered_map<int, int> cnt;\n                for (int p = lj - 1; p <= rj - 1; p++) {\n                    cnt[a[p]]++;\n                }\n                bool good = false;\n                for (auto &entry : cnt) {\n                    if (entry.second >= 2) {\n                        good = true;\n                        break;\n                    }\n                }\n                if (!good) {\n                    quitf(_wa, \"Segment [%d, %d] does not contain two pearls of the same type\", lj, rj);\n                }\n            }\n            for (int p = 0; p < n; p++) {\n                if (assigned[p] != 1) {\n                    quitf(_wa, \"Pearl %d is not assigned to any segment\", p + 1);\n                }\n            }\n            quitf(_ok, \"Participant's partition is correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parsing parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    int maxType = opt<int>(\"maxType\", 1000000000); // default 1e9\n    int k = opt<int>(\"k\", 2); // default value for 'pairs' type\n\n    vector<int> ai(n);\n\n    if (type == \"all_same\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"all_unique\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = i + 1;\n        }\n    } else if (type == \"pairs\") {\n        // Uses parameter k\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % k) + 1;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2) + 1;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, maxType);\n        }\n    } else if (type == \"max_segments\") {\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            ai[2*i] = i + 1;\n            ai[2*i + 1] = i + 1;\n        }\n        if (n % 2 == 1) {\n            if (n >= 3) {\n                // Make the last segment include the last three elements with a repeating type\n                ai[n - 1] = ai[n - 3];\n            } else {\n                // If n is 1, set ai[0] as any value\n                ai[n - 1] = 1;\n            }\n        }\n    } else if (type == \"min_segments\") {\n        for (int i = 0; i < n - 1; ++i) {\n            ai[i] = i + 1;\n        }\n        ai[n - 1] = 1; // Duplicate type to first pearl\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, maxType);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n -1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parsing parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    int maxType = opt<int>(\"maxType\", 1000000000); // default 1e9\n    int k = opt<int>(\"k\", 2); // default value for 'pairs' type\n\n    vector<int> ai(n);\n\n    if (type == \"all_same\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"all_unique\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = i + 1;\n        }\n    } else if (type == \"pairs\") {\n        // Uses parameter k\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % k) + 1;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2) + 1;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, maxType);\n        }\n    } else if (type == \"max_segments\") {\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            ai[2*i] = i + 1;\n            ai[2*i + 1] = i + 1;\n        }\n        if (n % 2 == 1) {\n            if (n >= 3) {\n                // Make the last segment include the last three elements with a repeating type\n                ai[n - 1] = ai[n - 3];\n            } else {\n                // If n is 1, set ai[0] as any value\n                ai[n - 1] = 1;\n            }\n        }\n    } else if (type == \"min_segments\") {\n        for (int i = 0; i < n - 1; ++i) {\n            ai[i] = i + 1;\n        }\n        ai[n - 1] = 1; // Duplicate type to first pearl\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, maxType);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n -1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type all_unique\n./gen -n 2 -type all_same\n./gen -n 2 -type all_unique\n./gen -n 2 -type pairs -k 1\n./gen -n 2 -type pairs -k 2\n./gen -n 3 -type all_same\n./gen -n 3 -type all_unique\n./gen -n 10 -type alternating\n./gen -n 10 -type pairs -k 3\n./gen -n 100 -type random -maxType 10\n./gen -n 100 -type random -maxType 100\n./gen -n 1000 -type random -maxType 1000\n./gen -n 10000 -type all_same\n./gen -n 10000 -type all_unique\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 100000 -type max_segments\n./gen -n 100000 -type min_segments\n./gen -n 300000 -type random\n./gen -n 300000 -type max_segments\n./gen -n 300000 -type min_segments\n./gen -n 300000 -type alternating\n./gen -n 300000 -type pairs -k 100\n./gen -n 300000 -type pairs -k 1000\n./gen -n 100000 -type all_unique\n./gen -n 100000 -type all_same\n./gen -n 100000 -type pairs -k 2\n./gen -n 300000 -type pairs -k 2\n./gen -n 300000 -type pairs -k 3\n./gen -n 299999 -type max_segments\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:18.599118",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "620/D",
      "title": "D. Профессор GukiZ и два массива",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится целое число n (1 ≤ n ≤ 2000) — количество элементов в массиве a.Во второй строке находятся n целых ai ( - 109 ≤ ai ≤ 109) — элементы массива a.В третьей строке находится целое число m (1 ≤ m ≤ 2000) — количество элементов в массиве b.В четвёртой строке находятся m целых bj ( - 109 ≤ bj ≤ 109) — элементы массива b.",
      "output_spec": "Выходные данныеВ первой строке выведите наименьшую разность v = |sa - sb|, которую можно получить за не более чем две операции.Во второй строке выведите количество операций k (0 ≤ k ≤ 2).Далее в k строках выведите по два целых числа xp, yp (1 ≤ xp ≤ n, 1 ≤ yp ≤ m) — номер элемента в массиве a и номер элемента в массиве b при p-й операции.Если существует несколько оптимальных решений, выведите любое из них. Операции нужно выводить в порядке, в котором профессор делал их.",
      "sample_tests": "ПримерыВходные данныеСкопировать55 4 3 2 141 1 1 1Выходные данныеСкопировать121 14 2Входные данныеСкопировать51 2 3 4 5115Выходные данныеСкопировать00Входные данныеСкопировать51 2 3 4 541 2 3 4Выходные данныеСкопировать113 1",
      "description": "D. Профессор GukiZ и два массива\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится целое число n (1 ≤ n ≤ 2000) — количество элементов в массиве a.Во второй строке находятся n целых ai ( - 109 ≤ ai ≤ 109) — элементы массива a.В третьей строке находится целое число m (1 ≤ m ≤ 2000) — количество элементов в массиве b.В четвёртой строке находятся m целых bj ( - 109 ≤ bj ≤ 109) — элементы массива b.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите наименьшую разность v = |sa - sb|, которую можно получить за не более чем две операции.Во второй строке выведите количество операций k (0 ≤ k ≤ 2).Далее в k строках выведите по два целых числа xp, yp (1 ≤ xp ≤ n, 1 ≤ yp ≤ m) — номер элемента в массиве a и номер элемента в массиве b при p-й операции.Если существует несколько оптимальных решений, выведите любое из них. Операции нужно выводить в порядке, в котором профессор делал их.\n\nВыходные данные\n\nВходные данныеСкопировать55 4 3 2 141 1 1 1Выходные данныеСкопировать121 14 2Входные данныеСкопировать51 2 3 4 5115Выходные данныеСкопировать00Входные данныеСкопировать51 2 3 4 541 2 3 4Выходные данныеСкопировать113 1\n\nВходные данныеСкопировать55 4 3 2 141 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать121 14 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 4 5115\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 4 541 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать113 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces",
          "content": "Привет, Codeforces!21 января 2016 года в 18:00 MSK состоится шестой учебный раунд Educational Codeforces Round 6 для участников из первого и второго дивизионов.<Здесь могла быть ваша реклама>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день, в течение которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.</Здесь могла быть ваша реклама>Большое спасибо Aleksa Plavsic allllekssssa, который предложил несколько отличных задач, две из них вы увидите на раунде (задачи D и F). Также большое пользователям Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A, они совместно (через Aleksa Plavsic) предложили несколько задач. Две из них вы увидите на раунде (задачи B и E).Подготовкой задач как всегда занимался я (Эдвард Давтян). Благодарю MikeMirzayanov мы вместе придумывали задачи A и C. Спасибо Маше Беловой Delinur за проверку английских текстов условий. Также большое спасибо Aleksa Plavsic allllekssssa, который тестировал задачи и постоянно был на связи.На этом раунде вам по традиции будет предложено шесть задач. Первая задача в этот раз проще, чем обычно (я надеюсь на очень быстрые сабмиты по ней от вас), а последняя, на мой взгляд, очень сложная (респект участникам, которые смогут её сдать). Надеюсь комплект задач вам понравится и вы хорошо их порешаете!Good luck and have fun!UPD 1: Забыл поблагодарить всех ребят, которые мне уже прислали идеи задач, но мы их ещё не взяли в раунд. Я постараюсь поскорее их дать.UPD 2: Основная часть соревнования закончилась. Фаза открытых взломов открыта.UPD 3: Разбор задач готов.UPD 4: Соревнование закончено, результаты окончательные.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22925",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2410
        },
        {
          "title": "Разбор задач Educational Codeforces Round 6 - Codeforces",
          "content": "620A - Робот профессора GukiZЛегко видеть, что ответ в задаче равен max(|x1 - x2|, |y1 - y2|).С++ solutionСложность: O(1).620B - Калькулятор дедушки ДовлетаВ этой задаче достаточно было пройти по всем числам от a до b и прибавить к ответу количество сегментов, необходимое для отображения очередного числа. Для подсчёта этой величины нужно пройти по всем десятичным цифрам числа и прибавить к ответу количество сегментов, необходимой для отображения очередной цифры. Последние величины можно просто посчитать по картинке и вбить в один массив.C++ solutionСложность: O((b - a)logb).620C - ЖемчужинкиБудем решать задачу жадно. Давайте набирать жемчужинки в самый левый хороший подотрезок по одному, начиная с первой жемчужинки. Как только подотрезок станет хорошим (то есть встретится повторение) начнём набирать новый хороший подотрезок. Если мы не смогли набрать ни одного хорошего подотрезка, то ответ  - 1. В противном случае, в конце массива может остаться некоторое количество различных элементов, их нужно отнести к последнему набранному отрезку. Легко доказать, что такая жадность правильная: нужно рассмотреть первые два отрезка в оптимальном ответе и понять, что второй отрезок можно расширить пока первый не станет размера первого подотрезка в нашем ответе.C++ solutionСложность: O(nlogn).620D - Профессор GukiZ и два массиваСлучаи когда нужно сделать одну операцию или их не нужно делать вовсе легко разобрать в лоб (за O(nm)). Теперь рассмотрим случай когда нужно сделать две операции. Заметим, что можно считать, что после двух операций два элемента первого массива перейдёт во второй массив и наоборот, поскольку в противном случае то же самое можно сделать и за одну операцию и значит мы уже рассмотрели этот случай. Давайте переберём пару чисел, которая перейдёт во второй массив и сложим суммы в некоторую структуру данных (например, можно сложить в map в C++). Далее переберём пару чисел во втором массиве bi, bj и найдём в нашей структуре данных сумму v наиболее близкую к числу x = sa - sb + 2·(bi + bj) и обновим ответ значением |x - v|. Нужную сумму можно искать бинарным поиском по структуре данных (для map есть функция lower_bound).C++ solutionСложность: O((n2 + m2)log(n + m)).620E - Новогодняя ёлкаЗапустим dfs из корня дерева и выпишем вершины в порядке в котором их обойдёт dfs (эта перестановка называется обходом Эйлера). Легко видеть, что поддерево в этой перестановке является подотрезком. Заметим, что цветов всего 60, таким образом, мы можем хранить множество цветов просто как маску двоичных битов в 64-битном типе (*long long* в C++, long в Java). Построим дерево отрезков над Эйлеровым обходом, который поддерживает операцию покраски подотрезка и нахождения маски цветов на подотрезке.С++ solutionСложность: O(nlogn).620F - Ксоры на подотрезкеВ этой задаче неудачно были подобраны ограничения в связи с чем некоторые участники сдали решения со сложностью O(n2 + m).Заметим сначала, что . Значения f(0, x) можно было просто предподсчитать или заметить что в зависимости от остатка числа x по модулю 4 значение функции равно x, 1, x + 1, 0 соответственно.Воспользуемся алгоритмом Мо. Разобьём все запросы на блоков по левому концу. Внутри каждого блока отсортируем запросы по правому концу. Пусть r наибольшая левая граница внутри блока, тогда все левые границы отстоят от r на расстояние не более чем , а правые границы идут в порядке неубывания, поэтому их можно двигать по одному (в сумме на один блок мы сделаем не более n передвижений правой границы). Передвигая правую границу, внутри блока для чисел в позициях от r + 1 до текущей правой границы будем поддерживать два бора: первый для значений f(0, x - 1), второй для значений f(0, x), в первом будем поддерживать наименьшее значение x, во втором — наибольшее. Понятно как добавлять число в боры, после добавлений нужно найти наибольшее значение, которое может образовать текущий x для этого будем спускаться по первому бору, поддерживая инвариант того, что в текущем поддереве минимальное значение не больше x, и по возможности ходить по биту отличному от нашего. Аналогичное нужно делать во втором боре, только нужно поддерживать инвариант, что максимальное значение не меньше x. После того как для текущего запроса мы сдвинули правую границу на сколько нужно, нужно пройти от левой границы запроса до r и, не добавляя значения в бор, обновить ответы. Ещё отдельно для каждого запроса в новом (пустом) боре нужно пройти от левой границы до r добавляя значения в бор и обновляя ответ.С++ solution: в коде 0-й бор соответсвует второму, а 1-й — первому.Сложность: .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22936",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 620\\s*D"
          },
          "content_length": 4557
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "long abs(long)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 2",
          "code": "double abs(long)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 3",
          "code": "#include <cmath>\n#include <iostream>\n\nint main()\n{\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 4",
          "code": "#include <cmath>\n#include <iostream>\n\nint main()\n{\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 5",
          "code": "$ g++ main.cpp --std=c++03 -E -o main.cpp.p && grep labs main.cpp.p -B 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 6",
          "code": "extern int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n--\n\n__extension__ extern long long int llabs (long long int __x)\n--\n  using ::getenv;\n  using ::labs;\n--\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n--\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n--\n\n  using ::llabs;\n--\n\n  using ::__gnu_cxx::llabs;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 7",
          "code": "extern int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n--\n\n__extension__ extern long long int llabs (long long int __x)\n--\n  using ::getenv;\n  using ::labs;\n--\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n--\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n--\n\n  using ::llabs;\n--\n\n  using ::__gnu_cxx::llabs;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 8",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 9",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 10",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 12",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 13",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 14",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 15",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "bit-mask_for_node_i = bitmask_of_right_child | bitmask_of_left_child",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22936",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"ai\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, -1000000000, 1000000000, \"bj\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"ai\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, -1000000000, 1000000000, \"bj\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"ai\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, -1000000000, 1000000000, \"bj\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input\n    int n = inf.readInt();\n    vector<long long> a(n);\n    long long s_a = 0;\n\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readLong();\n        s_a += a[i];\n    }\n\n    int m = inf.readInt();\n    vector<long long> b(m);\n    long long s_b = 0;\n\n    for (int i = 0; i < m; ++i) {\n        b[i] = inf.readLong();\n        s_b += b[i];\n    }\n\n    // Compute initial difference\n    long long d = s_a - s_b;\n    long long min_v = abs(d);\n\n    // Keep track of minimal v1 (one swap)\n    long long min_v1 = min_v;\n    pair<int, int> best_swap1(-1, -1);\n\n    // Precompute possible deltas for one swap\n    map<long long, vector<pair<int, int>>> delta_map1;\n\n    for (int i = 0; i < n; ++i) {\n        long long a_i = a[i];\n        for (int j = 0; j < m; ++j) {\n            long long b_j = b[j];\n            long long delta = -2 * a_i + 2 * b_j;\n            long long v1 = llabs(d + delta);\n            if (v1 < min_v1) {\n                min_v1 = v1;\n                best_swap1 = make_pair(i, j);\n            }\n        }\n    }\n\n    // Keep track of minimal v2 (two swaps)\n    long long min_v2 = min_v1;\n    tuple<int, int, int, int> best_swap2(-1, -1, -1, -1);\n\n    // Precompute sums of pairs in a and b\n    vector<pair<long long, pair<int, int>>> a_sums;\n    vector<pair<long long, pair<int, int>>> b_sums;\n\n    for (int i = 0; i < n; ++i) {\n        for (int k = i + 1; k < n; ++k) {\n            long long sum_a = a[i] + a[k];\n            a_sums.push_back({sum_a, {i, k}});\n        }\n    }\n\n    for (int j = 0; j < m; ++j) {\n        for (int l = j + 1; l < m; ++l) {\n            long long sum_b = b[j] + b[l];\n            b_sums.push_back({sum_b, {j, l}});\n        }\n    }\n\n    // Sort sums\n    sort(b_sums.begin(), b_sums.end());\n\n    // For each sum in a_sums, find the best matching sum in b_sums\n    for (const auto& a_item : a_sums) {\n        long long s_a_pair = a_item.first;\n        long long t = -d + 2 * s_a_pair;\n\n        // We need to find s_b such that |2 * s_b - t| is minimized\n        // Use binary search on sorted b_sums\n        auto it = lower_bound(b_sums.begin(), b_sums.end(), make_pair((t + 1) / 2, make_pair(0, 0)));\n        for (int idx = -1; idx <= 1; ++idx) {\n            auto curr_it = it + idx;\n            if (curr_it >= b_sums.begin() && curr_it < b_sums.end()) {\n                long long s_b_pair = curr_it->first;\n                long long v2 = llabs((d - 2 * s_a_pair + 2 * s_b_pair));\n                if (v2 < min_v2) {\n                    min_v2 = v2;\n                    best_swap2 = make_tuple(a_item.second.first, curr_it->second.first,\n                                            a_item.second.second, curr_it->second.second);\n                }\n            }\n        }\n    }\n\n    // Determine the minimal possible v\n    min_v = min({min_v, min_v1, min_v2});\n\n    // Now read participant's output\n    long long v_participant = ouf.readLong();\n    if (v_participant != min_v) {\n        quitf(_wa, \"Participant's minimal v (%lld) is not equal to the minimal possible v (%lld)\", v_participant, min_v);\n    }\n\n    int k = ouf.readInt(0, 2, \"number of swaps\");\n    vector<pair<int, int>> swaps;\n\n    set<int> a_indices_used;\n    set<int> b_indices_used;\n\n    vector<long long> a_new = a;\n    vector<long long> b_new = b;\n    long long s_a_new = s_a;\n    long long s_b_new = s_b;\n\n    for (int p = 0; p < k; ++p) {\n        int x_p = ouf.readInt(1, n, format(\"x_%d\", p + 1).c_str()) - 1;\n        int y_p = ouf.readInt(1, m, format(\"y_%d\", p + 1).c_str()) - 1;\n\n        // Check for duplicate swaps\n        if (a_indices_used.count(x_p) > 0) {\n            quitf(_wa, \"Element a[%d] is swapped more than once\", x_p + 1);\n        }\n        if (b_indices_used.count(y_p) > 0) {\n            quitf(_wa, \"Element b[%d] is swapped more than once\", y_p + 1);\n        }\n        a_indices_used.insert(x_p);\n        b_indices_used.insert(y_p);\n\n        // Apply the swap\n        s_a_new = s_a_new - a_new[x_p] + b_new[y_p];\n        s_b_new = s_b_new - b_new[y_p] + a_new[x_p];\n        swap(a_new[x_p], b_new[y_p]);\n    }\n\n    long long v_p = llabs(s_a_new - s_b_new);\n\n    if (v_participant != v_p) {\n        quitf(_wa, \"Participant's claimed v (%lld) does not match computed v (%lld) after swaps\", v_participant, v_p);\n    }\n\n    if (v_p != min_v) {\n        quitf(_wa, \"Participant's v (%lld) is not minimal possible v (%lld)\", v_p, min_v);\n    }\n\n    // Everything is correct\n    quitf(_ok, \"Correct: minimal v = %lld\", min_v);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // If m is not provided, set m = n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(m);\n\n    if (type == \"noswap\" || type == \"equal\") {\n        // Generate arrays such that sa == sb\n        long long sa = 0, sb = 0;\n        // Generate array a with elements in a manageable range\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000, 1000000);\n            sa += a[i];\n        }\n        // Generate array b with elements in a manageable range\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000, 1000000);\n            sb += b[i];\n        }\n        // Adjust first element(s) of b to make sa == sb\n        long long delta = sa - sb;\n        if (delta >= -1000000000 && delta <= 1000000000) {\n            if (b.size() > 0) {\n                b[0] += delta;\n            } else {\n                // unlikely, but handle m=0\n            }\n        } else {\n            // delta is too big, adjust elements in b\n            // Distribute delta over all elements of b\n            for (int i = 0; i < m; ++i) {\n                b[i] += delta / m;\n            }\n            // Adjust any remaining difference\n            delta = sa - accumulate(b.begin(), b.end(), 0LL);\n            if (delta != 0 && m > 0) {\n                b[0] += delta;\n            }\n        }\n    } else if (type == \"swap1\") {\n        // Generate arrays where swapping one element can minimize v\n        // Initialize arrays\n        for (int i = 0; i < n; ++i) {\n            if (i == 0)\n                a[i] = rnd.next(-1000, 1000);\n            else\n                a[i] = rnd.next(-1000000, 1000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            if (i == 0)\n                b[i] = rnd.next(-1000000, 1000000);\n            else\n                b[i] = rnd.next(-1000, 1000);\n        }\n        // This setup encourages swapping a[0] and b[0]\n    } else if (type == \"allpositive\") {\n        // Generate arrays with positive elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"allnegative\") {\n        // Generate arrays with negative elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, -1);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, -1);\n        }\n    } else if (type == \"mix\") {\n        // Generate arrays with mixed positive and negative elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_elements\") {\n        // Elements at their maximum and minimum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0 ? 1000000000 : -1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = (i % 2 == 0 ? -1000000000 : 1000000000);\n        }\n    } else if (type == \"random\") {\n        // Random arrays\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_size\") {\n        // n and m are maximized, elements are random\n        n = m = 2000;\n        a.resize(n);\n        b.resize(m);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else {\n        // Default random arrays\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        cout << a[i] << (i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output m\n    cout << m << endl;\n\n    // Output array b\n    for (int i = 0; i < m; ++i) {\n        cout << b[i] << (i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // If m is not provided, set m = n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(m);\n\n    if (type == \"noswap\" || type == \"equal\") {\n        // Generate arrays such that sa == sb\n        long long sa = 0, sb = 0;\n        // Generate array a with elements in a manageable range\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000, 1000000);\n            sa += a[i];\n        }\n        // Generate array b with elements in a manageable range\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000, 1000000);\n            sb += b[i];\n        }\n        // Adjust first element(s) of b to make sa == sb\n        long long delta = sa - sb;\n        if (delta >= -1000000000 && delta <= 1000000000) {\n            if (b.size() > 0) {\n                b[0] += delta;\n            } else {\n                // unlikely, but handle m=0\n            }\n        } else {\n            // delta is too big, adjust elements in b\n            // Distribute delta over all elements of b\n            for (int i = 0; i < m; ++i) {\n                b[i] += delta / m;\n            }\n            // Adjust any remaining difference\n            delta = sa - accumulate(b.begin(), b.end(), 0LL);\n            if (delta != 0 && m > 0) {\n                b[0] += delta;\n            }\n        }\n    } else if (type == \"swap1\") {\n        // Generate arrays where swapping one element can minimize v\n        // Initialize arrays\n        for (int i = 0; i < n; ++i) {\n            if (i == 0)\n                a[i] = rnd.next(-1000, 1000);\n            else\n                a[i] = rnd.next(-1000000, 1000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            if (i == 0)\n                b[i] = rnd.next(-1000000, 1000000);\n            else\n                b[i] = rnd.next(-1000, 1000);\n        }\n        // This setup encourages swapping a[0] and b[0]\n    } else if (type == \"allpositive\") {\n        // Generate arrays with positive elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"allnegative\") {\n        // Generate arrays with negative elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, -1);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, -1);\n        }\n    } else if (type == \"mix\") {\n        // Generate arrays with mixed positive and negative elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_elements\") {\n        // Elements at their maximum and minimum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0 ? 1000000000 : -1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = (i % 2 == 0 ? -1000000000 : 1000000000);\n        }\n    } else if (type == \"random\") {\n        // Random arrays\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_size\") {\n        // n and m are maximized, elements are random\n        n = m = 2000;\n        a.resize(n);\n        b.resize(m);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else {\n        // Default random arrays\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        cout << a[i] << (i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output m\n    cout << m << endl;\n\n    // Output array b\n    for (int i = 0; i < m; ++i) {\n        cout << b[i] << (i + 1 == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type noswap\n./gen -n 5 -m 5 -type swap1\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type allpositive\n./gen -n 5 -m 5 -type allnegative\n./gen -n 5 -m 5 -type mix\n\n./gen -n 10 -m 10 -type noswap\n./gen -n 10 -m 10 -type swap1\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type allpositive\n./gen -n 10 -m 10 -type allnegative\n./gen -n 10 -m 10 -type mix\n\n./gen -n 100 -m 100 -type noswap\n./gen -n 100 -m 100 -type swap1\n./gen -n 100 -m 100 -type random\n\n./gen -n 500 -m 500 -type swap1\n./gen -n 500 -m 500 -type mix\n\n./gen -n 1000 -m 1000 -type allpositive\n./gen -n 1000 -m 1000 -type allnegative\n\n./gen -n 2000 -m 2000 -type noswap\n./gen -n 2000 -m 2000 -type random\n\n./gen -n 2000 -m 2000 -type max_size\n\n./gen -n 2000 -m 2000 -type max_elements\n\n./gen -n 2000 -m 2000 -type mix\n\n./gen -n 1 -m 1 -type noswap\n./gen -n 1 -m 1 -type swap1\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 3 -type swap1\n\n./gen -n 3 -m 2 -type swap1\n\n./gen -n 100 -m 200 -type noswap\n\n./gen -n 2000 -m 2000 -type swap1\n\n./gen -n 2000 -m 2000 -type allpositive\n\n./gen -n 1999 -m 1999 -type allnegative\n\n./gen -n 2000 -m 1000 -type mix\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:20.569038",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "620/E",
      "title": "E. New Year Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 4·105) — the number of vertices in the tree and the number of the queries.The second line contains n integers ci (1 ≤ ci ≤ 60) — the colour of the i-th vertex.Each of the next n - 1 lines contains two integers xj, yj (1 ≤ xj, yj ≤ n) — the vertices of the j-th edge. It is guaranteed that you are given correct undirected tree.The last m lines contains the description of the queries. Each description starts with the integer tk (1 ≤ tk ≤ 2) — the type of the k-th query. For the queries of the first type then follows two integers vk, ck (1 ≤ vk ≤ n, 1 ≤ ck ≤ 60) — the number of the vertex whose subtree will be recoloured with the colour ck. For the queries of the second type then follows integer vk (1 ≤ vk ≤ n) — the number of the vertex for which subtree you should find the number of different colours.",
      "output_spec": "OutputFor each query of the second type print the integer a — the number of different colours in the subtree of the vertex given in the query.Each of the numbers should be printed on a separate line in order of query appearing in the input.",
      "sample_tests": "ExamplesInputCopy7 101 1 1 1 1 1 11 21 31 43 53 63 71 3 22 11 4 32 11 2 52 11 6 42 12 22 3OutputCopy234512InputCopy23 301 2 2 6 5 3 2 1 1 1 2 4 5 3 4 4 3 3 3 3 3 4 61 21 31 42 52 63 73 84 94 104 116 126 137 147 157 168 178 1810 1910 2010 2111 2211 232 12 52 62 72 82 92 102 112 41 12 11 13 11 14 11 15 11 16 11 17 11 18 11 19 11 20 11 21 11 22 11 23 12 12 52 62 72 82 92 102 112 4OutputCopy613321235512211123",
      "description": "E. New Year Tree\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 4·105) — the number of vertices in the tree and the number of the queries.The second line contains n integers ci (1 ≤ ci ≤ 60) — the colour of the i-th vertex.Each of the next n - 1 lines contains two integers xj, yj (1 ≤ xj, yj ≤ n) — the vertices of the j-th edge. It is guaranteed that you are given correct undirected tree.The last m lines contains the description of the queries. Each description starts with the integer tk (1 ≤ tk ≤ 2) — the type of the k-th query. For the queries of the first type then follows two integers vk, ck (1 ≤ vk ≤ n, 1 ≤ ck ≤ 60) — the number of the vertex whose subtree will be recoloured with the colour ck. For the queries of the second type then follows integer vk (1 ≤ vk ≤ n) — the number of the vertex for which subtree you should find the number of different colours.\n\nOutputFor each query of the second type print the integer a — the number of different colours in the subtree of the vertex given in the query.Each of the numbers should be printed on a separate line in order of query appearing in the input.\n\nInputCopy7 101 1 1 1 1 1 11 21 31 43 53 63 71 3 22 11 4 32 11 2 52 11 6 42 12 22 3OutputCopy234512InputCopy23 301 2 2 6 5 3 2 1 1 1 2 4 5 3 4 4 3 3 3 3 3 4 61 21 31 42 52 63 73 84 94 104 116 126 137 147 157 168 178 1810 1910 2010 2111 2211 232 12 52 62 72 82 92 102 112 41 12 11 13 11 14 11 15 11 16 11 17 11 18 11 19 11 20 11 21 11 22 11 23 12 12 52 62 72 82 92 102 112 4OutputCopy613321235512211123\n\nInputCopy7 101 1 1 1 1 1 11 21 31 43 53 63 71 3 22 11 4 32 11 2 52 11 6 42 12 22 3\n\nOutputCopy234512\n\nInputCopy23 301 2 2 6 5 3 2 1 1 1 2 4 5 3 4 4 3 3 3 3 3 4 61 21 31 42 52 63 73 84 94 104 116 126 137 147 157 168 178 1810 1910 2010 2111 2211 232 12 52 62 72 82 92 102 112 41 12 11 13 11 14 11 15 11 16 11 17 11 18 11 19 11 20 11 21 11 22 11 23 12 12 52 62 72 82 92 102 112 4\n\nOutputCopy613321235512211123",
      "solutions": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 6 will take place on 21 January 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<Your Ad Could Be Here>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</Your Ad Could Be Here>Thanks a lot to Aleksa Plavsic allllekssssa who suggested several problems, two of them you will see on the round (the problems D and F). Also thanks to Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. They are together suggested five problems, two of them you will see on the round (the problems B and E).As usual the round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A and C together. Also thanks to Maria Belova Delinur who will check English statements and Aleksa Plavsic allllekssssa who help me with problem testing and have constantly been in touch.The first problem is pretty simple, so I'm waiting fast accepteds from you. The last problem is pretty difficult, so respect to all particiants who will solve it. I hope you will enjoy the problems!Good luck and have fun!UPD 1: I forgot to thank all other users who already sent me the ideas for the problems. I'll try to give that problems to the next rounds.UPD 2: The main part of the contest is finished. The phase of hacks is started.UPD 3: The editorial is ready.UPD 4: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22925",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1790
        },
        {
          "title": "Editorial of Educational Codeforces Round 6 - Codeforces",
          "content": "620A - Professor GukiZ's RobotEasy to see that the answer is max(|x1 - x2|, |y1 - y2|).С++ solutionComplexity: O(1).620B - Grandfather Dovlet’s calculatorLet's simply iterate over all the values from a to b and add to the answer the number of segments of the current value x. To count the number of segments we should iterate over all the digits of the number x and add to the answer the number of segments of the current digit d. These values can be calculated by the image from the problem statement and stored in some array in code.C++ solutionComplexity: O((b - a)logb).620C - Pearls in a RowLet's solve the problem greedily. Let's make the first segment by adding elements until the segment will be good. After that let's make the second segment in the same way and so on. If we couldn't make any good segment then the answer is  - 1. Otherwise let's add all uncovered elements at the end to the last segment. Easy to prove that our construction is optimal: consider the first two segments of the optimal answer, obviously we can extend the second segment until the first segment will be equal to the first segment in our construction.C++ solutionComplexity: O(nlogn).620D - Professor GukiZ and Two ArraysWe can process the cases of zero or one swap in O(nm) time. Consider the case with two swaps. Note we can assume that two swaps will lead to move two elements from a to b and vice versa (in other case it is similar to the case with one swap). Let's iterate over all the pairs of the values in a and store them in some data structure (in C++ we can user map). Now let's iterate over all the pairs bi, bj and find in out data structure the value v closest to the value x = sa - sb + 2·(bi + bj) and update the answer by the value |x - v|. Required sum we can find using binary search by data structure (*map* in C++ has lower_bound function).C++ solutionСложность: O((n2 + m2)log(n + m)).620E - New Year TreeLet's run dfs on the tree and write out the vertices in order of their visisiting by dfs (that permutation is called Euler walk). Easy to see that subtree of any vertex is a subsegment of that permutation. Note that the number of different colours is 60, so we can store the set of colours just as mask of binary bits in 64-bit type (*long long* in C++, long in Java). Let's build the segment tree over the permutation which supports two operations: paint subsegment by some colour and find the mask of colours of some segment.С++ solutionComplexity: O(nlogn).620F - Xors on SegmentsWe gave bad constraints to this problem so some participants solved it in O(n2 + m) time.Note that . The values f(0, x) can be simply precomputed. Also you can notice that the value f(0, x) is equal to x, 1, x + 1, 0 depending on the value x modulo 4.Let's use Mo's algorithm: we should group all the queries to blocks by the left end and sort all the queries in each block by the right end. Let r be the maximal left end inside the current group then all left ends will be in distance not greater than from r and right ends will be in nondecreasing order, so we can move the right end by one (total we will made no more than n movements in each block). During moving of the right end inside some group from the value r + 1 to the value of the current right end we will maintain two tries: the first for the values f(0, x - 1) and the second for the values f(0, x), in the first we will maintain the minimal value of x, in the second — the maximal. After adding some values to the trie we should find the maximal value that can be formed by the current value x. To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than x. Each time we should go by the bit that is not equal to the corresponding bit in x (if we can do that, otherwise we should go by the other bit). In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value x. After moving the right end we should iterate from the left end of the query to r and update the answer (without adding the current value to the tries). Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to r, add the current values to the tries and update the answer.С++ solution: in this code the trie number 0 corresponds to the second trie and the trie number 1 corresponds to the first trie.Complexity: .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22936",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 620\\s*E"
          },
          "content_length": 4495
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 2",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 3",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 4",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 5",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 6",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 7",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 8",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "bit-mask_for_node_i = bitmask_of_right_child | bitmask_of_left_child",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22936",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 400000 + 5;\n\nint parent[MAX_N];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    ensuref(pu != pv, \"Graph contains a cycle involving edge (%d, %d)\", u, v);\n    parent[pu] = pv;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400000, \"m\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(n, 1, 60, \"ci\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n        ensuref(xj != yj, \"Edge cannot connect a vertex to itself: %d\", xj);\n        unite(xj, yj);\n    }\n\n    // Process m queries\n    for (int i = 0; i < m; ++i) {\n        int tk = inf.readInt(1, 2, \"tk\");\n        if (tk == 1) {\n            inf.readSpace();\n            int vk = inf.readInt(1, n, \"vk\");\n            inf.readSpace();\n            int ck = inf.readInt(1, 60, \"ck\");\n            inf.readEoln();\n        } else if (tk == 2) {\n            inf.readSpace();\n            int vk = inf.readInt(1, n, \"vk\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid query type %d\", tk);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 400000 + 5;\n\nint parent[MAX_N];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    ensuref(pu != pv, \"Graph contains a cycle involving edge (%d, %d)\", u, v);\n    parent[pu] = pv;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400000, \"m\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(n, 1, 60, \"ci\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n        ensuref(xj != yj, \"Edge cannot connect a vertex to itself: %d\", xj);\n        unite(xj, yj);\n    }\n\n    // Process m queries\n    for (int i = 0; i < m; ++i) {\n        int tk = inf.readInt(1, 2, \"tk\");\n        if (tk == 1) {\n            inf.readSpace();\n            int vk = inf.readInt(1, n, \"vk\");\n            inf.readSpace();\n            int ck = inf.readInt(1, 60, \"ck\");\n            inf.readEoln();\n        } else if (tk == 2) {\n            inf.readSpace();\n            int vk = inf.readInt(1, n, \"vk\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid query type %d\", tk);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 400000 + 5;\n\nint parent[MAX_N];\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    ensuref(pu != pv, \"Graph contains a cycle involving edge (%d, %d)\", u, v);\n    parent[pu] = pv;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400000, \"m\");\n    inf.readEoln();\n\n    vector<int> ci = inf.readInts(n, 1, 60, \"ci\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n        ensuref(xj != yj, \"Edge cannot connect a vertex to itself: %d\", xj);\n        unite(xj, yj);\n    }\n\n    // Process m queries\n    for (int i = 0; i < m; ++i) {\n        int tk = inf.readInt(1, 2, \"tk\");\n        if (tk == 1) {\n            inf.readSpace();\n            int vk = inf.readInt(1, n, \"vk\");\n            inf.readSpace();\n            int ck = inf.readInt(1, 60, \"ck\");\n            inf.readEoln();\n        } else if (tk == 2) {\n            inf.readSpace();\n            int vk = inf.readInt(1, n, \"vk\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid query type %d\", tk);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string ci_type = opt<string>(\"ci_type\", \"random\");\n    string queries_type = opt<string>(\"queries_type\", \"mixed\");\n\n    vector<int> parent(n + 1);\n    vector<pair<int, int>> edges;\n    vector<vector<int>> adj(n + 1);\n\n    parent[1] = 0; // Root node has no parent\n\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            edges.push_back({parent[i], i});\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            edges.push_back({parent[i], i});\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n        }\n    } else if (tree_type == \"balanced\") {\n        queue<int> q;\n        q.push(1);\n        int node = 2;\n        while (node <= n) {\n            int curr = q.front();\n            q.pop();\n            for (int i = 0; i < 2 && node <= n; ++i) {\n                parent[node] = curr;\n                edges.push_back({parent[node], node});\n                adj[parent[node]].push_back(node);\n                adj[node].push_back(parent[node]);\n                q.push(node);\n                ++node;\n            }\n        }\n    } else { // Default to random\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({parent[i], i});\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n        }\n    }\n\n    // Generate initial colors\n    vector<int> ci(n + 1);\n    if (ci_type == \"same\") {\n        for (int i = 1; i <= n; ++i) {\n            ci[i] = 1;\n        }\n    } else if (ci_type == \"unique\") {\n        for (int i = 1; i <= n; ++i) {\n            ci[i] = ((i - 1) % 60) + 1;\n        }\n    } else { // Default to random\n        for (int i = 1; i <= n; ++i) {\n            ci[i] = rnd.next(1, 60);\n        }\n    }\n\n    // Shuffle the nodes except node 1\n    vector<int> perm(n + 1);\n    vector<int> inv_perm(n + 1);\n\n    perm[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n\n    for (int i = 1; i <= n; ++i) {\n        inv_perm[perm[i]] = i;\n    }\n\n    // Remap colors\n    vector<int> ci_new(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        ci_new[i] = ci[perm[i]];\n    }\n\n    // Remap edges\n    vector<pair<int, int>> edges_new;\n    for (auto edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        int new_u = inv_perm[u];\n        int new_v = inv_perm[v];\n        edges_new.push_back({new_u, new_v});\n    }\n\n    // Shuffle edges\n    shuffle(edges_new.begin(), edges_new.end());\n\n    // Generate queries\n    vector<pair<int, vector<int>>> queries;\n    if (queries_type == \"type1\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            int c = rnd.next(1, 60);\n            queries.push_back({1, {v, c}});\n        }\n    } else if (queries_type == \"type2\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({2, {v}});\n        }\n    } else if (queries_type == \"mixed\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            if (t == 1) {\n                int v = rnd.next(1, n);\n                int c = rnd.next(1, 60);\n                queries.push_back({1, {v, c}});\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back({2, {v}});\n            }\n        }\n    } else if (queries_type == \"type1_edges\") {\n        // Generate type 1 queries on leaf nodes\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1 && i != 1) {\n                leaves.push_back(i);\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, (int)leaves.size() - 1);\n            int v = leaves[idx];\n            int c = rnd.next(1, 60);\n            queries.push_back({1, {v, c}});\n        }\n    } else if (queries_type == \"type2_root\") {\n        // Generate type 2 queries on root\n        for (int i = 0; i < m; ++i) {\n            int v = 1; // Root node\n            queries.push_back({2, {v}});\n        }\n    } else if (queries_type == \"recolor_root\") {\n        // Recolor root multiple times\n        for (int i = 0; i < m; ++i) {\n            int v = 1;\n            int c = rnd.next(1, 60);\n            queries.push_back({1, {v, c}});\n        }\n    } else if (queries_type == \"alternate\") {\n        // Alternate between type 1 and type 2 queries\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                int v = rnd.next(1, n);\n                int c = rnd.next(1, 60);\n                queries.push_back({1, {v, c}});\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back({2, {v}});\n            }\n        }\n    } else { // Default to mixed\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            if (t == 1) {\n                int v = rnd.next(1, n);\n                int c = rnd.next(1, 60);\n                queries.push_back({1, {v, c}});\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back({2, {v}});\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", ci_new[i]);\n        if (i == n) printf(\"\\n\");\n        else printf(\" \");\n    }\n    for (auto edge : edges_new) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    for (auto query : queries) {\n        int t = query.first;\n        if (t == 1) {\n            int v = query.second[0];\n            int c = query.second[1];\n            printf(\"1 %d %d\\n\", v, c);\n        } else {\n            int v = query.second[0];\n            printf(\"2 %d\\n\", v);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string ci_type = opt<string>(\"ci_type\", \"random\");\n    string queries_type = opt<string>(\"queries_type\", \"mixed\");\n\n    vector<int> parent(n + 1);\n    vector<pair<int, int>> edges;\n    vector<vector<int>> adj(n + 1);\n\n    parent[1] = 0; // Root node has no parent\n\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            edges.push_back({parent[i], i});\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            edges.push_back({parent[i], i});\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n        }\n    } else if (tree_type == \"balanced\") {\n        queue<int> q;\n        q.push(1);\n        int node = 2;\n        while (node <= n) {\n            int curr = q.front();\n            q.pop();\n            for (int i = 0; i < 2 && node <= n; ++i) {\n                parent[node] = curr;\n                edges.push_back({parent[node], node});\n                adj[parent[node]].push_back(node);\n                adj[node].push_back(parent[node]);\n                q.push(node);\n                ++node;\n            }\n        }\n    } else { // Default to random\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({parent[i], i});\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n        }\n    }\n\n    // Generate initial colors\n    vector<int> ci(n + 1);\n    if (ci_type == \"same\") {\n        for (int i = 1; i <= n; ++i) {\n            ci[i] = 1;\n        }\n    } else if (ci_type == \"unique\") {\n        for (int i = 1; i <= n; ++i) {\n            ci[i] = ((i - 1) % 60) + 1;\n        }\n    } else { // Default to random\n        for (int i = 1; i <= n; ++i) {\n            ci[i] = rnd.next(1, 60);\n        }\n    }\n\n    // Shuffle the nodes except node 1\n    vector<int> perm(n + 1);\n    vector<int> inv_perm(n + 1);\n\n    perm[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n\n    for (int i = 1; i <= n; ++i) {\n        inv_perm[perm[i]] = i;\n    }\n\n    // Remap colors\n    vector<int> ci_new(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        ci_new[i] = ci[perm[i]];\n    }\n\n    // Remap edges\n    vector<pair<int, int>> edges_new;\n    for (auto edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        int new_u = inv_perm[u];\n        int new_v = inv_perm[v];\n        edges_new.push_back({new_u, new_v});\n    }\n\n    // Shuffle edges\n    shuffle(edges_new.begin(), edges_new.end());\n\n    // Generate queries\n    vector<pair<int, vector<int>>> queries;\n    if (queries_type == \"type1\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            int c = rnd.next(1, 60);\n            queries.push_back({1, {v, c}});\n        }\n    } else if (queries_type == \"type2\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.next(1, n);\n            queries.push_back({2, {v}});\n        }\n    } else if (queries_type == \"mixed\") {\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            if (t == 1) {\n                int v = rnd.next(1, n);\n                int c = rnd.next(1, 60);\n                queries.push_back({1, {v, c}});\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back({2, {v}});\n            }\n        }\n    } else if (queries_type == \"type1_edges\") {\n        // Generate type 1 queries on leaf nodes\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1 && i != 1) {\n                leaves.push_back(i);\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, (int)leaves.size() - 1);\n            int v = leaves[idx];\n            int c = rnd.next(1, 60);\n            queries.push_back({1, {v, c}});\n        }\n    } else if (queries_type == \"type2_root\") {\n        // Generate type 2 queries on root\n        for (int i = 0; i < m; ++i) {\n            int v = 1; // Root node\n            queries.push_back({2, {v}});\n        }\n    } else if (queries_type == \"recolor_root\") {\n        // Recolor root multiple times\n        for (int i = 0; i < m; ++i) {\n            int v = 1;\n            int c = rnd.next(1, 60);\n            queries.push_back({1, {v, c}});\n        }\n    } else if (queries_type == \"alternate\") {\n        // Alternate between type 1 and type 2 queries\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                int v = rnd.next(1, n);\n                int c = rnd.next(1, 60);\n                queries.push_back({1, {v, c}});\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back({2, {v}});\n            }\n        }\n    } else { // Default to mixed\n        for (int i = 0; i < m; ++i) {\n            int t = rnd.next(1, 2);\n            if (t == 1) {\n                int v = rnd.next(1, n);\n                int c = rnd.next(1, 60);\n                queries.push_back({1, {v, c}});\n            } else {\n                int v = rnd.next(1, n);\n                queries.push_back({2, {v}});\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", ci_new[i]);\n        if (i == n) printf(\"\\n\");\n        else printf(\" \");\n    }\n    for (auto edge : edges_new) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    for (auto query : queries) {\n        int t = query.first;\n        if (t == 1) {\n            int v = query.second[0];\n            int c = query.second[1];\n            printf(\"1 %d %d\\n\", v, c);\n        } else {\n            int v = query.second[0];\n            printf(\"2 %d\\n\", v);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 5 -m 5 -tree_type chain -ci_type same -queries_type type1\n./gen -n 5 -m 5 -tree_type star -ci_type random -queries_type type2\n./gen -n 5 -m 5 -tree_type random -ci_type unique -queries_type mixed\n\n# Medium test cases\n./gen -n 1000 -m 1000 -tree_type balanced -ci_type same -queries_type type1\n./gen -n 1000 -m 1000 -tree_type chain -ci_type random -queries_type type2\n./gen -n 1000 -m 1000 -tree_type star -ci_type unique -queries_type mixed\n./gen -n 1000 -m 1000 -tree_type random -ci_type random -queries_type mixed\n\n# Large test cases\n./gen -n 100000 -m 100000 -tree_type balanced -ci_type same -queries_type type1\n./gen -n 100000 -m 100000 -tree_type chain -ci_type random -queries_type type2\n./gen -n 100000 -m 100000 -tree_type star -ci_type unique -queries_type mixed\n./gen -n 100000 -m 100000 -tree_type random -ci_type random -queries_type mixed\n\n# Maximum size test cases\n./gen -n 400000 -m 400000 -tree_type balanced -ci_type same -queries_type type1\n./gen -n 400000 -m 400000 -tree_type chain -ci_type random -queries_type type2\n./gen -n 400000 -m 400000 -tree_type star -ci_type unique -queries_type mixed\n./gen -n 400000 -m 400000 -tree_type random -ci_type random -queries_type mixed\n\n# Special test cases\n./gen -n 400000 -m 400000 -tree_type random -ci_type same -queries_type recolor_root\n./gen -n 400000 -m 400000 -tree_type random -ci_type unique -queries_type type2_root\n./gen -n 400000 -m 400000 -tree_type random -ci_type random -queries_type type1_edges\n./gen -n 400000 -m 400000 -tree_type random -ci_type random -queries_type alternate\n\n# Chain tree with mixed queries\n./gen -n 400000 -m 400000 -tree_type chain -ci_type random -queries_type mixed\n\n# Star tree with mixed queries\n./gen -n 400000 -m 400000 -tree_type star -ci_type random -queries_type mixed\n\n# Balanced tree with mixed queries\n./gen -n 400000 -m 400000 -tree_type balanced -ci_type random -queries_type mixed\n\n# Random tree with mixed queries\n./gen -n 400000 -m 400000 -tree_type random -ci_type random -queries_type mixed\n\n# Edge case: All queries are type 2 on root\n./gen -n 400000 -m 400000 -tree_type random -ci_type random -queries_type type2_root\n\n# Edge case: All queries are type 1 on leaves\n./gen -n 400000 -m 400000 -tree_type random -ci_type random -queries_type type1_edges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:22.380985",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "620/F",
      "title": "F. Ксоры на подотрезке",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест10 секунд",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится пара целых чисел n, m (1 ≤ n ≤ 5·104,  1 ≤ m ≤ 5·103) — количество элементов в массиве a и количество запросов.Во второй строке находятся n целых чисел ai (1 ≤ ai ≤ 106) — элементы массива a.В каждой из следующих m строк находится пара целых чисел lj, rj (1 ≤ lj ≤ rj ≤ n) — параметры j-го запроса.",
      "output_spec": "Выходные данныеДля каждого запроса выведите в отдельной строке целое число aj — наибольшее значение функции f(ax, ay) по всем lj ≤ x, y ≤ rj,  ax ≤ ay.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 31 2 3 4 5 61 62 53 4Выходные данныеСкопировать777Входные данныеСкопировать1 111 1Выходные данныеСкопировать1Входные данныеСкопировать6 2010 21312 2314 214 1 3221 11 21 31 41 51 62 22 32 42 52 63 43 53 64 44 54 65 55 66 6Выходные данныеСкопировать10213132131321313213132131321312213132131321313213132314231523152142153231323322",
      "description": "F. Ксоры на подотрезке\n\nограничение по времени на тест10 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится пара целых чисел n, m (1 ≤ n ≤ 5·104,  1 ≤ m ≤ 5·103) — количество элементов в массиве a и количество запросов.Во второй строке находятся n целых чисел ai (1 ≤ ai ≤ 106) — элементы массива a.В каждой из следующих m строк находится пара целых чисел lj, rj (1 ≤ lj ≤ rj ≤ n) — параметры j-го запроса.\n\nВходные данные\n\nВыходные данныеДля каждого запроса выведите в отдельной строке целое число aj — наибольшее значение функции f(ax, ay) по всем lj ≤ x, y ≤ rj,  ax ≤ ay.\n\nВыходные данные\n\nВходные данныеСкопировать6 31 2 3 4 5 61 62 53 4Выходные данныеСкопировать777Входные данныеСкопировать1 111 1Выходные данныеСкопировать1Входные данныеСкопировать6 2010 21312 2314 214 1 3221 11 21 31 41 51 62 22 32 42 52 63 43 53 64 44 54 65 55 66 6Выходные данныеСкопировать10213132131321313213132131321312213132131321313213132314231523152142153231323322\n\nВходные данныеСкопировать6 31 2 3 4 5 61 62 53 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать777\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 111 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2010 21312 2314 214 1 3221 11 21 31 41 51 62 22 32 42 52 63 43 53 64 44 54 65 55 66 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10213132131321313213132131321312213132131321313213132314231523152142153231323322\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces",
          "content": "Привет, Codeforces!21 января 2016 года в 18:00 MSK состоится шестой учебный раунд Educational Codeforces Round 6 для участников из первого и второго дивизионов.<Здесь могла быть ваша реклама>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день, в течение которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.</Здесь могла быть ваша реклама>Большое спасибо Aleksa Plavsic allllekssssa, который предложил несколько отличных задач, две из них вы увидите на раунде (задачи D и F). Также большое пользователям Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A, они совместно (через Aleksa Plavsic) предложили несколько задач. Две из них вы увидите на раунде (задачи B и E).Подготовкой задач как всегда занимался я (Эдвард Давтян). Благодарю MikeMirzayanov мы вместе придумывали задачи A и C. Спасибо Маше Беловой Delinur за проверку английских текстов условий. Также большое спасибо Aleksa Plavsic allllekssssa, который тестировал задачи и постоянно был на связи.На этом раунде вам по традиции будет предложено шесть задач. Первая задача в этот раз проще, чем обычно (я надеюсь на очень быстрые сабмиты по ней от вас), а последняя, на мой взгляд, очень сложная (респект участникам, которые смогут её сдать). Надеюсь комплект задач вам понравится и вы хорошо их порешаете!Good luck and have fun!UPD 1: Забыл поблагодарить всех ребят, которые мне уже прислали идеи задач, но мы их ещё не взяли в раунд. Я постараюсь поскорее их дать.UPD 2: Основная часть соревнования закончилась. Фаза открытых взломов открыта.UPD 3: Разбор задач готов.UPD 4: Соревнование закончено, результаты окончательные.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22925",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2410
        },
        {
          "title": "Разбор задач Educational Codeforces Round 6 - Codeforces",
          "content": "620A - Робот профессора GukiZЛегко видеть, что ответ в задаче равен max(|x1 - x2|, |y1 - y2|).С++ solutionСложность: O(1).620B - Калькулятор дедушки ДовлетаВ этой задаче достаточно было пройти по всем числам от a до b и прибавить к ответу количество сегментов, необходимое для отображения очередного числа. Для подсчёта этой величины нужно пройти по всем десятичным цифрам числа и прибавить к ответу количество сегментов, необходимой для отображения очередной цифры. Последние величины можно просто посчитать по картинке и вбить в один массив.C++ solutionСложность: O((b - a)logb).620C - ЖемчужинкиБудем решать задачу жадно. Давайте набирать жемчужинки в самый левый хороший подотрезок по одному, начиная с первой жемчужинки. Как только подотрезок станет хорошим (то есть встретится повторение) начнём набирать новый хороший подотрезок. Если мы не смогли набрать ни одного хорошего подотрезка, то ответ  - 1. В противном случае, в конце массива может остаться некоторое количество различных элементов, их нужно отнести к последнему набранному отрезку. Легко доказать, что такая жадность правильная: нужно рассмотреть первые два отрезка в оптимальном ответе и понять, что второй отрезок можно расширить пока первый не станет размера первого подотрезка в нашем ответе.C++ solutionСложность: O(nlogn).620D - Профессор GukiZ и два массиваСлучаи когда нужно сделать одну операцию или их не нужно делать вовсе легко разобрать в лоб (за O(nm)). Теперь рассмотрим случай когда нужно сделать две операции. Заметим, что можно считать, что после двух операций два элемента первого массива перейдёт во второй массив и наоборот, поскольку в противном случае то же самое можно сделать и за одну операцию и значит мы уже рассмотрели этот случай. Давайте переберём пару чисел, которая перейдёт во второй массив и сложим суммы в некоторую структуру данных (например, можно сложить в map в C++). Далее переберём пару чисел во втором массиве bi, bj и найдём в нашей структуре данных сумму v наиболее близкую к числу x = sa - sb + 2·(bi + bj) и обновим ответ значением |x - v|. Нужную сумму можно искать бинарным поиском по структуре данных (для map есть функция lower_bound).C++ solutionСложность: O((n2 + m2)log(n + m)).620E - Новогодняя ёлкаЗапустим dfs из корня дерева и выпишем вершины в порядке в котором их обойдёт dfs (эта перестановка называется обходом Эйлера). Легко видеть, что поддерево в этой перестановке является подотрезком. Заметим, что цветов всего 60, таким образом, мы можем хранить множество цветов просто как маску двоичных битов в 64-битном типе (*long long* в C++, long в Java). Построим дерево отрезков над Эйлеровым обходом, который поддерживает операцию покраски подотрезка и нахождения маски цветов на подотрезке.С++ solutionСложность: O(nlogn).620F - Ксоры на подотрезкеВ этой задаче неудачно были подобраны ограничения в связи с чем некоторые участники сдали решения со сложностью O(n2 + m).Заметим сначала, что . Значения f(0, x) можно было просто предподсчитать или заметить что в зависимости от остатка числа x по модулю 4 значение функции равно x, 1, x + 1, 0 соответственно.Воспользуемся алгоритмом Мо. Разобьём все запросы на блоков по левому концу. Внутри каждого блока отсортируем запросы по правому концу. Пусть r наибольшая левая граница внутри блока, тогда все левые границы отстоят от r на расстояние не более чем , а правые границы идут в порядке неубывания, поэтому их можно двигать по одному (в сумме на один блок мы сделаем не более n передвижений правой границы). Передвигая правую границу, внутри блока для чисел в позициях от r + 1 до текущей правой границы будем поддерживать два бора: первый для значений f(0, x - 1), второй для значений f(0, x), в первом будем поддерживать наименьшее значение x, во втором — наибольшее. Понятно как добавлять число в боры, после добавлений нужно найти наибольшее значение, которое может образовать текущий x для этого будем спускаться по первому бору, поддерживая инвариант того, что в текущем поддереве минимальное значение не больше x, и по возможности ходить по биту отличному от нашего. Аналогичное нужно делать во втором боре, только нужно поддерживать инвариант, что максимальное значение не меньше x. После того как для текущего запроса мы сдвинули правую границу на сколько нужно, нужно пройти от левой границы запроса до r и, не добавляя значения в бор, обновить ответы. Ещё отдельно для каждого запроса в новом (пустом) боре нужно пройти от левой границы до r добавляя значения в бор и обновляя ответ.С++ solution: в коде 0-й бор соответсвует второму, а 1-й — первому.Сложность: .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/22936",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 620\\s*F"
          },
          "content_length": 4557
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "long abs(long)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 2",
          "code": "double abs(long)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 3",
          "code": "#include <cmath>\n#include <iostream>\n\nint main()\n{\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 4",
          "code": "#include <cmath>\n#include <iostream>\n\nint main()\n{\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 5",
          "code": "$ g++ main.cpp --std=c++03 -E -o main.cpp.p && grep labs main.cpp.p -B 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 6",
          "code": "extern int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n--\n\n__extension__ extern long long int llabs (long long int __x)\n--\n  using ::getenv;\n  using ::labs;\n--\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n--\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n--\n\n  using ::llabs;\n--\n\n  using ::__gnu_cxx::llabs;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 7",
          "code": "extern int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n--\n\n__extension__ extern long long int llabs (long long int __x)\n--\n  using ::getenv;\n  using ::labs;\n--\n  inline long\n  abs(long __i) { return __builtin_labs(__i); }\n--\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n--\n\n  using ::llabs;\n--\n\n  using ::__gnu_cxx::llabs;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 8",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 9",
          "code": "while (x)\n            ans += ar[x%10], x /= 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 10",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 12",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 13",
          "code": "std::to_string()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 14",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 6 - Codeforces - Code 15",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22925",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 6 - Codeforces - Code 1",
          "code": "bit-mask_for_node_i = bitmask_of_right_child | bitmask_of_left_child",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/22936",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    // Read n integers ai\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    // Read m queries\n    for(int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_j\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_j\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    // Read n integers ai\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    // Read m queries\n    for(int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_j\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_j\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    // Read n integers ai\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    // Read m queries\n    for(int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_j\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_j\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"all-ones\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; i++) {\n            int delta = rnd.next(0, 10);\n            a[i] = min(1000000, a[i - 1] + delta);\n        }\n    } else if (type == \"decreasing\") {\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; i++) {\n            int delta = rnd.next(0, 10);\n            a[i] = max(1, a[i - 1] - delta);\n        }\n    } else if (type == \"maximal\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, 500000);\n            else\n                a[i] = rnd.next(500001, 1000000);\n        }\n    } else if (type == \"repeats\") {\n        int k = rnd.next(1, min(n, 1000));\n        vector<int> values(k);\n        for (int i = 0; i < k; i++) {\n            values[i] = rnd.next(1, 1000000);\n        }\n        for (int i = 0; i < n; i++) {\n            a[i] = values[rnd.next(0, k - 1)];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    vector<pair<int, int>> queries(m);\n\n    if (queryType == \"random\") {\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (queryType == \"full\") {\n        for (int i = 0; i < m; i++) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (queryType == \"single\") {\n        for (int i = 0; i < m; i++) {\n            int idx = rnd.next(1, n);\n            queries[i] = make_pair(idx, idx);\n        }\n    } else if (queryType == \"ends\") {\n        for (int i = 0; i < m; i++) {\n            if (i % 2 == 0)\n                queries[i] = make_pair(1, rnd.next(1, n));\n            else\n                queries[i] = make_pair(rnd.next(1, n), n);\n        }\n    } else if (queryType == \"overlapping\") {\n        int step = max(1, n / m);\n        int l = 1;\n        for (int i = 0; i < m; i++) {\n            int r = min(n, l + step + rnd.next(0, step));\n            queries[i] = make_pair(l, r);\n            l = rnd.next(1, n - step);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"all-ones\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; i++) {\n            int delta = rnd.next(0, 10);\n            a[i] = min(1000000, a[i - 1] + delta);\n        }\n    } else if (type == \"decreasing\") {\n        a[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; i++) {\n            int delta = rnd.next(0, 10);\n            a[i] = max(1, a[i - 1] - delta);\n        }\n    } else if (type == \"maximal\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, 500000);\n            else\n                a[i] = rnd.next(500001, 1000000);\n        }\n    } else if (type == \"repeats\") {\n        int k = rnd.next(1, min(n, 1000));\n        vector<int> values(k);\n        for (int i = 0; i < k; i++) {\n            values[i] = rnd.next(1, 1000000);\n        }\n        for (int i = 0; i < n; i++) {\n            a[i] = values[rnd.next(0, k - 1)];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    vector<pair<int, int>> queries(m);\n\n    if (queryType == \"random\") {\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (queryType == \"full\") {\n        for (int i = 0; i < m; i++) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (queryType == \"single\") {\n        for (int i = 0; i < m; i++) {\n            int idx = rnd.next(1, n);\n            queries[i] = make_pair(idx, idx);\n        }\n    } else if (queryType == \"ends\") {\n        for (int i = 0; i < m; i++) {\n            if (i % 2 == 0)\n                queries[i] = make_pair(1, rnd.next(1, n));\n            else\n                queries[i] = make_pair(rnd.next(1, n), n);\n        }\n    } else if (queryType == \"overlapping\") {\n        int step = max(1, n / m);\n        int l = 1;\n        for (int i = 0; i < m; i++) {\n            int r = min(n, l + step + rnd.next(0, step));\n            queries[i] = make_pair(l, r);\n            l = rnd.next(1, n - step);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random -queryType single\n\n./gen -n 5 -m 5 -type random -queryType random\n./gen -n 5 -m 5 -type all-ones -queryType full\n./gen -n 5 -m 5 -type increasing -queryType ends\n\n./gen -n 100 -m 10 -type random -queryType random\n./gen -n 100 -m 10 -type decreasing -queryType overlapping\n./gen -n 100 -m 10 -type repeats -queryType single\n\n./gen -n 50000 -m 5000 -type random -queryType random\n./gen -n 50000 -m 5000 -type all-ones -queryType full\n./gen -n 50000 -m 5000 -type maximal -queryType random\n\n./gen -n 50000 -m 5000 -type increasing -queryType random\n./gen -n 50000 -m 5000 -type decreasing -queryType random\n./gen -n 50000 -m 5000 -type alternating -queryType random\n\n./gen -n 50000 -m 5000 -type repeats -queryType random\n./gen -n 50000 -m 5000 -type repeats -queryType overlapping\n\n./gen -n 50000 -m 5000 -type random -queryType full\n./gen -n 50000 -m 5000 -type random -queryType single\n./gen -n 50000 -m 5000 -type random -queryType ends\n\n./gen -n 50000 -m 5000 -type maximal -queryType full\n./gen -n 50000 -m 5000 -type maximal -queryType single\n./gen -n 50000 -m 5000 -type maximal -queryType ends\n\n./gen -n 50000 -m 5000 -type decreasing -queryType overlapping\n./gen -n 50000 -m 5000 -type increasing -queryType overlapping\n\n./gen -n 50000 -m 5000 -type alternating -queryType single\n./gen -n 50000 -m 5000 -type alternating -queryType ends\n\n./gen -n 50000 -m 5000 -type repeats -queryType full\n\n./gen -n 50000 -m 5000 -type all-ones -queryType overlapping\n\n./gen -n 10000 -m 5000 -type repeats -queryType random\n./gen -n 10000 -m 5000 -type repeats -queryType overlapping\n./gen -n 10000 -m 5000 -type repeats -queryType full\n\n./gen -n 10000 -m 5000 -type random -queryType single\n./gen -n 10000 -m 5000 -type random -queryType ends\n\n./gen -n 2 -m 1 -type maximal -queryType full\n\n./gen -n 3 -m 3 -type decreasing -queryType single\n\n./gen -n 4 -m 6 -type increasing -queryType full\n\n./gen -n 50000 -m 5000 -type repeats -queryType single\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:24.643493",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "621/A",
      "title": "A. Wet Shark and Odd and Even",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains one integer, n (1 ≤ n ≤ 100 000). The next line contains n space separated integers given to Wet Shark. Each of these integers is in range from 1 to 109, inclusive.",
      "output_spec": "OutputPrint the maximum possible even sum that can be obtained if we use some of the given integers.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopy6InputCopy5999999999 999999999 999999999 999999999 999999999OutputCopy3999999996",
      "description": "A. Wet Shark and Odd and Even\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains one integer, n (1 ≤ n ≤ 100 000). The next line contains n space separated integers given to Wet Shark. Each of these integers is in range from 1 to 109, inclusive.\n\nOutputPrint the maximum possible even sum that can be obtained if we use some of the given integers.\n\nInputCopy31 2 3OutputCopy6InputCopy5999999999 999999999 999999999 999999999 999999999OutputCopy3999999996\n\nInputCopy31 2 3\n\nOutputCopy6\n\nInputCopy5999999999 999999999 999999999 999999999 999999999\n\nOutputCopy3999999996\n\nNoteIn the first sample, we can simply take all three integers for a total sum of 6.In the second sample Wet Shark should take any four out of five integers 999 999 999.",
      "solutions": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces",
          "content": "621A - Мокрая Акула и чётностьFirst, if the sum of all the numbers is already even, then we do nothing. Otherwise, we remove the smallest odd number. Since, if the sum is odd, we need to remove a number with the same parity to make the sum even. Notice it's always bad to remove more odd numbers, and it does nothing to remove even numbers. 621B - Мокрая Акула и слоныLet's start with two bishops (x1, y1) and (x2, y2). Notice that if (x1, y1) attacks (x2, y2), either x1 + y1 == x2 + y2 OR x1 — y1 == x2 — y2. So, for each bishop (x, y), we will store x + y in one map and x — y in another map.621C - Мокрая Акула и цветыLet f(x) be the probability that the product of the number of flowers of sharks x and is divisible by p.We want the expected value of the number of pairs of neighbouring sharks whose flower numbers are divisible by p. From linearity of expectation, this is equal to the probabilities that each pair multiplies to a number divisible by p, or f(0) + f(1) + ... + f(n). (Don't forget about the wrap-around at n) Now, for each pair of neighbouring sharks, we need to figure out the probability that their product is divisible by p. Consider an interval [li, ri]. How many numbers in this interval are divisible by p? Well, it is easier if we break the interval [li, ri] up into [1, ri] - [1, li - 1]. Since 1, 2, ..., x contains numbers divisible by p, the interval [li, ri] contains numbers divisible by p.Now, consider two numbers and , with . Let ai be the number of integers divisible by p in the interval [li, ri], and define aj similarly. Now what's the probability that fi·fj is divisible by p? We can count the opposite: the probability that fi·fj is not divisible by p. Since p is a prime, this means neither fi nor fj is divisible by p. The number of integers in [li, ri] not divisible by p is ri - li + 1 - ai. Similar for j. Therefore, the probability fi·fj is not divisible by p is given by . Therefore, the probability it is can be given by . Now, just sum over this for all i.621D - Крыса Квеш и сырThe tricky Rat Kwesh has finally made an appearance; it is time to prepare for some tricks. But truly, we didn't expect it to be so hard for competitors though. Especially the part about taking log of a negative number.We need a way to deal with xyz and xyz. We cannot directly compare them, 200200200 is way too big. So what we do? Take log! is an increasing function on positive numbers (we can see this by taking , then , which is positive when we are dealing with positive numbers). So if , then x ≥ y.When we take log, But yz can still be 200200, which is still far too big. So now what can we do? Another log! But is it legal? When x = 0.1 for example, , so we cannot take another log. When can we take another log, however? We need to be a positive number. yz will always be positive, so all we need is for to be positive. This happens when x > 1. So if x, y, z > 1, everything will be ok. There is another good observation to make. If one of x, y, z is greater than 1, then we can always achieve some expression (out of those 12) whose value is greater than 1. But if x < 1, then xa will never be greater than 1. So if at least one of x, y, z is greater than 1, then we can discard those bases that are less than or equal to 1. In this case, . Remember that , so . Similarly, .The last case is when x ≤ 1, y ≤ 1, z ≤ 1. Then, notice that for example, . But the denominator of this fraction is something we recognize, because 10 / 3 > 1. So if all x, y, z < 1, then it is the same as the original problem, except we are looking for the minimum this time.621E - Мокрая Акула и блокиFirst, let us build an X by X matrix. We will be applying matrix exponentiation on this matrix. For each modulo value T from 0 to X — 1, and each value in the array with index i between 1 and n, we will do: matrix[T][(10 * T + arr[i]) % X]++. This is because, notice that for each block we allow one more way to go between a modulo value T, and (10 * T + arr[i]) % X. We are multiplying T by 10 because we are \"left-shifting\" the number in a way (i.e. changing 123 -> 1230), and then adding arr[i] to it. Notice that this basically simulates the concatenation that Wet Shark is conducting, without need of a brute force dp approach.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 621\\s*A"
          },
          "content_length": 4252
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "E = x[1] * p[1] + x[2] * p[2] + ..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if x[i] = x[i]' + x[i]'' -> p[i] * x[i] = p[i] * x[i]' + p[i] * x[i]''",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxValue = opt<int>(\"maxValue\", 1000000000); // Default to 1e9\n    string type = opt<string>(\"type\", \"random\");\n    int value = opt<int>(\"value\", -1); // Default value\n\n    vector<int> nums(n);\n\n    if (type == \"all_odd\") {\n        // Generate n odd numbers between 1 and maxValue\n        for (int i = 0; i < n; ++i) {\n            int num = rnd.next(1, maxValue);\n            if (num % 2 == 0) num += 1;\n            if (num > maxValue) num -= 2; // Ensure it's in [1, maxValue]\n            if (num < 1) num = 1;\n            nums[i] = num;\n        }\n    } else if (type == \"all_even\") {\n        // Generate n even numbers between 2 and maxValue\n        for (int i = 0; i < n; ++i) {\n            int num = rnd.next(1, maxValue / 2) * 2;\n            nums[i] = num;\n        }\n    } else if (type == \"random\") {\n        // Generate n random numbers between 1 and maxValue\n        for (int i = 0; i < n; ++i) {\n            nums[i] = rnd.next(1, maxValue);\n        }\n    } else if (type == \"same_number\") {\n        // Use value if provided, otherwise default to 1\n        int num = (value != -1) ? value : 1;\n        for (int i = 0; i < n; ++i) {\n            nums[i] = num;\n        }\n    } else if (type == \"one_odd_rest_even\") {\n        // Generate one odd number and n-1 even numbers\n        if (n < 1) {\n            printf(\"0\\n\");\n            return 0;\n        }\n        // Generate the odd number\n        int oddNum = rnd.next(1, maxValue);\n        if (oddNum % 2 == 0) oddNum += 1;\n        if (oddNum > maxValue) oddNum -= 2;\n        if (oddNum < 1) oddNum = 1;\n        nums[0] = oddNum;\n        for (int i = 1; i < n; ++i) {\n            nums[i] = rnd.next(1, maxValue / 2) * 2;\n        }\n    } else if (type == \"one_even_rest_odd\") {\n        // Generate one even number and n-1 odd numbers\n        if (n < 1) {\n            printf(\"0\\n\");\n            return 0;\n        }\n        // Generate the even number\n        int evenNum = rnd.next(1, maxValue / 2) * 2;\n        nums[0] = evenNum;\n        for (int i = 1; i < n; ++i) {\n            int num = rnd.next(1, maxValue);\n            if (num % 2 == 0) num += 1;\n            if (num > maxValue) num -= 2;\n            if (num < 1) num = 1;\n            nums[i] = num;\n        }\n    } else if (type == \"max_numbers\") {\n        // Generate n numbers equal to maxValue\n        for (int i = 0; i < n; ++i) {\n            nums[i] = maxValue;\n        }\n    } else if (type == \"min_numbers\") {\n        // Generate n numbers equal to 1\n        for (int i = 0; i < n; ++i) {\n            nums[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // Generate numbers alternating between even and odd\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Even number\n                nums[i] = rnd.next(1, maxValue / 2) * 2;\n            } else {\n                // Odd number\n                int num = rnd.next(1, maxValue);\n                if (num % 2 == 0) num += 1;\n                if (num > maxValue) num -= 2;\n                if (num < 1) num = 1;\n                nums[i] = num;\n            }\n        }\n    } else if (type == \"subset_sum_odd\") {\n        // Generate numbers such that total sum is odd\n        for (int i = 0; i < n; ++i) {\n            nums[i] = rnd.next(1, maxValue);\n        }\n        long long total = 0;\n        for (int num : nums) total += num;\n        if (total % 2 == 0) {\n            // Change one number to make total sum odd\n            for (int i = 0; i < n; ++i) {\n                if (nums[i] > 1) {\n                    nums[i] -= 1;\n                    break;\n                }\n            }\n        }\n    } else {\n        // Type not recognized\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", nums[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxValue = opt<int>(\"maxValue\", 1000000000); // Default to 1e9\n    string type = opt<string>(\"type\", \"random\");\n    int value = opt<int>(\"value\", -1); // Default value\n\n    vector<int> nums(n);\n\n    if (type == \"all_odd\") {\n        // Generate n odd numbers between 1 and maxValue\n        for (int i = 0; i < n; ++i) {\n            int num = rnd.next(1, maxValue);\n            if (num % 2 == 0) num += 1;\n            if (num > maxValue) num -= 2; // Ensure it's in [1, maxValue]\n            if (num < 1) num = 1;\n            nums[i] = num;\n        }\n    } else if (type == \"all_even\") {\n        // Generate n even numbers between 2 and maxValue\n        for (int i = 0; i < n; ++i) {\n            int num = rnd.next(1, maxValue / 2) * 2;\n            nums[i] = num;\n        }\n    } else if (type == \"random\") {\n        // Generate n random numbers between 1 and maxValue\n        for (int i = 0; i < n; ++i) {\n            nums[i] = rnd.next(1, maxValue);\n        }\n    } else if (type == \"same_number\") {\n        // Use value if provided, otherwise default to 1\n        int num = (value != -1) ? value : 1;\n        for (int i = 0; i < n; ++i) {\n            nums[i] = num;\n        }\n    } else if (type == \"one_odd_rest_even\") {\n        // Generate one odd number and n-1 even numbers\n        if (n < 1) {\n            printf(\"0\\n\");\n            return 0;\n        }\n        // Generate the odd number\n        int oddNum = rnd.next(1, maxValue);\n        if (oddNum % 2 == 0) oddNum += 1;\n        if (oddNum > maxValue) oddNum -= 2;\n        if (oddNum < 1) oddNum = 1;\n        nums[0] = oddNum;\n        for (int i = 1; i < n; ++i) {\n            nums[i] = rnd.next(1, maxValue / 2) * 2;\n        }\n    } else if (type == \"one_even_rest_odd\") {\n        // Generate one even number and n-1 odd numbers\n        if (n < 1) {\n            printf(\"0\\n\");\n            return 0;\n        }\n        // Generate the even number\n        int evenNum = rnd.next(1, maxValue / 2) * 2;\n        nums[0] = evenNum;\n        for (int i = 1; i < n; ++i) {\n            int num = rnd.next(1, maxValue);\n            if (num % 2 == 0) num += 1;\n            if (num > maxValue) num -= 2;\n            if (num < 1) num = 1;\n            nums[i] = num;\n        }\n    } else if (type == \"max_numbers\") {\n        // Generate n numbers equal to maxValue\n        for (int i = 0; i < n; ++i) {\n            nums[i] = maxValue;\n        }\n    } else if (type == \"min_numbers\") {\n        // Generate n numbers equal to 1\n        for (int i = 0; i < n; ++i) {\n            nums[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // Generate numbers alternating between even and odd\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Even number\n                nums[i] = rnd.next(1, maxValue / 2) * 2;\n            } else {\n                // Odd number\n                int num = rnd.next(1, maxValue);\n                if (num % 2 == 0) num += 1;\n                if (num > maxValue) num -= 2;\n                if (num < 1) num = 1;\n                nums[i] = num;\n            }\n        }\n    } else if (type == \"subset_sum_odd\") {\n        // Generate numbers such that total sum is odd\n        for (int i = 0; i < n; ++i) {\n            nums[i] = rnd.next(1, maxValue);\n        }\n        long long total = 0;\n        for (int num : nums) total += num;\n        if (total % 2 == 0) {\n            // Change one number to make total sum odd\n            for (int i = 0; i < n; ++i) {\n                if (nums[i] > 1) {\n                    nums[i] -= 1;\n                    break;\n                }\n            }\n        }\n    } else {\n        // Type not recognized\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", nums[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# n = 1, a_i is odd\n./gen -n 1 -type same_number -value 1\n\n# n = 1, a_i is even\n./gen -n 1 -type same_number -value 2\n\n# n = 2, both numbers are odd\n./gen -n 2 -type all_odd -maxValue 10\n\n# n = 2, both numbers are even\n./gen -n 2 -type all_even -maxValue 10\n\n# n = 2, one odd and one even\n./gen -n 2 -type one_odd_rest_even -maxValue 10\n\n# n = 3, total sum is odd\n./gen -n 3 -type subset_sum_odd -maxValue 10\n\n# n = 5, all numbers are the same\n./gen -n 5 -type same_number -value 5\n\n# n = 10, alternating even and odd numbers\n./gen -n 10 -type alternating -maxValue 20\n\n# n = 1000, random numbers\n./gen -n 1000 -type random\n\n# n = 100000, all numbers are the maximum value\n./gen -n 100000 -type max_numbers\n\n# n = 100000, all numbers are the minimum value\n./gen -n 100000 -type min_numbers\n\n# n = 100000, all numbers are the same odd number\n./gen -n 100000 -type same_number -value 999999999\n\n# n = 100000, all numbers are odd\n./gen -n 100000 -type all_odd\n\n# n = 100000, all numbers are even\n./gen -n 100000 -type all_even\n\n# n = 99999, total sum is odd\n./gen -n 99999 -type subset_sum_odd\n\n# n = 100000, one odd number and the rest are even\n./gen -n 100000 -type one_odd_rest_even\n\n# n = 100000, one even number and the rest are odd\n./gen -n 100000 -type one_even_rest_odd\n\n# n = 100000, alternating even and odd numbers\n./gen -n 100000 -type alternating\n\n# n = 50000, random numbers\n./gen -n 50000 -type random\n\n# n = 50000, total sum is odd\n./gen -n 50000 -type subset_sum_odd\n\n# n = 100000, random numbers up to 1e9\n./gen -n 100000 -type random -maxValue 1000000000\n\n# n = 100000, random numbers up to 2\n./gen -n 100000 -type random -maxValue 2\n\n# n = 100000, all ones\n./gen -n 100000 -type same_number -value 1\n\n# n = 99999, numbers are random odd numbers\n./gen -n 99999 -type all_odd\n\n# n = 99999, numbers are random even numbers\n./gen -n 99999 -type all_even\n\n# n = 100000, one big odd number, rest are small even numbers\n./gen -n 100000 -type one_odd_rest_even -maxValue 1000000000\n\n# n = 100000, one small odd number, rest are big even numbers\n./gen -n 100000 -type one_odd_rest_even -maxValue 1000000000\n\n# n = 100000, alternating numbers with big odds and small evens\n./gen -n 100000 -type alternating -maxValue 1000000000\n\n# n = 100000, numbers alternating with small odds and big evens\n./gen -n 100000 -type alternating -maxValue 1000000000\n\n# n = 1000, random numbers in descending order\n./gen -n 1000 -type random -maxValue 1000000000\n\n# n = 1000, random numbers in ascending order\n./gen -n 1000 -type random -maxValue 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:27.033387",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "621/B",
      "title": "B. Мокрая Акула и слоны",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержится число n (1 ≤ n ≤ 200 000) — количество слонов на шахматной доске.Каждая из следующих n строк содержит два целых числа xi и yi (1 ≤ xi, yi ≤ 1000) — номер строки и номер столбца, в которых расположен i-й слон. Гарантируется, что позиции всех слонов различны.",
      "output_spec": "Выходные данныеВыведите количество пар слонов, которые атакуют друг друга.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 11 53 35 15 5Выходные данныеСкопировать6Входные данныеСкопировать31 12 33 5Выходные данныеСкопировать0",
      "description": "B. Мокрая Акула и слоны\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных содержится число n (1 ≤ n ≤ 200 000) — количество слонов на шахматной доске.Каждая из следующих n строк содержит два целых числа xi и yi (1 ≤ xi, yi ≤ 1000) — номер строки и номер столбца, в которых расположен i-й слон. Гарантируется, что позиции всех слонов различны.\n\nВходные данные\n\nВыходные данныеВыведите количество пар слонов, которые атакуют друг друга.\n\nВыходные данные\n\nВходные данныеСкопировать51 11 53 35 15 5Выходные данныеСкопировать6Входные данныеСкопировать31 12 33 5Выходные данныеСкопировать0\n\nВходные данныеСкопировать51 11 53 35 15 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 12 33 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере атакуют друг друга следующие пары слонов: (1, 3), (1, 5), (2, 3), (2, 4), (3, 4) и (3, 5). Пары (1, 2), (1, 4), (2, 5) и (4, 5) друг друга не атакуют, так как соответствующие слоны не находятся на одной диагонали.",
      "solutions": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces",
          "content": "621A - Мокрая Акула и чётностьFirst, if the sum of all the numbers is already even, then we do nothing. Otherwise, we remove the smallest odd number. Since, if the sum is odd, we need to remove a number with the same parity to make the sum even. Notice it's always bad to remove more odd numbers, and it does nothing to remove even numbers. 621B - Мокрая Акула и слоныLet's start with two bishops (x1, y1) and (x2, y2). Notice that if (x1, y1) attacks (x2, y2), either x1 + y1 == x2 + y2 OR x1 — y1 == x2 — y2. So, for each bishop (x, y), we will store x + y in one map and x — y in another map.621C - Мокрая Акула и цветыLet f(x) be the probability that the product of the number of flowers of sharks x and is divisible by p.We want the expected value of the number of pairs of neighbouring sharks whose flower numbers are divisible by p. From linearity of expectation, this is equal to the probabilities that each pair multiplies to a number divisible by p, or f(0) + f(1) + ... + f(n). (Don't forget about the wrap-around at n) Now, for each pair of neighbouring sharks, we need to figure out the probability that their product is divisible by p. Consider an interval [li, ri]. How many numbers in this interval are divisible by p? Well, it is easier if we break the interval [li, ri] up into [1, ri] - [1, li - 1]. Since 1, 2, ..., x contains numbers divisible by p, the interval [li, ri] contains numbers divisible by p.Now, consider two numbers and , with . Let ai be the number of integers divisible by p in the interval [li, ri], and define aj similarly. Now what's the probability that fi·fj is divisible by p? We can count the opposite: the probability that fi·fj is not divisible by p. Since p is a prime, this means neither fi nor fj is divisible by p. The number of integers in [li, ri] not divisible by p is ri - li + 1 - ai. Similar for j. Therefore, the probability fi·fj is not divisible by p is given by . Therefore, the probability it is can be given by . Now, just sum over this for all i.621D - Крыса Квеш и сырThe tricky Rat Kwesh has finally made an appearance; it is time to prepare for some tricks. But truly, we didn't expect it to be so hard for competitors though. Especially the part about taking log of a negative number.We need a way to deal with xyz and xyz. We cannot directly compare them, 200200200 is way too big. So what we do? Take log! is an increasing function on positive numbers (we can see this by taking , then , which is positive when we are dealing with positive numbers). So if , then x ≥ y.When we take log, But yz can still be 200200, which is still far too big. So now what can we do? Another log! But is it legal? When x = 0.1 for example, , so we cannot take another log. When can we take another log, however? We need to be a positive number. yz will always be positive, so all we need is for to be positive. This happens when x > 1. So if x, y, z > 1, everything will be ok. There is another good observation to make. If one of x, y, z is greater than 1, then we can always achieve some expression (out of those 12) whose value is greater than 1. But if x < 1, then xa will never be greater than 1. So if at least one of x, y, z is greater than 1, then we can discard those bases that are less than or equal to 1. In this case, . Remember that , so . Similarly, .The last case is when x ≤ 1, y ≤ 1, z ≤ 1. Then, notice that for example, . But the denominator of this fraction is something we recognize, because 10 / 3 > 1. So if all x, y, z < 1, then it is the same as the original problem, except we are looking for the minimum this time.621E - Мокрая Акула и блокиFirst, let us build an X by X matrix. We will be applying matrix exponentiation on this matrix. For each modulo value T from 0 to X — 1, and each value in the array with index i between 1 and n, we will do: matrix[T][(10 * T + arr[i]) % X]++. This is because, notice that for each block we allow one more way to go between a modulo value T, and (10 * T + arr[i]) % X. We are multiplying T by 10 because we are \"left-shifting\" the number in a way (i.e. changing 123 -> 1230), and then adding arr[i] to it. Notice that this basically simulates the concatenation that Wet Shark is conducting, without need of a brute force dp approach.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 621\\s*B"
          },
          "content_length": 4252
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "E = x[1] * p[1] + x[2] * p[2] + ..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if x[i] = x[i]' + x[i]'' -> p[i] * x[i] = p[i] * x[i]' + p[i] * x[i]''",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool occupied[1001][1001];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n        ensuref(!occupied[xi][yi], \"Duplicate position at bishop %d: (%d, %d)\", i+1, xi, yi);\n        occupied[xi][yi] = true;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool occupied[1001][1001];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n        ensuref(!occupied[xi][yi], \"Duplicate position at bishop %d: (%d, %d)\", i+1, xi, yi);\n        occupied[xi][yi] = true;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool occupied[1001][1001];\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n        ensuref(!occupied[xi][yi], \"Duplicate position at bishop %d: (%d, %d)\", i+1, xi, yi);\n        occupied[xi][yi] = true;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_COORD = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> positions;\n\n    vector<pair<int, int>> bishops;\n\n    if (type == \"max_attack\") {\n        // Place as many bishops as possible on the same diagonal\n        // We can fix x - y = c\n        int c = rnd.next(-MAX_COORD + 1, MAX_COORD - 1); // x - y = c\n        for (int x = 1; x <= MAX_COORD && (int)bishops.size() < n; x++) {\n            int y = x - c;\n            if (y >= 1 && y <= MAX_COORD) {\n                bishops.push_back({x, y});\n                positions.insert({x, y});\n            }\n        }\n        // If still not enough, pick another diagonal\n        while ((int)bishops.size() < n) {\n            c = rnd.next(-MAX_COORD + 1, MAX_COORD - 1);\n            for (int x = 1; x <= MAX_COORD && (int)bishops.size() < n; x++) {\n                int y = x - c;\n                if (y >= 1 && y <= MAX_COORD && !positions.count({x, y})) {\n                    bishops.push_back({x, y});\n                    positions.insert({x, y});\n                }\n            }\n        }\n    } else if (type == \"no_attack\") {\n        // Place bishops such that no two attack each other.\n        // That is, no two bishops share any diagonal.\n        // Total possible positions is limited.\n        vector<pair<int, int>> positions_list;\n\n        // For x + y diagonals\n        for (int sum = 2; sum <= 2 * MAX_COORD; sum++) {\n            for (int x = 1; x <= MAX_COORD; x++) {\n                int y = sum - x;\n                if (y >= 1 && y <= MAX_COORD) {\n                    positions_list.push_back({x, y});\n                    break; // Only one position per diagonal\n                }\n            }\n        }\n\n        // For x - y diagonals\n        for (int diff = -MAX_COORD + 1; diff <= MAX_COORD - 1; diff++) {\n            for (int x = 1; x <= MAX_COORD; x++) {\n                int y = x - diff;\n                if (y >= 1 && y <= MAX_COORD) {\n                    positions_list.push_back({x, y});\n                    break; // Only one position per diagonal\n                }\n            }\n        }\n\n        // Remove duplicates\n        sort(positions_list.begin(), positions_list.end());\n        positions_list.erase(unique(positions_list.begin(), positions_list.end()), positions_list.end());\n\n        if (n > (int)positions_list.size()) {\n            fprintf(stderr, \"n is too large for 'no_attack' type. Max n is %d\\n\", (int)positions_list.size());\n            n = positions_list.size(); // Adjust n\n        }\n\n        shuffle(positions_list.begin(), positions_list.end());\n\n        for (int i = 0; i < n; i++) {\n            bishops.push_back(positions_list[i]);\n            positions.insert(positions_list[i]);\n        }\n\n    } else if (type == \"min_attack\") {\n        // Generate positions to minimize attacks\n        // Distribute bishops to diagonals as evenly as possible\n        vector<int> sums;\n        for (int sum = 2; sum <= 2 * MAX_COORD; sum++) {\n            sums.push_back(sum);\n        }\n        shuffle(sums.begin(), sums.end());\n\n        int idx = 0;\n        while ((int)bishops.size() < n) {\n            if (idx >= (int)sums.size()) idx = 0;\n            int sum = sums[idx++];\n            vector<pair<int, int>> diag_positions;\n            for (int x = 1; x <= MAX_COORD; x++) {\n                int y = sum - x;\n                if (y >= 1 && y <= MAX_COORD && !positions.count({x, y})) {\n                    diag_positions.push_back({x, y});\n                }\n            }\n            shuffle(diag_positions.begin(), diag_positions.end());\n            for (auto pos : diag_positions) {\n                if ((int)bishops.size() >= n) break;\n                bishops.push_back(pos);\n                positions.insert(pos);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random positions\n        while ((int)bishops.size() < n) {\n            int x = rnd.next(1, MAX_COORD);\n            int y = rnd.next(1, MAX_COORD);\n            if (!positions.count({x, y})) {\n                bishops.push_back({x, y});\n                positions.insert({x, y});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto &p : bishops) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_COORD = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> positions;\n\n    vector<pair<int, int>> bishops;\n\n    if (type == \"max_attack\") {\n        // Place as many bishops as possible on the same diagonal\n        // We can fix x - y = c\n        int c = rnd.next(-MAX_COORD + 1, MAX_COORD - 1); // x - y = c\n        for (int x = 1; x <= MAX_COORD && (int)bishops.size() < n; x++) {\n            int y = x - c;\n            if (y >= 1 && y <= MAX_COORD) {\n                bishops.push_back({x, y});\n                positions.insert({x, y});\n            }\n        }\n        // If still not enough, pick another diagonal\n        while ((int)bishops.size() < n) {\n            c = rnd.next(-MAX_COORD + 1, MAX_COORD - 1);\n            for (int x = 1; x <= MAX_COORD && (int)bishops.size() < n; x++) {\n                int y = x - c;\n                if (y >= 1 && y <= MAX_COORD && !positions.count({x, y})) {\n                    bishops.push_back({x, y});\n                    positions.insert({x, y});\n                }\n            }\n        }\n    } else if (type == \"no_attack\") {\n        // Place bishops such that no two attack each other.\n        // That is, no two bishops share any diagonal.\n        // Total possible positions is limited.\n        vector<pair<int, int>> positions_list;\n\n        // For x + y diagonals\n        for (int sum = 2; sum <= 2 * MAX_COORD; sum++) {\n            for (int x = 1; x <= MAX_COORD; x++) {\n                int y = sum - x;\n                if (y >= 1 && y <= MAX_COORD) {\n                    positions_list.push_back({x, y});\n                    break; // Only one position per diagonal\n                }\n            }\n        }\n\n        // For x - y diagonals\n        for (int diff = -MAX_COORD + 1; diff <= MAX_COORD - 1; diff++) {\n            for (int x = 1; x <= MAX_COORD; x++) {\n                int y = x - diff;\n                if (y >= 1 && y <= MAX_COORD) {\n                    positions_list.push_back({x, y});\n                    break; // Only one position per diagonal\n                }\n            }\n        }\n\n        // Remove duplicates\n        sort(positions_list.begin(), positions_list.end());\n        positions_list.erase(unique(positions_list.begin(), positions_list.end()), positions_list.end());\n\n        if (n > (int)positions_list.size()) {\n            fprintf(stderr, \"n is too large for 'no_attack' type. Max n is %d\\n\", (int)positions_list.size());\n            n = positions_list.size(); // Adjust n\n        }\n\n        shuffle(positions_list.begin(), positions_list.end());\n\n        for (int i = 0; i < n; i++) {\n            bishops.push_back(positions_list[i]);\n            positions.insert(positions_list[i]);\n        }\n\n    } else if (type == \"min_attack\") {\n        // Generate positions to minimize attacks\n        // Distribute bishops to diagonals as evenly as possible\n        vector<int> sums;\n        for (int sum = 2; sum <= 2 * MAX_COORD; sum++) {\n            sums.push_back(sum);\n        }\n        shuffle(sums.begin(), sums.end());\n\n        int idx = 0;\n        while ((int)bishops.size() < n) {\n            if (idx >= (int)sums.size()) idx = 0;\n            int sum = sums[idx++];\n            vector<pair<int, int>> diag_positions;\n            for (int x = 1; x <= MAX_COORD; x++) {\n                int y = sum - x;\n                if (y >= 1 && y <= MAX_COORD && !positions.count({x, y})) {\n                    diag_positions.push_back({x, y});\n                }\n            }\n            shuffle(diag_positions.begin(), diag_positions.end());\n            for (auto pos : diag_positions) {\n                if ((int)bishops.size() >= n) break;\n                bishops.push_back(pos);\n                positions.insert(pos);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random positions\n        while ((int)bishops.size() < n) {\n            int x = rnd.next(1, MAX_COORD);\n            int y = rnd.next(1, MAX_COORD);\n            if (!positions.count({x, y})) {\n                bishops.push_back({x, y});\n                positions.insert({x, y});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto &p : bishops) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type no_attack\n./gen -n 1 -type max_attack\n./gen -n 2 -type random\n./gen -n 2 -type no_attack\n./gen -n 10 -type random\n./gen -n 10 -type no_attack\n./gen -n 10 -type max_attack\n./gen -n 100 -type random\n./gen -n 100 -type no_attack\n./gen -n 100 -type max_attack\n./gen -n 1000 -type random\n./gen -n 1000 -type no_attack\n./gen -n 1000 -type max_attack\n./gen -n 5000 -type random\n./gen -n 5000 -type min_attack\n./gen -n 5000 -type max_attack\n./gen -n 10000 -type random\n./gen -n 10000 -type min_attack\n./gen -n 10000 -type max_attack\n./gen -n 50000 -type random\n./gen -n 50000 -type min_attack\n./gen -n 50000 -type max_attack\n./gen -n 100000 -type random\n./gen -n 100000 -type min_attack\n./gen -n 100000 -type max_attack\n./gen -n 1998 -type no_attack\n./gen -n 1999 -type no_attack\n./gen -n 2000 -type min_attack\n./gen -n 200000 -type random\n./gen -n 200000 -type min_attack\n./gen -n 200000 -type max_attack\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:28.726003",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "621/C",
      "title": "Problem 621/C",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null modular_mul(ull a, ull b, ull mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\null modular_pow(ull base, ull exponent, ull mod) {\n    ull result = 1;\n    base = base % mod;\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = modular_mul(result, base, mod);\n        base = modular_mul(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nbool MillerRabin(ull n, ull a) {\n    if (n % a == 0) return false;\n    ull d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    ull x = modular_pow(a, d, n);\n    if (x == 1 || x == n - 1)\n        return true;\n    for (int r = 0; r < s - 1; r++) {\n        x = modular_mul(x, x, n);\n        if (x == n - 1)\n            return true;\n    }\n    return false;\n}\n\nbool isPrime(ull n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0) return false;\n    int known_primes[] = {2, 3, 5, 7, 11};\n    for (int a : known_primes) {\n        if (n == a)\n            return true;\n        if (!MillerRabin(n, a))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(2, 1000000000, \"p\");\n    inf.readEoln();\n\n    ensuref(isPrime(p), \"p must be prime, but p=%d\", p);\n\n    for (int i = 1; i <= n; i++) {\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null modular_mul(ull a, ull b, ull mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\null modular_pow(ull base, ull exponent, ull mod) {\n    ull result = 1;\n    base = base % mod;\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = modular_mul(result, base, mod);\n        base = modular_mul(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nbool MillerRabin(ull n, ull a) {\n    if (n % a == 0) return false;\n    ull d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    ull x = modular_pow(a, d, n);\n    if (x == 1 || x == n - 1)\n        return true;\n    for (int r = 0; r < s - 1; r++) {\n        x = modular_mul(x, x, n);\n        if (x == n - 1)\n            return true;\n    }\n    return false;\n}\n\nbool isPrime(ull n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0) return false;\n    int known_primes[] = {2, 3, 5, 7, 11};\n    for (int a : known_primes) {\n        if (n == a)\n            return true;\n        if (!MillerRabin(n, a))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(2, 1000000000, \"p\");\n    inf.readEoln();\n\n    ensuref(isPrime(p), \"p must be prime, but p=%d\", p);\n\n    for (int i = 1; i <= n; i++) {\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null modular_mul(ull a, ull b, ull mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\null modular_pow(ull base, ull exponent, ull mod) {\n    ull result = 1;\n    base = base % mod;\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = modular_mul(result, base, mod);\n        base = modular_mul(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nbool MillerRabin(ull n, ull a) {\n    if (n % a == 0) return false;\n    ull d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    ull x = modular_pow(a, d, n);\n    if (x == 1 || x == n - 1)\n        return true;\n    for (int r = 0; r < s - 1; r++) {\n        x = modular_mul(x, x, n);\n        if (x == n - 1)\n            return true;\n    }\n    return false;\n}\n\nbool isPrime(ull n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0) return false;\n    int known_primes[] = {2, 3, 5, 7, 11};\n    for (int a : known_primes) {\n        if (n == a)\n            return true;\n        if (!MillerRabin(n, a))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(2, 1000000000, \"p\");\n    inf.readEoln();\n\n    ensuref(isPrime(p), \"p must be prime, but p=%d\", p);\n\n    for (int i = 1; i <= n; i++) {\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    if (type == \"random\") {\n        // Generate random li and ri\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (type == \"fixed_s\") {\n        // All s_i are fixed to a specific value s\n        int s = opt<int>(\"s\", 1);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", s, s);\n        }\n    } else if (type == \"div_p\") {\n        // All s_i are divisible by p\n        for (int i = 0; i < n; ++i) {\n            int k1 = 1;\n            int k2 = 1000000000 / p;\n            if (k2 == 0) k2 = 1; // Ensure at least one possible value\n            int k = rnd.next(k1, k2);\n            int s = p * k;\n            printf(\"%d %d\\n\", s, s);\n        }\n    } else if (type == \"not_div_p\") {\n        // All s_i are not divisible by p\n        for (int i = 0; i < n; ++i) {\n            // Generate l and r in [1, 1e9]\n            int l = rnd.next(1, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            // Adjust l and r so that no number between l and r is divisible by p\n            int l_mod_p = l % p;\n            if (l_mod_p == 0) l += 1;\n            int r_mod_p = r % p;\n            if (r_mod_p == 0) r -= 1;\n            if (l > r) {\n                // No valid s_i in this range, adjust l and r\n                l = 1;\n                r = 1000000000;\n                // Ensure l % p != 0, r % p != 0\n                if (l % p == 0) l += 1;\n                if (r % p == 0) r -= 1;\n                if (l > r) {\n                    // Choose s_i = 1\n                    l = 1;\n                    r = 1;\n                }\n            }\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (type == \"mixed\") {\n        // Alternate between s_i divisible by p and not divisible by p\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // s_i divisible by p\n                int k1 = 1;\n                int k2 = 1000000000 / p;\n                if (k2 == 0) k2 = 1; // Ensure at least one possible value\n                int k = rnd.next(k1, k2);\n                int s = p * k;\n                printf(\"%d %d\\n\", s, s);\n            } else {\n                // s_i not divisible by p\n                int l = rnd.next(1, 1000000000);\n                int r = rnd.next(l, 1000000000);\n                // Adjust l and r\n                int l_mod_p = l % p;\n                if (l_mod_p == 0) l += 1;\n                int r_mod_p = r % p;\n                if (r_mod_p == 0) r -= 1;\n                if (l > r) {\n                    // Adjust to ensure at least one s_i not divisible by p\n                    l = 1;\n                    r = 1000000000;\n                    if (l % p == 0) l += 1;\n                    if (r % p == 0) r -= 1;\n                    if (l > r) {\n                        // Choose s_i = 1\n                        l = 1;\n                        r = 1;\n                    }\n                }\n                printf(\"%d %d\\n\", l, r);\n            }\n        }\n    } else if (type == \"max_range\") {\n        // All li = 1, ri = 1e9\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1000000000\\n\");\n        }\n    } else if (type == \"min_range\") {\n        // All li = ri = 1\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } else if (type == \"edges\") {\n        // li and ri at min and max values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                printf(\"1 1\\n\");\n            } else {\n                printf(\"1000000000 1000000000\\n\");\n            }\n        }\n    }\n    // We can add other types as needed.\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    if (type == \"random\") {\n        // Generate random li and ri\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (type == \"fixed_s\") {\n        // All s_i are fixed to a specific value s\n        int s = opt<int>(\"s\", 1);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", s, s);\n        }\n    } else if (type == \"div_p\") {\n        // All s_i are divisible by p\n        for (int i = 0; i < n; ++i) {\n            int k1 = 1;\n            int k2 = 1000000000 / p;\n            if (k2 == 0) k2 = 1; // Ensure at least one possible value\n            int k = rnd.next(k1, k2);\n            int s = p * k;\n            printf(\"%d %d\\n\", s, s);\n        }\n    } else if (type == \"not_div_p\") {\n        // All s_i are not divisible by p\n        for (int i = 0; i < n; ++i) {\n            // Generate l and r in [1, 1e9]\n            int l = rnd.next(1, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            // Adjust l and r so that no number between l and r is divisible by p\n            int l_mod_p = l % p;\n            if (l_mod_p == 0) l += 1;\n            int r_mod_p = r % p;\n            if (r_mod_p == 0) r -= 1;\n            if (l > r) {\n                // No valid s_i in this range, adjust l and r\n                l = 1;\n                r = 1000000000;\n                // Ensure l % p != 0, r % p != 0\n                if (l % p == 0) l += 1;\n                if (r % p == 0) r -= 1;\n                if (l > r) {\n                    // Choose s_i = 1\n                    l = 1;\n                    r = 1;\n                }\n            }\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (type == \"mixed\") {\n        // Alternate between s_i divisible by p and not divisible by p\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // s_i divisible by p\n                int k1 = 1;\n                int k2 = 1000000000 / p;\n                if (k2 == 0) k2 = 1; // Ensure at least one possible value\n                int k = rnd.next(k1, k2);\n                int s = p * k;\n                printf(\"%d %d\\n\", s, s);\n            } else {\n                // s_i not divisible by p\n                int l = rnd.next(1, 1000000000);\n                int r = rnd.next(l, 1000000000);\n                // Adjust l and r\n                int l_mod_p = l % p;\n                if (l_mod_p == 0) l += 1;\n                int r_mod_p = r % p;\n                if (r_mod_p == 0) r -= 1;\n                if (l > r) {\n                    // Adjust to ensure at least one s_i not divisible by p\n                    l = 1;\n                    r = 1000000000;\n                    if (l % p == 0) l += 1;\n                    if (r % p == 0) r -= 1;\n                    if (l > r) {\n                        // Choose s_i = 1\n                        l = 1;\n                        r = 1;\n                    }\n                }\n                printf(\"%d %d\\n\", l, r);\n            }\n        }\n    } else if (type == \"max_range\") {\n        // All li = 1, ri = 1e9\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1000000000\\n\");\n        }\n    } else if (type == \"min_range\") {\n        // All li = ri = 1\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } else if (type == \"edges\") {\n        // li and ri at min and max values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                printf(\"1 1\\n\");\n            } else {\n                printf(\"1000000000 1000000000\\n\");\n            }\n        }\n    }\n    // We can add other types as needed.\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimum n, p = 2, random li ri\n./gen -n 3 -p 2 -type random\n\n# Test case 2: Small n, p = 3, random\n./gen -n 10 -p 3 -type random\n\n# Test case 3: Medium n, p = 17, random\n./gen -n 1000 -p 17 -type random\n\n# Test case 4: Large n, p large, random\n./gen -n 100000 -p 1000000007 -type random\n\n# Test case 5: All s_i == 1\n./gen -n 3 -p 2 -type fixed_s -s 1\n\n# Test case 6: All s_i == p\n./gen -n 5 -p 7 -type fixed_s -s 7\n\n# Test case 7: All s_i divisible by p\n./gen -n 100 -p 3 -type div_p\n\n# Test case 8: All s_i not divisible by p\n./gen -n 100 -p 3 -type not_div_p\n\n# Test case 9: Mixed s_i\n./gen -n 100 -p 2 -type mixed\n\n# Test case 10: Max range\n./gen -n 1000 -p 3 -type max_range\n\n# Test case 11: Min range\n./gen -n 1000 -p 3 -type min_range\n\n# Test case 12: Edge values of li and ri\n./gen -n 1000 -p 3 -type edges\n\n# Test case 13: n maximum, p minimum, type random\n./gen -n 100000 -p 2 -type random\n\n# Test case 14: n maximum, p maximum, type random\n./gen -n 100000 -p 999999937 -type random\n\n# Test case 15: n maximum, p large, s_i divisible by p\n./gen -n 100000 -p 999999937 -type div_p\n\n# Test case 16: n maximum, p small, s_i not divisible by p\n./gen -n 100000 -p 2 -type not_div_p\n\n# Test case 17: n medium, p small, s_i mixed\n./gen -n 5000 -p 5 -type mixed\n\n# Test case 18: n small, p large, s_i fixed\n./gen -n 10 -p 1000000007 -type fixed_s -s 1000000000\n\n# Test case 19: n small, p large, s_i not divisible by p\n./gen -n 10 -p 1000000007 -type not_div_p\n\n# Test case 20: All s_i == 1e9\n./gen -n 1000 -p 2 -type fixed_s -s 1000000000\n\n# Test case 21: n large, p medium, max ranges\n./gen -n 100000 -p 17 -type max_range\n\n# Test case 22: n large, p medium, min ranges\n./gen -n 100000 -p 17 -type min_range\n\n# Test case 23: n large, p medium, edges\n./gen -n 100000 -p 17 -type edges\n\n# Test case 24: n large, p small, s_i divisible by p\n./gen -n 100000 -p 2 -type div_p\n\n# Test case 25: n large, p small, s_i not divisible by p\n./gen -n 100000 -p 2 -type not_div_p\n\n# Test case 26: n medium, p small, s_i mixed\n./gen -n 5000 -p 3 -type mixed\n\n# Test case 27: n small, p small, s_i random\n./gen -n 10 -p 2 -type random\n\n# Test case 28: n minimal, p minimal, s_i fixed\n./gen -n 3 -p 2 -type fixed_s -s 1\n\n# Test case 29: n minimal, p maximal, s_i fixed\n./gen -n 3 -p 999999937 -type fixed_s -s 999999937\n\n# Test case 30: n minimal, p maximal, s_i not divisible by p\n./gen -n 3 -p 999999937 -type not_div_p\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:31.043862",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "621/D",
      "title": "D. Rat Kwesh and Cheese",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains three space-separated real numbers x, y and z (0.1 ≤ x, y, z ≤ 200.0). Each of x, y and z is given with exactly one digit after the decimal point.",
      "output_spec": "OutputFind the maximum value of expression among xyz, xzy, (xy)z, (xz)y, yxz, yzx, (yx)z, (yz)x, zxy, zyx, (zx)y, (zy)x and print the corresponding expression. If there are many maximums, print the one that comes first in the list. xyz should be outputted as x^y^z (without brackets), and (xy)z should be outputted as (x^y)^z (quotes for clarity).",
      "sample_tests": "ExamplesInputCopy1.1 3.4 2.5OutputCopyz^y^xInputCopy2.0 2.0 2.0OutputCopyx^y^zInputCopy1.9 1.8 1.7OutputCopy(x^y)^z",
      "description": "D. Rat Kwesh and Cheese\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input contains three space-separated real numbers x, y and z (0.1 ≤ x, y, z ≤ 200.0). Each of x, y and z is given with exactly one digit after the decimal point.\n\nOutputFind the maximum value of expression among xyz, xzy, (xy)z, (xz)y, yxz, yzx, (yx)z, (yz)x, zxy, zyx, (zx)y, (zy)x and print the corresponding expression. If there are many maximums, print the one that comes first in the list. xyz should be outputted as x^y^z (without brackets), and (xy)z should be outputted as (x^y)^z (quotes for clarity).\n\nInputCopy1.1 3.4 2.5OutputCopyz^y^xInputCopy2.0 2.0 2.0OutputCopyx^y^zInputCopy1.9 1.8 1.7OutputCopy(x^y)^z\n\nInputCopy1.1 3.4 2.5\n\nOutputCopyz^y^x\n\nInputCopy2.0 2.0 2.0\n\nOutputCopyx^y^z\n\nInputCopy1.9 1.8 1.7\n\nOutputCopy(x^y)^z",
      "solutions": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces",
          "content": "621A - Мокрая Акула и чётностьFirst, if the sum of all the numbers is already even, then we do nothing. Otherwise, we remove the smallest odd number. Since, if the sum is odd, we need to remove a number with the same parity to make the sum even. Notice it's always bad to remove more odd numbers, and it does nothing to remove even numbers. 621B - Мокрая Акула и слоныLet's start with two bishops (x1, y1) and (x2, y2). Notice that if (x1, y1) attacks (x2, y2), either x1 + y1 == x2 + y2 OR x1 — y1 == x2 — y2. So, for each bishop (x, y), we will store x + y in one map and x — y in another map.621C - Мокрая Акула и цветыLet f(x) be the probability that the product of the number of flowers of sharks x and is divisible by p.We want the expected value of the number of pairs of neighbouring sharks whose flower numbers are divisible by p. From linearity of expectation, this is equal to the probabilities that each pair multiplies to a number divisible by p, or f(0) + f(1) + ... + f(n). (Don't forget about the wrap-around at n) Now, for each pair of neighbouring sharks, we need to figure out the probability that their product is divisible by p. Consider an interval [li, ri]. How many numbers in this interval are divisible by p? Well, it is easier if we break the interval [li, ri] up into [1, ri] - [1, li - 1]. Since 1, 2, ..., x contains numbers divisible by p, the interval [li, ri] contains numbers divisible by p.Now, consider two numbers and , with . Let ai be the number of integers divisible by p in the interval [li, ri], and define aj similarly. Now what's the probability that fi·fj is divisible by p? We can count the opposite: the probability that fi·fj is not divisible by p. Since p is a prime, this means neither fi nor fj is divisible by p. The number of integers in [li, ri] not divisible by p is ri - li + 1 - ai. Similar for j. Therefore, the probability fi·fj is not divisible by p is given by . Therefore, the probability it is can be given by . Now, just sum over this for all i.621D - Крыса Квеш и сырThe tricky Rat Kwesh has finally made an appearance; it is time to prepare for some tricks. But truly, we didn't expect it to be so hard for competitors though. Especially the part about taking log of a negative number.We need a way to deal with xyz and xyz. We cannot directly compare them, 200200200 is way too big. So what we do? Take log! is an increasing function on positive numbers (we can see this by taking , then , which is positive when we are dealing with positive numbers). So if , then x ≥ y.When we take log, But yz can still be 200200, which is still far too big. So now what can we do? Another log! But is it legal? When x = 0.1 for example, , so we cannot take another log. When can we take another log, however? We need to be a positive number. yz will always be positive, so all we need is for to be positive. This happens when x > 1. So if x, y, z > 1, everything will be ok. There is another good observation to make. If one of x, y, z is greater than 1, then we can always achieve some expression (out of those 12) whose value is greater than 1. But if x < 1, then xa will never be greater than 1. So if at least one of x, y, z is greater than 1, then we can discard those bases that are less than or equal to 1. In this case, . Remember that , so . Similarly, .The last case is when x ≤ 1, y ≤ 1, z ≤ 1. Then, notice that for example, . But the denominator of this fraction is something we recognize, because 10 / 3 > 1. So if all x, y, z < 1, then it is the same as the original problem, except we are looking for the minimum this time.621E - Мокрая Акула и блокиFirst, let us build an X by X matrix. We will be applying matrix exponentiation on this matrix. For each modulo value T from 0 to X — 1, and each value in the array with index i between 1 and n, we will do: matrix[T][(10 * T + arr[i]) % X]++. This is because, notice that for each block we allow one more way to go between a modulo value T, and (10 * T + arr[i]) % X. We are multiplying T by 10 because we are \"left-shifting\" the number in a way (i.e. changing 123 -> 1230), and then adding arr[i] to it. Notice that this basically simulates the concatenation that Wet Shark is conducting, without need of a brute force dp approach.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/23196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 621\\s*D"
          },
          "content_length": 4252
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "E = x[1] * p[1] + x[2] * p[2] + ..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if x[i] = x[i]' + x[i]'' -> p[i] * x[i] = p[i] * x[i]' + p[i] * x[i]''",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string PATTERN = \"(0\\\\.[1-9]|[1-9]\\\\.[0-9]|[1-9][0-9]\\\\.[0-9]|1[0-9][0-9]\\\\.[0-9]|200\\\\.0)\";\n\n    string x_str = inf.readToken(PATTERN, \"x\");\n    inf.readSpace();\n    string y_str = inf.readToken(PATTERN, \"y\");\n    inf.readSpace();\n    string z_str = inf.readToken(PATTERN, \"z\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string PATTERN = \"(0\\\\.[1-9]|[1-9]\\\\.[0-9]|[1-9][0-9]\\\\.[0-9]|1[0-9][0-9]\\\\.[0-9]|200\\\\.0)\";\n\n    string x_str = inf.readToken(PATTERN, \"x\");\n    inf.readSpace();\n    string y_str = inf.readToken(PATTERN, \"y\");\n    inf.readSpace();\n    string z_str = inf.readToken(PATTERN, \"z\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string PATTERN = \"(0\\\\.[1-9]|[1-9]\\\\.[0-9]|[1-9][0-9]\\\\.[0-9]|1[0-9][0-9]\\\\.[0-9]|200\\\\.0)\";\n\n    string x_str = inf.readToken(PATTERN, \"x\");\n    inf.readSpace();\n    string y_str = inf.readToken(PATTERN, \"y\");\n    inf.readSpace();\n    string z_str = inf.readToken(PATTERN, \"z\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    double x, y, z;\n\n    if (type == \"max\") {\n        x = y = z = 200.0;\n    } else if (type == \"min\") {\n        x = y = z = 0.1;\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, 2000);\n        x = y = z = val / 10.0;\n    } else if (type == \"small\") {\n        x = rnd.next(1, 10) / 10.0;\n        y = rnd.next(1, 10) / 10.0;\n        z = rnd.next(1, 10) / 10.0;\n    } else if (type == \"large\") {\n        x = rnd.next(1000, 2000) / 10.0;\n        y = rnd.next(1000, 2000) / 10.0;\n        z = rnd.next(1000, 2000) / 10.0;\n    } else if (type == \"one\") {\n        x = y = z = 1.0;\n    } else if (type == \"specific\") {\n        x = opt<double>(\"x\");\n        y = opt<double>(\"y\");\n        z = opt<double>(\"z\");\n    } else {\n        // Random\n        x = rnd.next(1, 2000) / 10.0;\n        y = rnd.next(1, 2000) / 10.0;\n        z = rnd.next(1, 2000) / 10.0;\n    }\n\n    // Ensure the values have exactly one digit after the decimal point.\n    printf(\"%.1f %.1f %.1f\\n\", x, y, z);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    double x, y, z;\n\n    if (type == \"max\") {\n        x = y = z = 200.0;\n    } else if (type == \"min\") {\n        x = y = z = 0.1;\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, 2000);\n        x = y = z = val / 10.0;\n    } else if (type == \"small\") {\n        x = rnd.next(1, 10) / 10.0;\n        y = rnd.next(1, 10) / 10.0;\n        z = rnd.next(1, 10) / 10.0;\n    } else if (type == \"large\") {\n        x = rnd.next(1000, 2000) / 10.0;\n        y = rnd.next(1000, 2000) / 10.0;\n        z = rnd.next(1000, 2000) / 10.0;\n    } else if (type == \"one\") {\n        x = y = z = 1.0;\n    } else if (type == \"specific\") {\n        x = opt<double>(\"x\");\n        y = opt<double>(\"y\");\n        z = opt<double>(\"z\");\n    } else {\n        // Random\n        x = rnd.next(1, 2000) / 10.0;\n        y = rnd.next(1, 2000) / 10.0;\n        z = rnd.next(1, 2000) / 10.0;\n    }\n\n    // Ensure the values have exactly one digit after the decimal point.\n    printf(\"%.1f %.1f %.1f\\n\", x, y, z);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max\n./gen -type min\n./gen -type equal\n./gen -type small\n./gen -type large\n./gen -type one\n\n./gen -type specific -x 1.0 -y 1.0 -z 1.0\n./gen -type specific -x 2.0 -y 2.0 -z 2.0\n./gen -type specific -x 0.1 -y 0.1 -z 0.1\n./gen -type specific -x 200.0 -y 200.0 -z 200.0\n./gen -type specific -x 0.1 -y 200.0 -z 0.1\n./gen -type specific -x 200.0 -y 0.1 -z 200.0\n./gen -type specific -x 1.0 -y 200.0 -z 1.0\n./gen -type specific -x 1.0 -y 1.0 -z 200.0\n./gen -type specific -x 200.0 -y 1.0 -z 1.0\n./gen -type specific -x 200.0 -y 1.0 -z 200.0\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type equal\n./gen -type equal\n./gen -type equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:33.005132",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "621/E",
      "title": "E. Wet Shark and Blocks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four space-separated integers, n, b, k and x (2 ≤ n ≤ 50 000, 1 ≤ b ≤ 109, 0 ≤ k < x ≤ 100, x ≥ 2) — the number of digits in one block, the number of blocks, interesting remainder modulo x and modulo x itself.The next line contains n space separated integers ai (1 ≤ ai ≤ 9), that give the digits contained in each block.",
      "output_spec": "OutputPrint the number of ways to pick exactly one digit from each blocks, such that the resulting integer equals k modulo x.",
      "sample_tests": "ExamplesInputCopy12 1 5 103 5 6 7 8 9 5 1 1 1 1 5OutputCopy3InputCopy3 2 1 26 2 2OutputCopy0InputCopy3 2 1 23 1 2OutputCopy6",
      "description": "E. Wet Shark and Blocks\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains four space-separated integers, n, b, k and x (2 ≤ n ≤ 50 000, 1 ≤ b ≤ 109, 0 ≤ k < x ≤ 100, x ≥ 2) — the number of digits in one block, the number of blocks, interesting remainder modulo x and modulo x itself.The next line contains n space separated integers ai (1 ≤ ai ≤ 9), that give the digits contained in each block.\n\nOutputPrint the number of ways to pick exactly one digit from each blocks, such that the resulting integer equals k modulo x.\n\nInputCopy12 1 5 103 5 6 7 8 9 5 1 1 1 1 5OutputCopy3InputCopy3 2 1 26 2 2OutputCopy0InputCopy3 2 1 23 1 2OutputCopy6\n\nInputCopy12 1 5 103 5 6 7 8 9 5 1 1 1 1 5\n\nOutputCopy3\n\nInputCopy3 2 1 26 2 2\n\nOutputCopy0\n\nInputCopy3 2 1 23 1 2\n\nOutputCopy6\n\nNoteIn the second sample possible integers are 22, 26, 62 and 66. None of them gives the remainder 1 modulo 2.In the third sample integers 11, 13, 21, 23, 31 and 33 have remainder 1 modulo 2. There is exactly one way to obtain each of these integers, so the total answer is 6.",
      "solutions": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces",
          "content": "621A - Мокрая Акула и чётностьFirst, if the sum of all the numbers is already even, then we do nothing. Otherwise, we remove the smallest odd number. Since, if the sum is odd, we need to remove a number with the same parity to make the sum even. Notice it's always bad to remove more odd numbers, and it does nothing to remove even numbers. 621B - Мокрая Акула и слоныLet's start with two bishops (x1, y1) and (x2, y2). Notice that if (x1, y1) attacks (x2, y2), either x1 + y1 == x2 + y2 OR x1 — y1 == x2 — y2. So, for each bishop (x, y), we will store x + y in one map and x — y in another map.621C - Мокрая Акула и цветыLet f(x) be the probability that the product of the number of flowers of sharks x and is divisible by p.We want the expected value of the number of pairs of neighbouring sharks whose flower numbers are divisible by p. From linearity of expectation, this is equal to the probabilities that each pair multiplies to a number divisible by p, or f(0) + f(1) + ... + f(n). (Don't forget about the wrap-around at n) Now, for each pair of neighbouring sharks, we need to figure out the probability that their product is divisible by p. Consider an interval [li, ri]. How many numbers in this interval are divisible by p? Well, it is easier if we break the interval [li, ri] up into [1, ri] - [1, li - 1]. Since 1, 2, ..., x contains numbers divisible by p, the interval [li, ri] contains numbers divisible by p.Now, consider two numbers and , with . Let ai be the number of integers divisible by p in the interval [li, ri], and define aj similarly. Now what's the probability that fi·fj is divisible by p? We can count the opposite: the probability that fi·fj is not divisible by p. Since p is a prime, this means neither fi nor fj is divisible by p. The number of integers in [li, ri] not divisible by p is ri - li + 1 - ai. Similar for j. Therefore, the probability fi·fj is not divisible by p is given by . Therefore, the probability it is can be given by . Now, just sum over this for all i.621D - Крыса Квеш и сырThe tricky Rat Kwesh has finally made an appearance; it is time to prepare for some tricks. But truly, we didn't expect it to be so hard for competitors though. Especially the part about taking log of a negative number.We need a way to deal with xyz and xyz. We cannot directly compare them, 200200200 is way too big. So what we do? Take log! is an increasing function on positive numbers (we can see this by taking , then , which is positive when we are dealing with positive numbers). So if , then x ≥ y.When we take log, But yz can still be 200200, which is still far too big. So now what can we do? Another log! But is it legal? When x = 0.1 for example, , so we cannot take another log. When can we take another log, however? We need to be a positive number. yz will always be positive, so all we need is for to be positive. This happens when x > 1. So if x, y, z > 1, everything will be ok. There is another good observation to make. If one of x, y, z is greater than 1, then we can always achieve some expression (out of those 12) whose value is greater than 1. But if x < 1, then xa will never be greater than 1. So if at least one of x, y, z is greater than 1, then we can discard those bases that are less than or equal to 1. In this case, . Remember that , so . Similarly, .The last case is when x ≤ 1, y ≤ 1, z ≤ 1. Then, notice that for example, . But the denominator of this fraction is something we recognize, because 10 / 3 > 1. So if all x, y, z < 1, then it is the same as the original problem, except we are looking for the minimum this time.621E - Мокрая Акула и блокиFirst, let us build an X by X matrix. We will be applying matrix exponentiation on this matrix. For each modulo value T from 0 to X — 1, and each value in the array with index i between 1 and n, we will do: matrix[T][(10 * T + arr[i]) % X]++. This is because, notice that for each block we allow one more way to go between a modulo value T, and (10 * T + arr[i]) % X. We are multiplying T by 10 because we are \"left-shifting\" the number in a way (i.e. changing 123 -> 1230), and then adding arr[i] to it. Notice that this basically simulates the concatenation that Wet Shark is conducting, without need of a brute force dp approach.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 621\\s*E"
          },
          "content_length": 4252
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "bool compare (complex x, complex y) {\n  if (imag(x) == 0 and imag(y) == 0) \n    return real(x) > real(y);\n  else if (imag(x) != 0 and imag(y) == 0) \n    return false;\n  else if (imag(x) == 0 and imag(y) != 0) \n    return true;\n  else if (imag(x) != 0 and imag(y) != 0) \n    return real(x) < real(y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "For shark1 -\nint p1 = count of numbers between l and r which are divisible by p\nint n1 = count of numbers between l and r\n\nNow, p1 = r/p - (l-1)/p\n     n1 = r-l+1  \nSimilarly define and calculate p2 and n2\nNow, money is given to both the sharks only when s1*s2 is divisible by p . \nThis is possible in following cases :\n i. s1 & s2 both are divisible by p . Count of such numbers is p1*p2 \n ii. Only s1 is divisible by p . Count of such numbers is p1*(n2-p2)\n iii. Only s2 is divisible by p . Count of such numbers is p2*(n1-p1)\n\nSince, \n i. Count of all the different s1*s2 that can be obtained is n1*n2\n ii.For every number s1*s2 divisible by p each shark get 1000 dollars (2000 total)\nHence, expected money that wet shark gives is\n 2000( p1*p2 + p1*(n2-p2) + p2*(n1-p1) )/(n1*n2) = x (say)\n\nWe calculate this x for the n+1 pairs and add them . This is our final answer . \nHope, it helps.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Arrays.sort(a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if(tot%2==0){\n\tSystem.out.println(tot);\n\treturn;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "E = x[1] * p[1] + x[2] * p[2] + ..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #341 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if x[i] = x[i]' + x[i]'' -> p[i] * x[i] = p[i] * x[i]' + p[i] * x[i]''",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23196",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 100, \"x\");\n    inf.readEoln();\n    ensuref(k < x, \"k must be less than x, but k=%d, x=%d\", k, x);\n    vector<int> a = inf.readInts(n, 1, 9, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 100, \"x\");\n    inf.readEoln();\n    ensuref(k < x, \"k must be less than x, but k=%d, x=%d\", k, x);\n    vector<int> a = inf.readInts(n, 1, 9, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 100, \"x\");\n    inf.readEoln();\n    ensuref(k < x, \"k must be less than x, but k=%d, x=%d\", k, x);\n    vector<int> a = inf.readInts(n, 1, 9, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters.\n\n    int n = opt<int>(\"n\", 50000); // default to max n\n    long long b = opt<long long>(\"b\", 1000000000LL); // default to max b\n    int x = opt<int>(\"x\", 100); // default to max x\n    int k = opt<int>(\"k\", 0); // default to 0\n    string digitsType = opt<string>(\"digitsType\", \"random\");\n    string digitsParam = opt<string>(\"digits\", \"\");\n\n    // Generate the digits a_i (in the block)\n\n    vector<int> digits(n);\n\n    if (digitsType == \"all_same\") {\n        // All digits are the same.\n        int d = opt<int>(\"d\", 1); // default to 1\n        for(int i = 0; i < n; ++i) {\n            digits[i] = d;\n        }\n    } else if (digitsType == \"random\") {\n        // Random digits from 1 to 9\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(1,9);\n        }\n    } else if (digitsType == \"skewed\") {\n        // Mostly one digit, few other digits\n        int dominantDigit = opt<int>(\"dominantDigit\", 1); // default to 1\n        int rareDigit = opt<int>(\"rareDigit\", 9); // default to 9\n\n        int dominantCount = n * 9 / 10; // 90% dominant digit\n        for(int i = 0; i < dominantCount; ++i) {\n            digits[i] = dominantDigit;\n        }\n        for(int i = dominantCount; i < n; ++i) {\n            digits[i] = rareDigit;\n        }\n        // Shuffle the digits\n        shuffle(digits.begin(), digits.end());\n    } else if (digitsType == \"custom\") {\n        // digitsParam should contain the digits separated by commas\n        // For example: \"1,2,3,4,5\"\n        stringstream ss(digitsParam);\n        vector<int> customDigits;\n        string d;\n        while(getline(ss, d, ',')) {\n            customDigits.push_back(atoi(d.c_str()));\n        }\n        // Copy or repeat the custom digits to fill up to n\n        for(int i = 0; i < n; ++i) {\n            digits[i] = customDigits[i % customDigits.size()];\n        }\n    } else if (digitsType == \"max_unique\") {\n        // Use digits from 1 to 9 as equally as possible\n        for(int i = 0; i < n; ++i) {\n            digits[i] = 1 + i % 9;\n        }\n        shuffle(digits.begin(), digits.end());\n    } else {\n        // Default is random\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(1,9);\n        }\n    }\n\n    // Now output the data as per problem statement.\n\n    // First line: n b k x\n    printf(\"%d %lld %d %d\\n\", n, b, k, x);\n\n    // Second line: n space-separated digits\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", digits[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters.\n\n    int n = opt<int>(\"n\", 50000); // default to max n\n    long long b = opt<long long>(\"b\", 1000000000LL); // default to max b\n    int x = opt<int>(\"x\", 100); // default to max x\n    int k = opt<int>(\"k\", 0); // default to 0\n    string digitsType = opt<string>(\"digitsType\", \"random\");\n    string digitsParam = opt<string>(\"digits\", \"\");\n\n    // Generate the digits a_i (in the block)\n\n    vector<int> digits(n);\n\n    if (digitsType == \"all_same\") {\n        // All digits are the same.\n        int d = opt<int>(\"d\", 1); // default to 1\n        for(int i = 0; i < n; ++i) {\n            digits[i] = d;\n        }\n    } else if (digitsType == \"random\") {\n        // Random digits from 1 to 9\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(1,9);\n        }\n    } else if (digitsType == \"skewed\") {\n        // Mostly one digit, few other digits\n        int dominantDigit = opt<int>(\"dominantDigit\", 1); // default to 1\n        int rareDigit = opt<int>(\"rareDigit\", 9); // default to 9\n\n        int dominantCount = n * 9 / 10; // 90% dominant digit\n        for(int i = 0; i < dominantCount; ++i) {\n            digits[i] = dominantDigit;\n        }\n        for(int i = dominantCount; i < n; ++i) {\n            digits[i] = rareDigit;\n        }\n        // Shuffle the digits\n        shuffle(digits.begin(), digits.end());\n    } else if (digitsType == \"custom\") {\n        // digitsParam should contain the digits separated by commas\n        // For example: \"1,2,3,4,5\"\n        stringstream ss(digitsParam);\n        vector<int> customDigits;\n        string d;\n        while(getline(ss, d, ',')) {\n            customDigits.push_back(atoi(d.c_str()));\n        }\n        // Copy or repeat the custom digits to fill up to n\n        for(int i = 0; i < n; ++i) {\n            digits[i] = customDigits[i % customDigits.size()];\n        }\n    } else if (digitsType == \"max_unique\") {\n        // Use digits from 1 to 9 as equally as possible\n        for(int i = 0; i < n; ++i) {\n            digits[i] = 1 + i % 9;\n        }\n        shuffle(digits.begin(), digits.end());\n    } else {\n        // Default is random\n        for(int i = 0; i < n; ++i) {\n            digits[i] = rnd.next(1,9);\n        }\n    }\n\n    // Now output the data as per problem statement.\n\n    // First line: n b k x\n    printf(\"%d %lld %d %d\\n\", n, b, k, x);\n\n    // Second line: n space-separated digits\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", digits[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input size\n./gen -n 2 -b 1 -x 2 -k 0 -digitsType all_same -d 1\n\n# Maximal n, minimal b\n./gen -n 50000 -b 1 -x 100 -k 50 -digitsType random\n\n# Minimal n, maximal b\n./gen -n 2 -b 1000000000 -x 100 -k 0 -digitsType all_same -d 9\n\n# Maximal values\n./gen -n 50000 -b 1000000000 -x 100 -k 99 -digitsType random\n\n# x = 2, k = 1, skewed digits\n./gen -n 50000 -b 1000000 -x 2 -k 1 -digitsType skewed -dominantDigit 1 -rareDigit 2\n\n# x = 100, k = 50, maximum unique digits\n./gen -n 10000 -b 10000 -x 100 -k 50 -digitsType max_unique\n\n# k = 0, all digits same\n./gen -n 1000 -b 1000000000 -x 10 -k 0 -digitsType all_same -d 1\n\n# k = x - 1, random digits\n./gen -n 3000 -b 200000000 -x 20 -k 19 -digitsType random\n\n# Big n and b, all digits are the same\n./gen -n 50000 -b 1000000000 -x 99 -k 0 -digitsType all_same -d 5\n\n# Digits are mostly one digit with a rare digit\n./gen -n 40000 -b 1000000000 -x 50 -k 25 -digitsType skewed -dominantDigit 3 -rareDigit 7\n\n# Digits from 1 to 9\n./gen -n 50000 -b 1000000000 -x 100 -k 40 -digitsType max_unique\n\n# Custom digits\n./gen -n 50000 -b 1000000000 -x 100 -k 0 -digitsType custom -digits 1,1,1,1,1\n\n# Small b, big n\n./gen -n 50000 -b 10 -x 97 -k 47 -digitsType random\n\n# Big b, small n\n./gen -n 10 -b 1000000000 -x 100 -k 23 -digitsType random\n\n# x is prime\n./gen -n 50000 -b 500000000 -x 97 -k 96 -digitsType random\n\n# x is composite\n./gen -n 50000 -b 500000000 -x 100 -k 50 -digitsType random\n\n# b is 1\n./gen -n 10 -b 1 -x 5 -k 2 -digitsType random\n\n# n is minimal\n./gen -n 2 -b 1000000000 -x 100 -k 99 -digitsType random\n\n# All digits 9\n./gen -n 50000 -b 1000000000 -x 100 -k 81 -digitsType all_same -d 9\n\n# Alternate digits\n./gen -n 50000 -b 1000000000 -x 100 -k 50 -digitsType custom -digits 1,2,3,4,5,6,7,8,9\n\n# Digits are 1 and 2 only\n./gen -n 50000 -b 1000000000 -x 99 -k 1 -digitsType skewed -dominantDigit 1 -rareDigit 2\n\n# Edge case: all digits are maximum\n./gen -n 50000 -b 1000000000 -x 100 -k 99 -digitsType all_same -d 9\n\n# Edge case: x and k are maximum\n./gen -n 50000 -b 1000000000 -x 100 -k 99 -digitsType random\n\n# Edge case: x and k are minimum\n./gen -n 50000 -b 1000000000 -x 2 -k 0 -digitsType random\n\n# All digits are minimum\n./gen -n 50000 -b 1000000000 -x 100 -k 0 -digitsType all_same -d 1\n\n# Random digits with digits from 1 to 9\n./gen -n 50000 -b 1000000000 -x 100 -k 50 -digitsType random\n\n# Test with specific digit frequencies\n./gen -n 50000 -b 10000000 -x 100 -k 25 -digitsType custom -digits 1,2,2,3,3,3,4,4,4,4\n\n# Test with x = 2 and k = 1, all digits 1\n./gen -n 50000 -b 1000000000 -x 2 -k 1 -digitsType all_same -d 1\n\n# Test with x = 2 and k = 0, all digits 2\n./gen -n 50000 -b 1000000000 -x 2 -k 0 -digitsType all_same -d 2\n\n# Test with small n and random digits\n./gen -n 100 -b 1000000000 -x 50 -k 10 -digitsType random\n\n# Test with large n and small x\n./gen -n 50000 -b 10000000 -x 2 -k 1 -digitsType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:34.836258",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "622/A",
      "title": "A. Infinite Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains integer n (1 ≤ n ≤ 1014) — the position of the number to find.Note that the given number is too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",
      "output_spec": "OutputPrint the element in the n-th position of the sequence (the elements are numerated from one).",
      "sample_tests": "ExamplesInputCopy3OutputCopy2InputCopy5OutputCopy2InputCopy10OutputCopy4InputCopy55OutputCopy10InputCopy56OutputCopy1",
      "description": "A. Infinite Sequence\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains integer n (1 ≤ n ≤ 1014) — the position of the number to find.Note that the given number is too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\nOutputPrint the element in the n-th position of the sequence (the elements are numerated from one).\n\nInputCopy3OutputCopy2InputCopy5OutputCopy2InputCopy10OutputCopy4InputCopy55OutputCopy10InputCopy56OutputCopy1\n\nOutputCopy2\n\nOutputCopy2\n\nInputCopy10\n\nOutputCopy4\n\nInputCopy55\n\nOutputCopy10\n\nInputCopy56\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 7 will take place on 10 February 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<This paragraph was modified last time>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</This paragraph was modified last time>Thanks a lot to Aleksa Plavsic allllekssssa who suggested the problems D, E and Ivan Popovich NVAL for the problem F. Also thanks to Mohammad Nematollahi Deemo who suggested the problem that was highly simplified and will be under the letter C.The round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A, B and C together. Also thanks to Maria Belova Delinur for checking the English statements, Aleksa Plavsic allllekssssa and Ivan Popovich for testing the problems.We tried to make the problems easy but interesting. I think that the problems is mathematized a little. I hope you will enjoy the problems!Good luck and have fun!P.S.: The Codeforces Educational Rounds was recognized by Snarknews as the best project in competitive programming in 2015 (the picture below is the prize).UPD1: The first phase of the contest is ended. You can hack any other solution.UPD2: The editorial is ready.UPD3: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23358",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1657
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces",
          "content": "622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.С++ solutionComplexity: .622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).Another solution is to use the next formulas as the answer: .C++ solution 1C++ solution 2Complexity: O(a) or O(1).622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.C++ solutionComplexity: O(n).622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.Easy to see that our construction will give zero sum.C++ solutionComplexity: O(n).622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.С++ solutionComplexity: O(nlogn).622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.С++ solutionComplexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 622\\s*A"
          },
          "content_length": 3976
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "if array[i + 1] != ar[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "nextUnequal[i] = i + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "else nextUnequal[i] = nextUnequal[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 4",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 5",
          "code": "2*10^5 * 4 * 6 = 4.8 * 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 6",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 7",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll NMAX = 1e14;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    ll n;\n    if (type == \"start_of_block\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(1LL, k_max);\n        }\n        n = (k*(k-1))/2 +1;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"end_of_block\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(1LL, k_max);\n        }\n        n = (k*(k+1))/2;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"max_number_in_block\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(1LL, k_max);\n        }\n        n = (k*k + k -2)/2;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"special\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(2LL, k_max);\n        }\n        n = (k*(k+1))/2 -1;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"small\") {\n        n = rnd.next(1LL, 1000LL);\n    } else if (type == \"large\") {\n        n = rnd.next(NMAX - 1000LL, NMAX);\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, NMAX);\n    } else {\n        n = rnd.next(1LL, NMAX);\n    }\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll NMAX = 1e14;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    ll n;\n    if (type == \"start_of_block\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(1LL, k_max);\n        }\n        n = (k*(k-1))/2 +1;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"end_of_block\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(1LL, k_max);\n        }\n        n = (k*(k+1))/2;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"max_number_in_block\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(1LL, k_max);\n        }\n        n = (k*k + k -2)/2;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"special\") {\n        ll k = opt<ll>(\"k\", -1);\n        if (k == -1) {\n            ll k_max = sqrt(2.0 * NMAX);\n            k = rnd.next(2LL, k_max);\n        }\n        n = (k*(k+1))/2 -1;\n        if (n < 1 || n > NMAX) n = NMAX;\n    } else if (type == \"small\") {\n        n = rnd.next(1LL, 1000LL);\n    } else if (type == \"large\") {\n        n = rnd.next(NMAX - 1000LL, NMAX);\n    } else if (type == \"random\") {\n        n = rnd.next(1LL, NMAX);\n    } else {\n        n = rnd.next(1LL, NMAX);\n    }\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n\n./gen -type random\n\n./gen -type start_of_block -k 1\n./gen -type start_of_block -k 2\n./gen -type start_of_block -k 1000\n./gen -type start_of_block -k 10000\n./gen -type start_of_block -k 100000\n./gen -type start_of_block -k 1000000\n./gen -type start_of_block -k 10000000\n\n./gen -type end_of_block -k 1\n./gen -type end_of_block -k 2\n./gen -type end_of_block -k 999\n./gen -type end_of_block -k 10000\n./gen -type end_of_block -k 100000\n./gen -type end_of_block -k 1000000\n./gen -type end_of_block -k 10000000\n\n./gen -type max_number_in_block -k 1\n./gen -type max_number_in_block -k 2\n./gen -type max_number_in_block -k 100\n./gen -type max_number_in_block -k 10000\n./gen -type max_number_in_block -k 100000\n./gen -type max_number_in_block -k 1000000\n./gen -type max_number_in_block -k 10000000\n\n./gen -type special -k 2\n./gen -type special -k 50000\n./gen -type special -k 1000000\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type start_of_block\n./gen -type end_of_block\n./gen -type max_number_in_block\n./gen -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:36.937385",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "622/B",
      "title": "B. The Time",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the current time in the format hh:mm (0 ≤ hh < 24, 0 ≤ mm < 60). The hours and the minutes are given with two digits (the hours or the minutes less than 10 are given with the leading zeroes).The second line contains integer a (0 ≤ a ≤ 104) — the number of the minutes passed.",
      "output_spec": "OutputThe only line should contain the time after a minutes in the format described in the input. Note that you should print exactly two digits for the hours and the minutes (add leading zeroes to the numbers if needed).See the examples to check the input/output format.",
      "sample_tests": "ExamplesInputCopy23:5910OutputCopy00:09InputCopy20:20121OutputCopy22:21InputCopy10:100OutputCopy10:10",
      "description": "B. The Time\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains the current time in the format hh:mm (0 ≤ hh < 24, 0 ≤ mm < 60). The hours and the minutes are given with two digits (the hours or the minutes less than 10 are given with the leading zeroes).The second line contains integer a (0 ≤ a ≤ 104) — the number of the minutes passed.\n\nOutputThe only line should contain the time after a minutes in the format described in the input. Note that you should print exactly two digits for the hours and the minutes (add leading zeroes to the numbers if needed).See the examples to check the input/output format.\n\nInputCopy23:5910OutputCopy00:09InputCopy20:20121OutputCopy22:21InputCopy10:100OutputCopy10:10\n\nInputCopy23:5910\n\nOutputCopy00:09\n\nInputCopy20:20121\n\nOutputCopy22:21\n\nInputCopy10:100\n\nOutputCopy10:10",
      "solutions": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 7 will take place on 10 February 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<This paragraph was modified last time>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</This paragraph was modified last time>Thanks a lot to Aleksa Plavsic allllekssssa who suggested the problems D, E and Ivan Popovich NVAL for the problem F. Also thanks to Mohammad Nematollahi Deemo who suggested the problem that was highly simplified and will be under the letter C.The round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A, B and C together. Also thanks to Maria Belova Delinur for checking the English statements, Aleksa Plavsic allllekssssa and Ivan Popovich for testing the problems.We tried to make the problems easy but interesting. I think that the problems is mathematized a little. I hope you will enjoy the problems!Good luck and have fun!P.S.: The Codeforces Educational Rounds was recognized by Snarknews as the best project in competitive programming in 2015 (the picture below is the prize).UPD1: The first phase of the contest is ended. You can hack any other solution.UPD2: The editorial is ready.UPD3: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23358",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1657
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces",
          "content": "622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.С++ solutionComplexity: .622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).Another solution is to use the next formulas as the answer: .C++ solution 1C++ solution 2Complexity: O(a) or O(1).622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.C++ solutionComplexity: O(n).622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.Easy to see that our construction will give zero sum.C++ solutionComplexity: O(n).622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.С++ solutionComplexity: O(nlogn).622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.С++ solutionComplexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 622\\s*B"
          },
          "content_length": 3976
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "if array[i + 1] != ar[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "nextUnequal[i] = i + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "else nextUnequal[i] = nextUnequal[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 4",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 5",
          "code": "2*10^5 * 4 * 6 = 4.8 * 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 6",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 7",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string timeLine = inf.readLine(\"\\\\d\\\\d:\\\\d\\\\d\", \"time\");\n\n    string hh_str = timeLine.substr(0,2);\n    string mm_str = timeLine.substr(3,2);\n\n    int hh = stoi(hh_str);\n    int mm = stoi(mm_str);\n\n    ensuref(hh >= 0 && hh <= 23, \"Hours hh should be between 0 and 23 inclusive, but hh=%d\", hh);\n    ensuref(mm >= 0 && mm <= 59, \"Minutes mm should be between 0 and 59 inclusive, but mm=%d\", mm);\n\n    int a = inf.readInt(0, 10000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string timeLine = inf.readLine(\"\\\\d\\\\d:\\\\d\\\\d\", \"time\");\n\n    string hh_str = timeLine.substr(0,2);\n    string mm_str = timeLine.substr(3,2);\n\n    int hh = stoi(hh_str);\n    int mm = stoi(mm_str);\n\n    ensuref(hh >= 0 && hh <= 23, \"Hours hh should be between 0 and 23 inclusive, but hh=%d\", hh);\n    ensuref(mm >= 0 && mm <= 59, \"Minutes mm should be between 0 and 59 inclusive, but mm=%d\", mm);\n\n    int a = inf.readInt(0, 10000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string timeLine = inf.readLine(\"\\\\d\\\\d:\\\\d\\\\d\", \"time\");\n\n    string hh_str = timeLine.substr(0,2);\n    string mm_str = timeLine.substr(3,2);\n\n    int hh = stoi(hh_str);\n    int mm = stoi(mm_str);\n\n    ensuref(hh >= 0 && hh <= 23, \"Hours hh should be between 0 and 23 inclusive, but hh=%d\", hh);\n    ensuref(mm >= 0 && mm <= 59, \"Minutes mm should be between 0 and 59 inclusive, but mm=%d\", mm);\n\n    int a = inf.readInt(0, 10000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int hh, mm, a;\n\n    if (type == \"random\") {\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = rnd.next(0, 10000);\n    } else if (type == \"over_midnight\") {\n        hh = rnd.next(22, 23); // Start time close to midnight\n        mm = rnd.next(50, 59);\n        int minutes_to_midnight = (24 - hh) * 60 - mm;\n        a = rnd.next(minutes_to_midnight + 1, minutes_to_midnight + 300); // Ensure it goes over midnight\n    } else if (type == \"zero_a\") {\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = 0;\n    } else if (type == \"max_a\") {\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = 10000;\n    } else if (type == \"leading_zero\") {\n        hh = rnd.next(0, 9);\n        mm = rnd.next(0, 9);\n        a = rnd.next(0, 10000);\n    } else if (type == \"edge_case\") {\n        hh = rnd.next(0, 23);\n        mm = 59;\n        a = rnd.next(0, 10000);\n    } else if (type == \"boundary\") {\n        hh = 23;\n        mm = 59;\n        a = rnd.next(1, 10000);\n    } else if (type == \"max_time\") {\n        hh = 23;\n        mm = 59;\n        a = 0;\n    } else if (type == \"min_time\") {\n        hh = 0;\n        mm = 0;\n        a = rnd.next(0, 10000);\n    } else if (type == \"exact_midnight\") {\n        hh = 0;\n        mm = 0;\n        a = 0;\n    } else if (type == \"exact_noon\") {\n        hh = 12;\n        mm = 0;\n        a = rnd.next(0, 10000);\n    } else if (type == \"over_noon\") {\n        hh = rnd.next(11, 12);\n        mm = rnd.next(30, 59);\n        a = rnd.next(30, 200);\n    } else if (type == \"large_a_small_time\") {\n        hh = rnd.next(0, 5);\n        mm = rnd.next(0, 59);\n        a = 10000;\n    } else if (type == \"small_a_large_time\") {\n        hh = rnd.next(20, 23);\n        mm = rnd.next(0, 59);\n        a = rnd.next(0, 5);\n    } else {\n        /* Default to random if unknown type */\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = rnd.next(0, 10000);\n    }\n\n    /* Output the time in hh:mm format with leading zeros */\n    printf(\"%02d:%02d\\n\", hh, mm);\n    printf(\"%d\\n\", a);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int hh, mm, a;\n\n    if (type == \"random\") {\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = rnd.next(0, 10000);\n    } else if (type == \"over_midnight\") {\n        hh = rnd.next(22, 23); // Start time close to midnight\n        mm = rnd.next(50, 59);\n        int minutes_to_midnight = (24 - hh) * 60 - mm;\n        a = rnd.next(minutes_to_midnight + 1, minutes_to_midnight + 300); // Ensure it goes over midnight\n    } else if (type == \"zero_a\") {\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = 0;\n    } else if (type == \"max_a\") {\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = 10000;\n    } else if (type == \"leading_zero\") {\n        hh = rnd.next(0, 9);\n        mm = rnd.next(0, 9);\n        a = rnd.next(0, 10000);\n    } else if (type == \"edge_case\") {\n        hh = rnd.next(0, 23);\n        mm = 59;\n        a = rnd.next(0, 10000);\n    } else if (type == \"boundary\") {\n        hh = 23;\n        mm = 59;\n        a = rnd.next(1, 10000);\n    } else if (type == \"max_time\") {\n        hh = 23;\n        mm = 59;\n        a = 0;\n    } else if (type == \"min_time\") {\n        hh = 0;\n        mm = 0;\n        a = rnd.next(0, 10000);\n    } else if (type == \"exact_midnight\") {\n        hh = 0;\n        mm = 0;\n        a = 0;\n    } else if (type == \"exact_noon\") {\n        hh = 12;\n        mm = 0;\n        a = rnd.next(0, 10000);\n    } else if (type == \"over_noon\") {\n        hh = rnd.next(11, 12);\n        mm = rnd.next(30, 59);\n        a = rnd.next(30, 200);\n    } else if (type == \"large_a_small_time\") {\n        hh = rnd.next(0, 5);\n        mm = rnd.next(0, 59);\n        a = 10000;\n    } else if (type == \"small_a_large_time\") {\n        hh = rnd.next(20, 23);\n        mm = rnd.next(0, 59);\n        a = rnd.next(0, 5);\n    } else {\n        /* Default to random if unknown type */\n        hh = rnd.next(0, 23);\n        mm = rnd.next(0, 59);\n        a = rnd.next(0, 10000);\n    }\n\n    /* Output the time in hh:mm format with leading zeros */\n    printf(\"%02d:%02d\\n\", hh, mm);\n    printf(\"%d\\n\", a);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type over_midnight\n./gen -type over_midnight\n./gen -type zero_a\n./gen -type zero_a\n./gen -type max_a\n./gen -type max_a\n./gen -type leading_zero\n./gen -type leading_zero\n./gen -type edge_case\n./gen -type edge_case\n./gen -type boundary\n./gen -type max_time\n./gen -type min_time\n./gen -type exact_midnight\n./gen -type exact_noon\n./gen -type over_noon\n./gen -type over_noon\n./gen -type large_a_small_time\n./gen -type small_a_large_time\n./gen -type small_a_large_time\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:39.035800",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "622/C",
      "title": "C. Not Equal on a Segment",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 2·105) — the number of elements in a and the number of queries.The second line contains n integers ai (1 ≤ ai ≤ 106) — the elements of the array a.Each of the next m lines contains three integers li, ri, xi (1 ≤ li ≤ ri ≤ n, 1 ≤ xi ≤ 106) — the parameters of the i-th query.",
      "output_spec": "OutputPrint m lines. On the i-th line print integer pi — the position of any number not equal to xi in segment [li, ri] or the value  - 1 if there is no such number.",
      "sample_tests": "ExamplesInputCopy6 41 2 1 1 3 51 4 12 6 23 4 13 4 2OutputCopy26-14",
      "description": "C. Not Equal on a Segment\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 2·105) — the number of elements in a and the number of queries.The second line contains n integers ai (1 ≤ ai ≤ 106) — the elements of the array a.Each of the next m lines contains three integers li, ri, xi (1 ≤ li ≤ ri ≤ n, 1 ≤ xi ≤ 106) — the parameters of the i-th query.\n\nOutputPrint m lines. On the i-th line print integer pi — the position of any number not equal to xi in segment [li, ri] or the value  - 1 if there is no such number.\n\nInputCopy6 41 2 1 1 3 51 4 12 6 23 4 13 4 2OutputCopy26-14\n\nInputCopy6 41 2 1 1 3 51 4 12 6 23 4 13 4 2\n\nOutputCopy26-14",
      "solutions": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 7 will take place on 10 February 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<This paragraph was modified last time>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</This paragraph was modified last time>Thanks a lot to Aleksa Plavsic allllekssssa who suggested the problems D, E and Ivan Popovich NVAL for the problem F. Also thanks to Mohammad Nematollahi Deemo who suggested the problem that was highly simplified and will be under the letter C.The round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A, B and C together. Also thanks to Maria Belova Delinur for checking the English statements, Aleksa Plavsic allllekssssa and Ivan Popovich for testing the problems.We tried to make the problems easy but interesting. I think that the problems is mathematized a little. I hope you will enjoy the problems!Good luck and have fun!P.S.: The Codeforces Educational Rounds was recognized by Snarknews as the best project in competitive programming in 2015 (the picture below is the prize).UPD1: The first phase of the contest is ended. You can hack any other solution.UPD2: The editorial is ready.UPD3: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23358",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1657
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces",
          "content": "622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.С++ solutionComplexity: .622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).Another solution is to use the next formulas as the answer: .C++ solution 1C++ solution 2Complexity: O(a) or O(1).622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.C++ solutionComplexity: O(n).622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.Easy to see that our construction will give zero sum.C++ solutionComplexity: O(n).622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.С++ solutionComplexity: O(nlogn).622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.С++ solutionComplexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 622\\s*C"
          },
          "content_length": 3976
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "if array[i + 1] != ar[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "nextUnequal[i] = i + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "else nextUnequal[i] = nextUnequal[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 4",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 5",
          "code": "2*10^5 * 4 * 6 = 4.8 * 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 6",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 7",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        int x_i = inf.readInt(1, 1000000, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        int x_i = inf.readInt(1, 1000000, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    // Read array a[1..n]\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m queries\n    for (int i = 0; i < m; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        int x_i = inf.readInt(1, 1000000, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n and m\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    // Read the array a[1..n]\n    vector<int> a(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i)\n        a[i] = inf.readInt();\n\n    // Read the queries\n    vector<int> l(m + 1), r(m + 1), x(m + 1);\n    for (int i = 1; i <= m; ++i) {\n        l[i] = inf.readInt();\n        r[i] = inf.readInt();\n        x[i] = inf.readInt();\n    }\n\n    // Process each query\n    for (int i = 1; i <= m; ++i) {\n        int pi = ouf.readInt();\n        if (pi == -1) {\n            // Check that there is no position in [l[i], r[i]] where a[position] != x[i]\n            bool exists = false;\n            int found_pos = -1;\n            for (int pos = l[i]; pos <= r[i]; ++pos) {\n                if (a[pos] != x[i]) {\n                    exists = true;\n                    found_pos = pos;\n                    break;\n                }\n            }\n            if (exists) {\n                quitf(_wa, \"Query %d: Output -1, but position %d exists where a[%d]=%d != x=%d\", i, found_pos, found_pos, a[found_pos], x[i]);\n            }\n        } else {\n            // Check that pi is within [l[i], r[i]]\n            if (pi < l[i] || pi > r[i]) {\n                quitf(_wa, \"Query %d: Output position %d is not in the range [%d, %d]\", i, pi, l[i], r[i]);\n            }\n            // Check that a[pi] != x[i]\n            if (a[pi] == x[i]) {\n                quitf(_wa, \"Query %d: a[%d]=%d equals x=%d\", i, pi, a[pi], x[i]);\n            }\n        }\n    }\n\n    // If all queries are processed without issues\n    quitf(_ok, \"All answers are correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters from arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Build array a of size n\n    vector<int> a(n);\n\n    // Build list of m queries\n    vector<tuple<int, int, int>> queries;\n\n    if (type == \"random\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n); // ensure li <= ri\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"all_equal\") {\n        // Pick a random value\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = val; // xi same as ai\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    } \n    else if (type == \"no_solution\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n\n        // Generate m queries where all elements in [li, ri] equal xi\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(10, n)); // small segments\n            int li = rnd.next(1, n - len + 1);\n            int ri = li + len -1;\n            int xi = rnd.next(1, 1000000);\n\n            // Set a[li-1..ri-1] = xi\n            for (int j = li -1; j < ri; ++j)\n                a[j] = xi;\n\n            // Now generate the query\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"always_solution\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries where there is always at least one ai != xi\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = rnd.next(1, 1000000);\n\n            // Set all ai in [li, ri] to xi\n            for (int j = li -1; j < ri; ++j)\n                a[j] = xi;\n\n            // Change one ai to not equal xi\n            int pos = rnd.next(li -1, ri -1);\n            int other = xi;\n            while (other == xi)\n                other = rnd.next(1, 1000000);\n            a[pos] = other;\n\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"li_eq_ri\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries where li == ri\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = li;\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"full_range\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries where li == 1, ri == n\n        for (int i = 0; i < m; ++i) {\n            int li = 1;\n            int ri = n;\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"duplicates\") {\n        // Generate ai with many duplicates\n        int k = rnd.next(1, 10);\n        vector<int> unique_nums;\n        for (int i = 0; i < k; ++i)\n            unique_nums.push_back(rnd.next(1, 1000000));\n        for (int i = 0; i < n; ++i) {\n            a[i] = unique_nums[rnd.next(0, k -1)];\n        }\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n\n            int xi = unique_nums[rnd.next(0, k -1)];\n\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"max_ai\") {\n        // All ai = 1e6\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000;\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"min_ai\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"all_equal_xi\") {\n        // Generate random a_i\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        int xi_val = rnd.next(1, 1000000);\n\n        // Generate m queries all with xi = xi_val\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = xi_val;\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"mixed\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries, mixing types\n        for (int i = 0; i < m; ++i) {\n            int query_type = rnd.next(1, 5);\n            int li, ri, xi;\n\n            if (query_type == 1) {\n                // Random query\n                li = rnd.next(1, n);\n                ri = rnd.next(li, n);\n                xi = rnd.next(1, 1000000);\n            } else if (query_type == 2) {\n                // li == ri\n                li = rnd.next(1, n);\n                ri = li;\n                xi = rnd.next(1, 1000000);\n            } else if (query_type == 3) {\n                // full range\n                li = 1;\n                ri = n;\n                xi = rnd.next(1, 1000000);\n            } else if (query_type == 4) {\n                // no solution\n                int len = rnd.next(1, min(10, n)); // small segments\n                li = rnd.next(1, n - len + 1);\n                ri = li + len -1;\n                xi = rnd.next(1, 1000000);\n\n                // Set a[li-1..ri-1] = xi\n                for (int j = li -1; j < ri; ++j)\n                    a[j] = xi;\n            } else {\n                // always solution: ensure there is at least one ai != xi\n                li = rnd.next(1, n);\n                ri = rnd.next(li, n);\n                xi = rnd.next(1, 1000000);\n\n                // Set all ai in [li, ri] to xi\n                for (int j = li -1; j < ri; ++j)\n                    a[j] = xi;\n\n                // Change one ai to not equal xi\n                int pos = rnd.next(li -1, ri -1);\n                int other = xi;\n                while (other == xi)\n                    other = rnd.next(1, 1000000);\n                a[pos] = other;\n            }\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else {\n        // Default to random if type is unrecognized\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n); // ensure li <= ri\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int li, ri, xi;\n        std::tie(li, ri, xi) = queries[i];\n        printf(\"%d %d %d\\n\", li, ri, xi);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters from arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Build array a of size n\n    vector<int> a(n);\n\n    // Build list of m queries\n    vector<tuple<int, int, int>> queries;\n\n    if (type == \"random\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n); // ensure li <= ri\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"all_equal\") {\n        // Pick a random value\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = val; // xi same as ai\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    } \n    else if (type == \"no_solution\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n\n        // Generate m queries where all elements in [li, ri] equal xi\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(10, n)); // small segments\n            int li = rnd.next(1, n - len + 1);\n            int ri = li + len -1;\n            int xi = rnd.next(1, 1000000);\n\n            // Set a[li-1..ri-1] = xi\n            for (int j = li -1; j < ri; ++j)\n                a[j] = xi;\n\n            // Now generate the query\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"always_solution\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries where there is always at least one ai != xi\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = rnd.next(1, 1000000);\n\n            // Set all ai in [li, ri] to xi\n            for (int j = li -1; j < ri; ++j)\n                a[j] = xi;\n\n            // Change one ai to not equal xi\n            int pos = rnd.next(li -1, ri -1);\n            int other = xi;\n            while (other == xi)\n                other = rnd.next(1, 1000000);\n            a[pos] = other;\n\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"li_eq_ri\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries where li == ri\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = li;\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"full_range\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries where li == 1, ri == n\n        for (int i = 0; i < m; ++i) {\n            int li = 1;\n            int ri = n;\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"duplicates\") {\n        // Generate ai with many duplicates\n        int k = rnd.next(1, 10);\n        vector<int> unique_nums;\n        for (int i = 0; i < k; ++i)\n            unique_nums.push_back(rnd.next(1, 1000000));\n        for (int i = 0; i < n; ++i) {\n            a[i] = unique_nums[rnd.next(0, k -1)];\n        }\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n\n            int xi = unique_nums[rnd.next(0, k -1)];\n\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"max_ai\") {\n        // All ai = 1e6\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000;\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"min_ai\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"all_equal_xi\") {\n        // Generate random a_i\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        int xi_val = rnd.next(1, 1000000);\n\n        // Generate m queries all with xi = xi_val\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n);\n            int xi = xi_val;\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else if (type == \"mixed\") {\n        // Generate random ai\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000);\n\n        // Generate m queries, mixing types\n        for (int i = 0; i < m; ++i) {\n            int query_type = rnd.next(1, 5);\n            int li, ri, xi;\n\n            if (query_type == 1) {\n                // Random query\n                li = rnd.next(1, n);\n                ri = rnd.next(li, n);\n                xi = rnd.next(1, 1000000);\n            } else if (query_type == 2) {\n                // li == ri\n                li = rnd.next(1, n);\n                ri = li;\n                xi = rnd.next(1, 1000000);\n            } else if (query_type == 3) {\n                // full range\n                li = 1;\n                ri = n;\n                xi = rnd.next(1, 1000000);\n            } else if (query_type == 4) {\n                // no solution\n                int len = rnd.next(1, min(10, n)); // small segments\n                li = rnd.next(1, n - len + 1);\n                ri = li + len -1;\n                xi = rnd.next(1, 1000000);\n\n                // Set a[li-1..ri-1] = xi\n                for (int j = li -1; j < ri; ++j)\n                    a[j] = xi;\n            } else {\n                // always solution: ensure there is at least one ai != xi\n                li = rnd.next(1, n);\n                ri = rnd.next(li, n);\n                xi = rnd.next(1, 1000000);\n\n                // Set all ai in [li, ri] to xi\n                for (int j = li -1; j < ri; ++j)\n                    a[j] = xi;\n\n                // Change one ai to not equal xi\n                int pos = rnd.next(li -1, ri -1);\n                int other = xi;\n                while (other == xi)\n                    other = rnd.next(1, 1000000);\n                a[pos] = other;\n            }\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n    else {\n        // Default to random if type is unrecognized\n        // Generate random ai\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n\n        // Generate m random queries\n        for (int i = 0; i < m; ++i) {\n            int li = rnd.next(1, n);\n            int ri = rnd.next(li, n); // ensure li <= ri\n            int xi = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(li, ri, xi));\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int li, ri, xi;\n        std::tie(li, ri, xi) = queries[i];\n        printf(\"%d %d %d\\n\", li, ri, xi);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 100000 -type random\n./gen -n 200000 -m 200000 -type random\n\n./gen -n 5 -m 5 -type all_equal\n./gen -n 1000 -m 1000 -type all_equal\n./gen -n 200000 -m 200000 -type all_equal\n\n./gen -n 200000 -m 200000 -type no_solution\n\n./gen -n 200000 -m 200000 -type always_solution\n\n./gen -n 200000 -m 200000 -type duplicates\n\n./gen -n 200000 -m 200000 -type max_ai\n\n./gen -n 200000 -m 200000 -type min_ai\n\n./gen -n 200000 -m 200000 -type li_eq_ri\n\n./gen -n 200000 -m 200000 -type full_range\n\n./gen -n 200000 -m 200000 -type all_equal_xi\n\n./gen -n 2 -m 1 -type random\n\n./gen -n 1 -m 1 -type random\n\n./gen -n 200000 -m 1 -type random\n\n./gen -n 1 -m 200000 -type random\n\n./gen -n 123456 -m 123456 -type random\n\n./gen -n 65432 -m 65432 -type duplicates\n\n./gen -n 99999 -m 99999 -type li_eq_ri\n\n./gen -n 100000 -m 100000 -type full_range\n\n./gen -n 100000 -m 100000 -type no_solution\n\n./gen -n 100000 -m 100000 -type always_solution\n\n./gen -n 100000 -m 100000 -type min_ai\n\n./gen -n 100000 -m 100000 -type max_ai\n\n./gen -n 200000 -m 200000 -type mixed\n\n./gen -n 100000 -m 100000 -type mixed\n\n./gen -n 50000 -m 50000 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:41.072820",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "622/D",
      "title": "D. Optimal Number Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains integer n (1 ≤ n ≤ 5·105).",
      "output_spec": "OutputPrint 2n integers — the permuted array a that minimizes the value of the sum s.",
      "sample_tests": "ExamplesInputCopy2OutputCopy1 1 2 2InputCopy1OutputCopy1 1",
      "description": "D. Optimal Number Permutation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains integer n (1 ≤ n ≤ 5·105).\n\nOutputPrint 2n integers — the permuted array a that minimizes the value of the sum s.\n\nInputCopy2OutputCopy1 1 2 2InputCopy1OutputCopy1 1\n\nOutputCopy1 1 2 2\n\nOutputCopy1 1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 7 will take place on 10 February 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<This paragraph was modified last time>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</This paragraph was modified last time>Thanks a lot to Aleksa Plavsic allllekssssa who suggested the problems D, E and Ivan Popovich NVAL for the problem F. Also thanks to Mohammad Nematollahi Deemo who suggested the problem that was highly simplified and will be under the letter C.The round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A, B and C together. Also thanks to Maria Belova Delinur for checking the English statements, Aleksa Plavsic allllekssssa and Ivan Popovich for testing the problems.We tried to make the problems easy but interesting. I think that the problems is mathematized a little. I hope you will enjoy the problems!Good luck and have fun!P.S.: The Codeforces Educational Rounds was recognized by Snarknews as the best project in competitive programming in 2015 (the picture below is the prize).UPD1: The first phase of the contest is ended. You can hack any other solution.UPD2: The editorial is ready.UPD3: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23358",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1657
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces",
          "content": "622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.С++ solutionComplexity: .622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).Another solution is to use the next formulas as the answer: .C++ solution 1C++ solution 2Complexity: O(a) or O(1).622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.C++ solutionComplexity: O(n).622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.Easy to see that our construction will give zero sum.C++ solutionComplexity: O(n).622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.С++ solutionComplexity: O(nlogn).622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.С++ solutionComplexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 622\\s*D"
          },
          "content_length": 3976
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "if array[i + 1] != ar[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "nextUnequal[i] = i + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "else nextUnequal[i] = nextUnequal[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 4",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 5",
          "code": "2*10^5 * 4 * 6 = 4.8 * 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 6",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 7",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long readAns(InStream& stream, int n) {\n    vector<int> positions[n + 1]; // positions[1..n]\n    // read 2n integers\n    for (int i = 0; i < 2 * n; ++i) {\n        int x = stream.readInt(1, n, format(\"a[%d]\", i + 1).c_str());\n        positions[x].push_back(i);\n        if (positions[x].size() > 2) {\n            stream.quitf(_wa, \"number %d appears more than twice\", x);\n        }\n    }\n    // check that each number from 1 to n appears exactly twice\n    for (int i = 1; i <= n; ++i) {\n        if (positions[i].size() != 2) {\n            stream.quitf(_wa, \"number %d does not appear exactly twice\", i);\n        }\n    }\n    // compute s\n    long long s = 0;\n    for (int i = 1; i <= n; ++i) {\n        int xi = positions[i][0];\n        int yi = positions[i][1];\n        if (xi >= yi) {\n            stream.quitf(_wa, \"number %d appears at positions %d and %d, which are not in increasing order\", i, xi + 1, yi + 1);\n        }\n        int di = yi - xi;\n        s += (long long) di * di;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n\n    long long jans = readAns(ans, n);\n    long long pans = readAns(ouf, n);\n\n    if (pans > jans)\n        quitf(_wa, \"participant's answer is worse: participant's s = %lld, jury's s = %lld\", pans, jans);\n    else if (pans == jans)\n        quitf(_ok, \"answer is correct with s = %lld\", pans);\n    else\n        quitf(_fail, \"participant has better answer: participant's s = %lld, jury's s = %lld\", pans, jans);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    ensure(1 <= n && n <= 500000); // Ensure n is within the problem constraints.\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    ensure(1 <= n && n <= 500000); // Ensure n is within the problem constraints.\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case with minimum n\n./gen -n 1\n\n# Small n values\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n\n# Medium n values\n./gen -n 50\n./gen -n 100\n./gen -n 200\n./gen -n 500\n./gen -n 1000\n\n# Powers of two\n./gen -n 16\n./gen -n 32\n./gen -n 64\n./gen -n 128\n./gen -n 256\n./gen -n 512\n./gen -n 1024\n./gen -n 2048\n./gen -n 4096\n./gen -n 8192\n./gen -n 16384\n./gen -n 32768\n./gen -n 65536\n./gen -n 131072\n./gen -n 262144\n\n# Large n values\n./gen -n 300000\n./gen -n 400000\n./gen -n 450000\n./gen -n 499999\n./gen -n 500000\n\n# Random large n values\n./gen -n 123456\n./gen -n 234567\n./gen -n 345678\n./gen -n 456789\n\n# Edge cases\n./gen -n 1\n./gen -n 499999\n./gen -n 500000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:43.051821",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "622/E",
      "title": "E. Ants in Leaves",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 5·105) — the number of vertices in the tree.Each of the next n - 1 lines contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the ends of the i-th edge. It is guaranteed that you are given the correct undirected tree.",
      "output_spec": "OutputPrint the only integer t — the minimal time required for all ants to be in the root of the tree.",
      "sample_tests": "ExamplesInputCopy121 21 31 42 52 63 73 83 98 108 118 12OutputCopy6InputCopy22 1OutputCopy1",
      "description": "E. Ants in Leaves\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (2 ≤ n ≤ 5·105) — the number of vertices in the tree.Each of the next n - 1 lines contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the ends of the i-th edge. It is guaranteed that you are given the correct undirected tree.\n\nOutputPrint the only integer t — the minimal time required for all ants to be in the root of the tree.\n\nInputCopy121 21 31 42 52 63 73 83 98 108 118 12OutputCopy6InputCopy22 1OutputCopy1\n\nInputCopy121 21 31 42 52 63 73 83 98 108 118 12\n\nOutputCopy6\n\nInputCopy22 1\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 7 will take place on 10 February 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<This paragraph was modified last time>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</This paragraph was modified last time>Thanks a lot to Aleksa Plavsic allllekssssa who suggested the problems D, E and Ivan Popovich NVAL for the problem F. Also thanks to Mohammad Nematollahi Deemo who suggested the problem that was highly simplified and will be under the letter C.The round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A, B and C together. Also thanks to Maria Belova Delinur for checking the English statements, Aleksa Plavsic allllekssssa and Ivan Popovich for testing the problems.We tried to make the problems easy but interesting. I think that the problems is mathematized a little. I hope you will enjoy the problems!Good luck and have fun!P.S.: The Codeforces Educational Rounds was recognized by Snarknews as the best project in competitive programming in 2015 (the picture below is the prize).UPD1: The first phase of the contest is ended. You can hack any other solution.UPD2: The editorial is ready.UPD3: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23358",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1657
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces",
          "content": "622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.С++ solutionComplexity: .622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).Another solution is to use the next formulas as the answer: .C++ solution 1C++ solution 2Complexity: O(a) or O(1).622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.C++ solutionComplexity: O(n).622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.Easy to see that our construction will give zero sum.C++ solutionComplexity: O(n).622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.С++ solutionComplexity: O(nlogn).622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.С++ solutionComplexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 622\\s*E"
          },
          "content_length": 3976
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "if array[i + 1] != ar[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "nextUnequal[i] = i + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "else nextUnequal[i] = nextUnequal[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 4",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 5",
          "code": "2*10^5 * 4 * 6 = 4.8 * 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 6",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 7",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    vector<vector<int>> adj(n+1); // 1-based indexing\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Self-loops are not allowed (edge from %d to %d)\", xi, yi);\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n        ensuref(edges.count({u,v}) == 0, \"Multiple edges between %d and %d\", u, v);\n        edges.insert({u,v});\n        adj[xi].push_back(yi);\n        adj[yi].push_back(xi);\n    }\n\n    vector<bool> visited(n+1, false);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        cnt++;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n    dfs(1);\n    ensuref(cnt == n, \"Graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    vector<vector<int>> adj(n+1); // 1-based indexing\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Self-loops are not allowed (edge from %d to %d)\", xi, yi);\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n        ensuref(edges.count({u,v}) == 0, \"Multiple edges between %d and %d\", u, v);\n        edges.insert({u,v});\n        adj[xi].push_back(yi);\n        adj[yi].push_back(xi);\n    }\n\n    vector<bool> visited(n+1, false);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        cnt++;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n    dfs(1);\n    ensuref(cnt == n, \"Graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    vector<vector<int>> adj(n+1); // 1-based indexing\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Self-loops are not allowed (edge from %d to %d)\", xi, yi);\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n        ensuref(edges.count({u,v}) == 0, \"Multiple edges between %d and %d\", u, v);\n        edges.insert({u,v});\n        adj[xi].push_back(yi);\n        adj[yi].push_back(xi);\n    }\n\n    vector<bool> visited(n+1, false);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        cnt++;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n    dfs(1);\n    ensuref(cnt == n, \"Graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> parent(n + 1);  // Parent of each node (1-based indexing)\n\n    if (type == \"chain\") {\n        // Chain: node i connected to i-1\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        // Star: everyone connected to root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (type == \"complete_binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n        }\n    } else if (type == \"skewed_binary\") {\n        // Skewed binary tree (like a chain but with some branches)\n        for (int i = 2; i <= n; ++i) {\n            if (i % 2 == 0)\n                parent[i] = i / 2;\n            else\n                parent[i] = i - 1;\n        }\n    } else if (type == \"bottleneck\") {\n        // All nodes connected to a single bottleneck node except root\n        int bottleneck_node = opt<int>(\"bottleneck_node\", 2);\n        if (bottleneck_node == 1) bottleneck_node = 2;  // bottleneck cannot be root\n        parent[bottleneck_node] = 1;  // bottleneck connected to root\n        for (int i = 2; i <= n; ++i) {\n            if (i == bottleneck_node) continue;\n            parent[i] = bottleneck_node;\n        }\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    } else if (type == \"bushy\") {\n        // Bushy tree: A tree with lots of nodes at low depth\n        int branching = opt<int>(\"branching\", 10);\n        queue<int> q;\n        q.push(1);\n        int idx = 2;\n        while (idx <= n && !q.empty()) {\n            int u = q.front();\n            q.pop();\n            int num_children = min(branching, n - idx + 1);\n            for (int i = 0; i < num_children; ++i) {\n                parent[idx] = u;\n                q.push(idx);\n                idx++;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Now output the tree\n    printf(\"%d\\n\", n);\n\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = parent[i];\n        if (rnd.next(0, 1)) swap(u, v);  // Randomly swap edges\n        edges.push_back({u, v});\n    }\n\n    // Optional: Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> parent(n + 1);  // Parent of each node (1-based indexing)\n\n    if (type == \"chain\") {\n        // Chain: node i connected to i-1\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        // Star: everyone connected to root\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (type == \"complete_binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n        }\n    } else if (type == \"skewed_binary\") {\n        // Skewed binary tree (like a chain but with some branches)\n        for (int i = 2; i <= n; ++i) {\n            if (i % 2 == 0)\n                parent[i] = i / 2;\n            else\n                parent[i] = i - 1;\n        }\n    } else if (type == \"bottleneck\") {\n        // All nodes connected to a single bottleneck node except root\n        int bottleneck_node = opt<int>(\"bottleneck_node\", 2);\n        if (bottleneck_node == 1) bottleneck_node = 2;  // bottleneck cannot be root\n        parent[bottleneck_node] = 1;  // bottleneck connected to root\n        for (int i = 2; i <= n; ++i) {\n            if (i == bottleneck_node) continue;\n            parent[i] = bottleneck_node;\n        }\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    } else if (type == \"bushy\") {\n        // Bushy tree: A tree with lots of nodes at low depth\n        int branching = opt<int>(\"branching\", 10);\n        queue<int> q;\n        q.push(1);\n        int idx = 2;\n        while (idx <= n && !q.empty()) {\n            int u = q.front();\n            q.pop();\n            int num_children = min(branching, n - idx + 1);\n            for (int i = 0; i < num_children; ++i) {\n                parent[idx] = u;\n                q.push(idx);\n                idx++;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Now output the tree\n    printf(\"%d\\n\", n);\n\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = parent[i];\n        if (rnd.next(0, 1)) swap(u, v);  // Randomly swap edges\n        edges.push_back({u, v});\n    }\n\n    // Optional: Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type bottleneck\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n./gen -n 10 -type complete_binary\n./gen -n 10 -type skewed_binary\n./gen -n 10 -type bushy -branching 3\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type bottleneck\n./gen -n 100 -type complete_binary\n./gen -n 100 -type skewed_binary\n./gen -n 100 -type bushy -branching 10\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type random\n./gen -n 1000 -type complete_binary\n./gen -n 1000 -type bottleneck -bottleneck_node 500\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type random\n./gen -n 10000 -type complete_binary\n./gen -n 10000 -type skewed_binary\n./gen -n 10000 -type bushy -branching 100\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type random\n./gen -n 100000 -type bottleneck -bottleneck_node 50000\n./gen -n 100000 -type bushy -branching 1000\n\n./gen -n 500000 -type chain\n./gen -n 500000 -type star\n./gen -n 500000 -type random\n./gen -n 500000 -type complete_binary\n./gen -n 500000 -type skewed_binary\n./gen -n 500000 -type bottleneck -bottleneck_node 250000\n./gen -n 500000 -type bushy -branching 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:45.371329",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "622/F",
      "title": "F. The Sum of the k-th Powers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains two integers n, k (1 ≤ n ≤ 109, 0 ≤ k ≤ 106).",
      "output_spec": "OutputPrint the only integer a — the remainder after dividing the value of the sum by the value 109 + 7.",
      "sample_tests": "ExamplesInputCopy4 1OutputCopy10InputCopy4 2OutputCopy30InputCopy4 3OutputCopy100InputCopy4 0OutputCopy4",
      "description": "F. The Sum of the k-th Powers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains two integers n, k (1 ≤ n ≤ 109, 0 ≤ k ≤ 106).\n\nOutputPrint the only integer a — the remainder after dividing the value of the sum by the value 109 + 7.\n\nInputCopy4 1OutputCopy10InputCopy4 2OutputCopy30InputCopy4 3OutputCopy100InputCopy4 0OutputCopy4\n\nInputCopy4 1\n\nOutputCopy10\n\nInputCopy4 2\n\nOutputCopy30\n\nInputCopy4 3\n\nOutputCopy100\n\nInputCopy4 0\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 7 will take place on 10 February 2016 at 18:00 MSK for the first and second divisions. You can read about educational rounds here and here.<This paragraph was modified last time>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.</This paragraph was modified last time>Thanks a lot to Aleksa Plavsic allllekssssa who suggested the problems D, E and Ivan Popovich NVAL for the problem F. Also thanks to Mohammad Nematollahi Deemo who suggested the problem that was highly simplified and will be under the letter C.The round was prepared by me, Edvard Davtyan. Thanks a lot to MikeMirzayanov we invented the problems A, B and C together. Also thanks to Maria Belova Delinur for checking the English statements, Aleksa Plavsic allllekssssa and Ivan Popovich for testing the problems.We tried to make the problems easy but interesting. I think that the problems is mathematized a little. I hope you will enjoy the problems!Good luck and have fun!P.S.: The Codeforces Educational Rounds was recognized by Snarknews as the best project in competitive programming in 2015 (the picture below is the prize).UPD1: The first phase of the contest is ended. You can hack any other solution.UPD2: The editorial is ready.UPD3: The round is over, the results is final.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23358",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1657
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces",
          "content": "622A - Infinite SequenceLet's decrease n by one. Now let's determine the block with the n-th number. To do that let's at first subtract 1 from n, then subtract 2, then subtract 3 and so on until we got negative n. The number of subtractions will be the number of the block and the position in the block will be the last nonnegative number we will get.С++ solutionComplexity: .622B - The TimeIn this problem we can simply increase a times the current time by one minute (after each increasing we should check the hours and the minutes for overflow).Another solution is to use the next formulas as the answer: .C++ solution 1C++ solution 2Complexity: O(a) or O(1).622C - Not Equal on a SegmentThis problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo.This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values pi — the position of the first element to the left from the i-th element such that ai ≠ api. Now to answer to the query we should check if ar ≠ x then we have the answer. Otherwise we should check the position pr.C++ solutionComplexity: O(n).622D - Optimal Number PermutationThis problem was suggested by Aleksa Plavsic allllekssssa.Let's build the answer with the sum equal to zero. Let n be even. Let's place odd numbers in the first half of the array: the number 1 in the positions 1 and n, the number 3 in the positions 2 and n - 1 and so on. Similarly let's place even numbers in the second half: the number 2 in the position n + 1 and 2n - 1, the number 4 in the positions n + 2 and 2n - 2 and so on. We can place the number n in the leftover positions. We can build the answer for odd n in a similar way.Easy to see that our construction will give zero sum.C++ solutionComplexity: O(n).622E - Ants in LeavesThis problem was suggested by Aleksa Plavsic allllekssssa.Easy to see that the answer is equal to the answer over all sons of the root plus one. Now let's solve the problem independently for each son v of the root. Let z be the array of the depths of all leaves in the subtree of the vertex v. Let's sort z. Statement 1: it's profitable to lift the leaves in order of their appearing in z. Statement 2: denote ax — the time of appearing the x-th leaf in the vertex v, let's consider the leaves zi and zi + 1 then azi + 1 ≥ azi + 1. Statement 3: azi + 1 = max(dzi + 1, azi + 1), where dx is the depth of the x-th leaf in the subtree of the vertex v. The last statement gives us the solution for the problem: we should simply iterate over z from left to right and recalculate the array a by formula from the third statement. All statements can be easily proved and it's recommended to do by yourself to understand better the idea of the solution.С++ solutionComplexity: O(nlogn).622F - The Sum of the k-th PowersThis problem was suggested by Ivan Popovich NVAL.Statement: the function of the sum is a polynomial of degree k + 1 over variable n. This statement can be proved by induction (to make step you should take the derivative).Denote Px the value of the sum for n = x. We can easily calculate the values of Px for x from 0 to k + 1 in O(klogk) time. If n < k + 2 then we already have the answer. Otherwise let's use Lagrange polynomial to get the value of the sum for the given value n.The Largange polynomial have the following form: . In our case xi = i - 1 and yi = Pxi.To calculate P(n) in a linear time we should use that xi + 1 - xi = xj + 1 - xj for all i, j < n. It's help us because with that property we can recalculate the inner product for i + 1 from the inner product for i simply by multiplying by two values and dividing by two values. So we can calculate the sum in linear time over k.С++ solutionComplexity: O(klog MOD) (logk appeared because we should find the inverse element in the field modulo MOD = 109 + 7).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23442",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 622\\s*F"
          },
          "content_length": 3976
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "if array[i + 1] != ar[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "nextUnequal[i] = i + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "else nextUnequal[i] = nextUnequal[i + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23358",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 1",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 2",
          "code": "cin >> n >> m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 3",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 4",
          "code": "for(long long int i=0;i<n;i++) //input and preprocessing\n{\n    cin >> a[i];\n    if(i!=0 && a[i]==a[i-1]) first_on_left[i]=first_on_left[i-1];\n    else if(i!=0) first_on_left[i]=i-1;\n    else if(i==0) first_on_left[i]=-1;\n}\n\nfor(long long int i=0;i<m;i++) //query\n{\n    cin >> l >> r >> x;\n    if(a[r-1]!=x) cout << r << endl;\n    else if(first_on_left[r-1]>=l-1) cout << first_on_left[r-1]+1 << endl;\n    else cout << -1 << endl;\n}\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 5",
          "code": "2*10^5 * 4 * 6 = 4.8 * 10^6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 6",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 7 - Codeforces - Code 7",
          "code": "/**\n * @author asif.hossain\n * @since 2/14/16\n */\npublic class P622C {\n    public static Scanner sc = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int[] numbers = new int[n + 1];\n        int[] mappings = new int[n + 1];\n        \n        numbers[0] = -1;\n        mappings[0] = -1;\n        int leftPos = 0;\n        for (int i = 1; i <= n; i++) {\n            numbers[i] = sc.nextInt();\n            if (numbers[i] != numbers[i-1]) {\n                leftPos = i;\n            }\n            mappings[i] = leftPos;\n        }\n        for (int i = 1; i <= m; i++) {\n            int l = sc.nextInt();\n            int r = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (numbers[r] != x) {\n                System.out.println(r);\n            }\n            else if (l < mappings[r]) {\n                System.out.println(mappings[r] - 1);\n            } \n            else {\n                System.out.println(-1);\n                \n            }\n            \n        }\n\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/23442",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1LL);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        k = 0;\n    } else if (type == \"max\") {\n        n = 1000000000LL;\n        k = 1000000;\n    } else if (type == \"small_n\") {\n        n = rnd.next(1LL, 1000LL);\n        k = rnd.next(1, 1000000);\n    } else if (type == \"small_k\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = rnd.next(0, 10);\n    } else if (type == \"k_zero\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = 0;\n    } else if (type == \"n_one\") {\n        n = 1;\n        k = rnd.next(0, 1000000);\n    } else if (type == \"n_max\") {\n        n = 1000000000LL;\n        k = rnd.next(0, 1000000);\n    } else if (type == \"k_max\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = 1000000;\n    } else { // random or if specify n and k\n        if (n == -1)\n            n = rnd.next(1LL, 1000000000LL);\n        if (k == -1)\n            k = rnd.next(0, 1000000);\n    }\n\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1LL);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n        k = 0;\n    } else if (type == \"max\") {\n        n = 1000000000LL;\n        k = 1000000;\n    } else if (type == \"small_n\") {\n        n = rnd.next(1LL, 1000LL);\n        k = rnd.next(1, 1000000);\n    } else if (type == \"small_k\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = rnd.next(0, 10);\n    } else if (type == \"k_zero\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = 0;\n    } else if (type == \"n_one\") {\n        n = 1;\n        k = rnd.next(0, 1000000);\n    } else if (type == \"n_max\") {\n        n = 1000000000LL;\n        k = rnd.next(0, 1000000);\n    } else if (type == \"k_max\") {\n        n = rnd.next(1LL, 1000000000LL);\n        k = 1000000;\n    } else { // random or if specify n and k\n        if (n == -1)\n            n = rnd.next(1LL, 1000000000LL);\n        if (k == -1)\n            k = rnd.next(0, 1000000);\n    }\n\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max\n\n./gen -type n_one\n\n./gen -type k_zero\n\n./gen -type small_n\n\n./gen -type small_n\n\n./gen -type small_k\n\n./gen -type small_k\n\n./gen -type n_max\n\n./gen -type k_max\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -n 1000000000 -k 0\n\n./gen -n 1000000000 -k 1\n\n./gen -n 1 -k 1000000\n\n./gen -n 1 -k 0\n\n./gen -n 1 -k 1\n\n./gen -n 999999999 -k 999999\n\n./gen -n 2 -k 1000000\n\n./gen -n 1000000000 -k 1000000\n\n./gen -n 1000000000 -k 999999\n\n./gen -n 500000000 -k 500000\n\n./gen -n 1000000000 -k 10\n\n./gen -n 100000000 -k 1000000\n\n./gen -n 10 -k 1000000\n\n./gen -n 1000000000 -k 0\n\n./gen -n 999999999 -k 0\n\n./gen -n 1 -k 100\n\n./gen -n 2 -k 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:47.107491",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "623/A",
      "title": "A. Граф и строка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны два числа n и m  — количество вершин и рёбер в графе, обнаруженном Петей.В следующих m строках заданы по два целых числа ui и vi (1 ≤ ui, vi ≤ n, ui ≠ vi), задающие рёбра графа. Гарантируется, что граф не содержит кратных рёбер, то есть любая пара вершин встречается в списке рёбер не более одного раза.",
      "output_spec": "Выходные данныеВ первой строке выведите «Yes» (без кавычек), если искомая строка существует, и «No» (без кавычек) в противном случае.Если искомая строка s существует, то выведите её во второй строке. Длина s должна в точности равняться n, все буквы должны быть «a», «b» или «c», а построенный по этой строке граф должен совпадать с заданным во входных данных. Если существует несколько возможных ответов, то разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 11 2Выходные данныеСкопироватьYesaaВходные данныеСкопировать4 31 21 31 4Выходные данныеСкопироватьNo",
      "description": "A. Граф и строка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны два числа n и m  — количество вершин и рёбер в графе, обнаруженном Петей.В следующих m строках заданы по два целых числа ui и vi (1 ≤ ui, vi ≤ n, ui ≠ vi), задающие рёбра графа. Гарантируется, что граф не содержит кратных рёбер, то есть любая пара вершин встречается в списке рёбер не более одного раза.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите «Yes» (без кавычек), если искомая строка существует, и «No» (без кавычек) в противном случае.Если искомая строка s существует, то выведите её во второй строке. Длина s должна в точности равняться n, все буквы должны быть «a», «b» или «c», а построенный по этой строке граф должен совпадать с заданным во входных данных. Если существует несколько возможных ответов, то разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать2 11 2Выходные данныеСкопироватьYesaaВходные данныеСкопировать4 31 21 31 4Выходные данныеСкопироватьNo\n\nВходные данныеСкопировать2 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYesaa\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 31 21 31 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере дан граф из двух вершин, между которыми проведено ребро. Значит, эти вершины могут соответствовать как одинаковым буквам, так и соседним. Этому графу удовлетворяет любая из строк «aa», «ab», «ba», «bb», «bc», «cb» и «cc».Во втором примере первая вершина соединена со всеми остальными тремя вершинами, но эти три вершины не соединены между собой. Это значит, что они должны соответствовать различным буквам, не являющимся соседними, а это невозможно.",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Привет, Codeforces!4 февраля, в четверг, в 20:05 MSK состоится AIM Tech Codeforces Round.Раунд подготовили для вас сотрудники компании AIM Tech: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov и zeliboba. Раунд пройдет во время Петрозаводских сборов, спонсорами которых наша компания стала в этом году.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Мы постарались сделать задачи проще, чем в прошлый наш раунд, но не менее интересными. Окончательная разбалловка будет опубликована прямо перед раундом, но сразу сообщу, что сложности задач C,D,E первого дивизиона отличаются меньше обычного, поэтому рекомендуем сначала прочитать их все. Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Глеба Евстропова (GlebsHP) и Марию Белову (Delinur) за перевод условий на английский.Наша компания занимается проп-трейдингом, ключевыми понятиями в нашей работе являются big data, low latency и high frequency. В нашей работе важно алгоритмическое мышление и умение писать эффективный C++ код, поэтому у нас работает много спортивных программистов. Чтобы придумывать hft-стратегии нужно обладать хорошей математической интуицией и умением подходить к задаче с разных сторон, поэтому их созданием в нашей компании занимаются в основном олимпиадники-математики. В свободное от работы время мы участвуем в разных соревнованиях по программированию и не только, вместе ходим в походы и путешествуем. Прочитать подробнее про нас и наши вакансии можно на сайте aimtech.com. Можно отправить нам резюме через эту форму, даже если вы не участвуете в раунде.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в пятницу 5 февраля в 19.30 вечера будет организован фуршет в Пауланер Бройхаус.Разбалловкаdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250РазборP.P.S. Авторское решение div2A имело погрешность 5e-7, поэтому мы решили пореджаджить эту задачу.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2046
        },
        {
          "title": "Разбор AIM Tech Round - Codeforces",
          "content": "624A - Спасти ЛюкаЗа единицу времени ширина полосы уменьшается на v1 + v2. Это значит, что она уменьшится от L до d за . Тот момент, когда ширина стала равна d — последний, когда Люк еще живет, значит t — это ответ.624B - Составить строкуОтсортируем кол-ва букв по невозрастанию.Очередную букву берем столько раз, сколько можно, но строго меньше, чем предыдущую. Не забываем, что если предыдущая буква не взята вообще, то все следующие тоже взяты не будут.623A - Граф и строкаЗаметим, что вершины \"b\" связаны со всеми остальными вершинами в графе. Найдём все подобные вершины и отметим их символом \"b\". После этого найдём любую непомеченную вершину V, пометим её символом \"a\". Все непомеченные вершины, которые связаны с V, тоже должны быть помечены символом \"a\". Все остальные непомеченные вершины в графе отметим символом \"c\".Теперь нужно проверить корректность графа, т.е. убедиться, что все вершины \"a\" связаны только между собой и с вершинами \"b\". Аналогично проверим все вершины \"c\".623B - НОД массиваХотя бы один из концов (a1 или an) изменится не больше, чем на 1. А это значит, что если gcd будет не равен 1, то он будет делиться на один из простых делителей одного из чисел a1 - 1, a1, a1 + 1, an - 1, an, an + 1. Переберём это простое.Пусть фиксировано простое p, тогда для каждого числа мы знаем, что оно, либо уже делится на p, либо его можно поправить за b, либо оно должно входить в массив-результат.После этого, можно запустить динамику dp[кол-во чисел, которое рассмотрели][отрезок для изменения за a еще не начался/начался/закончился] = минимальная стоимостьИтоговая сложность O(Nd) = O(NlogN), где d — количество простых делителей для перебора623C - Электрические зарядыРассмотрим сперва отдельно случаи, когда все точки спроецированы на одну ось (Тогда ответ — разница между максимумом и минимумом по одной из координат)Далее, рассмотрим самую левую и самую правую точку из тех, что спроецированы на ось x. Пусть их координаты xL и xR. Заметим, что все точки с координатами xL ≤ x ≤ xR также можно спроецировать на ось x, это не увеличит диаметр. Таким образом, если отсортировать точки по x-координате, можно считать, что точки спроецированные на ось x образуют подотрезок (непрерывный подмассив).Запустим бинарный поиск, теперь нам нужно проверять, что можно спроецировать точки так, что диаметр <= M.Зафиксируем самую дальнюю от 0 по x-координате точку, которая в итоге будет спроецированной на ось x. Она может быть слева или справа от нуля. Случаи будут симметричны, для примера рассмотрим случай, когда эта точка меньше 0. Пусть ее координата равна xL < 0. Заметим, что все точки, для которых 0 ≤ x - xL ≤ M и |x| ≤ |xL| можно спроецировать на ось x и от этого диаметр не увеличится, а все оставшиеся нужно спроецировать на ось y. Среди оставшихся точек нужно найти минимум и максимум по y координате и тогда ответ \"можно\", если расстояние между этими точками не превосходит M и расстояние от них до (xL, 0) не превосходит M.Теперь предподсчитаем минимум и максимум y координат на префиксе и суффиксе все точек. Будем перебирать левую границу отрезка точек спроецированных на x, а правую будем искать бинпоиском или поддерживать методом двух указателей.Таким образом одна проверка работает за O(M) или , и общая сложность или .623D - День РожденияОбозначим qi = 1 - pi.Идея решения: сначала нужно назвать каждого друга хотя бы по разу, потом на каждом шаге максимизируем вероятность закончить игру не позже, чем на данном шаге. Моделируем 300000 шагов, считая по ходу дела сумму . , где ki — количество раз, когда мы называли i-го друга ().Заметим, что матожидание с небольшой погрешностью равно при достаточно большом N (это легко видеть, раскрыв скобки в приведенном выше выражении). Поэтому нам достаточно доказать, что 1) Приведенная выше жадная стратегия дает максимальные значения всех Pr(t). 2) На 300000 шаге погрешность меньше 10 - 6.Доказательство:1) Предположим, что для какого-то t набор li (), отличный от полученного жадным алгоритмом набора ki, дает наибольшее значение Pr(t). Возьмем какое-нибудь ka < la и kb > lb (такие найдутся, если наборы не совпадают, а их суммы равны t), тогда легко показать, что если в наборе li заменить lb на lb + 1, la на la - 1, то будет достигнуто еще большее значение Pr(t), что противоречит предположению о максимальности набора li.2) Заметим, что qi ≤ 0.99. Возьмем набор ki такой, что для всех i выполняется , он даст вероятность завершения игры за t шагов не большую, чем оптимальный набор. Тогда Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Погрешность оценки не превосходит , что оценивается, как сумма геометрической прогрессии, и при N ≥ 300000 получим погрешность меньше 10 - 7.623E - Преобразование последовательности Для начала заметим, что если последовательность префиксных ксоров строго возрастает, то на каждом шаге ai имеет хотя бы один новый бит по сравнению с предыдущими элементами. Так как битов всего k, длина последовательности не может быть больше k. Поэтому если n > k, то ответ 0. Решим сначала задачу за O(k3). Посчитаем dp[n][k] — количество последовательностей длины n таких, что a1|a2|... |an имеет ровно k битов. Переход — добавить l новых битов и выбрать произвольно значения k битов, которые уже вошли в префиксный ксор. Значит, dp[n + 1][k + l] должно быть увеличено на dp[n][k]·2k·Ck + ll. Биномиальный коэффициент соответствует выбору добавляемых l битов из k + l, которые будут представлены в a1|a2|... |an + 1.Заметим, что переход не зависит от n, поэтому попробуем применить идею бинарного возведения в степень. Пусть мы хотим слить динамики dp1[k], dp2[k], где k — количество битов в a1|a2|... |aleft и b1|... |bright соответственно. Хотим посчитать dp[k] для массивов размера left + right. Формула получается такая: Здесь l соответствует битам в ксоре левой части, и для каждого числа из правой части эти l битов можно выбрать произвольно. Перепишем формулу так: Значит, мы можем посчитать dp[k] для всех k, перемножив многочлены и . Коэффициенты первого получаются из коэффициентов второго за . Значит, мы можем посчитать динамику для всех длин — степеней двойки за , используя быстрое преобразование Фурье. На самом деле, удобнее насчитывать , используя то же самое равенство. Далее, используя ту же стратегию слияния, можно найти ответ для данного n, используя динамику для степеней двойки. Получили решение за .Мы решили попросить ответ по модулю 109 + 7, чтобы участники не смогли легко догадаться, что это задача на FFT :) Поэтому для получения ОК нужно было реализовать один из методов перемножения многочленов по большому модулю с использованием FFT. Другой подход состоял в применении алгоритма Карацубы, наша его реализация не укладывалась в ТЛ, однако jqdai0815 каким-то образом смог заставить свое решение с Карацубой пройти :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 623\\s*A"
          },
          "content_length": 6760
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "сложности задач C,D,E отличаются меньше обычного",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 4",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 5",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 6",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(ui != vi, \"Self-loops are not allowed: u_i (%d) == v_i (%d)\", ui, vi);\n\n        int a = min(ui, vi);\n        int b = max(ui, vi);\n\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", a, b);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(ui != vi, \"Self-loops are not allowed: u_i (%d) == v_i (%d)\", ui, vi);\n\n        int a = min(ui, vi);\n        int b = max(ui, vi);\n\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", a, b);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(ui != vi, \"Self-loops are not allowed: u_i (%d) == v_i (%d)\", ui, vi);\n\n        int a = min(ui, vi);\n        int b = max(ui, vi);\n\n        pair<int, int> edge = make_pair(a, b);\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", a, b);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nset<pair<int,int>> G;\n\nset<pair<int,int>> constructGraph(const string &s)\n{\n    set<pair<int,int>> Gp;\n    for(int i = 0; i < n; ++i)\n        for(int j = i+1; j < n; ++j)\n        {\n            if(s[i] == s[j] || abs(s[i]-s[j]) == 1)\n            {\n                int u = i + 1;\n                int v = j + 1;\n                if(u > v) swap(u, v);\n                Gp.insert(make_pair(u, v));\n            }\n        }\n    return Gp;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    m = inf.readInt();\n    for(int i = 0; i < m; ++i)\n    {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        if(u > v) swap(u, v);\n        G.insert(make_pair(u, v));\n    }\n\n    string jans = ans.readToken();\n    string pans = ouf.readToken();\n\n    // Convert to lower case\n    transform(jans.begin(), jans.end(), jans.begin(), ::tolower);\n    transform(pans.begin(), pans.end(), pans.begin(), ::tolower);\n\n    if(jans != \"yes\" && jans != \"no\")\n    {\n        // Jury's answer is invalid\n        quitf(_fail, \"Jury's answer is neither 'Yes' nor 'No'\");\n    }\n    if(pans != \"yes\" && pans != \"no\")\n    {\n        // Participant's answer is invalid\n        quitf(_wa, \"Participant didn't output 'Yes' or 'No'\");\n    }\n\n    if(jans == \"no\")\n    {\n        if(pans == \"no\")\n        {\n            quitf(_ok, \"Correct: 'No'\");\n        }\n        else // pans == \"yes\"\n        {\n            // Read s from participant\n            string s = ouf.readToken();\n\n            if((int)s.size() != n)\n                quitf(_wa, \"Participant's string length is incorrect: expected %d, got %d\", n, (int)s.size());\n\n            for(char c : s)\n            {\n                if(c != 'a' && c != 'b' && c != 'c')\n                    quitf(_wa, \"Participant's string contains invalid character '%c'\", c);\n            }\n\n            // Construct G' from s\n            set<pair<int,int>> Gp = constructGraph(s);\n\n            if(Gp == G)\n            {\n                // Participant found a valid s, but jury's answer is \"No\"\n                quitf(_fail, \"Participant found a solution, but jury's answer is 'No'\");\n            }\n            else\n            {\n                // Participant's s is invalid\n                quitf(_wa, \"Participant's string does not produce the correct graph\");\n            }\n        }\n    }\n    else // jans == \"yes\"\n    {\n        if(pans == \"no\")\n        {\n            quitf(_wa, \"Participant output 'No', but a solution exists\");\n        }\n        else // pans == \"yes\"\n        {\n            // Read s from participant\n            string s = ouf.readToken();\n\n            if((int)s.size() != n)\n                quitf(_wa, \"Participant's string length is incorrect: expected %d, got %d\", n, (int)s.size());\n\n            for(char c : s)\n            {\n                if(c != 'a' && c != 'b' && c != 'c')\n                    quitf(_wa, \"Participant's string contains invalid character '%c'\", c);\n            }\n\n            // Construct G' from s\n            set<pair<int,int>> Gp = constructGraph(s);\n\n            if(Gp == G)\n            {\n                quitf(_ok, \"Correct solution\");\n            }\n            else\n            {\n                quitf(_wa, \"Participant's string does not produce the correct graph\");\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_yes\");\n\n    if (type == \"random_yes\") {\n        // Generate a random string s of length n\n        string s(n, ' ');\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(3); // 'a', 'b', or 'c'\n        }\n\n        // Build the graph G according to s\n        vector<int> letter_groups[3]; // 0: 'a', 1: 'b', 2: 'c'\n        for (int i = 0; i < n; ++i) {\n            letter_groups[s[i] - 'a'].push_back(i);\n        }\n\n        vector<pair<int, int>> edges;\n\n        // Edges between same letters ('a'-'a', 'b'-'b', 'c'-'c')\n        for (int l = 0; l < 3; ++l) {\n            int sz = letter_groups[l].size();\n            int max_edges = min(sz * (sz - 1) / 2, n); // Limit edges to n per group\n            set<pair<int, int>> used;\n            for (int e = 0; e < max_edges; ++e) {\n                int u = rnd.next(sz);\n                int v = rnd.next(sz);\n                if (u == v) continue;\n                int a = letter_groups[l][u];\n                int b = letter_groups[l][v];\n                if (a > b) swap(a, b);\n                if (used.count({a, b})) continue;\n                used.insert({a, b});\n                edges.push_back({a + 1, b + 1});\n            }\n        }\n        // Edges between 'a'-'b' and 'b'-'c' letters\n        vector<pair<int, int>> pairs;\n        // 'a'-'b' edges\n        int sz_a = letter_groups[0].size();\n        int sz_b = letter_groups[1].size();\n        for (int i = 0; i < sz_a; ++i) {\n            for (int j = 0; j < sz_b; ++j) {\n                pairs.push_back({letter_groups[0][i], letter_groups[1][j]});\n            }\n        }\n        // 'b'-'c' edges\n        int sz_c = letter_groups[2].size();\n        for (int i = 0; i < sz_b; ++i) {\n            for (int j = 0; j < sz_c; ++j) {\n                pairs.push_back({letter_groups[1][i], letter_groups[2][j]});\n            }\n        }\n        // Shuffle and pick up to n edges\n        shuffle(pairs.begin(), pairs.end());\n        int max_edges = min((int)pairs.size(), n);\n        set<pair<int, int>> used;\n        for (int e = 0, idx = 0; e < max_edges && idx < pairs.size(); ++idx) {\n            int a = pairs[idx].first;\n            int b = pairs[idx].second;\n            if (a > b) swap(a, b);\n            if (used.count({a, b})) continue;\n            used.insert({a, b});\n            edges.push_back({a + 1, b + 1});\n            e++;\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"star_no\") {\n        // Generate a star graph that is impossible to assign letters to\n        // Create one central vertex connected to n - 1 leaves\n        // For n >= 4, this will be impossible\n        vector<pair<int, int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"star_yes\") {\n        // Generate a star graph that is possible to assign letters to\n        // Create one central vertex connected to two leaves\n        // For n = 3, this will be possible\n        if (n < 3) {\n            printf(\"%d %d\\n\", n, 0);\n            return 0;\n        }\n        vector<pair<int, int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Connect leaves 2 and 3 to make it possible\n        edges.push_back({2, 3});\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain (path) graph\n        vector<pair<int, int>> edges;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"complete\") {\n        // Generate a complete graph\n        vector<pair<int, int>> edges;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"random_no\") {\n        // Generate a random graph that is impossible to assign letters to\n        // Create a star graph with more than 2 leaves and add edges to create contradictions\n        // For this example, we can create several stars connected in a way that makes it impossible\n        if (n < 4) {\n            n = 4;\n        }\n        vector<pair<int, int>> edges;\n        edges.push_back({1, 2});\n        edges.push_back({1, 3});\n        edges.push_back({1, 4});\n        edges.push_back({2, 3});\n        edges.push_back({3, 4});\n        edges.push_back({2, 4});\n        // Add random edges\n        for (int i = 5; i <= n; ++i) {\n            edges.push_back({1, i});\n            edges.push_back({2, i});\n            edges.push_back({3, i});\n            edges.push_back({4, i});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else {\n        // Default case: output empty graph\n        printf(\"%d 0\\n\", n);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_yes\");\n\n    if (type == \"random_yes\") {\n        // Generate a random string s of length n\n        string s(n, ' ');\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(3); // 'a', 'b', or 'c'\n        }\n\n        // Build the graph G according to s\n        vector<int> letter_groups[3]; // 0: 'a', 1: 'b', 2: 'c'\n        for (int i = 0; i < n; ++i) {\n            letter_groups[s[i] - 'a'].push_back(i);\n        }\n\n        vector<pair<int, int>> edges;\n\n        // Edges between same letters ('a'-'a', 'b'-'b', 'c'-'c')\n        for (int l = 0; l < 3; ++l) {\n            int sz = letter_groups[l].size();\n            int max_edges = min(sz * (sz - 1) / 2, n); // Limit edges to n per group\n            set<pair<int, int>> used;\n            for (int e = 0; e < max_edges; ++e) {\n                int u = rnd.next(sz);\n                int v = rnd.next(sz);\n                if (u == v) continue;\n                int a = letter_groups[l][u];\n                int b = letter_groups[l][v];\n                if (a > b) swap(a, b);\n                if (used.count({a, b})) continue;\n                used.insert({a, b});\n                edges.push_back({a + 1, b + 1});\n            }\n        }\n        // Edges between 'a'-'b' and 'b'-'c' letters\n        vector<pair<int, int>> pairs;\n        // 'a'-'b' edges\n        int sz_a = letter_groups[0].size();\n        int sz_b = letter_groups[1].size();\n        for (int i = 0; i < sz_a; ++i) {\n            for (int j = 0; j < sz_b; ++j) {\n                pairs.push_back({letter_groups[0][i], letter_groups[1][j]});\n            }\n        }\n        // 'b'-'c' edges\n        int sz_c = letter_groups[2].size();\n        for (int i = 0; i < sz_b; ++i) {\n            for (int j = 0; j < sz_c; ++j) {\n                pairs.push_back({letter_groups[1][i], letter_groups[2][j]});\n            }\n        }\n        // Shuffle and pick up to n edges\n        shuffle(pairs.begin(), pairs.end());\n        int max_edges = min((int)pairs.size(), n);\n        set<pair<int, int>> used;\n        for (int e = 0, idx = 0; e < max_edges && idx < pairs.size(); ++idx) {\n            int a = pairs[idx].first;\n            int b = pairs[idx].second;\n            if (a > b) swap(a, b);\n            if (used.count({a, b})) continue;\n            used.insert({a, b});\n            edges.push_back({a + 1, b + 1});\n            e++;\n        }\n\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"star_no\") {\n        // Generate a star graph that is impossible to assign letters to\n        // Create one central vertex connected to n - 1 leaves\n        // For n >= 4, this will be impossible\n        vector<pair<int, int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"star_yes\") {\n        // Generate a star graph that is possible to assign letters to\n        // Create one central vertex connected to two leaves\n        // For n = 3, this will be possible\n        if (n < 3) {\n            printf(\"%d %d\\n\", n, 0);\n            return 0;\n        }\n        vector<pair<int, int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Connect leaves 2 and 3 to make it possible\n        edges.push_back({2, 3});\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain (path) graph\n        vector<pair<int, int>> edges;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"complete\") {\n        // Generate a complete graph\n        vector<pair<int, int>> edges;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"random_no\") {\n        // Generate a random graph that is impossible to assign letters to\n        // Create a star graph with more than 2 leaves and add edges to create contradictions\n        // For this example, we can create several stars connected in a way that makes it impossible\n        if (n < 4) {\n            n = 4;\n        }\n        vector<pair<int, int>> edges;\n        edges.push_back({1, 2});\n        edges.push_back({1, 3});\n        edges.push_back({1, 4});\n        edges.push_back({2, 3});\n        edges.push_back({3, 4});\n        edges.push_back({2, 4});\n        // Add random edges\n        for (int i = 5; i <= n; ++i) {\n            edges.push_back({1, i});\n            edges.push_back({2, i});\n            edges.push_back({3, i});\n            edges.push_back({4, i});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        // Output edges\n        for (auto& e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else {\n        // Default case: output empty graph\n        printf(\"%d 0\\n\", n);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random_yes\n./gen -n 5 -type star_no\n./gen -n 5 -type star_yes\n./gen -n 5 -type chain\n./gen -n 5 -type complete\n./gen -n 5 -type random_no\n\n./gen -n 10 -type random_yes\n./gen -n 10 -type star_no\n./gen -n 10 -type star_yes\n./gen -n 10 -type chain\n./gen -n 10 -type complete\n./gen -n 10 -type random_no\n\n./gen -n 50 -type random_yes\n./gen -n 50 -type star_no\n./gen -n 50 -type star_yes\n./gen -n 50 -type chain\n./gen -n 50 -type random_no\n\n./gen -n 1000 -type random_yes\n./gen -n 1000 -type chain\n./gen -n 1000 -type random_no\n\n./gen -n 5000 -type random_yes\n./gen -n 5000 -type chain\n\n./gen -n 10000 -type random_yes\n./gen -n 10000 -type chain\n\n./gen -n 100000 -type random_yes\n./gen -n 100000 -type chain\n\n# Edge case with minimum n\n./gen -n 1 -type random_yes\n\n# Edge case with maximum n\n./gen -n 100000 -type star_no\n\n# Test with default type\n./gen -n 100\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:49.459356",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "623/B",
      "title": "B. Array GCD",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n, a and b (1 ≤ n ≤ 1 000 000, 0 ≤ a, b ≤ 109) — the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively.The second line contains n integers ai (2 ≤ ai ≤ 109) — elements of the array.",
      "output_spec": "OutputPrint a single number — the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.",
      "sample_tests": "ExamplesInputCopy3 1 44 2 3OutputCopy1InputCopy5 3 25 17 13 5 6OutputCopy8InputCopy8 3 43 7 5 4 3 12 9 4OutputCopy13",
      "description": "B. Array GCD\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers n, a and b (1 ≤ n ≤ 1 000 000, 0 ≤ a, b ≤ 109) — the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively.The second line contains n integers ai (2 ≤ ai ≤ 109) — elements of the array.\n\nOutputPrint a single number — the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.\n\nInputCopy3 1 44 2 3OutputCopy1InputCopy5 3 25 17 13 5 6OutputCopy8InputCopy8 3 43 7 5 4 3 12 9 4OutputCopy13\n\nInputCopy3 1 44 2 3\n\nOutputCopy1\n\nInputCopy5 3 25 17 13 5 6\n\nOutputCopy8\n\nInputCopy8 3 43 7 5 4 3 12 9 4\n\nOutputCopy13\n\nNoteIn the first sample the optimal way is to remove number 3 and pay 1 coin for it.In the second sample you need to remove a segment [17, 13] and then decrease number 6. The cost of these changes is equal to 2·3 + 2 = 8 coins.",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Hi, Codeforces!AIM Tech Codeforces Round will take place on February, 4 at 20:05 MSK.The round is prepared by AIM Tech employees: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov and zeliboba. Round will take place during Petrozavodsk Winter Camp, which is sponsored by our company.We made our problems a little easier than at our last Round, but we promise they won’t be less interesting. Scoring system will be static. The final distribution of points will be announced right before the round, however you should note that this time difference in complexity between problems div1 C, D and E may be less than usual so our strong recommendation that you read them all first.Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Gleb Evstropov (GlebsHP) and Maria Belova (Delinur) for English translation.Our company specialises in proprietary trading, the key concepts in our work are big data, low latency and high frequency. Our team mainly consists of graduates from the MSU Faculty of Mechanics and Mathematics and Moscow Institute of Physics and Technology (MIPT).We wish you good luck and high frequency rating!P.S. For all participants of PTZ gathering we are glad to announce evening buffet that will take place at Paulaner Brauhaus and will start Februrary, 5 at 7:30 pmScoringdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250EditorialP.P.S. Author solution of div2A had precision error 5e-7, so we decided to rejudge this problem.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1544
        },
        {
          "title": "AIM Tech Round Tutorial - Codeforces",
          "content": "624A - Save LukeWidth of free space is decreasing by v1 + v2 per second. It means that it'll decrease from L to d in seconds. The moment when width gets a value of d is the last when Luke is alive so t is the answer. 624B - Making a StringSort array in descending order.Iterate over all letters, First letter is added c1 = a1 times, each other letter is added ci = min(ai, ci - 1). Don't forget that if some letter is not added at all, then all next letters are not added too.623A - Graph and String Note that all vertices \"b\" are connected with all other vertices in the graph. Find all such vertices and mark them as \"b\". Now we need to find any unlabeled vertex V, mark it with \"a\" character. Unlabeled vertices connected with V should be also labeled as \"a\". All other vertices we can label as \"c\"Finally we need to check graph validity. Check that all vertices \"a\" are only connected with each other and \"b\" vertices. After that we need to perform a similar check for \"c\" vertices.623B - Array GCDAt least one of ends (a1 or an) is changed by at most 1. It means that if gcd > 1 then it divides on of prime divisors of either a1 - 1, a1, a1 + 1, an - 1, an or an + 1. We will iterate over these primes.Suppose prime p is fixed. For each number we know that it's either divisible by p or we can pay b to fix it or it should be in the subarray to change for aWe can use dynamic programming dp[number of numbers considered][subarray to change not started/started/finished] = minimal costComplexity is O(Nd) = O(Nlog(max(ai)), where d is the number of primes to check.623C - Electric ChargesFirst of all consider cases where all points are projected to the same axis. (In that case answer is difference between maximum and minimum of this coordinate).Now consider leftmost and rightmost points among projected to x axis. Let xL and xR are their x-coordinates. Notice that points with x-coordinate xL ≤ x ≤ xR may also be projected to x-axis and that will not increase the diameter. So, if we sort all points by x-coordinate, we may suppose that points projected to x-axis form a continuous subarray.We will use a binary search. Now we will need to check if it's possible to project point in a such way that diameter is <= M.Let's fix the most distant by x-coordinate point from 0 that is projected to x-axis. It may be to the left or to the right of 0. This cases are symmetrical and we will consider only the former one. Let xL < 0 be its coordinate. Notice that one may project all points such that 0 ≤ x - xL ≤ M and |x| ≤ |xL| to the x axis (and it'll not affect the diameter) and we have to project other points to y-axis. Among all other points we should find the maximum and minimum by y coordinate. Answer is \"yes (diam ≤ M)\" if ymax - ymin <  = M and distance from (xL, 0) to both (0, ymax) and (0, ymin) is not greater than M.Let's precalculate maximums and minimums of y coordinates on each prefix and suffix of original (sorted) points array. Now iterate over left border of subarray of points projected to x-axis and find the right border using binary search or maintain it using two-pointers technique.So we've got one check in O(M) or and entire solution in or 623D - BirthdayLet's denote qi = 1 - pi.Main idea: first of all guess each friend once, then maximize probability to end game on current step. Let's simulate first 300000 steps, and calculate . , where ki — how many times we called i-th friend ().Expectation with some precision equals . So it is enough to prove that:1) Greedy strategy gives maximum values for all Pr(t). 2) On 300000 step precision error will be less than 10 - 6.Proof:1) Suppose, that for some t there exists set li (), not equal to set produced by greedy algorithm ki, gives the maximum value of Pr(t). Let's take some ka < la and kb > lb, it is easy to prove tgat if we change lb to lb + 1, la to la - 1, then new set of li gives bigger value of Pr(t), contradiction.2) qi ≤ 0.99. Let's take set , it gives probability of end of the game not less than optimal. Then Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Precision error does not exceed . It could be estimated as sum of geometric progression. If N ≥ 300000 precision error doesn't exceed 10 - 7.623E - Transforming SequenceFirst observation is that if the sequence of prefix xors is strictly increasing, than on each step ai has at least one new bit comparing to the previous elements. So, since there are overall k bits, the length of the sequence can't be more than k. So, if n > k, the answer is 0. Let's firstly solve the task with O(k3) complexity. We calculate dp[n][k] — the number of sequences of length n such that a1|a2|... |an has k bits. The transition is to add a number with l new bits, and choose those k bits which are already in the prefix xor arbitrarily. So, dp[n + 1][k + l] is increased by dp[n][k]·2k·Ck + ll. The last binomial coefficient complies with the choice these very l bits from k + l which will be present in a1|a2|... |an + 1.Note now that the transition doesn't depend on n, so let's try to use the idea of the binary exponentiation. Suppose we want to merge two dynamics dp1[k], dp2[k], where k is the number of bits present in a1|a2|... |aleft and b1|... |bright correspondingly. Now we want to obtain dp[k] for arrays of size left + right. The formula is: Here l corresponds to the bits present in the xor of the left part, and for each number of the right part we can choose these l bits arbitrarily. Rewrite the formula in the following way: So, we can compute dp[k] for all k having multiplied two polynomials and . We can obtain the coefficients of the first polynomial from the coefficients of the second in . So, we can compute this dynamic programming for all lengths — powers of two, in , using the fast Fourier transform. In fact, it is more convenient to compute using the same equation. After that, we can use the same merge strategy to compute the answer for the given n, using dynamics for the powers of two. Overall complexity is .We decided to ask the answer modulo 109 + 7 to not let the participants easily guess that these problem requires FFT :) So, in order to get accepted you had to implement one of the methods to deal with the large modulo in polynomial multiplication using FFT. Another approach was to apply Karatsuba algorithm, our realisation timed out on our tests, but jqdai0815 somehow made it pass :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 623\\s*B"
          },
          "content_length": 6382
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, a, b\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n\n    // Read n integers ai\n    vector<int> ai = inf.readInts(n, 2, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Read EOF\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, a, b\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n\n    // Read n integers ai\n    vector<int> ai = inf.readInts(n, 2, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Read EOF\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, a, b\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n\n    // Read n integers ai\n    vector<int> ai = inf.readInts(n, 2, 1000000000, \"ai\");\n    inf.readEoln();\n\n    // Read EOF\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> primes;\nconst int MAX_PRIME = 1000000;\n\nvoid generate_primes() {\n    vector<bool> is_prime(MAX_PRIME + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= MAX_PRIME; ++i) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            if((long long)i * i <= MAX_PRIME)\n                for(int j = i * i; j <= MAX_PRIME; j += i)\n                    is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long a = opt<long long>(\"a\");\n    long long b = opt<long long>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> ai(n);\n\n    if (type == \"all_same\") {\n        long long val = opt<long long>(\"val\", 2); // Default value is 2\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    } else if (type == \"random_primes\") {\n        generate_primes();\n        for (int i = 0; i < n; ++i) {\n            ai[i] = primes[rnd.next(primes.size())];\n        }\n    } else if (type == \"alternating\") {\n        long long val1 = opt<long long>(\"val1\", 2);\n        long long val2 = opt<long long>(\"val2\", 3);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"one_different\") {\n        long long val1 = opt<long long>(\"val1\", 2);\n        long long val2 = opt<long long>(\"val2\", 3);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val1;\n        }\n        int idx = rnd.next(0, n - 1);\n        ai[idx] = val2;\n    } else if (type == \"max_gcd\") {\n        long long t = opt<long long>(\"t\", 2);\n        long long min_k = opt<long long>(\"min_k\", 1);\n        long long max_k = opt<long long>(\"max_k\", (long long)(1e9 / t));\n        for (int i = 0; i < n; ++i) {\n            ai[i] = t * rnd.next(min_k, max_k);\n        }\n    } else { // default is random\n        long long min_val = opt<long long>(\"min_val\", 2);\n        long long max_val = opt<long long>(\"max_val\", (long long)1e9);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_val, max_val);\n        }\n    }\n\n    // Output n, a, b\n    printf(\"%d %lld %lld\\n\", n, a, b);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", ai[i]);\n        if (i != n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> primes;\nconst int MAX_PRIME = 1000000;\n\nvoid generate_primes() {\n    vector<bool> is_prime(MAX_PRIME + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= MAX_PRIME; ++i) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            if((long long)i * i <= MAX_PRIME)\n                for(int j = i * i; j <= MAX_PRIME; j += i)\n                    is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long a = opt<long long>(\"a\");\n    long long b = opt<long long>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> ai(n);\n\n    if (type == \"all_same\") {\n        long long val = opt<long long>(\"val\", 2); // Default value is 2\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    } else if (type == \"random_primes\") {\n        generate_primes();\n        for (int i = 0; i < n; ++i) {\n            ai[i] = primes[rnd.next(primes.size())];\n        }\n    } else if (type == \"alternating\") {\n        long long val1 = opt<long long>(\"val1\", 2);\n        long long val2 = opt<long long>(\"val2\", 3);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"one_different\") {\n        long long val1 = opt<long long>(\"val1\", 2);\n        long long val2 = opt<long long>(\"val2\", 3);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val1;\n        }\n        int idx = rnd.next(0, n - 1);\n        ai[idx] = val2;\n    } else if (type == \"max_gcd\") {\n        long long t = opt<long long>(\"t\", 2);\n        long long min_k = opt<long long>(\"min_k\", 1);\n        long long max_k = opt<long long>(\"max_k\", (long long)(1e9 / t));\n        for (int i = 0; i < n; ++i) {\n            ai[i] = t * rnd.next(min_k, max_k);\n        }\n    } else { // default is random\n        long long min_val = opt<long long>(\"min_val\", 2);\n        long long max_val = opt<long long>(\"max_val\", (long long)1e9);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_val, max_val);\n        }\n    }\n\n    // Output n, a, b\n    printf(\"%d %lld %lld\\n\", n, a, b);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", ai[i]);\n        if (i != n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n\n./gen -n 1 -a 0 -b 0 -type all_same -val 2\n\n# Maximal n\n./gen -n 1000000 -a 0 -b 0 -type all_same -val 2\n\n# All ai are same, GCD greater than 1\n./gen -n 100000 -a 10 -b 10 -type all_same -val 4\n\n# All ai are same, GCD equal to 1\n./gen -n 100000 -a 10 -b 10 -type all_same -val 1\n\n# One element is different\n./gen -n 100000 -a 5 -b 5 -type one_different -val1 2 -val2 3\n\n# Random primes\n./gen -n 100000 -a 2 -b 1 -type random_primes\n\n# Alternating values\n./gen -n 100000 -a 100 -b 100 -type alternating -val1 2 -val2 3\n\n# Random values, small range\n./gen -n 100000 -a 1 -b 1 -type random -min_val 2 -max_val 10\n\n# Random values, large range\n./gen -n 100000 -a 1 -b 1 -type random -min_val 100000000 -max_val 1000000000\n\n# Maximum GCD\n./gen -n 100000 -a 3 -b 3 -type max_gcd -t 100\n\n# Zero cost for removing elements (a = 0)\n./gen -n 100000 -a 0 -b 1 -type random\n\n# Zero cost for changing elements (b = 0)\n./gen -n 100000 -a 1 -b 0 -type random\n\n# Maximal a and b\n./gen -n 100000 -a 1000000000 -b 1000000000 -type random\n\n# Minimal a and b\n./gen -n 100000 -a 0 -b 0 -type random\n\n# Small array where only one element needs to be changed\n./gen -n 10 -a 10 -b 1 -type one_different -val1 2 -val2 3\n\n# Large array where GCD is 1\n./gen -n 1000000 -a 100 -b 100 -type random -min_val 1 -max_val 1000000000\n\n# All ai are powers of two\n./gen -n 100000 -a 5 -b 5 -type max_gcd -t 2\n\n# Edge case with big primes\n./gen -n 100 -a 1 -b 1 -type random_primes\n\n# Small n with large a, b\n./gen -n 10 -a 1000000000 -b 1000000000 -type random\n\n# Test with n = 2\n./gen -n 2 -a 10 -b 5 -type alternating -val1 2 -val2 5\n\n# Operation a is more favorable than b\n./gen -n 1000 -a 1 -b 100000 -type random\n\n# Operation b is more favorable than a\n./gen -n 1000 -a 100000 -b 1 -type random\n\n# Impossible to get GCD > 1\n./gen -n 2 -a 1000 -b 1000 -type all_same -val 1\n\n# GCD is already greater than 1\n./gen -n 5 -a 100 -b 100 -type all_same -val 6\n\n# Test with maximum values\n./gen -n 1000000 -a 1000000000 -b 1000000000 -type random -min_val 1 -max_val 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:51.376420",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "623/C",
      "title": "C. Электрические заряды",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 100 000) — количество точек.Каждая из последующих n строк содержит два целых числа xi и yi ( - 108 ≤ xi, yi ≤ 108) — координаты i-й точки. Гарантируется, что никакие две точки не совпадают.",
      "output_spec": "Выходные данныеВыведите одно целое число — квадрат минимального возможного диаметра множества, после того как Вася расставит в заданные точки электроны и протоны и лаборант включит время.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 101 201 30Выходные данныеСкопировать0Входные данныеСкопировать21 1010 1Выходные данныеСкопировать2",
      "description": "C. Электрические заряды\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 100 000) — количество точек.Каждая из последующих n строк содержит два целых числа xi и yi ( - 108 ≤ xi, yi ≤ 108) — координаты i-й точки. Гарантируется, что никакие две точки не совпадают.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — квадрат минимального возможного диаметра множества, после того как Вася расставит в заданные точки электроны и протоны и лаборант включит время.\n\nВыходные данные\n\nВходные данныеСкопировать31 101 201 30Выходные данныеСкопировать0Входные данныеСкопировать21 1010 1Выходные данныеСкопировать2\n\nВходные данныеСкопировать31 101 201 30\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 1010 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Саня помещает во все точки электроны, и все частицы в итоге попадают в одну точку (1, 0).Во втором примере Саня помещает в точку (1, 10) электрон, а в точку (10, 1) — протон. В результате получается множество из двух точек (1, 0) и (0, 1), которое имеет диаметр .",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Привет, Codeforces!4 февраля, в четверг, в 20:05 MSK состоится AIM Tech Codeforces Round.Раунд подготовили для вас сотрудники компании AIM Tech: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov и zeliboba. Раунд пройдет во время Петрозаводских сборов, спонсорами которых наша компания стала в этом году.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Мы постарались сделать задачи проще, чем в прошлый наш раунд, но не менее интересными. Окончательная разбалловка будет опубликована прямо перед раундом, но сразу сообщу, что сложности задач C,D,E первого дивизиона отличаются меньше обычного, поэтому рекомендуем сначала прочитать их все. Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Глеба Евстропова (GlebsHP) и Марию Белову (Delinur) за перевод условий на английский.Наша компания занимается проп-трейдингом, ключевыми понятиями в нашей работе являются big data, low latency и high frequency. В нашей работе важно алгоритмическое мышление и умение писать эффективный C++ код, поэтому у нас работает много спортивных программистов. Чтобы придумывать hft-стратегии нужно обладать хорошей математической интуицией и умением подходить к задаче с разных сторон, поэтому их созданием в нашей компании занимаются в основном олимпиадники-математики. В свободное от работы время мы участвуем в разных соревнованиях по программированию и не только, вместе ходим в походы и путешествуем. Прочитать подробнее про нас и наши вакансии можно на сайте aimtech.com. Можно отправить нам резюме через эту форму, даже если вы не участвуете в раунде.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в пятницу 5 февраля в 19.30 вечера будет организован фуршет в Пауланер Бройхаус.Разбалловкаdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250РазборP.P.S. Авторское решение div2A имело погрешность 5e-7, поэтому мы решили пореджаджить эту задачу.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2046
        },
        {
          "title": "Разбор AIM Tech Round - Codeforces",
          "content": "624A - Спасти ЛюкаЗа единицу времени ширина полосы уменьшается на v1 + v2. Это значит, что она уменьшится от L до d за . Тот момент, когда ширина стала равна d — последний, когда Люк еще живет, значит t — это ответ.624B - Составить строкуОтсортируем кол-ва букв по невозрастанию.Очередную букву берем столько раз, сколько можно, но строго меньше, чем предыдущую. Не забываем, что если предыдущая буква не взята вообще, то все следующие тоже взяты не будут.623A - Граф и строкаЗаметим, что вершины \"b\" связаны со всеми остальными вершинами в графе. Найдём все подобные вершины и отметим их символом \"b\". После этого найдём любую непомеченную вершину V, пометим её символом \"a\". Все непомеченные вершины, которые связаны с V, тоже должны быть помечены символом \"a\". Все остальные непомеченные вершины в графе отметим символом \"c\".Теперь нужно проверить корректность графа, т.е. убедиться, что все вершины \"a\" связаны только между собой и с вершинами \"b\". Аналогично проверим все вершины \"c\".623B - НОД массиваХотя бы один из концов (a1 или an) изменится не больше, чем на 1. А это значит, что если gcd будет не равен 1, то он будет делиться на один из простых делителей одного из чисел a1 - 1, a1, a1 + 1, an - 1, an, an + 1. Переберём это простое.Пусть фиксировано простое p, тогда для каждого числа мы знаем, что оно, либо уже делится на p, либо его можно поправить за b, либо оно должно входить в массив-результат.После этого, можно запустить динамику dp[кол-во чисел, которое рассмотрели][отрезок для изменения за a еще не начался/начался/закончился] = минимальная стоимостьИтоговая сложность O(Nd) = O(NlogN), где d — количество простых делителей для перебора623C - Электрические зарядыРассмотрим сперва отдельно случаи, когда все точки спроецированы на одну ось (Тогда ответ — разница между максимумом и минимумом по одной из координат)Далее, рассмотрим самую левую и самую правую точку из тех, что спроецированы на ось x. Пусть их координаты xL и xR. Заметим, что все точки с координатами xL ≤ x ≤ xR также можно спроецировать на ось x, это не увеличит диаметр. Таким образом, если отсортировать точки по x-координате, можно считать, что точки спроецированные на ось x образуют подотрезок (непрерывный подмассив).Запустим бинарный поиск, теперь нам нужно проверять, что можно спроецировать точки так, что диаметр <= M.Зафиксируем самую дальнюю от 0 по x-координате точку, которая в итоге будет спроецированной на ось x. Она может быть слева или справа от нуля. Случаи будут симметричны, для примера рассмотрим случай, когда эта точка меньше 0. Пусть ее координата равна xL < 0. Заметим, что все точки, для которых 0 ≤ x - xL ≤ M и |x| ≤ |xL| можно спроецировать на ось x и от этого диаметр не увеличится, а все оставшиеся нужно спроецировать на ось y. Среди оставшихся точек нужно найти минимум и максимум по y координате и тогда ответ \"можно\", если расстояние между этими точками не превосходит M и расстояние от них до (xL, 0) не превосходит M.Теперь предподсчитаем минимум и максимум y координат на префиксе и суффиксе все точек. Будем перебирать левую границу отрезка точек спроецированных на x, а правую будем искать бинпоиском или поддерживать методом двух указателей.Таким образом одна проверка работает за O(M) или , и общая сложность или .623D - День РожденияОбозначим qi = 1 - pi.Идея решения: сначала нужно назвать каждого друга хотя бы по разу, потом на каждом шаге максимизируем вероятность закончить игру не позже, чем на данном шаге. Моделируем 300000 шагов, считая по ходу дела сумму . , где ki — количество раз, когда мы называли i-го друга ().Заметим, что матожидание с небольшой погрешностью равно при достаточно большом N (это легко видеть, раскрыв скобки в приведенном выше выражении). Поэтому нам достаточно доказать, что 1) Приведенная выше жадная стратегия дает максимальные значения всех Pr(t). 2) На 300000 шаге погрешность меньше 10 - 6.Доказательство:1) Предположим, что для какого-то t набор li (), отличный от полученного жадным алгоритмом набора ki, дает наибольшее значение Pr(t). Возьмем какое-нибудь ka < la и kb > lb (такие найдутся, если наборы не совпадают, а их суммы равны t), тогда легко показать, что если в наборе li заменить lb на lb + 1, la на la - 1, то будет достигнуто еще большее значение Pr(t), что противоречит предположению о максимальности набора li.2) Заметим, что qi ≤ 0.99. Возьмем набор ki такой, что для всех i выполняется , он даст вероятность завершения игры за t шагов не большую, чем оптимальный набор. Тогда Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Погрешность оценки не превосходит , что оценивается, как сумма геометрической прогрессии, и при N ≥ 300000 получим погрешность меньше 10 - 7.623E - Преобразование последовательности Для начала заметим, что если последовательность префиксных ксоров строго возрастает, то на каждом шаге ai имеет хотя бы один новый бит по сравнению с предыдущими элементами. Так как битов всего k, длина последовательности не может быть больше k. Поэтому если n > k, то ответ 0. Решим сначала задачу за O(k3). Посчитаем dp[n][k] — количество последовательностей длины n таких, что a1|a2|... |an имеет ровно k битов. Переход — добавить l новых битов и выбрать произвольно значения k битов, которые уже вошли в префиксный ксор. Значит, dp[n + 1][k + l] должно быть увеличено на dp[n][k]·2k·Ck + ll. Биномиальный коэффициент соответствует выбору добавляемых l битов из k + l, которые будут представлены в a1|a2|... |an + 1.Заметим, что переход не зависит от n, поэтому попробуем применить идею бинарного возведения в степень. Пусть мы хотим слить динамики dp1[k], dp2[k], где k — количество битов в a1|a2|... |aleft и b1|... |bright соответственно. Хотим посчитать dp[k] для массивов размера left + right. Формула получается такая: Здесь l соответствует битам в ксоре левой части, и для каждого числа из правой части эти l битов можно выбрать произвольно. Перепишем формулу так: Значит, мы можем посчитать dp[k] для всех k, перемножив многочлены и . Коэффициенты первого получаются из коэффициентов второго за . Значит, мы можем посчитать динамику для всех длин — степеней двойки за , используя быстрое преобразование Фурье. На самом деле, удобнее насчитывать , используя то же самое равенство. Далее, используя ту же стратегию слияния, можно найти ответ для данного n, используя динамику для степеней двойки. Получили решение за .Мы решили попросить ответ по модулю 109 + 7, чтобы участники не смогли легко догадаться, что это задача на FFT :) Поэтому для получения ОК нужно было реализовать один из методов перемножения многочленов по большому модулю с использованием FFT. Другой подход состоял в применении алгоритма Карацубы, наша его реализация не укладывалась в ТЛ, однако jqdai0815 каким-то образом смог заставить свое решение с Карацубой пройти :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 623\\s*C"
          },
          "content_length": 6760
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "сложности задач C,D,E отличаются меньше обычного",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 4",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 5",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 6",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int,int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n        pair<int,int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", xi, yi);\n        points.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int,int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n        pair<int,int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", xi, yi);\n        points.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int,int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n        pair<int,int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", xi, yi);\n        points.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    constexpr int MIN_VAL = -100000000;\n    constexpr int MAX_VAL = 100000000;\n\n    set<pair<int, int>> points;\n\n    int x_value = opt<int>(\"x_value\", 0);\n    int y_value = opt<int>(\"y_value\", 0);\n    int clusters = opt<int>(\"clusters\", 5);\n\n    while ((int)points.size() < n) {\n        int x, y;\n        if (type == \"all_same_x\") {\n            x = x_value;\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        } else if (type == \"all_same_y\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = y_value;\n        } else if (type == \"diagonal\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = x;\n        } else if (type == \"anti_diagonal\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = -x;\n        } else if (type == \"max_x\") {\n            x = MAX_VAL;\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        } else if (type == \"max_y\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = MAX_VAL;\n        } else if (type == \"min_x\") {\n            x = MIN_VAL;\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        } else if (type == \"min_y\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = MIN_VAL;\n        } else if (type == \"clustered\") {\n            static vector<pair<int, int>> centers;\n            if (centers.empty()) {\n                for (int i = 0; i < clusters; ++i) {\n                    int cx = rnd.next(MIN_VAL + 10000, MAX_VAL - 10000);\n                    int cy = rnd.next(MIN_VAL + 10000, MAX_VAL - 10000);\n                    centers.emplace_back(cx, cy);\n                }\n            }\n            int idx = rnd.next(centers.size());\n            x = centers[idx].first + rnd.next(-10000, 10000);\n            y = centers[idx].second + rnd.next(-10000, 10000);\n        } else if (type == \"big_coordinates\") {\n            if (rnd.next(2))\n                x = rnd.next(0, 1) == 0 ? MIN_VAL : MAX_VAL;\n            else\n                x = rnd.next(MIN_VAL, MAX_VAL);\n            if (rnd.next(2))\n                y = rnd.next(0, 1) == 0 ? MIN_VAL : MAX_VAL;\n            else\n                y = rnd.next(MIN_VAL, MAX_VAL);\n        } else {\n            // Default to random\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        }\n\n        if (x < MIN_VAL || x > MAX_VAL || y < MIN_VAL || y > MAX_VAL)\n            continue;\n        if (points.count({x, y}) == 0)\n            points.insert({x, y});\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    constexpr int MIN_VAL = -100000000;\n    constexpr int MAX_VAL = 100000000;\n\n    set<pair<int, int>> points;\n\n    int x_value = opt<int>(\"x_value\", 0);\n    int y_value = opt<int>(\"y_value\", 0);\n    int clusters = opt<int>(\"clusters\", 5);\n\n    while ((int)points.size() < n) {\n        int x, y;\n        if (type == \"all_same_x\") {\n            x = x_value;\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        } else if (type == \"all_same_y\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = y_value;\n        } else if (type == \"diagonal\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = x;\n        } else if (type == \"anti_diagonal\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = -x;\n        } else if (type == \"max_x\") {\n            x = MAX_VAL;\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        } else if (type == \"max_y\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = MAX_VAL;\n        } else if (type == \"min_x\") {\n            x = MIN_VAL;\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        } else if (type == \"min_y\") {\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = MIN_VAL;\n        } else if (type == \"clustered\") {\n            static vector<pair<int, int>> centers;\n            if (centers.empty()) {\n                for (int i = 0; i < clusters; ++i) {\n                    int cx = rnd.next(MIN_VAL + 10000, MAX_VAL - 10000);\n                    int cy = rnd.next(MIN_VAL + 10000, MAX_VAL - 10000);\n                    centers.emplace_back(cx, cy);\n                }\n            }\n            int idx = rnd.next(centers.size());\n            x = centers[idx].first + rnd.next(-10000, 10000);\n            y = centers[idx].second + rnd.next(-10000, 10000);\n        } else if (type == \"big_coordinates\") {\n            if (rnd.next(2))\n                x = rnd.next(0, 1) == 0 ? MIN_VAL : MAX_VAL;\n            else\n                x = rnd.next(MIN_VAL, MAX_VAL);\n            if (rnd.next(2))\n                y = rnd.next(0, 1) == 0 ? MIN_VAL : MAX_VAL;\n            else\n                y = rnd.next(MIN_VAL, MAX_VAL);\n        } else {\n            // Default to random\n            x = rnd.next(MIN_VAL, MAX_VAL);\n            y = rnd.next(MIN_VAL, MAX_VAL);\n        }\n\n        if (x < MIN_VAL || x > MAX_VAL || y < MIN_VAL || y > MAX_VAL)\n            continue;\n        if (points.count({x, y}) == 0)\n            points.insert({x, y});\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n\n./gen -n 2 -type random\n\n./gen -n 3 -type all_same_x -x_value 1\n./gen -n 3 -type all_same_y -y_value 1\n./gen -n 3 -type diagonal\n./gen -n 3 -type anti_diagonal\n\n./gen -n 10 -type random\n./gen -n 10 -type clustered -clusters 2\n\n./gen -n 100 -type random\n./gen -n 100 -type all_same_x -x_value 0\n./gen -n 100 -type all_same_y -y_value 0\n./gen -n 100 -type max_x\n./gen -n 100 -type min_x\n./gen -n 100 -type max_y\n./gen -n 100 -type min_y\n./gen -n 100 -type big_coordinates\n\n./gen -n 1000 -type random\n./gen -n 1000 -type clustered -clusters 5\n./gen -n 1000 -type diagonal\n./gen -n 1000 -type anti_diagonal\n\n./gen -n 10000 -type random\n./gen -n 10000 -type clustered -clusters 10\n./gen -n 10000 -type big_coordinates\n\n./gen -n 50000 -type random\n./gen -n 50000 -type clustered -clusters 100\n\n./gen -n 99999 -type random\n./gen -n 99999 -type big_coordinates\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_same_x -x_value 100000000\n./gen -n 100000 -type all_same_y -y_value -100000000\n./gen -n 100000 -type diagonal\n./gen -n 100000 -type anti_diagonal\n./gen -n 100000 -type clustered -clusters 1000\n./gen -n 100000 -type big_coordinates\n\n# Edge cases\n./gen -n 100000 -type max_x\n./gen -n 100000 -type max_y\n./gen -n 100000 -type min_x\n./gen -n 100000 -type min_y\n\n# Mixed types\n./gen -n 100000 -type random\n./gen -n 100000 -type clustered -clusters 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:53.002864",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "623/D",
      "title": "D. Birthday",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (1 ≤ n ≤ 100) — the number of Misha's friends.The second line contains n integers pi (), giving the probability to catch the i-th friend in one particular round in percent.",
      "output_spec": "OutputPrint a single real value — the expectation of the number of rounds provided that Misha plays optimally. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy250 50OutputCopy5.0000000000InputCopy450 20 20 10OutputCopy39.2846263444",
      "description": "D. Birthday\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (1 ≤ n ≤ 100) — the number of Misha's friends.The second line contains n integers pi (), giving the probability to catch the i-th friend in one particular round in percent.\n\nOutputPrint a single real value — the expectation of the number of rounds provided that Misha plays optimally. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy250 50OutputCopy5.0000000000InputCopy450 20 20 10OutputCopy39.2846263444\n\nInputCopy250 50\n\nOutputCopy5.0000000000\n\nInputCopy450 20 20 10\n\nOutputCopy39.2846263444\n\nNoteThe optimal strategy in the first sample is to guess friends alternately.",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Hi, Codeforces!AIM Tech Codeforces Round will take place on February, 4 at 20:05 MSK.The round is prepared by AIM Tech employees: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov and zeliboba. Round will take place during Petrozavodsk Winter Camp, which is sponsored by our company.We made our problems a little easier than at our last Round, but we promise they won’t be less interesting. Scoring system will be static. The final distribution of points will be announced right before the round, however you should note that this time difference in complexity between problems div1 C, D and E may be less than usual so our strong recommendation that you read them all first.Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Gleb Evstropov (GlebsHP) and Maria Belova (Delinur) for English translation.Our company specialises in proprietary trading, the key concepts in our work are big data, low latency and high frequency. Our team mainly consists of graduates from the MSU Faculty of Mechanics and Mathematics and Moscow Institute of Physics and Technology (MIPT).We wish you good luck and high frequency rating!P.S. For all participants of PTZ gathering we are glad to announce evening buffet that will take place at Paulaner Brauhaus and will start Februrary, 5 at 7:30 pmScoringdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250EditorialP.P.S. Author solution of div2A had precision error 5e-7, so we decided to rejudge this problem.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1544
        },
        {
          "title": "AIM Tech Round Tutorial - Codeforces",
          "content": "624A - Save LukeWidth of free space is decreasing by v1 + v2 per second. It means that it'll decrease from L to d in seconds. The moment when width gets a value of d is the last when Luke is alive so t is the answer. 624B - Making a StringSort array in descending order.Iterate over all letters, First letter is added c1 = a1 times, each other letter is added ci = min(ai, ci - 1). Don't forget that if some letter is not added at all, then all next letters are not added too.623A - Graph and String Note that all vertices \"b\" are connected with all other vertices in the graph. Find all such vertices and mark them as \"b\". Now we need to find any unlabeled vertex V, mark it with \"a\" character. Unlabeled vertices connected with V should be also labeled as \"a\". All other vertices we can label as \"c\"Finally we need to check graph validity. Check that all vertices \"a\" are only connected with each other and \"b\" vertices. After that we need to perform a similar check for \"c\" vertices.623B - Array GCDAt least one of ends (a1 or an) is changed by at most 1. It means that if gcd > 1 then it divides on of prime divisors of either a1 - 1, a1, a1 + 1, an - 1, an or an + 1. We will iterate over these primes.Suppose prime p is fixed. For each number we know that it's either divisible by p or we can pay b to fix it or it should be in the subarray to change for aWe can use dynamic programming dp[number of numbers considered][subarray to change not started/started/finished] = minimal costComplexity is O(Nd) = O(Nlog(max(ai)), where d is the number of primes to check.623C - Electric ChargesFirst of all consider cases where all points are projected to the same axis. (In that case answer is difference between maximum and minimum of this coordinate).Now consider leftmost and rightmost points among projected to x axis. Let xL and xR are their x-coordinates. Notice that points with x-coordinate xL ≤ x ≤ xR may also be projected to x-axis and that will not increase the diameter. So, if we sort all points by x-coordinate, we may suppose that points projected to x-axis form a continuous subarray.We will use a binary search. Now we will need to check if it's possible to project point in a such way that diameter is <= M.Let's fix the most distant by x-coordinate point from 0 that is projected to x-axis. It may be to the left or to the right of 0. This cases are symmetrical and we will consider only the former one. Let xL < 0 be its coordinate. Notice that one may project all points such that 0 ≤ x - xL ≤ M and |x| ≤ |xL| to the x axis (and it'll not affect the diameter) and we have to project other points to y-axis. Among all other points we should find the maximum and minimum by y coordinate. Answer is \"yes (diam ≤ M)\" if ymax - ymin <  = M and distance from (xL, 0) to both (0, ymax) and (0, ymin) is not greater than M.Let's precalculate maximums and minimums of y coordinates on each prefix and suffix of original (sorted) points array. Now iterate over left border of subarray of points projected to x-axis and find the right border using binary search or maintain it using two-pointers technique.So we've got one check in O(M) or and entire solution in or 623D - BirthdayLet's denote qi = 1 - pi.Main idea: first of all guess each friend once, then maximize probability to end game on current step. Let's simulate first 300000 steps, and calculate . , where ki — how many times we called i-th friend ().Expectation with some precision equals . So it is enough to prove that:1) Greedy strategy gives maximum values for all Pr(t). 2) On 300000 step precision error will be less than 10 - 6.Proof:1) Suppose, that for some t there exists set li (), not equal to set produced by greedy algorithm ki, gives the maximum value of Pr(t). Let's take some ka < la and kb > lb, it is easy to prove tgat if we change lb to lb + 1, la to la - 1, then new set of li gives bigger value of Pr(t), contradiction.2) qi ≤ 0.99. Let's take set , it gives probability of end of the game not less than optimal. Then Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Precision error does not exceed . It could be estimated as sum of geometric progression. If N ≥ 300000 precision error doesn't exceed 10 - 7.623E - Transforming SequenceFirst observation is that if the sequence of prefix xors is strictly increasing, than on each step ai has at least one new bit comparing to the previous elements. So, since there are overall k bits, the length of the sequence can't be more than k. So, if n > k, the answer is 0. Let's firstly solve the task with O(k3) complexity. We calculate dp[n][k] — the number of sequences of length n such that a1|a2|... |an has k bits. The transition is to add a number with l new bits, and choose those k bits which are already in the prefix xor arbitrarily. So, dp[n + 1][k + l] is increased by dp[n][k]·2k·Ck + ll. The last binomial coefficient complies with the choice these very l bits from k + l which will be present in a1|a2|... |an + 1.Note now that the transition doesn't depend on n, so let's try to use the idea of the binary exponentiation. Suppose we want to merge two dynamics dp1[k], dp2[k], where k is the number of bits present in a1|a2|... |aleft and b1|... |bright correspondingly. Now we want to obtain dp[k] for arrays of size left + right. The formula is: Here l corresponds to the bits present in the xor of the left part, and for each number of the right part we can choose these l bits arbitrarily. Rewrite the formula in the following way: So, we can compute dp[k] for all k having multiplied two polynomials and . We can obtain the coefficients of the first polynomial from the coefficients of the second in . So, we can compute this dynamic programming for all lengths — powers of two, in , using the fast Fourier transform. In fact, it is more convenient to compute using the same equation. After that, we can use the same merge strategy to compute the answer for the given n, using dynamics for the powers of two. Overall complexity is .We decided to ask the answer modulo 109 + 7 to not let the participants easily guess that these problem requires FFT :) So, in order to get accepted you had to implement one of the methods to deal with the large modulo in polynomial multiplication using FFT. Another approach was to apply Karatsuba algorithm, our realisation timed out on our tests, but jqdai0815 somehow made it pass :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 623\\s*D"
          },
          "content_length": 6382
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, 100, \"p\");\n    inf.readEoln();\n\n    int sumP = 0;\n    for (int i = 0; i < n; ++i) {\n        sumP += p[i];\n    }\n    ensuref(sumP == 100, \"Sum of p_i must equal to 100, but sum is %d\", sumP);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, 100, \"p\");\n    inf.readEoln();\n\n    int sumP = 0;\n    for (int i = 0; i < n; ++i) {\n        sumP += p[i];\n    }\n    ensuref(sumP == 100, \"Sum of p_i must equal to 100, but sum is %d\", sumP);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, 100, \"p\");\n    inf.readEoln();\n\n    int sumP = 0;\n    for (int i = 0; i < n; ++i) {\n        sumP += p[i];\n    }\n    ensuref(sumP == 100, \"Sum of p_i must equal to 100, but sum is %d\", sumP);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string piType = opt<string>(\"piType\", \"uniform\");\n\n    vector<int> pi(n, 0);\n\n    if (piType == \"uniform\") {\n        // Uniform distribution\n        int base_pi = 100 / n;\n        int remainder = 100 % n;\n\n        for (int i = 0; i < n; ++i) {\n            pi[i] = base_pi;\n            if (i < remainder) {\n                pi[i] += 1;\n            }\n        }\n    } else if (piType == \"skewed\") {\n        // One friend has high pi, others have low pi\n        if (n == 1) {\n            pi[0] = 100;\n        } else {\n            int high_pi = 90;\n            pi[0] = high_pi;\n            int remaining_pi = 100 - high_pi;\n            int base_pi = remaining_pi / (n - 1);\n            int remainder = remaining_pi % (n - 1);\n\n            for (int i = 1; i < n; ++i) {\n                pi[i] = base_pi;\n                if (i - 1 < remainder) {\n                    pi[i] += 1;\n                }\n            }\n        }\n    } else if (piType == \"zeros\") {\n        // Some pi_i are zero\n        int num_zero = n / 2;\n        if (num_zero >= n) {\n            // All zeros is not allowed, adjust\n            num_zero = n - 1;\n        }\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i)\n            idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n\n        int num_non_zero = n - num_zero;\n        if (num_non_zero == 0) {\n            // Ensure at least one non-zero pi_i\n            num_non_zero = 1;\n            num_zero = n - 1;\n        }\n        int base_pi = 100 / num_non_zero;\n        int remainder = 100 % num_non_zero;\n\n        for (int i = 0; i < num_non_zero; ++i) {\n            int index = idx[i];\n            pi[index] = base_pi;\n            if (i < remainder) {\n                pi[index] += 1;\n            }\n        }\n        // The remaining pi_i are zero (already initialized to zero)\n    } else if (piType == \"random\") {\n        // Random pi_i summing to 100\n        vector<int> points;\n        for (int i = 0; i < n + 1; ++i) {\n            points.push_back(rnd.next(0, 100));\n        }\n        sort(points.begin(), points.end());\n        for (int i = 0; i < n; ++i) {\n            pi[i] = points[i + 1] - points[i];\n        }\n        // No need to shuffle pi, already random\n    } else if (piType == \"increasing\") {\n        // pi_i increases from friend 1 to n\n        int total_weight = n * (n + 1) / 2;\n        int sum_pi = 0;\n        for (int i = 0; i < n; ++i) {\n            pi[i] = (i + 1) * 100 / total_weight;\n            sum_pi += pi[i];\n        }\n        // Adjust to sum to 100\n        int remainder = 100 - sum_pi;\n        for (int i = n - 1; remainder > 0 && i >= 0; --i) {\n            pi[i]++;\n            remainder--;\n        }\n    } else if (piType == \"decreasing\") {\n        // pi_i decreases from friend 1 to n\n        int total_weight = n * (n + 1) / 2;\n        int sum_pi = 0;\n        for (int i = 0; i < n; ++i) {\n            pi[i] = (n - i) * 100 / total_weight;\n            sum_pi += pi[i];\n        }\n        // Adjust to sum to 100\n        int remainder = 100 - sum_pi;\n        for (int i = 0; remainder > 0 && i < n; ++i) {\n            pi[i]++;\n            remainder--;\n        }\n    } else {\n        // Default to uniform if unknown type\n        int base_pi = 100 / n;\n        int remainder = 100 % n;\n\n        for (int i = 0; i < n; ++i) {\n            pi[i] = base_pi;\n            if (i < remainder) {\n                pi[i] += 1;\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output pi array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string piType = opt<string>(\"piType\", \"uniform\");\n\n    vector<int> pi(n, 0);\n\n    if (piType == \"uniform\") {\n        // Uniform distribution\n        int base_pi = 100 / n;\n        int remainder = 100 % n;\n\n        for (int i = 0; i < n; ++i) {\n            pi[i] = base_pi;\n            if (i < remainder) {\n                pi[i] += 1;\n            }\n        }\n    } else if (piType == \"skewed\") {\n        // One friend has high pi, others have low pi\n        if (n == 1) {\n            pi[0] = 100;\n        } else {\n            int high_pi = 90;\n            pi[0] = high_pi;\n            int remaining_pi = 100 - high_pi;\n            int base_pi = remaining_pi / (n - 1);\n            int remainder = remaining_pi % (n - 1);\n\n            for (int i = 1; i < n; ++i) {\n                pi[i] = base_pi;\n                if (i - 1 < remainder) {\n                    pi[i] += 1;\n                }\n            }\n        }\n    } else if (piType == \"zeros\") {\n        // Some pi_i are zero\n        int num_zero = n / 2;\n        if (num_zero >= n) {\n            // All zeros is not allowed, adjust\n            num_zero = n - 1;\n        }\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i)\n            idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n\n        int num_non_zero = n - num_zero;\n        if (num_non_zero == 0) {\n            // Ensure at least one non-zero pi_i\n            num_non_zero = 1;\n            num_zero = n - 1;\n        }\n        int base_pi = 100 / num_non_zero;\n        int remainder = 100 % num_non_zero;\n\n        for (int i = 0; i < num_non_zero; ++i) {\n            int index = idx[i];\n            pi[index] = base_pi;\n            if (i < remainder) {\n                pi[index] += 1;\n            }\n        }\n        // The remaining pi_i are zero (already initialized to zero)\n    } else if (piType == \"random\") {\n        // Random pi_i summing to 100\n        vector<int> points;\n        for (int i = 0; i < n + 1; ++i) {\n            points.push_back(rnd.next(0, 100));\n        }\n        sort(points.begin(), points.end());\n        for (int i = 0; i < n; ++i) {\n            pi[i] = points[i + 1] - points[i];\n        }\n        // No need to shuffle pi, already random\n    } else if (piType == \"increasing\") {\n        // pi_i increases from friend 1 to n\n        int total_weight = n * (n + 1) / 2;\n        int sum_pi = 0;\n        for (int i = 0; i < n; ++i) {\n            pi[i] = (i + 1) * 100 / total_weight;\n            sum_pi += pi[i];\n        }\n        // Adjust to sum to 100\n        int remainder = 100 - sum_pi;\n        for (int i = n - 1; remainder > 0 && i >= 0; --i) {\n            pi[i]++;\n            remainder--;\n        }\n    } else if (piType == \"decreasing\") {\n        // pi_i decreases from friend 1 to n\n        int total_weight = n * (n + 1) / 2;\n        int sum_pi = 0;\n        for (int i = 0; i < n; ++i) {\n            pi[i] = (n - i) * 100 / total_weight;\n            sum_pi += pi[i];\n        }\n        // Adjust to sum to 100\n        int remainder = 100 - sum_pi;\n        for (int i = 0; remainder > 0 && i < n; ++i) {\n            pi[i]++;\n            remainder--;\n        }\n    } else {\n        // Default to uniform if unknown type\n        int base_pi = 100 / n;\n        int remainder = 100 % n;\n\n        for (int i = 0; i < n; ++i) {\n            pi[i] = base_pi;\n            if (i < remainder) {\n                pi[i] += 1;\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output pi array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -piType uniform\n./gen -n 1 -piType skewed\n./gen -n 1 -piType zeros\n./gen -n 1 -piType random\n./gen -n 1 -piType increasing\n./gen -n 1 -piType decreasing\n\n./gen -n 2 -piType uniform\n./gen -n 2 -piType skewed\n./gen -n 2 -piType zeros\n./gen -n 2 -piType random\n./gen -n 2 -piType increasing\n./gen -n 2 -piType decreasing\n\n./gen -n 5 -piType uniform\n./gen -n 5 -piType skewed\n./gen -n 5 -piType zeros\n./gen -n 5 -piType random\n./gen -n 5 -piType increasing\n./gen -n 5 -piType decreasing\n\n./gen -n 10 -piType uniform\n./gen -n 10 -piType skewed\n./gen -n 10 -piType zeros\n./gen -n 10 -piType random\n./gen -n 10 -piType increasing\n./gen -n 10 -piType decreasing\n\n./gen -n 50 -piType uniform\n./gen -n 50 -piType skewed\n./gen -n 50 -piType zeros\n./gen -n 50 -piType random\n./gen -n 50 -piType increasing\n./gen -n 50 -piType decreasing\n\n./gen -n 100 -piType uniform\n./gen -n 100 -piType skewed\n./gen -n 100 -piType zeros\n./gen -n 100 -piType random\n./gen -n 100 -piType increasing\n./gen -n 100 -piType decreasing\n\n./gen -n 99 -piType random\n./gen -n 99 -piType zeros\n\n./gen -n 97 -piType random\n\n./gen -n 100 -piType zeros\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:55.184696",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "623/E",
      "title": "E. Преобразование последовательности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест7 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке заданы два целых числа n и k (1 ≤ n ≤ 1018, 1 ≤ k ≤ 30 000).",
      "output_spec": "Выходные данныеВ единственной строке выведите количество подходящих последовательностей по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 2Выходные данныеСкопировать3Входные данныеСкопировать2 3Выходные данныеСкопировать30Входные данныеСкопировать3 3Выходные данныеСкопировать48",
      "description": "E. Преобразование последовательности\n\nограничение по времени на тест7 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке заданы два целых числа n и k (1 ≤ n ≤ 1018, 1 ≤ k ≤ 30 000).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите количество подходящих последовательностей по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать1 2Выходные данныеСкопировать3Входные данныеСкопировать2 3Выходные данныеСкопировать30Входные данныеСкопировать3 3Выходные данныеСкопировать48\n\nВходные данныеСкопировать1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать30\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать48\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Привет, Codeforces!4 февраля, в четверг, в 20:05 MSK состоится AIM Tech Codeforces Round.Раунд подготовили для вас сотрудники компании AIM Tech: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov и zeliboba. Раунд пройдет во время Петрозаводских сборов, спонсорами которых наша компания стала в этом году.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Мы постарались сделать задачи проще, чем в прошлый наш раунд, но не менее интересными. Окончательная разбалловка будет опубликована прямо перед раундом, но сразу сообщу, что сложности задач C,D,E первого дивизиона отличаются меньше обычного, поэтому рекомендуем сначала прочитать их все. Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Глеба Евстропова (GlebsHP) и Марию Белову (Delinur) за перевод условий на английский.Наша компания занимается проп-трейдингом, ключевыми понятиями в нашей работе являются big data, low latency и high frequency. В нашей работе важно алгоритмическое мышление и умение писать эффективный C++ код, поэтому у нас работает много спортивных программистов. Чтобы придумывать hft-стратегии нужно обладать хорошей математической интуицией и умением подходить к задаче с разных сторон, поэтому их созданием в нашей компании занимаются в основном олимпиадники-математики. В свободное от работы время мы участвуем в разных соревнованиях по программированию и не только, вместе ходим в походы и путешествуем. Прочитать подробнее про нас и наши вакансии можно на сайте aimtech.com. Можно отправить нам резюме через эту форму, даже если вы не участвуете в раунде.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в пятницу 5 февраля в 19.30 вечера будет организован фуршет в Пауланер Бройхаус.Разбалловкаdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250РазборP.P.S. Авторское решение div2A имело погрешность 5e-7, поэтому мы решили пореджаджить эту задачу.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2046
        },
        {
          "title": "Разбор AIM Tech Round - Codeforces",
          "content": "624A - Спасти ЛюкаЗа единицу времени ширина полосы уменьшается на v1 + v2. Это значит, что она уменьшится от L до d за . Тот момент, когда ширина стала равна d — последний, когда Люк еще живет, значит t — это ответ.624B - Составить строкуОтсортируем кол-ва букв по невозрастанию.Очередную букву берем столько раз, сколько можно, но строго меньше, чем предыдущую. Не забываем, что если предыдущая буква не взята вообще, то все следующие тоже взяты не будут.623A - Граф и строкаЗаметим, что вершины \"b\" связаны со всеми остальными вершинами в графе. Найдём все подобные вершины и отметим их символом \"b\". После этого найдём любую непомеченную вершину V, пометим её символом \"a\". Все непомеченные вершины, которые связаны с V, тоже должны быть помечены символом \"a\". Все остальные непомеченные вершины в графе отметим символом \"c\".Теперь нужно проверить корректность графа, т.е. убедиться, что все вершины \"a\" связаны только между собой и с вершинами \"b\". Аналогично проверим все вершины \"c\".623B - НОД массиваХотя бы один из концов (a1 или an) изменится не больше, чем на 1. А это значит, что если gcd будет не равен 1, то он будет делиться на один из простых делителей одного из чисел a1 - 1, a1, a1 + 1, an - 1, an, an + 1. Переберём это простое.Пусть фиксировано простое p, тогда для каждого числа мы знаем, что оно, либо уже делится на p, либо его можно поправить за b, либо оно должно входить в массив-результат.После этого, можно запустить динамику dp[кол-во чисел, которое рассмотрели][отрезок для изменения за a еще не начался/начался/закончился] = минимальная стоимостьИтоговая сложность O(Nd) = O(NlogN), где d — количество простых делителей для перебора623C - Электрические зарядыРассмотрим сперва отдельно случаи, когда все точки спроецированы на одну ось (Тогда ответ — разница между максимумом и минимумом по одной из координат)Далее, рассмотрим самую левую и самую правую точку из тех, что спроецированы на ось x. Пусть их координаты xL и xR. Заметим, что все точки с координатами xL ≤ x ≤ xR также можно спроецировать на ось x, это не увеличит диаметр. Таким образом, если отсортировать точки по x-координате, можно считать, что точки спроецированные на ось x образуют подотрезок (непрерывный подмассив).Запустим бинарный поиск, теперь нам нужно проверять, что можно спроецировать точки так, что диаметр <= M.Зафиксируем самую дальнюю от 0 по x-координате точку, которая в итоге будет спроецированной на ось x. Она может быть слева или справа от нуля. Случаи будут симметричны, для примера рассмотрим случай, когда эта точка меньше 0. Пусть ее координата равна xL < 0. Заметим, что все точки, для которых 0 ≤ x - xL ≤ M и |x| ≤ |xL| можно спроецировать на ось x и от этого диаметр не увеличится, а все оставшиеся нужно спроецировать на ось y. Среди оставшихся точек нужно найти минимум и максимум по y координате и тогда ответ \"можно\", если расстояние между этими точками не превосходит M и расстояние от них до (xL, 0) не превосходит M.Теперь предподсчитаем минимум и максимум y координат на префиксе и суффиксе все точек. Будем перебирать левую границу отрезка точек спроецированных на x, а правую будем искать бинпоиском или поддерживать методом двух указателей.Таким образом одна проверка работает за O(M) или , и общая сложность или .623D - День РожденияОбозначим qi = 1 - pi.Идея решения: сначала нужно назвать каждого друга хотя бы по разу, потом на каждом шаге максимизируем вероятность закончить игру не позже, чем на данном шаге. Моделируем 300000 шагов, считая по ходу дела сумму . , где ki — количество раз, когда мы называли i-го друга ().Заметим, что матожидание с небольшой погрешностью равно при достаточно большом N (это легко видеть, раскрыв скобки в приведенном выше выражении). Поэтому нам достаточно доказать, что 1) Приведенная выше жадная стратегия дает максимальные значения всех Pr(t). 2) На 300000 шаге погрешность меньше 10 - 6.Доказательство:1) Предположим, что для какого-то t набор li (), отличный от полученного жадным алгоритмом набора ki, дает наибольшее значение Pr(t). Возьмем какое-нибудь ka < la и kb > lb (такие найдутся, если наборы не совпадают, а их суммы равны t), тогда легко показать, что если в наборе li заменить lb на lb + 1, la на la - 1, то будет достигнуто еще большее значение Pr(t), что противоречит предположению о максимальности набора li.2) Заметим, что qi ≤ 0.99. Возьмем набор ki такой, что для всех i выполняется , он даст вероятность завершения игры за t шагов не большую, чем оптимальный набор. Тогда Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Погрешность оценки не превосходит , что оценивается, как сумма геометрической прогрессии, и при N ≥ 300000 получим погрешность меньше 10 - 7.623E - Преобразование последовательности Для начала заметим, что если последовательность префиксных ксоров строго возрастает, то на каждом шаге ai имеет хотя бы один новый бит по сравнению с предыдущими элементами. Так как битов всего k, длина последовательности не может быть больше k. Поэтому если n > k, то ответ 0. Решим сначала задачу за O(k3). Посчитаем dp[n][k] — количество последовательностей длины n таких, что a1|a2|... |an имеет ровно k битов. Переход — добавить l новых битов и выбрать произвольно значения k битов, которые уже вошли в префиксный ксор. Значит, dp[n + 1][k + l] должно быть увеличено на dp[n][k]·2k·Ck + ll. Биномиальный коэффициент соответствует выбору добавляемых l битов из k + l, которые будут представлены в a1|a2|... |an + 1.Заметим, что переход не зависит от n, поэтому попробуем применить идею бинарного возведения в степень. Пусть мы хотим слить динамики dp1[k], dp2[k], где k — количество битов в a1|a2|... |aleft и b1|... |bright соответственно. Хотим посчитать dp[k] для массивов размера left + right. Формула получается такая: Здесь l соответствует битам в ксоре левой части, и для каждого числа из правой части эти l битов можно выбрать произвольно. Перепишем формулу так: Значит, мы можем посчитать dp[k] для всех k, перемножив многочлены и . Коэффициенты первого получаются из коэффициентов второго за . Значит, мы можем посчитать динамику для всех длин — степеней двойки за , используя быстрое преобразование Фурье. На самом деле, удобнее насчитывать , используя то же самое равенство. Далее, используя ту же стратегию слияния, можно найти ответ для данного n, используя динамику для степеней двойки. Получили решение за .Мы решили попросить ответ по модулю 109 + 7, чтобы участники не смогли легко догадаться, что это задача на FFT :) Поэтому для получения ОК нужно было реализовать один из методов перемножения многочленов по большому модулю с использованием FFT. Другой подход состоял в применении алгоритма Карацубы, наша его реализация не укладывалась в ТЛ, однако jqdai0815 каким-то образом смог заставить свое решение с Карацубой пройти :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 623\\s*E"
          },
          "content_length": 6760
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "сложности задач C,D,E отличаются меньше обычного",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 4",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 5",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 6",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 30000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAX_N = 1000000000000000000LL; // 1e18\nconst int MAX_K = 30000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") {\n        n = 1;\n        if (k == -1) k = rnd.next(1, MAX_K);\n    } else if (type == \"max_n\") {\n        n = MAX_N;\n        if (k == -1) k = rnd.next(1, MAX_K);\n    } else if (type == \"min_k\") {\n        k = 1;\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n    } else if (type == \"max_k\") {\n        k = MAX_K;\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n    } else if (type == \"small_nk\") {\n        n = rnd.next(1LL, 10LL);\n        k = rnd.next(1, 10);\n    } else if (type == \"large_nk\") {\n        n = rnd.next(MAX_N - 1000LL, MAX_N);\n        k = rnd.next(MAX_K - 10, MAX_K);\n    } else if (type == \"max_values\") {\n        n = MAX_N;\n        k = MAX_K;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n        if (k == -1) k = rnd.next(1, MAX_K);\n    } else {\n        // Unknown type, default to random values within constraints\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n        if (k == -1) k = rnd.next(1, MAX_K);\n    }\n\n    // Ensure n and k are within the constraints\n    n = max(1LL, min(n, MAX_N));\n    k = max(1, min(k, MAX_K));\n\n    // Output n and k\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAX_N = 1000000000000000000LL; // 1e18\nconst int MAX_K = 30000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") {\n        n = 1;\n        if (k == -1) k = rnd.next(1, MAX_K);\n    } else if (type == \"max_n\") {\n        n = MAX_N;\n        if (k == -1) k = rnd.next(1, MAX_K);\n    } else if (type == \"min_k\") {\n        k = 1;\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n    } else if (type == \"max_k\") {\n        k = MAX_K;\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n    } else if (type == \"small_nk\") {\n        n = rnd.next(1LL, 10LL);\n        k = rnd.next(1, 10);\n    } else if (type == \"large_nk\") {\n        n = rnd.next(MAX_N - 1000LL, MAX_N);\n        k = rnd.next(MAX_K - 10, MAX_K);\n    } else if (type == \"max_values\") {\n        n = MAX_N;\n        k = MAX_K;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n        if (k == -1) k = rnd.next(1, MAX_K);\n    } else {\n        // Unknown type, default to random values within constraints\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n        if (k == -1) k = rnd.next(1, MAX_K);\n    }\n\n    // Ensure n and k are within the constraints\n    n = max(1LL, min(n, MAX_N));\n    k = max(1, min(k, MAX_K));\n\n    // Output n and k\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n\n./gen -type max_n\n./gen -type min_k\n./gen -type max_k\n./gen -type small_nk\n./gen -type large_nk\n./gen -type max_values\n\n./gen -n 1 -k 1\n./gen -n 1 -k 30000\n./gen -n 1000000000000000000 -k 1\n./gen -n 1000000000000000000 -k 30000\n\n./gen -n 1\n./gen -k 1\n./gen -n 2 -k 2\n./gen -n 10 -k 10\n./gen -n 100 -k 100\n./gen -n 1000 -k 1000\n./gen -n 10000 -k 10000\n./gen -n 100000 -k 10000\n\n./gen -n 999999999999999999 -k 29999\n./gen -n 500000000000000000 -k 15000\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:57.285650",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "624/A",
      "title": "A. Спасти Люка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны четыре целых числа d, L, v1, v2 (1 ≤ d, L, v1, v2 ≤ 10 000, d < L) — толщина Люка, координата второго пресса и скорости первого и второго прессов соответственно.",
      "output_spec": "Выходные данныеВыведите одно вещественное число — максимальное время, в течение которого Люк может оставаться живым. Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не будет превосходить 10 - 6. А именно: пусть ваш ответ равен a, а ответ жюри — b. Проверяющая программа будет считать ваш ответ правильным, если .",
      "sample_tests": "ПримерыВходные данныеСкопировать2 6 2 2Выходные данныеСкопировать1.00000000000000000000Входные данныеСкопировать1 9 1 2Выходные данныеСкопировать2.66666666666666650000",
      "description": "A. Спасти Люка\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны четыре целых числа d, L, v1, v2 (1 ≤ d, L, v1, v2 ≤ 10 000, d < L) — толщина Люка, координата второго пресса и скорости первого и второго прессов соответственно.\n\nВходные данные\n\nВыходные данныеВыведите одно вещественное число — максимальное время, в течение которого Люк может оставаться живым. Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не будет превосходить 10 - 6. А именно: пусть ваш ответ равен a, а ответ жюри — b. Проверяющая программа будет считать ваш ответ правильным, если .\n\nВыходные данные\n\nВходные данныеСкопировать2 6 2 2Выходные данныеСкопировать1.00000000000000000000Входные данныеСкопировать1 9 1 2Выходные данныеСкопировать2.66666666666666650000\n\nВходные данныеСкопировать2 6 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.00000000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 9 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.66666666666666650000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте Люку нужно расположиться в середине отрезка, то есть в координатах [2;4], так как прессы двигаются с одинаковой скоростью.Во втором тесте ему нужно расположиться в координатах . В таком случае оба пресса придвинутся к его краям одновременно.",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Привет, Codeforces!4 февраля, в четверг, в 20:05 MSK состоится AIM Tech Codeforces Round.Раунд подготовили для вас сотрудники компании AIM Tech: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov и zeliboba. Раунд пройдет во время Петрозаводских сборов, спонсорами которых наша компания стала в этом году.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Мы постарались сделать задачи проще, чем в прошлый наш раунд, но не менее интересными. Окончательная разбалловка будет опубликована прямо перед раундом, но сразу сообщу, что сложности задач C,D,E первого дивизиона отличаются меньше обычного, поэтому рекомендуем сначала прочитать их все. Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Глеба Евстропова (GlebsHP) и Марию Белову (Delinur) за перевод условий на английский.Наша компания занимается проп-трейдингом, ключевыми понятиями в нашей работе являются big data, low latency и high frequency. В нашей работе важно алгоритмическое мышление и умение писать эффективный C++ код, поэтому у нас работает много спортивных программистов. Чтобы придумывать hft-стратегии нужно обладать хорошей математической интуицией и умением подходить к задаче с разных сторон, поэтому их созданием в нашей компании занимаются в основном олимпиадники-математики. В свободное от работы время мы участвуем в разных соревнованиях по программированию и не только, вместе ходим в походы и путешествуем. Прочитать подробнее про нас и наши вакансии можно на сайте aimtech.com. Можно отправить нам резюме через эту форму, даже если вы не участвуете в раунде.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в пятницу 5 февраля в 19.30 вечера будет организован фуршет в Пауланер Бройхаус.Разбалловкаdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250РазборP.P.S. Авторское решение div2A имело погрешность 5e-7, поэтому мы решили пореджаджить эту задачу.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2046
        },
        {
          "title": "Разбор AIM Tech Round - Codeforces",
          "content": "624A - Спасти ЛюкаЗа единицу времени ширина полосы уменьшается на v1 + v2. Это значит, что она уменьшится от L до d за . Тот момент, когда ширина стала равна d — последний, когда Люк еще живет, значит t — это ответ.624B - Составить строкуОтсортируем кол-ва букв по невозрастанию.Очередную букву берем столько раз, сколько можно, но строго меньше, чем предыдущую. Не забываем, что если предыдущая буква не взята вообще, то все следующие тоже взяты не будут.623A - Граф и строкаЗаметим, что вершины \"b\" связаны со всеми остальными вершинами в графе. Найдём все подобные вершины и отметим их символом \"b\". После этого найдём любую непомеченную вершину V, пометим её символом \"a\". Все непомеченные вершины, которые связаны с V, тоже должны быть помечены символом \"a\". Все остальные непомеченные вершины в графе отметим символом \"c\".Теперь нужно проверить корректность графа, т.е. убедиться, что все вершины \"a\" связаны только между собой и с вершинами \"b\". Аналогично проверим все вершины \"c\".623B - НОД массиваХотя бы один из концов (a1 или an) изменится не больше, чем на 1. А это значит, что если gcd будет не равен 1, то он будет делиться на один из простых делителей одного из чисел a1 - 1, a1, a1 + 1, an - 1, an, an + 1. Переберём это простое.Пусть фиксировано простое p, тогда для каждого числа мы знаем, что оно, либо уже делится на p, либо его можно поправить за b, либо оно должно входить в массив-результат.После этого, можно запустить динамику dp[кол-во чисел, которое рассмотрели][отрезок для изменения за a еще не начался/начался/закончился] = минимальная стоимостьИтоговая сложность O(Nd) = O(NlogN), где d — количество простых делителей для перебора623C - Электрические зарядыРассмотрим сперва отдельно случаи, когда все точки спроецированы на одну ось (Тогда ответ — разница между максимумом и минимумом по одной из координат)Далее, рассмотрим самую левую и самую правую точку из тех, что спроецированы на ось x. Пусть их координаты xL и xR. Заметим, что все точки с координатами xL ≤ x ≤ xR также можно спроецировать на ось x, это не увеличит диаметр. Таким образом, если отсортировать точки по x-координате, можно считать, что точки спроецированные на ось x образуют подотрезок (непрерывный подмассив).Запустим бинарный поиск, теперь нам нужно проверять, что можно спроецировать точки так, что диаметр <= M.Зафиксируем самую дальнюю от 0 по x-координате точку, которая в итоге будет спроецированной на ось x. Она может быть слева или справа от нуля. Случаи будут симметричны, для примера рассмотрим случай, когда эта точка меньше 0. Пусть ее координата равна xL < 0. Заметим, что все точки, для которых 0 ≤ x - xL ≤ M и |x| ≤ |xL| можно спроецировать на ось x и от этого диаметр не увеличится, а все оставшиеся нужно спроецировать на ось y. Среди оставшихся точек нужно найти минимум и максимум по y координате и тогда ответ \"можно\", если расстояние между этими точками не превосходит M и расстояние от них до (xL, 0) не превосходит M.Теперь предподсчитаем минимум и максимум y координат на префиксе и суффиксе все точек. Будем перебирать левую границу отрезка точек спроецированных на x, а правую будем искать бинпоиском или поддерживать методом двух указателей.Таким образом одна проверка работает за O(M) или , и общая сложность или .623D - День РожденияОбозначим qi = 1 - pi.Идея решения: сначала нужно назвать каждого друга хотя бы по разу, потом на каждом шаге максимизируем вероятность закончить игру не позже, чем на данном шаге. Моделируем 300000 шагов, считая по ходу дела сумму . , где ki — количество раз, когда мы называли i-го друга ().Заметим, что матожидание с небольшой погрешностью равно при достаточно большом N (это легко видеть, раскрыв скобки в приведенном выше выражении). Поэтому нам достаточно доказать, что 1) Приведенная выше жадная стратегия дает максимальные значения всех Pr(t). 2) На 300000 шаге погрешность меньше 10 - 6.Доказательство:1) Предположим, что для какого-то t набор li (), отличный от полученного жадным алгоритмом набора ki, дает наибольшее значение Pr(t). Возьмем какое-нибудь ka < la и kb > lb (такие найдутся, если наборы не совпадают, а их суммы равны t), тогда легко показать, что если в наборе li заменить lb на lb + 1, la на la - 1, то будет достигнуто еще большее значение Pr(t), что противоречит предположению о максимальности набора li.2) Заметим, что qi ≤ 0.99. Возьмем набор ki такой, что для всех i выполняется , он даст вероятность завершения игры за t шагов не большую, чем оптимальный набор. Тогда Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Погрешность оценки не превосходит , что оценивается, как сумма геометрической прогрессии, и при N ≥ 300000 получим погрешность меньше 10 - 7.623E - Преобразование последовательности Для начала заметим, что если последовательность префиксных ксоров строго возрастает, то на каждом шаге ai имеет хотя бы один новый бит по сравнению с предыдущими элементами. Так как битов всего k, длина последовательности не может быть больше k. Поэтому если n > k, то ответ 0. Решим сначала задачу за O(k3). Посчитаем dp[n][k] — количество последовательностей длины n таких, что a1|a2|... |an имеет ровно k битов. Переход — добавить l новых битов и выбрать произвольно значения k битов, которые уже вошли в префиксный ксор. Значит, dp[n + 1][k + l] должно быть увеличено на dp[n][k]·2k·Ck + ll. Биномиальный коэффициент соответствует выбору добавляемых l битов из k + l, которые будут представлены в a1|a2|... |an + 1.Заметим, что переход не зависит от n, поэтому попробуем применить идею бинарного возведения в степень. Пусть мы хотим слить динамики dp1[k], dp2[k], где k — количество битов в a1|a2|... |aleft и b1|... |bright соответственно. Хотим посчитать dp[k] для массивов размера left + right. Формула получается такая: Здесь l соответствует битам в ксоре левой части, и для каждого числа из правой части эти l битов можно выбрать произвольно. Перепишем формулу так: Значит, мы можем посчитать dp[k] для всех k, перемножив многочлены и . Коэффициенты первого получаются из коэффициентов второго за . Значит, мы можем посчитать динамику для всех длин — степеней двойки за , используя быстрое преобразование Фурье. На самом деле, удобнее насчитывать , используя то же самое равенство. Далее, используя ту же стратегию слияния, можно найти ответ для данного n, используя динамику для степеней двойки. Получили решение за .Мы решили попросить ответ по модулю 109 + 7, чтобы участники не смогли легко догадаться, что это задача на FFT :) Поэтому для получения ОК нужно было реализовать один из методов перемножения многочленов по большому модулю с использованием FFT. Другой подход состоял в применении алгоритма Карацубы, наша его реализация не укладывалась в ТЛ, однако jqdai0815 каким-то образом смог заставить свое решение с Карацубой пройти :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 624\\s*A"
          },
          "content_length": 6760
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "сложности задач C,D,E отличаются меньше обычного",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 4",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 5",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 6",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readSpace();\n    int L = inf.readInt(1, 10000, \"L\");\n    inf.readSpace();\n    int v1 = inf.readInt(1, 10000, \"v1\");\n    inf.readSpace();\n    int v2 = inf.readInt(1, 10000, \"v2\");\n    inf.readEoln();\n    ensuref(d < L, \"d (%d) must be less than L (%d)\", d, L);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readSpace();\n    int L = inf.readInt(1, 10000, \"L\");\n    inf.readSpace();\n    int v1 = inf.readInt(1, 10000, \"v1\");\n    inf.readSpace();\n    int v2 = inf.readInt(1, 10000, \"v2\");\n    inf.readEoln();\n    ensuref(d < L, \"d (%d) must be less than L (%d)\", d, L);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readSpace();\n    int L = inf.readInt(1, 10000, \"L\");\n    inf.readSpace();\n    int v1 = inf.readInt(1, 10000, \"v1\");\n    inf.readSpace();\n    int v2 = inf.readInt(1, 10000, \"v2\");\n    inf.readEoln();\n    ensuref(d < L, \"d (%d) must be less than L (%d)\", d, L);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int d, L, v1, v2;\n\n    if (type == \"max_d\") {\n        L = rnd.next(2, 10000); // L ≥ 2\n        d = L - 1;  // d = L - 1\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else if (type == \"min_d\") {\n        d = 1;\n        L = rnd.next(d + 1, 10000); // L ≥ d + 1\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else if (type == \"equal_v\") {\n        v1 = rnd.next(1, 10000);\n        v2 = v1;\n        d = rnd.next(1, 10000 - 1);\n        L = rnd.next(d + 1, 10000);\n    } else if (type == \"v1_slow\") {\n        v1 = 1;\n        v2 = rnd.next(5000, 10000);\n        d = rnd.next(1, 10000 - 1);\n        L = rnd.next(d + 1, 10000);\n    } else if (type == \"v2_slow\") {\n        v2 = 1;\n        v1 = rnd.next(5000, 10000);\n        d = rnd.next(1, 10000 -1);\n        L = rnd.next(d + 1, 10000);\n    } else if (type == \"d_equals_L_over_2\") {\n        // to test cases where d is half of L\n        L = rnd.next(2, 5000)*2; // ensure L even\n        d = L / 2;\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else if (type == \"max_values\") {\n        d = 9999;\n        L = 10000;\n        v1 = 10000;\n        v2 = 10000;\n    } else if (type == \"small_values\") {\n        d = rnd.next(1, 10);\n        L = rnd.next(d + 1, 10);\n        v1 = rnd.next(1, 10);\n        v2 = rnd.next(1, 10);\n    } else if (type == \"precision_test\") {\n        // Generate values that cause the time to be a repeating decimal or need high precision\n        d = 1;\n        L = 9999;\n        v1 = 1234;\n        v2 = 5678;\n    } else if (type == \"small_fraction\") {\n        // Generates small time values\n        d = rnd.next(1, 9998);\n        L = d + rnd.next(1, 2); // L just a bit bigger than d\n        v1 = rnd.next(5000, 10000);\n        v2 = rnd.next(5000, 10000);\n    } else if (type == \"large_fraction\") {\n        // Generates large time values\n        d = 1;\n        L = 10000;\n        v1 = 1;\n        v2 = 1;\n    } else if (type == \"small_time\") {\n        // Generates time less than 1e-6\n        d = 9999;\n        L = 10000;\n        v1 = 10000;\n        v2 = 10000;\n    } else if (type == \"large_time\") {\n        // Generates time as large as possible\n        d = 1;\n        L = 10000;\n        v1 = 1;\n        v2 = 1;\n    } else if (type == \"random\") {\n        d = rnd.next(1, 9999);\n        L = rnd.next(d + 1, 10000);\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else {\n        // default random\n        d = rnd.next(1, 9999);\n        L = rnd.next(d + 1, 10000);\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", d, L, v1, v2);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int d, L, v1, v2;\n\n    if (type == \"max_d\") {\n        L = rnd.next(2, 10000); // L ≥ 2\n        d = L - 1;  // d = L - 1\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else if (type == \"min_d\") {\n        d = 1;\n        L = rnd.next(d + 1, 10000); // L ≥ d + 1\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else if (type == \"equal_v\") {\n        v1 = rnd.next(1, 10000);\n        v2 = v1;\n        d = rnd.next(1, 10000 - 1);\n        L = rnd.next(d + 1, 10000);\n    } else if (type == \"v1_slow\") {\n        v1 = 1;\n        v2 = rnd.next(5000, 10000);\n        d = rnd.next(1, 10000 - 1);\n        L = rnd.next(d + 1, 10000);\n    } else if (type == \"v2_slow\") {\n        v2 = 1;\n        v1 = rnd.next(5000, 10000);\n        d = rnd.next(1, 10000 -1);\n        L = rnd.next(d + 1, 10000);\n    } else if (type == \"d_equals_L_over_2\") {\n        // to test cases where d is half of L\n        L = rnd.next(2, 5000)*2; // ensure L even\n        d = L / 2;\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else if (type == \"max_values\") {\n        d = 9999;\n        L = 10000;\n        v1 = 10000;\n        v2 = 10000;\n    } else if (type == \"small_values\") {\n        d = rnd.next(1, 10);\n        L = rnd.next(d + 1, 10);\n        v1 = rnd.next(1, 10);\n        v2 = rnd.next(1, 10);\n    } else if (type == \"precision_test\") {\n        // Generate values that cause the time to be a repeating decimal or need high precision\n        d = 1;\n        L = 9999;\n        v1 = 1234;\n        v2 = 5678;\n    } else if (type == \"small_fraction\") {\n        // Generates small time values\n        d = rnd.next(1, 9998);\n        L = d + rnd.next(1, 2); // L just a bit bigger than d\n        v1 = rnd.next(5000, 10000);\n        v2 = rnd.next(5000, 10000);\n    } else if (type == \"large_fraction\") {\n        // Generates large time values\n        d = 1;\n        L = 10000;\n        v1 = 1;\n        v2 = 1;\n    } else if (type == \"small_time\") {\n        // Generates time less than 1e-6\n        d = 9999;\n        L = 10000;\n        v1 = 10000;\n        v2 = 10000;\n    } else if (type == \"large_time\") {\n        // Generates time as large as possible\n        d = 1;\n        L = 10000;\n        v1 = 1;\n        v2 = 1;\n    } else if (type == \"random\") {\n        d = rnd.next(1, 9999);\n        L = rnd.next(d + 1, 10000);\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    } else {\n        // default random\n        d = rnd.next(1, 9999);\n        L = rnd.next(d + 1, 10000);\n        v1 = rnd.next(1, 10000);\n        v2 = rnd.next(1, 10000);\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", d, L, v1, v2);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type max_d\n./gen -type min_d\n./gen -type equal_v\n./gen -type v1_slow\n./gen -type v2_slow\n./gen -type equal_v\n./gen -type v1_slow\n./gen -type v2_slow\n./gen -type max_values\n./gen -type small_values\n./gen -type precision_test\n./gen -type small_fraction\n./gen -type large_fraction\n./gen -type small_time\n./gen -type large_time\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type d_equals_L_over_2\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:00:59.181146",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "624/B",
      "title": "B. Making a String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (2  ≤  n  ≤  26) — the number of letters in the alphabet.The next line contains n integers ai (1 ≤ ai ≤ 109) — i-th of these integers gives the limitation on the number of occurrences of the i-th character in the string.",
      "output_spec": "OutputPrint a single integer — the maximum length of the string that meets all the requirements.",
      "sample_tests": "ExamplesInputCopy32 5 5OutputCopy11InputCopy31 1 2OutputCopy3",
      "description": "B. Making a String\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (2  ≤  n  ≤  26) — the number of letters in the alphabet.The next line contains n integers ai (1 ≤ ai ≤ 109) — i-th of these integers gives the limitation on the number of occurrences of the i-th character in the string.\n\nOutputPrint a single integer — the maximum length of the string that meets all the requirements.\n\nInputCopy32 5 5OutputCopy11InputCopy31 1 2OutputCopy3\n\nInputCopy32 5 5\n\nOutputCopy11\n\nInputCopy31 1 2\n\nOutputCopy3\n\nNoteFor convenience let's consider an alphabet consisting of three letters: \"a\", \"b\", \"c\". In the first sample, some of the optimal strings are: \"cccaabbccbb\", \"aabcbcbcbcb\". In the second sample some of the optimal strings are: \"acc\", \"cbc\".",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Hi, Codeforces!AIM Tech Codeforces Round will take place on February, 4 at 20:05 MSK.The round is prepared by AIM Tech employees: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov and zeliboba. Round will take place during Petrozavodsk Winter Camp, which is sponsored by our company.We made our problems a little easier than at our last Round, but we promise they won’t be less interesting. Scoring system will be static. The final distribution of points will be announced right before the round, however you should note that this time difference in complexity between problems div1 C, D and E may be less than usual so our strong recommendation that you read them all first.Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Gleb Evstropov (GlebsHP) and Maria Belova (Delinur) for English translation.Our company specialises in proprietary trading, the key concepts in our work are big data, low latency and high frequency. Our team mainly consists of graduates from the MSU Faculty of Mechanics and Mathematics and Moscow Institute of Physics and Technology (MIPT).We wish you good luck and high frequency rating!P.S. For all participants of PTZ gathering we are glad to announce evening buffet that will take place at Paulaner Brauhaus and will start Februrary, 5 at 7:30 pmScoringdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250EditorialP.P.S. Author solution of div2A had precision error 5e-7, so we decided to rejudge this problem.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1544
        },
        {
          "title": "AIM Tech Round Tutorial - Codeforces",
          "content": "624A - Save LukeWidth of free space is decreasing by v1 + v2 per second. It means that it'll decrease from L to d in seconds. The moment when width gets a value of d is the last when Luke is alive so t is the answer. 624B - Making a StringSort array in descending order.Iterate over all letters, First letter is added c1 = a1 times, each other letter is added ci = min(ai, ci - 1). Don't forget that if some letter is not added at all, then all next letters are not added too.623A - Graph and String Note that all vertices \"b\" are connected with all other vertices in the graph. Find all such vertices and mark them as \"b\". Now we need to find any unlabeled vertex V, mark it with \"a\" character. Unlabeled vertices connected with V should be also labeled as \"a\". All other vertices we can label as \"c\"Finally we need to check graph validity. Check that all vertices \"a\" are only connected with each other and \"b\" vertices. After that we need to perform a similar check for \"c\" vertices.623B - Array GCDAt least one of ends (a1 or an) is changed by at most 1. It means that if gcd > 1 then it divides on of prime divisors of either a1 - 1, a1, a1 + 1, an - 1, an or an + 1. We will iterate over these primes.Suppose prime p is fixed. For each number we know that it's either divisible by p or we can pay b to fix it or it should be in the subarray to change for aWe can use dynamic programming dp[number of numbers considered][subarray to change not started/started/finished] = minimal costComplexity is O(Nd) = O(Nlog(max(ai)), where d is the number of primes to check.623C - Electric ChargesFirst of all consider cases where all points are projected to the same axis. (In that case answer is difference between maximum and minimum of this coordinate).Now consider leftmost and rightmost points among projected to x axis. Let xL and xR are their x-coordinates. Notice that points with x-coordinate xL ≤ x ≤ xR may also be projected to x-axis and that will not increase the diameter. So, if we sort all points by x-coordinate, we may suppose that points projected to x-axis form a continuous subarray.We will use a binary search. Now we will need to check if it's possible to project point in a such way that diameter is <= M.Let's fix the most distant by x-coordinate point from 0 that is projected to x-axis. It may be to the left or to the right of 0. This cases are symmetrical and we will consider only the former one. Let xL < 0 be its coordinate. Notice that one may project all points such that 0 ≤ x - xL ≤ M and |x| ≤ |xL| to the x axis (and it'll not affect the diameter) and we have to project other points to y-axis. Among all other points we should find the maximum and minimum by y coordinate. Answer is \"yes (diam ≤ M)\" if ymax - ymin <  = M and distance from (xL, 0) to both (0, ymax) and (0, ymin) is not greater than M.Let's precalculate maximums and minimums of y coordinates on each prefix and suffix of original (sorted) points array. Now iterate over left border of subarray of points projected to x-axis and find the right border using binary search or maintain it using two-pointers technique.So we've got one check in O(M) or and entire solution in or 623D - BirthdayLet's denote qi = 1 - pi.Main idea: first of all guess each friend once, then maximize probability to end game on current step. Let's simulate first 300000 steps, and calculate . , where ki — how many times we called i-th friend ().Expectation with some precision equals . So it is enough to prove that:1) Greedy strategy gives maximum values for all Pr(t). 2) On 300000 step precision error will be less than 10 - 6.Proof:1) Suppose, that for some t there exists set li (), not equal to set produced by greedy algorithm ki, gives the maximum value of Pr(t). Let's take some ka < la and kb > lb, it is easy to prove tgat if we change lb to lb + 1, la to la - 1, then new set of li gives bigger value of Pr(t), contradiction.2) qi ≤ 0.99. Let's take set , it gives probability of end of the game not less than optimal. Then Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Precision error does not exceed . It could be estimated as sum of geometric progression. If N ≥ 300000 precision error doesn't exceed 10 - 7.623E - Transforming SequenceFirst observation is that if the sequence of prefix xors is strictly increasing, than on each step ai has at least one new bit comparing to the previous elements. So, since there are overall k bits, the length of the sequence can't be more than k. So, if n > k, the answer is 0. Let's firstly solve the task with O(k3) complexity. We calculate dp[n][k] — the number of sequences of length n such that a1|a2|... |an has k bits. The transition is to add a number with l new bits, and choose those k bits which are already in the prefix xor arbitrarily. So, dp[n + 1][k + l] is increased by dp[n][k]·2k·Ck + ll. The last binomial coefficient complies with the choice these very l bits from k + l which will be present in a1|a2|... |an + 1.Note now that the transition doesn't depend on n, so let's try to use the idea of the binary exponentiation. Suppose we want to merge two dynamics dp1[k], dp2[k], where k is the number of bits present in a1|a2|... |aleft and b1|... |bright correspondingly. Now we want to obtain dp[k] for arrays of size left + right. The formula is: Here l corresponds to the bits present in the xor of the left part, and for each number of the right part we can choose these l bits arbitrarily. Rewrite the formula in the following way: So, we can compute dp[k] for all k having multiplied two polynomials and . We can obtain the coefficients of the first polynomial from the coefficients of the second in . So, we can compute this dynamic programming for all lengths — powers of two, in , using the fast Fourier transform. In fact, it is more convenient to compute using the same equation. After that, we can use the same merge strategy to compute the answer for the given n, using dynamics for the powers of two. Overall complexity is .We decided to ask the answer modulo 109 + 7 to not let the participants easily guess that these problem requires FFT :) So, in order to get accepted you had to implement one of the methods to deal with the large modulo in polynomial multiplication using FFT. Another approach was to apply Karatsuba algorithm, our realisation timed out on our tests, but jqdai0815 somehow made it pass :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 624\\s*B"
          },
          "content_length": 6382
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 26, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 26, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 26, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"min_ai\") {\n        // ai = 1 for all letters\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"max_ai\") {\n        // ai = 1e9\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1000000000;\n    } else if (type == \"equal_ai\") {\n        // ai all equal to some value k\n        int k = opt<int>(\"k\", 1000000000); // default k=1e9\n        for (int i = 0; i < n; ++i)\n            ai[i] = k;\n    } else if (type == \"duplicates\") {\n        // ai with duplicates\n        int k = opt<int>(\"k\", 1000); // max value of ai\n        vector<int> possible_ai;\n        int num_values = rnd.next(1, n);\n        for (int i = 0; i < num_values; ++i)\n            possible_ai.push_back(rnd.next(1, k));\n        for (int i = 0; i < n; ++i)\n            ai[i] = possible_ai[rnd.next(0, (int)possible_ai.size()-1)];\n    } else if (type == \"increasing\") {\n        // ai in increasing order\n        int max_ai = 1000000000;\n        ai[0] = rnd.next(1, max_ai / n);\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i-1] + rnd.next(1, (max_ai - ai[i-1]) / (n - i));\n    } else if (type == \"decreasing\") {\n        // ai in decreasing order\n        int max_ai = 1000000000;\n        ai[0] = rnd.next(n, max_ai);\n        for (int i = 1; i < n; ++i)\n            ai[i] = max(1, ai[i-1] - rnd.next(1, ai[i-1] / (n - i + 1)));\n    } else if (type == \"random\") {\n        // Random ai\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    } else if (type == \"small_random\") {\n        // Random small ai\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 100);\n    } else if (type == \"impossible\") {\n        // ai such that it's impossible to assign distinct counts\n        int k = opt<int>(\"k\", 1);\n        for (int i = 0; i < n; ++i)\n            ai[i] = k;\n    } else {\n        // Default: random ai\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        cout << ai[i];\n        if (i + 1 < n)\n            cout << ' ';\n        else\n            cout << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"min_ai\") {\n        // ai = 1 for all letters\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"max_ai\") {\n        // ai = 1e9\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1000000000;\n    } else if (type == \"equal_ai\") {\n        // ai all equal to some value k\n        int k = opt<int>(\"k\", 1000000000); // default k=1e9\n        for (int i = 0; i < n; ++i)\n            ai[i] = k;\n    } else if (type == \"duplicates\") {\n        // ai with duplicates\n        int k = opt<int>(\"k\", 1000); // max value of ai\n        vector<int> possible_ai;\n        int num_values = rnd.next(1, n);\n        for (int i = 0; i < num_values; ++i)\n            possible_ai.push_back(rnd.next(1, k));\n        for (int i = 0; i < n; ++i)\n            ai[i] = possible_ai[rnd.next(0, (int)possible_ai.size()-1)];\n    } else if (type == \"increasing\") {\n        // ai in increasing order\n        int max_ai = 1000000000;\n        ai[0] = rnd.next(1, max_ai / n);\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i-1] + rnd.next(1, (max_ai - ai[i-1]) / (n - i));\n    } else if (type == \"decreasing\") {\n        // ai in decreasing order\n        int max_ai = 1000000000;\n        ai[0] = rnd.next(n, max_ai);\n        for (int i = 1; i < n; ++i)\n            ai[i] = max(1, ai[i-1] - rnd.next(1, ai[i-1] / (n - i + 1)));\n    } else if (type == \"random\") {\n        // Random ai\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    } else if (type == \"small_random\") {\n        // Random small ai\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 100);\n    } else if (type == \"impossible\") {\n        // ai such that it's impossible to assign distinct counts\n        int k = opt<int>(\"k\", 1);\n        for (int i = 0; i < n; ++i)\n            ai[i] = k;\n    } else {\n        // Default: random ai\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        cout << ai[i];\n        if (i + 1 < n)\n            cout << ' ';\n        else\n            cout << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n, minimum ai\n./gen -n 2 -type min_ai\n\n# Minimum n, maximum ai\n./gen -n 2 -type max_ai\n\n# Maximum n, maximum ai\n./gen -n 26 -type max_ai\n\n# Maximum n, minimum ai\n./gen -n 26 -type min_ai\n\n# Equal ai, small value\n./gen -n 5 -type equal_ai -k 1\n\n# Equal ai, medium value\n./gen -n 10 -type equal_ai -k 1000\n\n# Equal ai, large value\n./gen -n 10 -type equal_ai -k 1000000000\n\n# Duplicates in ai, small values\n./gen -n 10 -type duplicates -k 5\n\n# Duplicates in ai, medium values\n./gen -n 10 -type duplicates -k 1000\n\n# ai in increasing order\n./gen -n 10 -type increasing\n\n# ai in decreasing order\n./gen -n 10 -type decreasing\n\n# Random ai\n./gen -n 10 -type random\n\n# Small random ai\n./gen -n 10 -type small_random\n\n# Max n, random ai\n./gen -n 26 -type random\n\n# Max n, small random ai\n./gen -n 26 -type small_random\n\n# Impossible case (ai all 1)\n./gen -n 5 -type impossible -k 1\n\n# Impossible case with limited ai\n./gen -n 10 -type impossible -k 2\n\n# Random ai with maximum values\n./gen -n 10 -type random\n\n# Random ai with small values\n./gen -n 10 -type small_random\n\n# Edge case: ai with some 1's and some large values\n./gen -n 10 -type random\n\n# Max n, mixed ai values\n./gen -n 26 -type random\n\n# Max n, duplicate ai\n./gen -n 26 -type duplicates -k 1000000000\n\n# Edge case: Only two letters\n./gen -n 2 -type random\n\n# Edge case: Large ai for small n\n./gen -n 2 -type max_ai\n\n# Edge case: Small ai for large n\n./gen -n 26 -type small_random\n\n# Edge case: All ai are large except one\n./gen -n 10 -type random\n\n# Edge case: ai are in random order\n./gen -n 10 -type random\n\n# Edge case: ai sum is small\n./gen -n 5 -type small_random\n\n# Edge case: Maximum total sum of ai\n./gen -n 26 -type max_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:01.021793",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "624/C",
      "title": "C. Graph and String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m  — the number of vertices and edges in the graph found by Petya, respectively.Each of the next m lines contains two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the edges of the graph G. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.",
      "output_spec": "OutputIn the first line print \"Yes\" (without the quotes), if the string s Petya is interested in really exists and \"No\" (without the quotes) otherwise.If the string s exists, then print it on the second line of the output. The length of s must be exactly n, it must consist of only letters \"a\", \"b\" and \"c\" only, and the graph built using this string must coincide with G. If there are multiple possible answers, you may print any of them.",
      "sample_tests": "ExamplesInputCopy2 11 2OutputCopyYesaaInputCopy4 31 21 31 4OutputCopyNo",
      "description": "C. Graph and String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n and m  — the number of vertices and edges in the graph found by Petya, respectively.Each of the next m lines contains two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the edges of the graph G. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.\n\nOutputIn the first line print \"Yes\" (without the quotes), if the string s Petya is interested in really exists and \"No\" (without the quotes) otherwise.If the string s exists, then print it on the second line of the output. The length of s must be exactly n, it must consist of only letters \"a\", \"b\" and \"c\" only, and the graph built using this string must coincide with G. If there are multiple possible answers, you may print any of them.\n\nInputCopy2 11 2OutputCopyYesaaInputCopy4 31 21 31 4OutputCopyNo\n\nInputCopy2 11 2\n\nOutputCopyYesaa\n\nInputCopy4 31 21 31 4\n\nOutputCopyNo\n\nNoteIn the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings \"aa\", \"ab\", \"ba\", \"bb\", \"bc\", \"cb\", \"cc\" meets the graph's conditions. In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Hi, Codeforces!AIM Tech Codeforces Round will take place on February, 4 at 20:05 MSK.The round is prepared by AIM Tech employees: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov and zeliboba. Round will take place during Petrozavodsk Winter Camp, which is sponsored by our company.We made our problems a little easier than at our last Round, but we promise they won’t be less interesting. Scoring system will be static. The final distribution of points will be announced right before the round, however you should note that this time difference in complexity between problems div1 C, D and E may be less than usual so our strong recommendation that you read them all first.Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Gleb Evstropov (GlebsHP) and Maria Belova (Delinur) for English translation.Our company specialises in proprietary trading, the key concepts in our work are big data, low latency and high frequency. Our team mainly consists of graduates from the MSU Faculty of Mechanics and Mathematics and Moscow Institute of Physics and Technology (MIPT).We wish you good luck and high frequency rating!P.S. For all participants of PTZ gathering we are glad to announce evening buffet that will take place at Paulaner Brauhaus and will start Februrary, 5 at 7:30 pmScoringdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250EditorialP.P.S. Author solution of div2A had precision error 5e-7, so we decided to rejudge this problem.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1544
        },
        {
          "title": "AIM Tech Round Tutorial - Codeforces",
          "content": "624A - Save LukeWidth of free space is decreasing by v1 + v2 per second. It means that it'll decrease from L to d in seconds. The moment when width gets a value of d is the last when Luke is alive so t is the answer. 624B - Making a StringSort array in descending order.Iterate over all letters, First letter is added c1 = a1 times, each other letter is added ci = min(ai, ci - 1). Don't forget that if some letter is not added at all, then all next letters are not added too.623A - Graph and String Note that all vertices \"b\" are connected with all other vertices in the graph. Find all such vertices and mark them as \"b\". Now we need to find any unlabeled vertex V, mark it with \"a\" character. Unlabeled vertices connected with V should be also labeled as \"a\". All other vertices we can label as \"c\"Finally we need to check graph validity. Check that all vertices \"a\" are only connected with each other and \"b\" vertices. After that we need to perform a similar check for \"c\" vertices.623B - Array GCDAt least one of ends (a1 or an) is changed by at most 1. It means that if gcd > 1 then it divides on of prime divisors of either a1 - 1, a1, a1 + 1, an - 1, an or an + 1. We will iterate over these primes.Suppose prime p is fixed. For each number we know that it's either divisible by p or we can pay b to fix it or it should be in the subarray to change for aWe can use dynamic programming dp[number of numbers considered][subarray to change not started/started/finished] = minimal costComplexity is O(Nd) = O(Nlog(max(ai)), where d is the number of primes to check.623C - Electric ChargesFirst of all consider cases where all points are projected to the same axis. (In that case answer is difference between maximum and minimum of this coordinate).Now consider leftmost and rightmost points among projected to x axis. Let xL and xR are their x-coordinates. Notice that points with x-coordinate xL ≤ x ≤ xR may also be projected to x-axis and that will not increase the diameter. So, if we sort all points by x-coordinate, we may suppose that points projected to x-axis form a continuous subarray.We will use a binary search. Now we will need to check if it's possible to project point in a such way that diameter is <= M.Let's fix the most distant by x-coordinate point from 0 that is projected to x-axis. It may be to the left or to the right of 0. This cases are symmetrical and we will consider only the former one. Let xL < 0 be its coordinate. Notice that one may project all points such that 0 ≤ x - xL ≤ M and |x| ≤ |xL| to the x axis (and it'll not affect the diameter) and we have to project other points to y-axis. Among all other points we should find the maximum and minimum by y coordinate. Answer is \"yes (diam ≤ M)\" if ymax - ymin <  = M and distance from (xL, 0) to both (0, ymax) and (0, ymin) is not greater than M.Let's precalculate maximums and minimums of y coordinates on each prefix and suffix of original (sorted) points array. Now iterate over left border of subarray of points projected to x-axis and find the right border using binary search or maintain it using two-pointers technique.So we've got one check in O(M) or and entire solution in or 623D - BirthdayLet's denote qi = 1 - pi.Main idea: first of all guess each friend once, then maximize probability to end game on current step. Let's simulate first 300000 steps, and calculate . , where ki — how many times we called i-th friend ().Expectation with some precision equals . So it is enough to prove that:1) Greedy strategy gives maximum values for all Pr(t). 2) On 300000 step precision error will be less than 10 - 6.Proof:1) Suppose, that for some t there exists set li (), not equal to set produced by greedy algorithm ki, gives the maximum value of Pr(t). Let's take some ka < la and kb > lb, it is easy to prove tgat if we change lb to lb + 1, la to la - 1, then new set of li gives bigger value of Pr(t), contradiction.2) qi ≤ 0.99. Let's take set , it gives probability of end of the game not less than optimal. Then Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Precision error does not exceed . It could be estimated as sum of geometric progression. If N ≥ 300000 precision error doesn't exceed 10 - 7.623E - Transforming SequenceFirst observation is that if the sequence of prefix xors is strictly increasing, than on each step ai has at least one new bit comparing to the previous elements. So, since there are overall k bits, the length of the sequence can't be more than k. So, if n > k, the answer is 0. Let's firstly solve the task with O(k3) complexity. We calculate dp[n][k] — the number of sequences of length n such that a1|a2|... |an has k bits. The transition is to add a number with l new bits, and choose those k bits which are already in the prefix xor arbitrarily. So, dp[n + 1][k + l] is increased by dp[n][k]·2k·Ck + ll. The last binomial coefficient complies with the choice these very l bits from k + l which will be present in a1|a2|... |an + 1.Note now that the transition doesn't depend on n, so let's try to use the idea of the binary exponentiation. Suppose we want to merge two dynamics dp1[k], dp2[k], where k is the number of bits present in a1|a2|... |aleft and b1|... |bright correspondingly. Now we want to obtain dp[k] for arrays of size left + right. The formula is: Here l corresponds to the bits present in the xor of the left part, and for each number of the right part we can choose these l bits arbitrarily. Rewrite the formula in the following way: So, we can compute dp[k] for all k having multiplied two polynomials and . We can obtain the coefficients of the first polynomial from the coefficients of the second in . So, we can compute this dynamic programming for all lengths — powers of two, in , using the fast Fourier transform. In fact, it is more convenient to compute using the same equation. After that, we can use the same merge strategy to compute the answer for the given n, using dynamics for the powers of two. Overall complexity is .We decided to ask the answer modulo 109 + 7 to not let the participants easily guess that these problem requires FFT :) So, in order to get accepted you had to implement one of the methods to deal with the large modulo in polynomial multiplication using FFT. Another approach was to apply Karatsuba algorithm, our realisation timed out on our tests, but jqdai0815 somehow made it pass :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 624 和字母"
          },
          "content_length": 6382
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u (%d) should not equal v (%d)\", i+1, u, v);\n        pair<int,int> edge = make_pair(min(u,v), max(u,v));\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Edge %d: duplicate edge between %d and %d found\", i+1, u, v);\n        edgeSet.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u (%d) should not equal v (%d)\", i+1, u, v);\n        pair<int,int> edge = make_pair(min(u,v), max(u,v));\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Edge %d: duplicate edge between %d and %d found\", i+1, u, v);\n        edgeSet.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u (%d) should not equal v (%d)\", i+1, u, v);\n        pair<int,int> edge = make_pair(min(u,v), max(u,v));\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Edge %d: duplicate edge between %d and %d found\", i+1, u, v);\n        edgeSet.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nset<pair<int,int>> edges;\n\n// Checks if a string s of length n (with chars in {a,b,c}) reconstructs\n// exactly the graph described by the stored edges.\nbool checkStringValid(const string &s)\n{\n    // Partition vertices by assigned letters\n    vector<int> A, B, C;\n    A.reserve(n);\n    B.reserve(n);\n    C.reserve(n);\n\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        if      (c == 'a') A.push_back(i+1);\n        else if (c == 'b') B.push_back(i+1);\n        else if (c == 'c') C.push_back(i+1);\n        else return false; // invalid character\n    }\n\n    // Helper for edges in a complete subgraph of k vertices\n    auto completeEdges = [&](long long k){\n        return k * (k - 1) / 2;\n    };\n\n    // Count how many edges s should create:\n    // 1) edges among same letters (complete subgraphs)\n    // 2) edges between 'neighbor' letters (a<->b, b<->c)\n    long long forced = 0;\n    forced += completeEdges((long long)A.size());\n    forced += completeEdges((long long)B.size());\n    forced += completeEdges((long long)C.size());\n    // neighbor cross-edges: (a,b) and (b,c)\n    forced += (long long)A.size() * (long long)B.size();\n    forced += (long long)B.size() * (long long)C.size();\n    // (a,c) are not neighbors => no edges\n\n    if (forced != m)\n        return false;\n\n    // Ensure each input edge is valid: same or neighbor letters\n    auto neighborOrSame = [&](char x, char y){\n        if (x == y) return true;\n        if ((x == 'a' && y == 'b') || (x == 'b' && y == 'a')) return true;\n        if ((x == 'b' && y == 'c') || (x == 'c' && y == 'b')) return true;\n        return false;\n    };\n\n    for (auto &ed : edges) {\n        int u = ed.first;\n        int v = ed.second;\n        // Indices in s are 0-based, so we use u-1, v-1\n        if (!neighborOrSame(s[u - 1], s[v - 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read graph from 'inf'\n    n = inf.readInt(1, 100000, \"n\");\n    m = inf.readInt(0, 200000, \"m\");\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        int v = inf.readInt(1, n, \"v\");\n        if (u == v) {\n            inf.quitf(_fail, \"Found a self-loop (u == v), which is disallowed.\");\n        }\n        if (u > v) swap(u, v);\n        if (!edges.insert({u, v}).second) {\n            inf.quitf(_fail, \"Duplicate edge found in the input.\");\n        }\n    }\n    // No readEof() to avoid any environment issues.\n\n    // 2) Read participant answer from 'ouf'\n    string verdict = ouf.readToken(\"^(Yes|No)$\", \"verdict\");\n    if (verdict == \"No\") {\n        // Accept \"No\" immediately, no further checks\n        quitf(_ok, \"Participant answered No; accepted without validation.\");\n    }\n\n    // If \"Yes\", read exactly one more token: s\n    string s = ouf.readToken(\"[abc]{\"+ to_string(n) +\"}\", \"assignment_string\");\n\n    // Check that s reproduces the given graph exactly\n    if (!checkStringValid(s)) {\n        quitf(_wa, \"Provided string does not reconstruct the graph as required.\");\n    }\n\n    // If all checks pass\n    quitf(_ok, \"Valid solution for the given graph.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring letters = \"abc\";\nmap<char, set<char>> neighbor;\n\nvoid init_neighbors() {\n    neighbor['a'].insert('a');\n    neighbor['a'].insert('b');\n    neighbor['b'].insert('a');\n    neighbor['b'].insert('b');\n    neighbor['b'].insert('c');\n    neighbor['c'].insert('b');\n    neighbor['c'].insert('c');\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize neighbor map\n    init_neighbors();\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"complete\") {\n        // Generate complete graph\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                edges.push_back({i, j});\n    } else if (type == \"empty\") {\n        // No edges\n        // Do nothing\n    } else if (type == \"random_valid\") {\n        // Generate random string s\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)];\n        }\n\n        // Build edges according to s\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j) {\n                char si = s[i - 1], sj = s[j - 1];\n                if (neighbor[si].count(sj)) {\n                    // Edge exists\n                    edges.push_back({i, j});\n                }\n            }\n    } else if (type == \"random_invalid\") {\n        // Generate a random graph that is likely to be invalid\n        // Generate a random graph and make modifications to invalidate it\n        // Start with a valid graph and then add or remove edges\n        // For simplicity, here we generate a random graph\n\n        int max_edges = n * (n - 1) / 2;\n        int m = rnd.next(1, max_edges);  // Random number of edges between 1 and max_edges\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u, v);\n                int b = max(u, v);\n                edge_set.insert({a, b});\n            }\n        }\n        edges = vector<pair<int, int>>(edge_set.begin(), edge_set.end());\n\n    } else if (type == \"max_edges\") {\n        // Generate a graph with almost maximum edges but not complete\n        int max_edges = n * (n - 1) / 2;\n        int m = max_edges - rnd.next(1, min(n, 10));  // Subtract a small random number\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u, v);\n                int b = max(u, v);\n                edge_set.insert({a, b});\n            }\n        }\n        edges = vector<pair<int, int>>(edge_set.begin(), edge_set.end());\n\n    } else if (type == \"min_edges\") {\n        // Generate a sparse graph\n        int m = rnd.next(1, n);  // Small number of edges\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u, v);\n                int b = max(u, v);\n                edge_set.insert({a, b});\n            }\n        }\n        edges = vector<pair<int, int>>(edge_set.begin(), edge_set.end());\n    } else if (type == \"special_no\") {\n        // Construct a graph that cannot satisfy the conditions\n        // For example, create a triangle between nodes that must not be connected\n        n = opt<int>(\"n\", 3);\n        n = max(n, 3); // Ensure n >= 3\n\n        // Create a complete graph with 3 nodes which cannot be labeled appropriately\n        edges.push_back({1, 2});\n        edges.push_back({2, 3});\n        edges.push_back({1, 3});\n        \n        // If n > 3, connect the rest nodes randomly to make the graph invalid\n        for (int i = 4; i <= n; ++i) {\n            edges.push_back({1, i});\n            edges.push_back({2, i});\n            edges.push_back({3, i});\n        }\n\n    } else if (type == \"small\") {\n        // Small n, random valid graph\n        n = rnd.next(1, 5);\n        // Generate random string s\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)];\n        }\n\n        // Build edges according to s\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j) {\n                char si = s[i - 1], sj = s[j - 1];\n                if (neighbor[si].count(sj)) {\n                    // Edge exists\n                    edges.push_back({i, j});\n                }\n            }\n\n    } else {\n        // Default is random_valid\n        // Generate random string s\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)];\n        }\n\n        // Build edges according to s\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j) {\n                char si = s[i - 1], sj = s[j - 1];\n                if (neighbor[si].count(sj)) {\n                    // Edge exists\n                    edges.push_back({i, j});\n                }\n            }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring letters = \"abc\";\nmap<char, set<char>> neighbor;\n\nvoid init_neighbors() {\n    neighbor['a'].insert('a');\n    neighbor['a'].insert('b');\n    neighbor['b'].insert('a');\n    neighbor['b'].insert('b');\n    neighbor['b'].insert('c');\n    neighbor['c'].insert('b');\n    neighbor['c'].insert('c');\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize neighbor map\n    init_neighbors();\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"complete\") {\n        // Generate complete graph\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                edges.push_back({i, j});\n    } else if (type == \"empty\") {\n        // No edges\n        // Do nothing\n    } else if (type == \"random_valid\") {\n        // Generate random string s\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)];\n        }\n\n        // Build edges according to s\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j) {\n                char si = s[i - 1], sj = s[j - 1];\n                if (neighbor[si].count(sj)) {\n                    // Edge exists\n                    edges.push_back({i, j});\n                }\n            }\n    } else if (type == \"random_invalid\") {\n        // Generate a random graph that is likely to be invalid\n        // Generate a random graph and make modifications to invalidate it\n        // Start with a valid graph and then add or remove edges\n        // For simplicity, here we generate a random graph\n\n        int max_edges = n * (n - 1) / 2;\n        int m = rnd.next(1, max_edges);  // Random number of edges between 1 and max_edges\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u, v);\n                int b = max(u, v);\n                edge_set.insert({a, b});\n            }\n        }\n        edges = vector<pair<int, int>>(edge_set.begin(), edge_set.end());\n\n    } else if (type == \"max_edges\") {\n        // Generate a graph with almost maximum edges but not complete\n        int max_edges = n * (n - 1) / 2;\n        int m = max_edges - rnd.next(1, min(n, 10));  // Subtract a small random number\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u, v);\n                int b = max(u, v);\n                edge_set.insert({a, b});\n            }\n        }\n        edges = vector<pair<int, int>>(edge_set.begin(), edge_set.end());\n\n    } else if (type == \"min_edges\") {\n        // Generate a sparse graph\n        int m = rnd.next(1, n);  // Small number of edges\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                int a = min(u, v);\n                int b = max(u, v);\n                edge_set.insert({a, b});\n            }\n        }\n        edges = vector<pair<int, int>>(edge_set.begin(), edge_set.end());\n    } else if (type == \"special_no\") {\n        // Construct a graph that cannot satisfy the conditions\n        // For example, create a triangle between nodes that must not be connected\n        n = opt<int>(\"n\", 3);\n        n = max(n, 3); // Ensure n >= 3\n\n        // Create a complete graph with 3 nodes which cannot be labeled appropriately\n        edges.push_back({1, 2});\n        edges.push_back({2, 3});\n        edges.push_back({1, 3});\n        \n        // If n > 3, connect the rest nodes randomly to make the graph invalid\n        for (int i = 4; i <= n; ++i) {\n            edges.push_back({1, i});\n            edges.push_back({2, i});\n            edges.push_back({3, i});\n        }\n\n    } else if (type == \"small\") {\n        // Small n, random valid graph\n        n = rnd.next(1, 5);\n        // Generate random string s\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)];\n        }\n\n        // Build edges according to s\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j) {\n                char si = s[i - 1], sj = s[j - 1];\n                if (neighbor[si].count(sj)) {\n                    // Edge exists\n                    edges.push_back({i, j});\n                }\n            }\n\n    } else {\n        // Default is random_valid\n        // Generate random string s\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(3)];\n        }\n\n        // Build edges according to s\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j) {\n                char si = s[i - 1], sj = s[j - 1];\n                if (neighbor[si].count(sj)) {\n                    // Edge exists\n                    edges.push_back({i, j});\n                }\n            }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type small\n./gen -n 2 -type small\n./gen -n 3 -type small\n./gen -n 5 -type small\n\n./gen -n 10 -type random_valid\n./gen -n 10 -type random_invalid\n\n./gen -n 50 -type complete\n./gen -n 50 -type empty\n\n./gen -n 100 -type random_valid\n./gen -n 100 -type random_invalid\n\n./gen -n 200 -type max_edges\n./gen -n 200 -type min_edges\n\n./gen -n 300 -type random_valid\n./gen -n 300 -type random_invalid\n\n./gen -n 500 -type complete\n./gen -n 500 -type empty\n\n./gen -n 500 -type max_edges\n./gen -n 500 -type min_edges\n\n./gen -n 400 -type random_valid\n./gen -n 400 -type random_invalid\n\n./gen -n 3 -type special_no\n./gen -n 4 -type special_no\n\n./gen -n 100 -type special_no\n./gen -n 500 -type special_no\n\n./gen -n 499 -type random_valid\n./gen -n 499 -type random_invalid\n\n./gen -n 1 -type empty\n./gen -n 500 -type random_valid\n./gen -n 500 -type random_invalid\n\n./gen -n 100 -type min_edges\n./gen -n 100 -type max_edges\n\n./gen -n 250 -type random_valid\n./gen -n 250 -type random_invalid\n\n./gen -n 6 -type small\n./gen -n 7 -type small\n\n./gen -n 3 -type special_no\n./gen -n 5 -type special_no\n\n./gen -n 50 -type random_valid\n./gen -n 50 -type random_invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:02.837194",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "624/D",
      "title": "D. Array GCD",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n, a and b (1 ≤ n ≤ 1 000 000, 0 ≤ a, b ≤ 109) — the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively.The second line contains n integers ai (2 ≤ ai ≤ 109) — elements of the array.",
      "output_spec": "OutputPrint a single number — the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.",
      "sample_tests": "ExamplesInputCopy3 1 44 2 3OutputCopy1InputCopy5 3 25 17 13 5 6OutputCopy8InputCopy8 3 43 7 5 4 3 12 9 4OutputCopy13",
      "description": "D. Array GCD\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers n, a and b (1 ≤ n ≤ 1 000 000, 0 ≤ a, b ≤ 109) — the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively.The second line contains n integers ai (2 ≤ ai ≤ 109) — elements of the array.\n\nOutputPrint a single number — the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.\n\nInputCopy3 1 44 2 3OutputCopy1InputCopy5 3 25 17 13 5 6OutputCopy8InputCopy8 3 43 7 5 4 3 12 9 4OutputCopy13\n\nInputCopy3 1 44 2 3\n\nOutputCopy1\n\nInputCopy5 3 25 17 13 5 6\n\nOutputCopy8\n\nInputCopy8 3 43 7 5 4 3 12 9 4\n\nOutputCopy13\n\nNoteIn the first sample the optimal way is to remove number 3 and pay 1 coin for it.In the second sample you need to remove a segment [17, 13] and then decrease number 6. The cost of these changes is equal to 2·3 + 2 = 8 coins.",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Hi, Codeforces!AIM Tech Codeforces Round will take place on February, 4 at 20:05 MSK.The round is prepared by AIM Tech employees: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov and zeliboba. Round will take place during Petrozavodsk Winter Camp, which is sponsored by our company.We made our problems a little easier than at our last Round, but we promise they won’t be less interesting. Scoring system will be static. The final distribution of points will be announced right before the round, however you should note that this time difference in complexity between problems div1 C, D and E may be less than usual so our strong recommendation that you read them all first.Thanks to Mike Mirzayanov(MikeMirzayanov) for brilliant platforms Polygon and Codeforces, problem coordinator Gleb Evstropov (GlebsHP) and Maria Belova (Delinur) for English translation.Our company specialises in proprietary trading, the key concepts in our work are big data, low latency and high frequency. Our team mainly consists of graduates from the MSU Faculty of Mechanics and Mathematics and Moscow Institute of Physics and Technology (MIPT).We wish you good luck and high frequency rating!P.S. For all participants of PTZ gathering we are glad to announce evening buffet that will take place at Paulaner Brauhaus and will start Februrary, 5 at 7:30 pmScoringdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250EditorialP.P.S. Author solution of div2A had precision error 5e-7, so we decided to rejudge this problem.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1544
        },
        {
          "title": "AIM Tech Round Tutorial - Codeforces",
          "content": "624A - Save LukeWidth of free space is decreasing by v1 + v2 per second. It means that it'll decrease from L to d in seconds. The moment when width gets a value of d is the last when Luke is alive so t is the answer. 624B - Making a StringSort array in descending order.Iterate over all letters, First letter is added c1 = a1 times, each other letter is added ci = min(ai, ci - 1). Don't forget that if some letter is not added at all, then all next letters are not added too.623A - Graph and String Note that all vertices \"b\" are connected with all other vertices in the graph. Find all such vertices and mark them as \"b\". Now we need to find any unlabeled vertex V, mark it with \"a\" character. Unlabeled vertices connected with V should be also labeled as \"a\". All other vertices we can label as \"c\"Finally we need to check graph validity. Check that all vertices \"a\" are only connected with each other and \"b\" vertices. After that we need to perform a similar check for \"c\" vertices.623B - Array GCDAt least one of ends (a1 or an) is changed by at most 1. It means that if gcd > 1 then it divides on of prime divisors of either a1 - 1, a1, a1 + 1, an - 1, an or an + 1. We will iterate over these primes.Suppose prime p is fixed. For each number we know that it's either divisible by p or we can pay b to fix it or it should be in the subarray to change for aWe can use dynamic programming dp[number of numbers considered][subarray to change not started/started/finished] = minimal costComplexity is O(Nd) = O(Nlog(max(ai)), where d is the number of primes to check.623C - Electric ChargesFirst of all consider cases where all points are projected to the same axis. (In that case answer is difference between maximum and minimum of this coordinate).Now consider leftmost and rightmost points among projected to x axis. Let xL and xR are their x-coordinates. Notice that points with x-coordinate xL ≤ x ≤ xR may also be projected to x-axis and that will not increase the diameter. So, if we sort all points by x-coordinate, we may suppose that points projected to x-axis form a continuous subarray.We will use a binary search. Now we will need to check if it's possible to project point in a such way that diameter is <= M.Let's fix the most distant by x-coordinate point from 0 that is projected to x-axis. It may be to the left or to the right of 0. This cases are symmetrical and we will consider only the former one. Let xL < 0 be its coordinate. Notice that one may project all points such that 0 ≤ x - xL ≤ M and |x| ≤ |xL| to the x axis (and it'll not affect the diameter) and we have to project other points to y-axis. Among all other points we should find the maximum and minimum by y coordinate. Answer is \"yes (diam ≤ M)\" if ymax - ymin <  = M and distance from (xL, 0) to both (0, ymax) and (0, ymin) is not greater than M.Let's precalculate maximums and minimums of y coordinates on each prefix and suffix of original (sorted) points array. Now iterate over left border of subarray of points projected to x-axis and find the right border using binary search or maintain it using two-pointers technique.So we've got one check in O(M) or and entire solution in or 623D - BirthdayLet's denote qi = 1 - pi.Main idea: first of all guess each friend once, then maximize probability to end game on current step. Let's simulate first 300000 steps, and calculate . , where ki — how many times we called i-th friend ().Expectation with some precision equals . So it is enough to prove that:1) Greedy strategy gives maximum values for all Pr(t). 2) On 300000 step precision error will be less than 10 - 6.Proof:1) Suppose, that for some t there exists set li (), not equal to set produced by greedy algorithm ki, gives the maximum value of Pr(t). Let's take some ka < la and kb > lb, it is easy to prove tgat if we change lb to lb + 1, la to la - 1, then new set of li gives bigger value of Pr(t), contradiction.2) qi ≤ 0.99. Let's take set , it gives probability of end of the game not less than optimal. Then Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Precision error does not exceed . It could be estimated as sum of geometric progression. If N ≥ 300000 precision error doesn't exceed 10 - 7.623E - Transforming SequenceFirst observation is that if the sequence of prefix xors is strictly increasing, than on each step ai has at least one new bit comparing to the previous elements. So, since there are overall k bits, the length of the sequence can't be more than k. So, if n > k, the answer is 0. Let's firstly solve the task with O(k3) complexity. We calculate dp[n][k] — the number of sequences of length n such that a1|a2|... |an has k bits. The transition is to add a number with l new bits, and choose those k bits which are already in the prefix xor arbitrarily. So, dp[n + 1][k + l] is increased by dp[n][k]·2k·Ck + ll. The last binomial coefficient complies with the choice these very l bits from k + l which will be present in a1|a2|... |an + 1.Note now that the transition doesn't depend on n, so let's try to use the idea of the binary exponentiation. Suppose we want to merge two dynamics dp1[k], dp2[k], where k is the number of bits present in a1|a2|... |aleft and b1|... |bright correspondingly. Now we want to obtain dp[k] for arrays of size left + right. The formula is: Here l corresponds to the bits present in the xor of the left part, and for each number of the right part we can choose these l bits arbitrarily. Rewrite the formula in the following way: So, we can compute dp[k] for all k having multiplied two polynomials and . We can obtain the coefficients of the first polynomial from the coefficients of the second in . So, we can compute this dynamic programming for all lengths — powers of two, in , using the fast Fourier transform. In fact, it is more convenient to compute using the same equation. After that, we can use the same merge strategy to compute the answer for the given n, using dynamics for the powers of two. Overall complexity is .We decided to ask the answer modulo 109 + 7 to not let the participants easily guess that these problem requires FFT :) So, in order to get accepted you had to implement one of the methods to deal with the large modulo in polynomial multiplication using FFT. Another approach was to apply Karatsuba algorithm, our realisation timed out on our tests, but jqdai0815 somehow made it pass :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 624 和字母"
          },
          "content_length": 6382
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N_MAX = 1'000'000;\n    const int A_B_MAX = 1'000'000'000;\n    const int AI_MIN = 2;\n    const int AI_MAX = 1'000'000'000;\n\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(0, A_B_MAX, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, A_B_MAX, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) inf.readSpace();\n        int ai = inf.readInt(AI_MIN, AI_MAX, \"ai\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N_MAX = 1'000'000;\n    const int A_B_MAX = 1'000'000'000;\n    const int AI_MIN = 2;\n    const int AI_MAX = 1'000'000'000;\n\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(0, A_B_MAX, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, A_B_MAX, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) inf.readSpace();\n        int ai = inf.readInt(AI_MIN, AI_MAX, \"ai\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N_MAX = 1'000'000;\n    const int A_B_MAX = 1'000'000'000;\n    const int AI_MIN = 2;\n    const int AI_MAX = 1'000'000'000;\n\n    int n = inf.readInt(1, N_MAX, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(0, A_B_MAX, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, A_B_MAX, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) inf.readSpace();\n        int ai = inf.readInt(AI_MIN, AI_MAX, \"ai\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", rnd.next(0, int(1e9)));\n    int b = opt<int>(\"b\", rnd.next(0, int(1e9)));\n\n    vector<int> ai(n);\n\n    if (type == \"all_same\") {\n        /* All elements are the same random value */\n        int val = rnd.next(2, int(1e9));\n        fill(ai.begin(), ai.end(), val);\n    } else if (type == \"all_primes\") {\n        /* All elements are large prime numbers */\n        vector<int> bigPrimes = {999999937, 999999929, 999999893, 999999883, 999999797, 999999761};\n        int val = bigPrimes[rnd.next(0, (int)bigPrimes.size() - 1)];\n        fill(ai.begin(), ai.end(), val);\n    } else if (type == \"gcd_one\") {\n        /* Generate array with GCD equal to 1 */\n        ai[0] = 2;\n        ai[1] = 3;\n        for(int i = 2; i < n; ++i)\n            ai[i] = rnd.next(2, int(1e9));\n    } else if (type == \"already_good\") {\n        /* GCD of the array is greater than 1 */\n        int val = rnd.next(2, int(5e8));\n        for(int i = 0; i < n; ++i)\n            ai[i] = val * rnd.next(1, 10);\n    } else if (type == \"one_off\") {\n        /* All elements are the same except one */\n        int val1 = rnd.next(2, int(1e9 - 2));\n        int val2 = val1 + rnd.next(1, 2); // Different by 1 or 2\n        for(int i = 0; i < n; ++i)\n            ai[i] = val1;\n        ai[rnd.next(0, n - 1)] = val2;\n    } else if (type == \"max_ai\") {\n        /* All elements are maximum allowed value */\n        fill(ai.begin(), ai.end(), int(1e9));\n    } else if (type == \"min_ai\") {\n        /* All elements are minimum allowed value */\n        fill(ai.begin(), ai.end(), 2);\n    } else if (type == \"worst_case\") {\n        /* Worst-case scenario for the problem */\n        int val = 999999937; // Large prime\n        fill(ai.begin(), ai.end(), val);\n        if (n >= 2) {\n            ai[0] = val - 1;\n            ai[1] = val + 1;\n        }\n    } else {\n        /* Random values */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(2, int(1e9));\n    }\n\n    printf(\"%d %d %d\\n\", n, a, b);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", rnd.next(0, int(1e9)));\n    int b = opt<int>(\"b\", rnd.next(0, int(1e9)));\n\n    vector<int> ai(n);\n\n    if (type == \"all_same\") {\n        /* All elements are the same random value */\n        int val = rnd.next(2, int(1e9));\n        fill(ai.begin(), ai.end(), val);\n    } else if (type == \"all_primes\") {\n        /* All elements are large prime numbers */\n        vector<int> bigPrimes = {999999937, 999999929, 999999893, 999999883, 999999797, 999999761};\n        int val = bigPrimes[rnd.next(0, (int)bigPrimes.size() - 1)];\n        fill(ai.begin(), ai.end(), val);\n    } else if (type == \"gcd_one\") {\n        /* Generate array with GCD equal to 1 */\n        ai[0] = 2;\n        ai[1] = 3;\n        for(int i = 2; i < n; ++i)\n            ai[i] = rnd.next(2, int(1e9));\n    } else if (type == \"already_good\") {\n        /* GCD of the array is greater than 1 */\n        int val = rnd.next(2, int(5e8));\n        for(int i = 0; i < n; ++i)\n            ai[i] = val * rnd.next(1, 10);\n    } else if (type == \"one_off\") {\n        /* All elements are the same except one */\n        int val1 = rnd.next(2, int(1e9 - 2));\n        int val2 = val1 + rnd.next(1, 2); // Different by 1 or 2\n        for(int i = 0; i < n; ++i)\n            ai[i] = val1;\n        ai[rnd.next(0, n - 1)] = val2;\n    } else if (type == \"max_ai\") {\n        /* All elements are maximum allowed value */\n        fill(ai.begin(), ai.end(), int(1e9));\n    } else if (type == \"min_ai\") {\n        /* All elements are minimum allowed value */\n        fill(ai.begin(), ai.end(), 2);\n    } else if (type == \"worst_case\") {\n        /* Worst-case scenario for the problem */\n        int val = 999999937; // Large prime\n        fill(ai.begin(), ai.end(), val);\n        if (n >= 2) {\n            ai[0] = val - 1;\n            ai[1] = val + 1;\n        }\n    } else {\n        /* Random values */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(2, int(1e9));\n    }\n\n    printf(\"%d %d %d\\n\", n, a, b);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -a 0 -b 0 -type min_ai\n./gen -n 1 -a 1 -b 1 -type min_ai\n./gen -n 1 -a 1000000000 -b 1000000000 -type max_ai\n\n./gen -n 2 -a 0 -b 0 -type gcd_one\n./gen -n 2 -a 1000000000 -b 1000000000 -type gcd_one\n./gen -n 2 -a 0 -b 0 -type already_good\n\n./gen -n 10 -a 0 -b 0 -type all_same\n./gen -n 10 -a 1000000000 -b 1000000000 -type all_same\n\n./gen -n 10 -a 1000000000 -b 0 -type one_off\n./gen -n 10 -a 0 -b 1000000000 -type one_off\n\n./gen -n 1000 -a 0 -b 0 -type random\n./gen -n 1000 -a 1000000000 -b 1000000000 -type random\n\n./gen -n 1000000 -a 0 -b 0 -type random\n./gen -n 1000000 -a 1 -b 1 -type random\n./gen -n 1000000 -a 1000000000 -b 1000000000 -type random\n\n./gen -n 1000000 -a 0 -b 1000000000 -type max_ai\n./gen -n 1000000 -a 1000000000 -b 0 -type min_ai\n\n./gen -n 1000000 -a 0 -b 1000000000 -type gcd_one\n./gen -n 1000000 -a 1000000000 -b 0 -type already_good\n\n./gen -n 3 -a 1 -b 4 -type random\n./gen -n 5 -a 3 -b 2 -type random\n./gen -n 8 -a 3 -b 4 -type random\n\n./gen -n 100 -a 0 -b 0 -type worst_case\n./gen -n 1000000 -a 1 -b 1 -type worst_case\n./gen -n 1000000 -a 1000000000 -b 1000000000 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:04.888015",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "624/E",
      "title": "E. Электрические заряды",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 100 000) — количество точек.Каждая из последующих n строк содержит два целых числа xi и yi ( - 108 ≤ xi, yi ≤ 108) — координаты i-й точки. Гарантируется, что никакие две точки не совпадают.",
      "output_spec": "Выходные данныеВыведите одно целое число — квадрат минимального возможного диаметра множества, после того как Вася расставит в заданные точки электроны и протоны и лаборант включит время.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 101 201 30Выходные данныеСкопировать0Входные данныеСкопировать21 1010 1Выходные данныеСкопировать2",
      "description": "E. Электрические заряды\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано единственное целое число n (1 ≤ n ≤ 100 000) — количество точек.Каждая из последующих n строк содержит два целых числа xi и yi ( - 108 ≤ xi, yi ≤ 108) — координаты i-й точки. Гарантируется, что никакие две точки не совпадают.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — квадрат минимального возможного диаметра множества, после того как Вася расставит в заданные точки электроны и протоны и лаборант включит время.\n\nВыходные данные\n\nВходные данныеСкопировать31 101 201 30Выходные данныеСкопировать0Входные данныеСкопировать21 1010 1Выходные данныеСкопировать2\n\nВходные данныеСкопировать31 101 201 30\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 1010 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Саня помещает во все точки электроны, и все частицы в итоге попадают в одну точку (1, 0).Во втором примере Саня помещает в точку (1, 10) электрон, а в точку (10, 1) — протон. В результате получается множество из двух точек (1, 0) и (0, 1), которое имеет диаметр .",
      "solutions": [
        {
          "title": "AIM Tech Round 2 - Codeforces",
          "content": "Привет, Codeforces!4 февраля, в четверг, в 20:05 MSK состоится AIM Tech Codeforces Round.Раунд подготовили для вас сотрудники компании AIM Tech: Kostroma, riadwaw, yarrr, ArtDitel, ValenKof, bobrdobr, agul, gchebanov и zeliboba. Раунд пройдет во время Петрозаводских сборов, спонсорами которых наша компания стала в этом году.В каждом из дивизионов участникам будет предложено пять задач и два часа на их решение. Разбалловка будет статическая.Мы постарались сделать задачи проще, чем в прошлый наш раунд, но не менее интересными. Окончательная разбалловка будет опубликована прямо перед раундом, но сразу сообщу, что сложности задач C,D,E первого дивизиона отличаются меньше обычного, поэтому рекомендуем сначала прочитать их все. Благодарим Михаила Мирзаянова (MikeMirzayanov) за замечательные платформы Polygon и Codeforces, координатора задач Codeforces Глеба Евстропова (GlebsHP) и Марию Белову (Delinur) за перевод условий на английский.Наша компания занимается проп-трейдингом, ключевыми понятиями в нашей работе являются big data, low latency и high frequency. В нашей работе важно алгоритмическое мышление и умение писать эффективный C++ код, поэтому у нас работает много спортивных программистов. Чтобы придумывать hft-стратегии нужно обладать хорошей математической интуицией и умением подходить к задаче с разных сторон, поэтому их созданием в нашей компании занимаются в основном олимпиадники-математики. В свободное от работы время мы участвуем в разных соревнованиях по программированию и не только, вместе ходим в походы и путешествуем. Прочитать подробнее про нас и наши вакансии можно на сайте aimtech.com. Можно отправить нам резюме через эту форму, даже если вы не участвуете в раунде.Всем удачи и высокого рейтинга!P.S. Для участников петрозаводских сборов в пятницу 5 февраля в 19.30 вечера будет организован фуршет в Пауланер Бройхаус.Разбалловкаdiv2: 500 — 1000 — 1500 — 2000 — 3000div1: 500 — 1000 — 1750 — 2000 — 2250РазборP.P.S. Авторское решение div2A имело погрешность 5e-7, поэтому мы решили пореджаджить эту задачу.",
          "author": "zeliboba",
          "url": "https://codeforces.com/blog/entry/23240",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2046
        },
        {
          "title": "Разбор AIM Tech Round - Codeforces",
          "content": "624A - Спасти ЛюкаЗа единицу времени ширина полосы уменьшается на v1 + v2. Это значит, что она уменьшится от L до d за . Тот момент, когда ширина стала равна d — последний, когда Люк еще живет, значит t — это ответ.624B - Составить строкуОтсортируем кол-ва букв по невозрастанию.Очередную букву берем столько раз, сколько можно, но строго меньше, чем предыдущую. Не забываем, что если предыдущая буква не взята вообще, то все следующие тоже взяты не будут.623A - Граф и строкаЗаметим, что вершины \"b\" связаны со всеми остальными вершинами в графе. Найдём все подобные вершины и отметим их символом \"b\". После этого найдём любую непомеченную вершину V, пометим её символом \"a\". Все непомеченные вершины, которые связаны с V, тоже должны быть помечены символом \"a\". Все остальные непомеченные вершины в графе отметим символом \"c\".Теперь нужно проверить корректность графа, т.е. убедиться, что все вершины \"a\" связаны только между собой и с вершинами \"b\". Аналогично проверим все вершины \"c\".623B - НОД массиваХотя бы один из концов (a1 или an) изменится не больше, чем на 1. А это значит, что если gcd будет не равен 1, то он будет делиться на один из простых делителей одного из чисел a1 - 1, a1, a1 + 1, an - 1, an, an + 1. Переберём это простое.Пусть фиксировано простое p, тогда для каждого числа мы знаем, что оно, либо уже делится на p, либо его можно поправить за b, либо оно должно входить в массив-результат.После этого, можно запустить динамику dp[кол-во чисел, которое рассмотрели][отрезок для изменения за a еще не начался/начался/закончился] = минимальная стоимостьИтоговая сложность O(Nd) = O(NlogN), где d — количество простых делителей для перебора623C - Электрические зарядыРассмотрим сперва отдельно случаи, когда все точки спроецированы на одну ось (Тогда ответ — разница между максимумом и минимумом по одной из координат)Далее, рассмотрим самую левую и самую правую точку из тех, что спроецированы на ось x. Пусть их координаты xL и xR. Заметим, что все точки с координатами xL ≤ x ≤ xR также можно спроецировать на ось x, это не увеличит диаметр. Таким образом, если отсортировать точки по x-координате, можно считать, что точки спроецированные на ось x образуют подотрезок (непрерывный подмассив).Запустим бинарный поиск, теперь нам нужно проверять, что можно спроецировать точки так, что диаметр <= M.Зафиксируем самую дальнюю от 0 по x-координате точку, которая в итоге будет спроецированной на ось x. Она может быть слева или справа от нуля. Случаи будут симметричны, для примера рассмотрим случай, когда эта точка меньше 0. Пусть ее координата равна xL < 0. Заметим, что все точки, для которых 0 ≤ x - xL ≤ M и |x| ≤ |xL| можно спроецировать на ось x и от этого диаметр не увеличится, а все оставшиеся нужно спроецировать на ось y. Среди оставшихся точек нужно найти минимум и максимум по y координате и тогда ответ \"можно\", если расстояние между этими точками не превосходит M и расстояние от них до (xL, 0) не превосходит M.Теперь предподсчитаем минимум и максимум y координат на префиксе и суффиксе все точек. Будем перебирать левую границу отрезка точек спроецированных на x, а правую будем искать бинпоиском или поддерживать методом двух указателей.Таким образом одна проверка работает за O(M) или , и общая сложность или .623D - День РожденияОбозначим qi = 1 - pi.Идея решения: сначала нужно назвать каждого друга хотя бы по разу, потом на каждом шаге максимизируем вероятность закончить игру не позже, чем на данном шаге. Моделируем 300000 шагов, считая по ходу дела сумму . , где ki — количество раз, когда мы называли i-го друга ().Заметим, что матожидание с небольшой погрешностью равно при достаточно большом N (это легко видеть, раскрыв скобки в приведенном выше выражении). Поэтому нам достаточно доказать, что 1) Приведенная выше жадная стратегия дает максимальные значения всех Pr(t). 2) На 300000 шаге погрешность меньше 10 - 6.Доказательство:1) Предположим, что для какого-то t набор li (), отличный от полученного жадным алгоритмом набора ki, дает наибольшее значение Pr(t). Возьмем какое-нибудь ka < la и kb > lb (такие найдутся, если наборы не совпадают, а их суммы равны t), тогда легко показать, что если в наборе li заменить lb на lb + 1, la на la - 1, то будет достигнуто еще большее значение Pr(t), что противоречит предположению о максимальности набора li.2) Заметим, что qi ≤ 0.99. Возьмем набор ki такой, что для всех i выполняется , он даст вероятность завершения игры за t шагов не большую, чем оптимальный набор. Тогда Pr(t) ≥ (1 - 0.99t / 100)100 ≥ 1 - 100·0.99t / 100. Погрешность оценки не превосходит , что оценивается, как сумма геометрической прогрессии, и при N ≥ 300000 получим погрешность меньше 10 - 7.623E - Преобразование последовательности Для начала заметим, что если последовательность префиксных ксоров строго возрастает, то на каждом шаге ai имеет хотя бы один новый бит по сравнению с предыдущими элементами. Так как битов всего k, длина последовательности не может быть больше k. Поэтому если n > k, то ответ 0. Решим сначала задачу за O(k3). Посчитаем dp[n][k] — количество последовательностей длины n таких, что a1|a2|... |an имеет ровно k битов. Переход — добавить l новых битов и выбрать произвольно значения k битов, которые уже вошли в префиксный ксор. Значит, dp[n + 1][k + l] должно быть увеличено на dp[n][k]·2k·Ck + ll. Биномиальный коэффициент соответствует выбору добавляемых l битов из k + l, которые будут представлены в a1|a2|... |an + 1.Заметим, что переход не зависит от n, поэтому попробуем применить идею бинарного возведения в степень. Пусть мы хотим слить динамики dp1[k], dp2[k], где k — количество битов в a1|a2|... |aleft и b1|... |bright соответственно. Хотим посчитать dp[k] для массивов размера left + right. Формула получается такая: Здесь l соответствует битам в ксоре левой части, и для каждого числа из правой части эти l битов можно выбрать произвольно. Перепишем формулу так: Значит, мы можем посчитать dp[k] для всех k, перемножив многочлены и . Коэффициенты первого получаются из коэффициентов второго за . Значит, мы можем посчитать динамику для всех длин — степеней двойки за , используя быстрое преобразование Фурье. На самом деле, удобнее насчитывать , используя то же самое равенство. Далее, используя ту же стратегию слияния, можно найти ответ для данного n, используя динамику для степеней двойки. Получили решение за .Мы решили попросить ответ по модулю 109 + 7, чтобы участники не смогли легко догадаться, что это задача на FFT :) Поэтому для получения ОК нужно было реализовать один из методов перемножения многочленов по большому модулю с использованием FFT. Другой подход состоял в применении алгоритма Карацубы, наша его реализация не укладывалась в ТЛ, однако jqdai0815 каким-то образом смог заставить свое решение с Карацубой пройти :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23278",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 624 和字母"
          },
          "content_length": 6760
        }
      ],
      "code_examples": [
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 1",
          "code": "сложности задач C,D,E отличаются меньше обычного",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 2",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 3",
          "code": "6 8\n6 4\n5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 4",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 5",
          "code": "6\n1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        },
        {
          "title": "AIM Tech Round 2 - Codeforces - Code 6",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23240",
          "author": "zeliboba"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) occurs more than once\", xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) occurs more than once\", xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) occurs more than once\", xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> points;\n    set<pair<int,int>> used;\n\n    if (type == \"all_same_x\") {\n        // All points have the same x-coordinate\n        int x = rnd.next(-100000000, 100000000);\n        set<int> ys;\n        while ((int)points.size() < n) {\n            int y = rnd.next(-100000000, 100000000);\n            if (ys.count(y)) continue; // Ensure uniqueness\n            ys.insert(y);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"all_same_y\") {\n        // All points have the same y-coordinate\n        int y = rnd.next(-100000000, 100000000);\n        set<int> xs;\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            if (xs.count(x)) continue;\n            xs.insert(x);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"max_coords\") {\n        // Points with maximum coordinate values\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            int y = rnd.next(-100000000, 100000000);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"small_coords\") {\n        // Points with small coordinate values\n        while ((int)points.size() < n) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"cluster\") {\n        // Points clustered closely together\n        int cx = rnd.next(-100000000, 100000000);\n        int cy = rnd.next(-100000000, 100000000);\n        while ((int)points.size() < n) {\n            int x = rnd.next(cx - 1000, cx + 1000);\n            int y = rnd.next(cy - 1000, cy + 1000);\n            if (x < -100000000 || x > 100000000 || y < -100000000 || y > 100000000) continue;\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"circle\") {\n        // Points lying on a circle\n        int R = 100000000 - 1000;\n        int cx = rnd.next(-100000000 + R, 100000000 - R);\n        int cy = rnd.next(-100000000 + R, 100000000 - R);\n        set<pair<int,int>> pts;\n        while ((int)points.size() < n) {\n            double angle = rnd.next(0.0, 2 * M_PI);\n            int x = cx + (int)(R * cos(angle));\n            int y = cy + (int)(R * sin(angle));\n            if (x < -100000000 || x > 100000000 || y < -100000000 || y > 100000000) continue;\n            if (pts.count({x, y})) continue;\n            pts.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"line\") {\n        // Points lying along a line\n        int x0 = rnd.next(-100000000, 100000000);\n        int y0 = rnd.next(-100000000, 100000000);\n        int dx = rnd.next(-10000, 10000);\n        int dy = rnd.next(-10000, 10000);\n        if (dx == 0 && dy == 0) dx = 1; // Avoid zero increments\n        set<pair<int,int>> pts;\n        for (int i = 0; i < n; ++i) {\n            long long x = x0 + (long long)dx * i;\n            long long y = y0 + (long long)dy * i;\n            if (x < -100000000 || x > 100000000 || y < -100000000 || y > 100000000) break;\n            if (pts.count({(int)x, (int)y})) continue;\n            pts.insert({(int)x, (int)y});\n            points.emplace_back((int)x, (int)y);\n        }\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            int y = rnd.next(-100000000, 100000000);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else {\n        // Random points\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            int y = rnd.next(-100000000, 100000000);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    }\n\n    // Shuffle points\n    shuffle(points.begin(), points.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> points;\n    set<pair<int,int>> used;\n\n    if (type == \"all_same_x\") {\n        // All points have the same x-coordinate\n        int x = rnd.next(-100000000, 100000000);\n        set<int> ys;\n        while ((int)points.size() < n) {\n            int y = rnd.next(-100000000, 100000000);\n            if (ys.count(y)) continue; // Ensure uniqueness\n            ys.insert(y);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"all_same_y\") {\n        // All points have the same y-coordinate\n        int y = rnd.next(-100000000, 100000000);\n        set<int> xs;\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            if (xs.count(x)) continue;\n            xs.insert(x);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"max_coords\") {\n        // Points with maximum coordinate values\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            int y = rnd.next(-100000000, 100000000);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"small_coords\") {\n        // Points with small coordinate values\n        while ((int)points.size() < n) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"cluster\") {\n        // Points clustered closely together\n        int cx = rnd.next(-100000000, 100000000);\n        int cy = rnd.next(-100000000, 100000000);\n        while ((int)points.size() < n) {\n            int x = rnd.next(cx - 1000, cx + 1000);\n            int y = rnd.next(cy - 1000, cy + 1000);\n            if (x < -100000000 || x > 100000000 || y < -100000000 || y > 100000000) continue;\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"circle\") {\n        // Points lying on a circle\n        int R = 100000000 - 1000;\n        int cx = rnd.next(-100000000 + R, 100000000 - R);\n        int cy = rnd.next(-100000000 + R, 100000000 - R);\n        set<pair<int,int>> pts;\n        while ((int)points.size() < n) {\n            double angle = rnd.next(0.0, 2 * M_PI);\n            int x = cx + (int)(R * cos(angle));\n            int y = cy + (int)(R * sin(angle));\n            if (x < -100000000 || x > 100000000 || y < -100000000 || y > 100000000) continue;\n            if (pts.count({x, y})) continue;\n            pts.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"line\") {\n        // Points lying along a line\n        int x0 = rnd.next(-100000000, 100000000);\n        int y0 = rnd.next(-100000000, 100000000);\n        int dx = rnd.next(-10000, 10000);\n        int dy = rnd.next(-10000, 10000);\n        if (dx == 0 && dy == 0) dx = 1; // Avoid zero increments\n        set<pair<int,int>> pts;\n        for (int i = 0; i < n; ++i) {\n            long long x = x0 + (long long)dx * i;\n            long long y = y0 + (long long)dy * i;\n            if (x < -100000000 || x > 100000000 || y < -100000000 || y > 100000000) break;\n            if (pts.count({(int)x, (int)y})) continue;\n            pts.insert({(int)x, (int)y});\n            points.emplace_back((int)x, (int)y);\n        }\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            int y = rnd.next(-100000000, 100000000);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    } else {\n        // Random points\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100000000, 100000000);\n            int y = rnd.next(-100000000, 100000000);\n            if (used.count({x, y})) continue;\n            used.insert({x, y});\n            points.emplace_back(x, y);\n        }\n    }\n\n    // Shuffle points\n    shuffle(points.begin(), points.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 2 -type max_coords\n./gen -n 2 -type small_coords\n./gen -n 2 -type all_same_x\n./gen -n 2 -type all_same_y\n./gen -n 10 -type random\n./gen -n 10 -type cluster\n./gen -n 10 -type circle\n./gen -n 10 -type line\n./gen -n 100 -type random\n./gen -n 100 -type max_coords\n./gen -n 100 -type small_coords\n./gen -n 100 -type cluster\n./gen -n 100 -type circle\n./gen -n 100 -type line\n./gen -n 1000 -type random\n./gen -n 1000 -type cluster\n./gen -n 1000 -type circle\n./gen -n 1000 -type line\n./gen -n 99999 -type max_coords\n./gen -n 99999 -type small_coords\n./gen -n 100000 -type random\n./gen -n 100000 -type cluster\n./gen -n 100000 -type circle\n./gen -n 100000 -type line\n./gen -n 100000 -type all_same_x\n./gen -n 100000 -type all_same_y\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:06.933216",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "625/A",
      "title": "A. Guest From the Past",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains a single integer n (1 ≤ n ≤ 1018) — the number of rubles Kolya has at the beginning.Then follow three lines containing integers a, b and c (1 ≤ a ≤ 1018, 1 ≤ c < b ≤ 1018) — the cost of one plastic liter bottle, the cost of one glass liter bottle and the money one can get back by returning an empty glass bottle, respectively.",
      "output_spec": "OutputPrint the only integer — maximum number of liters of kefir, that Kolya can drink.",
      "sample_tests": "ExamplesInputCopy101198OutputCopy2InputCopy10561OutputCopy2",
      "description": "A. Guest From the Past\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of the input contains a single integer n (1 ≤ n ≤ 1018) — the number of rubles Kolya has at the beginning.Then follow three lines containing integers a, b and c (1 ≤ a ≤ 1018, 1 ≤ c < b ≤ 1018) — the cost of one plastic liter bottle, the cost of one glass liter bottle and the money one can get back by returning an empty glass bottle, respectively.\n\nOutputPrint the only integer — maximum number of liters of kefir, that Kolya can drink.\n\nInputCopy101198OutputCopy2InputCopy10561OutputCopy2\n\nInputCopy101198\n\nOutputCopy2\n\nInputCopy10561\n\nOutputCopy2\n\nNoteIn the first sample, Kolya can buy one glass bottle, then return it and buy one more glass bottle. Thus he will drink 2 liters of kefir.In the second sample, Kolya can buy two plastic bottle and get two liters of kefir, or he can buy one liter glass bottle, then return it and buy one plastic bottle. In both cases he will drink two liters of kefir.",
      "solutions": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces",
          "content": "Hello, community!Tomorrow Codeforces Round #342 is going to take place. It will share the problemset with Moscow Olympiads in Informatics for students of grades from 6 to 9. Though, grades from 6 to 9 in Russia usually match the ages from 12 to 15, I guarantee that everyone (even Div. 1 participants) will find some interesting problems to solve. Problems were selected for you by the Moscow jury team: Zlobober, meshanya, romanandreev, Helena Andreeva and me; and prepared by members of our scientific committee: wilwell, Sender, iskhakovt, thefacetakt and feldsherov.Scoring distribution will be quite unusual: 750-750-1000-2000-3000.UPD System testing is over. Here are the top 10: _XuMuk_ pandamonium latisel zetamoo yukariko I_Love_Ximera kittylover shdut harry.zhao luke0201 Congratulation! Also, problems seemed to be too tough, we should have probably made Div. 1 round. Anyway, thanks for participating, I hope you enjoyed it and learned something new!Thanks to romanandreev for nice analysis.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1003
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces",
          "content": "625A - Guest From the PastIdea author: collaboration, preparation: feldsherov.If we have at least b money then cost of one glass bottle is b - c. This means that if a ≤ b - c then we don't need to buy glass bottles, only plastic ones, and the answer will be . Otherwise we need to buy glass bottles while we can. So, if we have at least b money, then we will buy glass bottles and then spend rest of the money on plastic ones. This is simple O(1) solution. 625B - War of the CorporationsIdea author: gustokashin, preparation: thefacetakt.Lets find leftmost occurrence of the second word in the first one. We need to add # to remove this occurrence, so where we would like to put it? Instead of the last symbol of this occurrence to remove as many others as we can. After that we will continue this operation after the new # symbol. Simplest implementation of this idea works in O(|S|·|T|), but with the power of string algorithms (for example, Knuth–Morris–Pratt algorithm) we can do it in O(|S| + |T|) time.Hint/Bug/Feature: in Python language there is already function that does exactly what we need: print(input().count(input()))625C - K-special TablesIdea author: Elena Andreeva, preparation: wilwell.Lets fill our table row by row greedily. We want to have maximal possible number on k-th place in the first row. After it we need at least n - k numbers greater than ours, so its maximum value is n2 - (n - k). If we select it then we are fixing all numbers after column k in the first row from n2 - (n - k) to n2. On the first k - 1 lets put smallest possible numbers 1,  2,  ... ,  k - 1. If we do the same thing in the second row then in the beginning it will have numbers from k to 2(k - 1), and from k-th position maximum possible values from n2 - (n - k) - (n - k + 1) to n2 - (n - k + 1). And so on we will fill all rows. With careful implementation we don't need to store whole matrix and we need only O(1) memory. Our algorithm works in O(n2) time. 625D - Finals in arithmeticIdea author: Sender, preparation: Sender.Lets say that input has length of n digits, then size of answer can be n if we didn't carry 1 to the left out of addition, and n - 1 otherwise. Lets fix length m of our answer and denote i-th number in the representation as ai. Then we know from the rightmost digit of the sum. Lets figure out what does equals to. If the remainder is 9, it means that , because we can't get 19 out of the sum of two digits. Otherwise the result is defined uniquely by the fact that there was carrying 1 in the leftmost digit of the result or not. So after this we know a1 + am. It doesn't matter how we divide sum by two digits, because the result will be the same. After this we can uniquely identify the fact of carrying after the first digit of the result and before the last digit. Repeating this m / 2 times we will get candidate for the answer. In the end we will have O(n) solution.If you've missed the fact that every step is uniquely defined, then you could've wrote basically the same solution, but with dynamic programming. 625E - Frog FightsIdea author: Elena Andreeva, preparation: iskhakovt.We want to efficiently simulate the process from the problem statement. Lets have a data structure with times of key events that could've happened during simulation (some frog removed other frog from the board). Lets remove earliest event from our data structure and apply it to the board, make a critical jump. After that the speed of the first frog will decrease and we will be forced to recount times of collision of this frog this its 2 neighbors. This data structure could be set from C++, TreeSet from Java or self-written Segment Tree. To quickly find out who are we gonna remove from the board after the jump lets store double-linked list of all frogs sorted by their positions. Technical part is to calculate time of the collision, but it can be easily done with the simple notion of linear movement of two points on a line. There could be at max n - 1 collisions, so whole solution will be .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23342",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 625\\s*A"
          },
          "content_length": 4020
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 1",
          "code": "x = raw_input() y = raw_input() print x.count(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 2",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 3",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 4",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 5",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 1",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 2",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 3",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 4",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 5",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 6",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 7",
          "code": "k > (n - b) / (b - c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 8",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 9",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    long long c = inf.readLong(1LL, 999999999999999999LL, \"c\");\n    inf.readEoln();\n\n    ensuref(c < b, \"c (%lld) must be less than b (%lld)\", c, b);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    long long c = inf.readLong(1LL, 999999999999999999LL, \"c\");\n    inf.readEoln();\n\n    ensuref(c < b, \"c (%lld) must be less than b (%lld)\", c, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n\n    long long a = inf.readLong(1LL, 1000000000000000000LL, \"a\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    long long c = inf.readLong(1LL, 999999999999999999LL, \"c\");\n    inf.readEoln();\n\n    ensuref(c < b, \"c (%lld) must be less than b (%lld)\", c, b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long a, b, c;\n    \n    if (n == -1) {\n        n = rnd.next(1LL, (long long)1e18);\n    }\n    \n    if (type == \"equal_prices\") {\n        a = b = rnd.next(1LL, (long long)1e18);\n        c = rnd.next(1LL, b - 1);\n    } else if (type == \"plastic_better\") {\n        a = rnd.next(1LL, (long long)1e18 - 1);\n        b = rnd.next(a + 1, (long long)1e18);\n        c = rnd.next(1LL, b - 1);\n    } else if (type == \"glass_better\") {\n        b = rnd.next(1LL, (long long)1e18 - 1);\n        c = rnd.next(1LL, b - 1);\n        a = rnd.next(b + 1, (long long)1e18);\n    } else if (type == \"c_near_b\") {\n        b = rnd.next(2LL, (long long)1e18);\n        c = b - 1;\n        a = rnd.next(1LL, (long long)1e18);\n    } else if (type == \"c_is_one\") {\n        b = rnd.next(2LL, (long long)1e18);\n        c = 1;\n        a = rnd.next(1LL, (long long)1e18);\n    } else if (type == \"max_values\") {\n        n = (long long)1e18;\n        a = (long long)1e18;\n        b = (long long)1e18;\n        c = b - 1;\n    } else {\n        // Random case\n        a = rnd.next(1LL, (long long)1e18);\n        b = rnd.next(2LL, (long long)1e18); // Ensure b >= 2\n        c = rnd.next(1LL, b - 1);\n    }\n    \n    // Output the test case\n    printf(\"%lld\\n%lld\\n%lld\\n%lld\\n\", n, a, b, c);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long a, b, c;\n    \n    if (n == -1) {\n        n = rnd.next(1LL, (long long)1e18);\n    }\n    \n    if (type == \"equal_prices\") {\n        a = b = rnd.next(1LL, (long long)1e18);\n        c = rnd.next(1LL, b - 1);\n    } else if (type == \"plastic_better\") {\n        a = rnd.next(1LL, (long long)1e18 - 1);\n        b = rnd.next(a + 1, (long long)1e18);\n        c = rnd.next(1LL, b - 1);\n    } else if (type == \"glass_better\") {\n        b = rnd.next(1LL, (long long)1e18 - 1);\n        c = rnd.next(1LL, b - 1);\n        a = rnd.next(b + 1, (long long)1e18);\n    } else if (type == \"c_near_b\") {\n        b = rnd.next(2LL, (long long)1e18);\n        c = b - 1;\n        a = rnd.next(1LL, (long long)1e18);\n    } else if (type == \"c_is_one\") {\n        b = rnd.next(2LL, (long long)1e18);\n        c = 1;\n        a = rnd.next(1LL, (long long)1e18);\n    } else if (type == \"max_values\") {\n        n = (long long)1e18;\n        a = (long long)1e18;\n        b = (long long)1e18;\n        c = b - 1;\n    } else {\n        // Random case\n        a = rnd.next(1LL, (long long)1e18);\n        b = rnd.next(2LL, (long long)1e18); // Ensure b >= 2\n        c = rnd.next(1LL, b - 1);\n    }\n    \n    // Output the test case\n    printf(\"%lld\\n%lld\\n%lld\\n%lld\\n\", n, a, b, c);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type small\n./gen -n 10 -type small\n./gen -n 100 -type small\n\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 1000000 -type plastic_better\n./gen -n 10000000 -type plastic_better\n./gen -n 100000000 -type plastic_better\n\n./gen -n 1000000 -type glass_better\n./gen -n 10000000 -type glass_better\n./gen -n 100000000 -type glass_better\n\n./gen -n 999999999999999999 -type c_near_b\n./gen -n 999999999999999999 -type c_is_one\n\n./gen -n 1000000000000000000 -type max_values\n\n./gen -n 1 -type equal_prices\n./gen -n 1000000000 -type equal_prices\n\n./gen -n 500000000000000000 -type random\n./gen -n 1000000000000000000 -type random\n\n./gen -n 123456789012345678 -type random\n./gen -n 987654321098765432 -type random\n\n./gen -n 123456789 -type plastic_better\n./gen -n 987654321 -type plastic_better\n\n./gen -n 1000000000000 -type glass_better\n./gen -n 1000000000000000 -type glass_better\n\n./gen -n 1000000000 -type c_near_b\n./gen -n 1000000000 -type c_is_one\n\n./gen -n 1234567890123456789 -type max_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:08.960352",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "625/B",
      "title": "B. War of the Corporations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100 000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.",
      "output_spec": "OutputPrint the minimum number of characters that must be replaced with \"#\" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.",
      "sample_tests": "ExamplesInputCopyintellecttellOutputCopy1InputCopygoogleappleOutputCopy0InputCopysirisirisirOutputCopy2",
      "description": "B. War of the Corporations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100 000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.\n\nOutputPrint the minimum number of characters that must be replaced with \"#\" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.\n\nInputCopyintellecttellOutputCopy1InputCopygoogleappleOutputCopy0InputCopysirisirisirOutputCopy2\n\nInputCopyintellecttell\n\nOutputCopy1\n\nInputCopygoogleapple\n\nOutputCopy0\n\nInputCopysirisirisir\n\nOutputCopy2\n\nNoteIn the first sample AI's name may be replaced with \"int#llect\".In the second sample Gogol can just keep things as they are.In the third sample one of the new possible names of AI may be \"s#ris#ri\".",
      "solutions": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces",
          "content": "Hello, community!Tomorrow Codeforces Round #342 is going to take place. It will share the problemset with Moscow Olympiads in Informatics for students of grades from 6 to 9. Though, grades from 6 to 9 in Russia usually match the ages from 12 to 15, I guarantee that everyone (even Div. 1 participants) will find some interesting problems to solve. Problems were selected for you by the Moscow jury team: Zlobober, meshanya, romanandreev, Helena Andreeva and me; and prepared by members of our scientific committee: wilwell, Sender, iskhakovt, thefacetakt and feldsherov.Scoring distribution will be quite unusual: 750-750-1000-2000-3000.UPD System testing is over. Here are the top 10: _XuMuk_ pandamonium latisel zetamoo yukariko I_Love_Ximera kittylover shdut harry.zhao luke0201 Congratulation! Also, problems seemed to be too tough, we should have probably made Div. 1 round. Anyway, thanks for participating, I hope you enjoyed it and learned something new!Thanks to romanandreev for nice analysis.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1003
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces",
          "content": "625A - Guest From the PastIdea author: collaboration, preparation: feldsherov.If we have at least b money then cost of one glass bottle is b - c. This means that if a ≤ b - c then we don't need to buy glass bottles, only plastic ones, and the answer will be . Otherwise we need to buy glass bottles while we can. So, if we have at least b money, then we will buy glass bottles and then spend rest of the money on plastic ones. This is simple O(1) solution. 625B - War of the CorporationsIdea author: gustokashin, preparation: thefacetakt.Lets find leftmost occurrence of the second word in the first one. We need to add # to remove this occurrence, so where we would like to put it? Instead of the last symbol of this occurrence to remove as many others as we can. After that we will continue this operation after the new # symbol. Simplest implementation of this idea works in O(|S|·|T|), but with the power of string algorithms (for example, Knuth–Morris–Pratt algorithm) we can do it in O(|S| + |T|) time.Hint/Bug/Feature: in Python language there is already function that does exactly what we need: print(input().count(input()))625C - K-special TablesIdea author: Elena Andreeva, preparation: wilwell.Lets fill our table row by row greedily. We want to have maximal possible number on k-th place in the first row. After it we need at least n - k numbers greater than ours, so its maximum value is n2 - (n - k). If we select it then we are fixing all numbers after column k in the first row from n2 - (n - k) to n2. On the first k - 1 lets put smallest possible numbers 1,  2,  ... ,  k - 1. If we do the same thing in the second row then in the beginning it will have numbers from k to 2(k - 1), and from k-th position maximum possible values from n2 - (n - k) - (n - k + 1) to n2 - (n - k + 1). And so on we will fill all rows. With careful implementation we don't need to store whole matrix and we need only O(1) memory. Our algorithm works in O(n2) time. 625D - Finals in arithmeticIdea author: Sender, preparation: Sender.Lets say that input has length of n digits, then size of answer can be n if we didn't carry 1 to the left out of addition, and n - 1 otherwise. Lets fix length m of our answer and denote i-th number in the representation as ai. Then we know from the rightmost digit of the sum. Lets figure out what does equals to. If the remainder is 9, it means that , because we can't get 19 out of the sum of two digits. Otherwise the result is defined uniquely by the fact that there was carrying 1 in the leftmost digit of the result or not. So after this we know a1 + am. It doesn't matter how we divide sum by two digits, because the result will be the same. After this we can uniquely identify the fact of carrying after the first digit of the result and before the last digit. Repeating this m / 2 times we will get candidate for the answer. In the end we will have O(n) solution.If you've missed the fact that every step is uniquely defined, then you could've wrote basically the same solution, but with dynamic programming. 625E - Frog FightsIdea author: Elena Andreeva, preparation: iskhakovt.We want to efficiently simulate the process from the problem statement. Lets have a data structure with times of key events that could've happened during simulation (some frog removed other frog from the board). Lets remove earliest event from our data structure and apply it to the board, make a critical jump. After that the speed of the first frog will decrease and we will be forced to recount times of collision of this frog this its 2 neighbors. This data structure could be set from C++, TreeSet from Java or self-written Segment Tree. To quickly find out who are we gonna remove from the board after the jump lets store double-linked list of all frogs sorted by their positions. Technical part is to calculate time of the collision, but it can be easily done with the simple notion of linear movement of two points on a line. There could be at max n - 1 collisions, so whole solution will be .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23342",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 625\\s*B"
          },
          "content_length": 4020
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 1",
          "code": "x = raw_input() y = raw_input() print x.count(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 2",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 3",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 4",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 5",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 1",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 2",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 3",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 4",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 5",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 6",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 7",
          "code": "k > (n - b) / (b - c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 8",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 9",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 100000, \n        \"Length of the AI name 's' (%d) is not within the allowed range [1, 100000]\", (int)s.length());\n    for (int i = 0; i < (int)s.length(); i++) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \n            \"Character s[%d]='%c' is not a lowercase letter\", i + 1, s[i]);\n    }\n\n    string t = inf.readLine();\n    ensuref(1 <= (int)t.length() && (int)t.length() <= 30, \n        \"Length of the phone name 't' (%d) is not within the allowed range [1, 30]\", (int)t.length());\n    for (int i = 0; i < (int)t.length(); i++) {\n        ensuref('a' <= t[i] && t[i] <= 'z', \n            \"Character t[%d]='%c' is not a lowercase letter\", i + 1, t[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 100000, \n        \"Length of the AI name 's' (%d) is not within the allowed range [1, 100000]\", (int)s.length());\n    for (int i = 0; i < (int)s.length(); i++) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \n            \"Character s[%d]='%c' is not a lowercase letter\", i + 1, s[i]);\n    }\n\n    string t = inf.readLine();\n    ensuref(1 <= (int)t.length() && (int)t.length() <= 30, \n        \"Length of the phone name 't' (%d) is not within the allowed range [1, 30]\", (int)t.length());\n    for (int i = 0; i < (int)t.length(); i++) {\n        ensuref('a' <= t[i] && t[i] <= 'z', \n            \"Character t[%d]='%c' is not a lowercase letter\", i + 1, t[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 100000, \n        \"Length of the AI name 's' (%d) is not within the allowed range [1, 100000]\", (int)s.length());\n    for (int i = 0; i < (int)s.length(); i++) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \n            \"Character s[%d]='%c' is not a lowercase letter\", i + 1, s[i]);\n    }\n\n    string t = inf.readLine();\n    ensuref(1 <= (int)t.length() && (int)t.length() <= 30, \n        \"Length of the phone name 't' (%d) is not within the allowed range [1, 30]\", (int)t.length());\n    for (int i = 0; i < (int)t.length(); i++) {\n        ensuref('a' <= t[i] && t[i] <= 'z', \n            \"Character t[%d]='%c' is not a lowercase letter\", i + 1, t[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int slen = opt<int>(\"slen\");\n    int tlen = opt<int>(\"tlen\");\n    string stype = opt<string>(\"stype\", \"random\");\n    string ttype = opt<string>(\"ttype\", \"random\");\n\n    // Ensure constraints are met\n    assert(1 <= tlen && tlen <= min(30, slen));\n    assert(1 <= slen && slen <= 100000);\n\n    string T;\n    string S;\n\n    if (ttype == \"from_s\" || ttype == \"reverse_s\") {\n        // Generate S first\n        if (stype == \"random\") {\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        } else if (stype == \"same\") {\n            char c = rnd.next('a', 'z');\n            S = string(slen, c);\n        } else {\n            // If stype depends on T but T is not defined yet, default to random\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        }\n        // Now generate T from S\n        int pos = rnd.next(0, slen - tlen);\n        T = S.substr(pos, tlen);\n        if (ttype == \"reverse_s\") {\n            reverse(T.begin(), T.end());\n        }\n    } else {\n        // Generate T first\n        if (ttype == \"random\") {\n            T.resize(tlen);\n            for (int i = 0; i < tlen; ++i) {\n                T[i] = rnd.next('a', 'z');\n            }\n        } else if (ttype == \"same\") {\n            char c = rnd.next('a', 'z');\n            T = string(tlen, c);\n        } else {\n            // Default to random\n            T.resize(tlen);\n            for (int i = 0; i < tlen; ++i) {\n                T[i] = rnd.next('a', 'z');\n            }\n        }\n\n        // Now generate S\n        if (stype == \"random\") {\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        } else if (stype == \"same\") {\n            char c = rnd.next('a', 'z');\n            S = string(slen, c);\n        } else if (stype == \"contains_t\") {\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n            int pos = rnd.next(0, slen - tlen);\n            for (int i = 0; i < tlen; ++i) {\n                S[pos + i] = T[i];\n            }\n        } else if (stype == \"many_t\") {\n            // S is formed by repeating T multiple times\n            while ((int)S.size() + tlen <= slen) {\n                S += T;\n            }\n            // Fill the rest with random letters\n            while ((int)S.size() < slen) {\n                S += rnd.next('a', 'z');\n            }\n        } else {\n            // Default to random\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        }\n    }\n\n    // Output S and T\n    printf(\"%s\\n%s\\n\", S.c_str(), T.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int slen = opt<int>(\"slen\");\n    int tlen = opt<int>(\"tlen\");\n    string stype = opt<string>(\"stype\", \"random\");\n    string ttype = opt<string>(\"ttype\", \"random\");\n\n    // Ensure constraints are met\n    assert(1 <= tlen && tlen <= min(30, slen));\n    assert(1 <= slen && slen <= 100000);\n\n    string T;\n    string S;\n\n    if (ttype == \"from_s\" || ttype == \"reverse_s\") {\n        // Generate S first\n        if (stype == \"random\") {\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        } else if (stype == \"same\") {\n            char c = rnd.next('a', 'z');\n            S = string(slen, c);\n        } else {\n            // If stype depends on T but T is not defined yet, default to random\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        }\n        // Now generate T from S\n        int pos = rnd.next(0, slen - tlen);\n        T = S.substr(pos, tlen);\n        if (ttype == \"reverse_s\") {\n            reverse(T.begin(), T.end());\n        }\n    } else {\n        // Generate T first\n        if (ttype == \"random\") {\n            T.resize(tlen);\n            for (int i = 0; i < tlen; ++i) {\n                T[i] = rnd.next('a', 'z');\n            }\n        } else if (ttype == \"same\") {\n            char c = rnd.next('a', 'z');\n            T = string(tlen, c);\n        } else {\n            // Default to random\n            T.resize(tlen);\n            for (int i = 0; i < tlen; ++i) {\n                T[i] = rnd.next('a', 'z');\n            }\n        }\n\n        // Now generate S\n        if (stype == \"random\") {\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        } else if (stype == \"same\") {\n            char c = rnd.next('a', 'z');\n            S = string(slen, c);\n        } else if (stype == \"contains_t\") {\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n            int pos = rnd.next(0, slen - tlen);\n            for (int i = 0; i < tlen; ++i) {\n                S[pos + i] = T[i];\n            }\n        } else if (stype == \"many_t\") {\n            // S is formed by repeating T multiple times\n            while ((int)S.size() + tlen <= slen) {\n                S += T;\n            }\n            // Fill the rest with random letters\n            while ((int)S.size() < slen) {\n                S += rnd.next('a', 'z');\n            }\n        } else {\n            // Default to random\n            S.resize(slen);\n            for (int i = 0; i < slen; ++i) {\n                S[i] = rnd.next('a', 'z');\n            }\n        }\n    }\n\n    // Output S and T\n    printf(\"%s\\n%s\\n\", S.c_str(), T.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -slen 1 -tlen 1 -stype random -ttype random\n./gen -slen 1 -tlen 1 -stype same -ttype same\n./gen -slen 30 -tlen 30 -stype random -ttype random\n./gen -slen 1000 -tlen 10 -stype contains_t -ttype random\n./gen -slen 1000 -tlen 10 -stype random -ttype from_s\n./gen -slen 1000 -tlen 10 -stype random -ttype reverse_s\n\n./gen -slen 10000 -tlen 20 -stype random -ttype random\n./gen -slen 10000 -tlen 20 -stype same -ttype same\n./gen -slen 10000 -tlen 20 -stype contains_t -ttype random\n./gen -slen 10000 -tlen 20 -stype many_t -ttype random\n./gen -slen 10000 -tlen 20 -stype random -ttype from_s\n./gen -slen 10000 -tlen 20 -stype random -ttype reverse_s\n\n./gen -slen 50000 -tlen 25 -stype random -ttype random\n./gen -slen 50000 -tlen 25 -stype same -ttype random\n./gen -slen 50000 -tlen 25 -stype random -ttype same\n./gen -slen 50000 -tlen 25 -stype contains_t -ttype random\n./gen -slen 50000 -tlen 25 -stype many_t -ttype random\n./gen -slen 50000 -tlen 25 -stype random -ttype from_s\n./gen -slen 50000 -tlen 25 -stype random -ttype reverse_s\n\n./gen -slen 100000 -tlen 30 -stype random -ttype random\n./gen -slen 100000 -tlen 30 -stype random -ttype same\n./gen -slen 100000 -tlen 30 -stype same -ttype random\n./gen -slen 100000 -tlen 30 -stype same -ttype same\n./gen -slen 100000 -tlen 30 -stype contains_t -ttype random\n./gen -slen 100000 -tlen 30 -stype many_t -ttype random\n./gen -slen 100000 -tlen 30 -stype random -ttype from_s\n./gen -slen 100000 -tlen 30 -stype random -ttype reverse_s\n\n./gen -slen 100000 -tlen 1 -stype random -ttype random\n./gen -slen 100000 -tlen 1 -stype random -ttype same\n./gen -slen 100000 -tlen 1 -stype same -ttype random\n./gen -slen 100000 -tlen 1 -stype same -ttype same\n./gen -slen 100000 -tlen 1 -stype contains_t -ttype random\n./gen -slen 100000 -tlen 1 -stype many_t -ttype random\n./gen -slen 100000 -tlen 1 -stype random -ttype from_s\n./gen -slen 100000 -tlen 1 -stype random -ttype reverse_s\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:11.259890",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "625/C",
      "title": "C. K-special Tables",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and k (1 ≤ n ≤ 500, 1 ≤ k ≤ n) — the size of the table Alice is looking for and the column that should have maximum possible sum.",
      "output_spec": "OutputFirst print the sum of the integers in the k-th column of the required table.Next n lines should contain the description of the table itself: first line should contains n elements of the first row, second line should contain n elements of the second row and so on.If there are multiple suitable table, you are allowed to print any.",
      "sample_tests": "ExamplesInputCopy4 1OutputCopy281 2 3 45 6 7 89 10 11 1213 14 15 16InputCopy5 3OutputCopy855 6 17 18 199 10 23 24 257 8 20 21 223 4 14 15 161 2 11 12 13",
      "description": "C. K-special Tables\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n and k (1 ≤ n ≤ 500, 1 ≤ k ≤ n) — the size of the table Alice is looking for and the column that should have maximum possible sum.\n\nOutputFirst print the sum of the integers in the k-th column of the required table.Next n lines should contain the description of the table itself: first line should contains n elements of the first row, second line should contain n elements of the second row and so on.If there are multiple suitable table, you are allowed to print any.\n\nInputCopy4 1OutputCopy281 2 3 45 6 7 89 10 11 1213 14 15 16InputCopy5 3OutputCopy855 6 17 18 199 10 23 24 257 8 20 21 223 4 14 15 161 2 11 12 13\n\nInputCopy4 1\n\nOutputCopy281 2 3 45 6 7 89 10 11 1213 14 15 16\n\nInputCopy5 3\n\nOutputCopy855 6 17 18 199 10 23 24 257 8 20 21 223 4 14 15 161 2 11 12 13",
      "solutions": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces",
          "content": "Hello, community!Tomorrow Codeforces Round #342 is going to take place. It will share the problemset with Moscow Olympiads in Informatics for students of grades from 6 to 9. Though, grades from 6 to 9 in Russia usually match the ages from 12 to 15, I guarantee that everyone (even Div. 1 participants) will find some interesting problems to solve. Problems were selected for you by the Moscow jury team: Zlobober, meshanya, romanandreev, Helena Andreeva and me; and prepared by members of our scientific committee: wilwell, Sender, iskhakovt, thefacetakt and feldsherov.Scoring distribution will be quite unusual: 750-750-1000-2000-3000.UPD System testing is over. Here are the top 10: _XuMuk_ pandamonium latisel zetamoo yukariko I_Love_Ximera kittylover shdut harry.zhao luke0201 Congratulation! Also, problems seemed to be too tough, we should have probably made Div. 1 round. Anyway, thanks for participating, I hope you enjoyed it and learned something new!Thanks to romanandreev for nice analysis.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/23309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1003
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces",
          "content": "625A - Guest From the PastIdea author: collaboration, preparation: feldsherov.If we have at least b money then cost of one glass bottle is b - c. This means that if a ≤ b - c then we don't need to buy glass bottles, only plastic ones, and the answer will be . Otherwise we need to buy glass bottles while we can. So, if we have at least b money, then we will buy glass bottles and then spend rest of the money on plastic ones. This is simple O(1) solution. 625B - War of the CorporationsIdea author: gustokashin, preparation: thefacetakt.Lets find leftmost occurrence of the second word in the first one. We need to add # to remove this occurrence, so where we would like to put it? Instead of the last symbol of this occurrence to remove as many others as we can. After that we will continue this operation after the new # symbol. Simplest implementation of this idea works in O(|S|·|T|), but with the power of string algorithms (for example, Knuth–Morris–Pratt algorithm) we can do it in O(|S| + |T|) time.Hint/Bug/Feature: in Python language there is already function that does exactly what we need: print(input().count(input()))625C - K-special TablesIdea author: Elena Andreeva, preparation: wilwell.Lets fill our table row by row greedily. We want to have maximal possible number on k-th place in the first row. After it we need at least n - k numbers greater than ours, so its maximum value is n2 - (n - k). If we select it then we are fixing all numbers after column k in the first row from n2 - (n - k) to n2. On the first k - 1 lets put smallest possible numbers 1,  2,  ... ,  k - 1. If we do the same thing in the second row then in the beginning it will have numbers from k to 2(k - 1), and from k-th position maximum possible values from n2 - (n - k) - (n - k + 1) to n2 - (n - k + 1). And so on we will fill all rows. With careful implementation we don't need to store whole matrix and we need only O(1) memory. Our algorithm works in O(n2) time. 625D - Finals in arithmeticIdea author: Sender, preparation: Sender.Lets say that input has length of n digits, then size of answer can be n if we didn't carry 1 to the left out of addition, and n - 1 otherwise. Lets fix length m of our answer and denote i-th number in the representation as ai. Then we know from the rightmost digit of the sum. Lets figure out what does equals to. If the remainder is 9, it means that , because we can't get 19 out of the sum of two digits. Otherwise the result is defined uniquely by the fact that there was carrying 1 in the leftmost digit of the result or not. So after this we know a1 + am. It doesn't matter how we divide sum by two digits, because the result will be the same. After this we can uniquely identify the fact of carrying after the first digit of the result and before the last digit. Repeating this m / 2 times we will get candidate for the answer. In the end we will have O(n) solution.If you've missed the fact that every step is uniquely defined, then you could've wrote basically the same solution, but with dynamic programming. 625E - Frog FightsIdea author: Elena Andreeva, preparation: iskhakovt.We want to efficiently simulate the process from the problem statement. Lets have a data structure with times of key events that could've happened during simulation (some frog removed other frog from the board). Lets remove earliest event from our data structure and apply it to the board, make a critical jump. After that the speed of the first frog will decrease and we will be forced to recount times of collision of this frog this its 2 neighbors. This data structure could be set from C++, TreeSet from Java or self-written Segment Tree. To quickly find out who are we gonna remove from the board after the jump lets store double-linked list of all frogs sorted by their positions. Technical part is to calculate time of the collision, but it can be easily done with the simple notion of linear movement of two points on a line. There could be at max n - 1 collisions, so whole solution will be .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/23342",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 625\\s*C"
          },
          "content_length": 4020
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 1",
          "code": "x = raw_input() y = raw_input() print x.count(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 2",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 3",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 4",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 5",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 1",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 2",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 3",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 4",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 5",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 6",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 7",
          "code": "k > (n - b) / (b - c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 8",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 9",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\n\nvoid readAndValidateTable(InStream& stream, int reportedSum) {\n    vector<bool> used(n * n + 1, false);\n    vector<vector<int>> table(n, vector<int>(n));\n    int computedSum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int prevVal = -1;\n        for (int j = 0; j < n; ++j) {\n            int val = stream.readInt(1, n * n, format(\"table[%d][%d]\", i + 1, j + 1).c_str());\n            table[i][j] = val;\n            if (used[val]) {\n                stream.quitf(_wa, \"number %d appears more than once in the table\", val);\n            }\n            used[val] = true;\n            if (j > 0 && val <= prevVal) {\n                stream.quitf(_wa, \"row %d is not in increasing order\", i + 1);\n            }\n            prevVal = val;\n            if (j + 1 == k) {\n                computedSum += val;\n            }\n        }\n    }\n\n    // Check if all numbers from 1 to n^2 are used\n    for (int i = 1; i <= n * n; ++i) {\n        if (!used[i]) {\n            stream.quitf(_wa, \"number %d does not appear in the table\", i);\n        }\n    }\n\n    if (computedSum != reportedSum) {\n        stream.quitf(_wa, \"the sum of numbers in k-th column does not match the reported sum: reportedSum = %d, computedSum = %d\", reportedSum, computedSum);\n    }\n}\n\nint readAns(InStream& stream) {\n    int sum = stream.readInt();\n    readAndValidateTable(stream, sum);\n    return sum;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(1, 500, \"n\");\n    k = inf.readInt(1, n, \"k\");\n\n    int jans = readAns(ans);\n    int pans = readAns(ouf);\n\n    if (pans < jans)\n        quitf(_wa, \"participant's sum is less than the maximum possible sum: jans = %d, pans = %d\", jans, pans);\n    else if (pans == jans)\n        quitf(_ok, \"answer = %d\", pans);\n    else // (pans > jans)\n        quitf(_fail, \"participant's sum is greater than the jury's sum: jans = %d, pans = %d\", jans, pans);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_min = opt<int>(\"nmin\", 1);\n    int n_max = opt<int>(\"nmax\", 500);\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string ktype = opt<string>(\"ktype\", \"random\");\n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = n_min;\n        } else if (type == \"max\") {\n            n = n_max;\n        } else if (type == \"small\") {\n            n = rnd.next(n_min, min(n_min + 9, n_max));\n        } else if (type == \"large\") {\n            n = rnd.next(max(n_max - 99, n_min), n_max);\n        } else { // random\n            n = rnd.next(n_min, n_max);\n        }\n    }\n\n    if (k == -1) {\n        if (ktype == \"first\") {\n            k = 1;\n        } else if (ktype == \"last\") {\n            k = n;\n        } else if (ktype == \"middle\") {\n            k = n / 2;\n            if (k == 0) k = 1;\n        } else { // random\n            k = rnd.next(1, n);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_min = opt<int>(\"nmin\", 1);\n    int n_max = opt<int>(\"nmax\", 500);\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string ktype = opt<string>(\"ktype\", \"random\");\n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = n_min;\n        } else if (type == \"max\") {\n            n = n_max;\n        } else if (type == \"small\") {\n            n = rnd.next(n_min, min(n_min + 9, n_max));\n        } else if (type == \"large\") {\n            n = rnd.next(max(n_max - 99, n_min), n_max);\n        } else { // random\n            n = rnd.next(n_min, n_max);\n        }\n    }\n\n    if (k == -1) {\n        if (ktype == \"first\") {\n            k = 1;\n        } else if (ktype == \"last\") {\n            k = n;\n        } else if (ktype == \"middle\") {\n            k = n / 2;\n            if (k == 0) k = 1;\n        } else { // random\n            k = rnd.next(1, n);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n\n./gen -type min -ktype first\n./gen -type min -ktype last\n./gen -type min -ktype middle\n./gen -type min          # n = nmin, k random\n\n# Maximum n\n./gen -type max -ktype first\n./gen -type max -ktype last\n./gen -type max -ktype middle\n./gen -type max          # n = nmax, k random\n\n# Small n\n./gen -type small -ktype first\n./gen -type small -ktype last\n./gen -type small -ktype middle\n./gen -type small\n\n# Large n\n./gen -type large -ktype first\n./gen -type large -ktype last\n./gen -type large -ktype middle\n./gen -type large\n\n# Random n\n./gen -type random -ktype first\n./gen -type random -ktype last\n./gen -type random -ktype middle\n./gen -type random\n\n# Specific n and k\n./gen -n 500 -k 1\n./gen -n 500 -k 250\n./gen -n 500 -k 500\n./gen -n 1 -k 1\n./gen -n 10 -k 5\n./gen -n 100 -k 50\n./gen -n 100 -k 100\n./gen -n 100 -k 1\n./gen -n 250 -k 125\n./gen -n 2 -k 1\n./gen -n 2 -k 2\n\n# Random n and k\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:13.326232",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "625/D",
      "title": "D. Finals in arithmetic",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (1 ≤ n ≤ 10100 000).",
      "output_spec": "OutputIf there is no such positive integer a without leading zeroes that a + ar = n then print 0. Otherwise, print any valid a. If there are many possible answers, you are allowed to pick any.",
      "sample_tests": "ExamplesInputCopy4OutputCopy2InputCopy11OutputCopy10InputCopy5OutputCopy0InputCopy33OutputCopy21",
      "description": "D. Finals in arithmetic\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (1 ≤ n ≤ 10100 000).\n\nOutputIf there is no such positive integer a without leading zeroes that a + ar = n then print 0. Otherwise, print any valid a. If there are many possible answers, you are allowed to pick any.\n\nInputCopy4OutputCopy2InputCopy11OutputCopy10InputCopy5OutputCopy0InputCopy33OutputCopy21\n\nOutputCopy2\n\nInputCopy11\n\nOutputCopy10\n\nOutputCopy0\n\nInputCopy33\n\nOutputCopy21\n\nNoteIn the first sample 4 = 2 + 2, a = 2 is the only possibility.In the second sample 11 = 10 + 1, a = 10 — the only valid solution. Note, that a = 01 is incorrect, because a can't have leading zeroes.It's easy to check that there is no suitable a in the third sample.In the fourth sample 33 = 30 + 3 = 12 + 21, so there are three possibilities for a: a = 30, a = 12, a = 21. Any of these is considered to be correct answer.",
      "solutions": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces",
          "content": "Hello, community!Tomorrow Codeforces Round #342 is going to take place. It will share the problemset with Moscow Olympiads in Informatics for students of grades from 6 to 9. Though, grades from 6 to 9 in Russia usually match the ages from 12 to 15, I guarantee that everyone (even Div. 1 participants) will find some interesting problems to solve. Problems were selected for you by the Moscow jury team: Zlobober, meshanya, romanandreev, Helena Andreeva and me; and prepared by members of our scientific committee: wilwell, Sender, iskhakovt, thefacetakt and feldsherov.Scoring distribution will be quite unusual: 750-750-1000-2000-3000.UPD System testing is over. Here are the top 10: _XuMuk_ pandamonium latisel zetamoo yukariko I_Love_Ximera kittylover shdut harry.zhao luke0201 Congratulation! Also, problems seemed to be too tough, we should have probably made Div. 1 round. Anyway, thanks for participating, I hope you enjoyed it and learned something new!Thanks to romanandreev for nice analysis.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1003
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces",
          "content": "625A - Guest From the PastIdea author: collaboration, preparation: feldsherov.If we have at least b money then cost of one glass bottle is b - c. This means that if a ≤ b - c then we don't need to buy glass bottles, only plastic ones, and the answer will be . Otherwise we need to buy glass bottles while we can. So, if we have at least b money, then we will buy glass bottles and then spend rest of the money on plastic ones. This is simple O(1) solution. 625B - War of the CorporationsIdea author: gustokashin, preparation: thefacetakt.Lets find leftmost occurrence of the second word in the first one. We need to add # to remove this occurrence, so where we would like to put it? Instead of the last symbol of this occurrence to remove as many others as we can. After that we will continue this operation after the new # symbol. Simplest implementation of this idea works in O(|S|·|T|), but with the power of string algorithms (for example, Knuth–Morris–Pratt algorithm) we can do it in O(|S| + |T|) time.Hint/Bug/Feature: in Python language there is already function that does exactly what we need: print(input().count(input()))625C - K-special TablesIdea author: Elena Andreeva, preparation: wilwell.Lets fill our table row by row greedily. We want to have maximal possible number on k-th place in the first row. After it we need at least n - k numbers greater than ours, so its maximum value is n2 - (n - k). If we select it then we are fixing all numbers after column k in the first row from n2 - (n - k) to n2. On the first k - 1 lets put smallest possible numbers 1,  2,  ... ,  k - 1. If we do the same thing in the second row then in the beginning it will have numbers from k to 2(k - 1), and from k-th position maximum possible values from n2 - (n - k) - (n - k + 1) to n2 - (n - k + 1). And so on we will fill all rows. With careful implementation we don't need to store whole matrix and we need only O(1) memory. Our algorithm works in O(n2) time. 625D - Finals in arithmeticIdea author: Sender, preparation: Sender.Lets say that input has length of n digits, then size of answer can be n if we didn't carry 1 to the left out of addition, and n - 1 otherwise. Lets fix length m of our answer and denote i-th number in the representation as ai. Then we know from the rightmost digit of the sum. Lets figure out what does equals to. If the remainder is 9, it means that , because we can't get 19 out of the sum of two digits. Otherwise the result is defined uniquely by the fact that there was carrying 1 in the leftmost digit of the result or not. So after this we know a1 + am. It doesn't matter how we divide sum by two digits, because the result will be the same. After this we can uniquely identify the fact of carrying after the first digit of the result and before the last digit. Repeating this m / 2 times we will get candidate for the answer. In the end we will have O(n) solution.If you've missed the fact that every step is uniquely defined, then you could've wrote basically the same solution, but with dynamic programming. 625E - Frog FightsIdea author: Elena Andreeva, preparation: iskhakovt.We want to efficiently simulate the process from the problem statement. Lets have a data structure with times of key events that could've happened during simulation (some frog removed other frog from the board). Lets remove earliest event from our data structure and apply it to the board, make a critical jump. After that the speed of the first frog will decrease and we will be forced to recount times of collision of this frog this its 2 neighbors. This data structure could be set from C++, TreeSet from Java or self-written Segment Tree. To quickly find out who are we gonna remove from the board after the jump lets store double-linked list of all frogs sorted by their positions. Technical part is to calculate time of the collision, but it can be easily done with the simple notion of linear movement of two points on a line. There could be at max n - 1 collisions, so whole solution will be .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23342",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 625\\s*D"
          },
          "content_length": 4020
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 1",
          "code": "x = raw_input() y = raw_input() print x.count(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 2",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 3",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 4",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 5",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 1",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 2",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 3",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 4",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 5",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 6",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 7",
          "code": "k > (n - b) / (b - c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 8",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 9",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string n_str = inf.readToken(\"[0-9]+\", \"n\");\n    inf.readEoln();\n\n    // Remove leading zeros\n    string n_trimmed = n_str;\n    n_trimmed.erase(0, n_trimmed.find_first_not_of('0'));\n\n    ensuref(!n_trimmed.empty(), \"n cannot be zero\");\n\n    // Prepare max_n_str = \"1\" + 100000 zeros\n    string max_n_str = \"1\" + string(100000, '0');\n\n    if (n_trimmed.length() < max_n_str.length()) {\n        // OK\n    } else if (n_trimmed.length() > max_n_str.length()) {\n        ensuref(false, \"n = %s is greater than 10^100000\", n_str.c_str());\n    } else {\n        if (n_trimmed.compare(max_n_str) <= 0) {\n            // OK\n        } else {\n            ensuref(false, \"n = %s is greater than 10^100000\", n_str.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string n_str = inf.readToken(\"[0-9]+\", \"n\");\n    inf.readEoln();\n\n    // Remove leading zeros\n    string n_trimmed = n_str;\n    n_trimmed.erase(0, n_trimmed.find_first_not_of('0'));\n\n    ensuref(!n_trimmed.empty(), \"n cannot be zero\");\n\n    // Prepare max_n_str = \"1\" + 100000 zeros\n    string max_n_str = \"1\" + string(100000, '0');\n\n    if (n_trimmed.length() < max_n_str.length()) {\n        // OK\n    } else if (n_trimmed.length() > max_n_str.length()) {\n        ensuref(false, \"n = %s is greater than 10^100000\", n_str.c_str());\n    } else {\n        if (n_trimmed.compare(max_n_str) <= 0) {\n            // OK\n        } else {\n            ensuref(false, \"n = %s is greater than 10^100000\", n_str.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string n_str = inf.readToken(\"[0-9]+\", \"n\");\n    inf.readEoln();\n\n    // Remove leading zeros\n    string n_trimmed = n_str;\n    n_trimmed.erase(0, n_trimmed.find_first_not_of('0'));\n\n    ensuref(!n_trimmed.empty(), \"n cannot be zero\");\n\n    // Prepare max_n_str = \"1\" + 100000 zeros\n    string max_n_str = \"1\" + string(100000, '0');\n\n    if (n_trimmed.length() < max_n_str.length()) {\n        // OK\n    } else if (n_trimmed.length() > max_n_str.length()) {\n        ensuref(false, \"n = %s is greater than 10^100000\", n_str.c_str());\n    } else {\n        if (n_trimmed.compare(max_n_str) <= 0) {\n            // OK\n        } else {\n            ensuref(false, \"n = %s is greater than 10^100000\", n_str.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Removes leading zeros but leaves at least one digit.\nstring stripLeadingZeros(const string &s) {\n    int idx = 0;\n    while (idx + 1 < (int)s.size() && s[idx] == '0') {\n        idx++;\n    }\n    return s.substr(idx);\n}\n\n// Flips the decimal representation of s (as described in the statement).\n// e.g. flip(\"130\") -> \"31\", flip(\"31\") -> \"13\", flip(\"100\") -> \"1\".\nstring flipNumber(const string &s) {\n    string r = s;\n    reverse(r.begin(), r.end());\n    return stripLeadingZeros(r);\n}\n\n// Adds two large decimal strings (no negative numbers).\nstring addBigInts(const string &a, const string &b) {\n    int carry = 0;\n    int i = (int)a.size() - 1;\n    int j = (int)b.size() - 1;\n    string result;\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n        int x = (i >= 0 ? a[i--] - '0' : 0);\n        int y = (j >= 0 ? b[j--] - '0' : 0);\n        int s = x + y + carry;\n        carry = s / 10;\n        s %= 10;\n        result.push_back(char('0' + s));\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Instead of inf.readToken(\"n\"), we simply read one token for n without a forced pattern check.\n    // That resolves the validation error: \"FAIL Token ... doesn't correspond to pattern 'n'...\".\n    string n = inf.readToken();  // read the input n as a string\n\n    // Read jury's answer (they pick 0 if no solution, or a valid solution otherwise).\n    string juryAns = ans.readToken();\n\n    // Read participant's answer.\n    string partAns = ouf.readToken();\n\n    // If the jury's answer is \"0\", that means the jury has determined there is no solution.\n    if (juryAns == \"0\") {\n        // Then participant's answer must also be \"0\" to be correct.\n        if (partAns == \"0\") {\n            quitf(_ok, \"No solution exists and participant also printed 0.\");\n        } else {\n            quitf(_wa, \"Jury claims no solution exists, but participant provided a non-zero answer.\");\n        }\n    } else {\n        // Jury found some valid solution (so a solution definitely exists).\n        // The participant must provide a valid non-zero solution as well.\n        if (partAns == \"0\") {\n            quitf(_wa, \"A solution exists, but participant printed 0.\");\n        }\n        // Check that participant's answer has no leading zero (unless it is exactly \"0\", which we handled above).\n        if (partAns.size() > 1 && partAns[0] == '0') {\n            quitf(_wa, \"Participant's answer has a leading zero.\");\n        }\n\n        // Check correctness: a + flip(a) = n\n        // Flip participant's answer:\n        string flipped = flipNumber(partAns);\n        // Add them as big integers:\n        string sumAns = addBigInts(partAns, flipped);\n\n        if (sumAns == n) {\n            quitf(_ok, \"Valid solution: a + flip(a) = n\");\n        } else {\n            quitf(_wa, \"Invalid solution: a + flip(a) != n\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverse_str(string s) {\n    reverse(s.begin(), s.end());\n    // Remove leading zeros\n    while (!s.empty() && s[0] == '0') {\n        s.erase(s.begin());\n    }\n    if (s.empty())\n        s = \"0\";\n    return s;\n}\n\nstring add_str(string a, string b) {\n    string result = \"\";\n    int carry = 0;\n    int i = int(a.size()) - 1;\n    int j = int(b.size()) - 1;\n    while (i >=0 || j >=0 || carry) {\n        int x = (i >= 0) ? a[i] - '0' : 0;\n        int y = (j >= 0) ? b[j] - '0' : 0;\n        int sum = x + y + carry;\n        carry = sum / 10;\n        sum %= 10;\n        result += char('0' + sum);\n        i--; j--;\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    if (type == \"possible\") {\n        // Generate a number a such that n=a+reverse(a) has length len\n        while (true) {\n            // We can generate len_a between 1 and len\n            int len_a = rnd.next(1, len);\n            string a;\n            a += char('1' + rnd.next(9)); // First digit from '1' to '9'\n            for (int i = 1; i < len_a; ++i) {\n                a += char('0' + rnd.next(10)); // Digits from '0' to '9'\n            }\n            string ar = reverse_str(a);\n            string n = add_str(a, ar);\n            if (int(n.size()) == len) {\n                cout << n << endl;\n                break;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate a random n of length len\n        string n;\n        n += char('1' + rnd.next(8)); // First digit from '1' to '9', avoid '9' to reduce chance of possible n\n        for (int i = 1; i < len; ++i) {\n            n += char('0' + rnd.next(10));\n        }\n        cout << n << endl;\n    } else if (type == \"edge\") {\n        // Output known edge cases\n        vector<string> edge_cases = {\"1\", \"2\", \"5\", \"10\", \"33\", \"100\", \"1000\", string(len, '9')};\n        string n = edge_cases[rnd.next(0, (int)edge_cases.size() - 1)];\n        cout << n << endl;\n    } else if (type == \"palindrome\") {\n        // Generate palindromic n\n        int half_len = (len + 1) / 2;\n        string first_half;\n        first_half += char('1' + rnd.next(9)); // First digit\n        for (int i = 1; i < half_len; ++i) {\n            first_half += char('0' + rnd.next(10));\n        }\n        string n = first_half;\n        string second_half = first_half.substr(0, len / 2);\n        reverse(second_half.begin(), second_half.end());\n        n += second_half;\n        cout << n << endl;\n    } else if (type == \"random\") {\n        // Generate random n of length len\n        string n;\n        n += char('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < len; ++i) {\n            n += char('0' + rnd.next(10));\n        }\n        cout << n << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring reverse_str(string s) {\n    reverse(s.begin(), s.end());\n    // Remove leading zeros\n    while (!s.empty() && s[0] == '0') {\n        s.erase(s.begin());\n    }\n    if (s.empty())\n        s = \"0\";\n    return s;\n}\n\nstring add_str(string a, string b) {\n    string result = \"\";\n    int carry = 0;\n    int i = int(a.size()) - 1;\n    int j = int(b.size()) - 1;\n    while (i >=0 || j >=0 || carry) {\n        int x = (i >= 0) ? a[i] - '0' : 0;\n        int y = (j >= 0) ? b[j] - '0' : 0;\n        int sum = x + y + carry;\n        carry = sum / 10;\n        sum %= 10;\n        result += char('0' + sum);\n        i--; j--;\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    if (type == \"possible\") {\n        // Generate a number a such that n=a+reverse(a) has length len\n        while (true) {\n            // We can generate len_a between 1 and len\n            int len_a = rnd.next(1, len);\n            string a;\n            a += char('1' + rnd.next(9)); // First digit from '1' to '9'\n            for (int i = 1; i < len_a; ++i) {\n                a += char('0' + rnd.next(10)); // Digits from '0' to '9'\n            }\n            string ar = reverse_str(a);\n            string n = add_str(a, ar);\n            if (int(n.size()) == len) {\n                cout << n << endl;\n                break;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate a random n of length len\n        string n;\n        n += char('1' + rnd.next(8)); // First digit from '1' to '9', avoid '9' to reduce chance of possible n\n        for (int i = 1; i < len; ++i) {\n            n += char('0' + rnd.next(10));\n        }\n        cout << n << endl;\n    } else if (type == \"edge\") {\n        // Output known edge cases\n        vector<string> edge_cases = {\"1\", \"2\", \"5\", \"10\", \"33\", \"100\", \"1000\", string(len, '9')};\n        string n = edge_cases[rnd.next(0, (int)edge_cases.size() - 1)];\n        cout << n << endl;\n    } else if (type == \"palindrome\") {\n        // Generate palindromic n\n        int half_len = (len + 1) / 2;\n        string first_half;\n        first_half += char('1' + rnd.next(9)); // First digit\n        for (int i = 1; i < half_len; ++i) {\n            first_half += char('0' + rnd.next(10));\n        }\n        string n = first_half;\n        string second_half = first_half.substr(0, len / 2);\n        reverse(second_half.begin(), second_half.end());\n        n += second_half;\n        cout << n << endl;\n    } else if (type == \"random\") {\n        // Generate random n of length len\n        string n;\n        n += char('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < len; ++i) {\n            n += char('0' + rnd.next(10));\n        }\n        cout << n << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -type possible\n./gen -len 1 -type impossible\n./gen -len 1 -type edge\n./gen -len 1 -type palindrome\n./gen -len 2 -type possible\n./gen -len 2 -type impossible\n./gen -len 2 -type edge\n./gen -len 2 -type palindrome\n./gen -len 5 -type possible\n./gen -len 5 -type impossible\n./gen -len 5 -type edge\n./gen -len 5 -type palindrome\n./gen -len 10 -type possible\n./gen -len 10 -type impossible\n./gen -len 10 -type palindrome\n./gen -len 50 -type possible\n./gen -len 100 -type possible\n./gen -len 100 -type impossible\n./gen -len 100 -type palindrome\n./gen -len 1000 -type possible\n./gen -len 1000 -type random\n./gen -len 10000 -type possible\n./gen -len 10000 -type random\n./gen -len 100000 -type possible\n./gen -len 100000 -type impossible\n./gen -len 100000 -type palindrome\n\n# Random test cases\n./gen -len 50 -type random\n./gen -len 12345 -type random\n./gen -len 54321 -type random\n./gen -len 99999 -type random\n\n# Edge cases\n./gen -len 1 -type edge\n./gen -len 5 -type edge\n./gen -len 100000 -type edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:15.196544",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "625/E",
      "title": "E. Frog Fights",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 109, n ≤ m) — number of frogs and gameboard size, respectively.Following n lines contains frogs descriptions — two integers pi and ai (1 ≤ pi, ai ≤ m) — the number of cell occupied by i-th frog initially and initial jump length. All pi are guaranteed to be distinct.",
      "output_spec": "OutputIn the first line output number of frogs on the final gameboard. In the second line output their numbers in any order.",
      "sample_tests": "ExamplesInputCopy3 52 15 34 3OutputCopy13 InputCopy5 61 23 42 55 16 1OutputCopy21 4",
      "description": "E. Frog Fights\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of the input contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 109, n ≤ m) — number of frogs and gameboard size, respectively.Following n lines contains frogs descriptions — two integers pi and ai (1 ≤ pi, ai ≤ m) — the number of cell occupied by i-th frog initially and initial jump length. All pi are guaranteed to be distinct.\n\nOutputIn the first line output number of frogs on the final gameboard. In the second line output their numbers in any order.\n\nInputCopy3 52 15 34 3OutputCopy13 InputCopy5 61 23 42 55 16 1OutputCopy21 4\n\nInputCopy3 52 15 34 3\n\nOutputCopy13\n\nInputCopy5 61 23 42 55 16 1\n\nOutputCopy21 4\n\nNoteIn the first sample first frog jumps 1 cell and finishes in cell number 3. Second frog jumps for 3 cells and finishes on cell number 3, knocking out frog number 1. Current jump length for frog number 2 is now 2. Third frog jumps to cell 2, then second frog jumps to cell 5. Third frog in turn finishes in cell 5 and removes frog 2 from the gameboard. Now, it's the only remaining frog in the game.In the second sample first frog jumps 2 cells and knocks out frogs in cells 2 and 3. Its value ai is now 0. Then fourth frog jumps and knocks out fifth frog and its ai is now 0 too. These two frogs will remains on the gameboard forever.",
      "solutions": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces",
          "content": "Hello, community!Tomorrow Codeforces Round #342 is going to take place. It will share the problemset with Moscow Olympiads in Informatics for students of grades from 6 to 9. Though, grades from 6 to 9 in Russia usually match the ages from 12 to 15, I guarantee that everyone (even Div. 1 participants) will find some interesting problems to solve. Problems were selected for you by the Moscow jury team: Zlobober, meshanya, romanandreev, Helena Andreeva and me; and prepared by members of our scientific committee: wilwell, Sender, iskhakovt, thefacetakt and feldsherov.Scoring distribution will be quite unusual: 750-750-1000-2000-3000.UPD System testing is over. Here are the top 10: _XuMuk_ pandamonium latisel zetamoo yukariko I_Love_Ximera kittylover shdut harry.zhao luke0201 Congratulation! Also, problems seemed to be too tough, we should have probably made Div. 1 round. Anyway, thanks for participating, I hope you enjoyed it and learned something new!Thanks to romanandreev for nice analysis.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1003
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces",
          "content": "625A - Guest From the PastIdea author: collaboration, preparation: feldsherov.If we have at least b money then cost of one glass bottle is b - c. This means that if a ≤ b - c then we don't need to buy glass bottles, only plastic ones, and the answer will be . Otherwise we need to buy glass bottles while we can. So, if we have at least b money, then we will buy glass bottles and then spend rest of the money on plastic ones. This is simple O(1) solution. 625B - War of the CorporationsIdea author: gustokashin, preparation: thefacetakt.Lets find leftmost occurrence of the second word in the first one. We need to add # to remove this occurrence, so where we would like to put it? Instead of the last symbol of this occurrence to remove as many others as we can. After that we will continue this operation after the new # symbol. Simplest implementation of this idea works in O(|S|·|T|), but with the power of string algorithms (for example, Knuth–Morris–Pratt algorithm) we can do it in O(|S| + |T|) time.Hint/Bug/Feature: in Python language there is already function that does exactly what we need: print(input().count(input()))625C - K-special TablesIdea author: Elena Andreeva, preparation: wilwell.Lets fill our table row by row greedily. We want to have maximal possible number on k-th place in the first row. After it we need at least n - k numbers greater than ours, so its maximum value is n2 - (n - k). If we select it then we are fixing all numbers after column k in the first row from n2 - (n - k) to n2. On the first k - 1 lets put smallest possible numbers 1,  2,  ... ,  k - 1. If we do the same thing in the second row then in the beginning it will have numbers from k to 2(k - 1), and from k-th position maximum possible values from n2 - (n - k) - (n - k + 1) to n2 - (n - k + 1). And so on we will fill all rows. With careful implementation we don't need to store whole matrix and we need only O(1) memory. Our algorithm works in O(n2) time. 625D - Finals in arithmeticIdea author: Sender, preparation: Sender.Lets say that input has length of n digits, then size of answer can be n if we didn't carry 1 to the left out of addition, and n - 1 otherwise. Lets fix length m of our answer and denote i-th number in the representation as ai. Then we know from the rightmost digit of the sum. Lets figure out what does equals to. If the remainder is 9, it means that , because we can't get 19 out of the sum of two digits. Otherwise the result is defined uniquely by the fact that there was carrying 1 in the leftmost digit of the result or not. So after this we know a1 + am. It doesn't matter how we divide sum by two digits, because the result will be the same. After this we can uniquely identify the fact of carrying after the first digit of the result and before the last digit. Repeating this m / 2 times we will get candidate for the answer. In the end we will have O(n) solution.If you've missed the fact that every step is uniquely defined, then you could've wrote basically the same solution, but with dynamic programming. 625E - Frog FightsIdea author: Elena Andreeva, preparation: iskhakovt.We want to efficiently simulate the process from the problem statement. Lets have a data structure with times of key events that could've happened during simulation (some frog removed other frog from the board). Lets remove earliest event from our data structure and apply it to the board, make a critical jump. After that the speed of the first frog will decrease and we will be forced to recount times of collision of this frog this its 2 neighbors. This data structure could be set from C++, TreeSet from Java or self-written Segment Tree. To quickly find out who are we gonna remove from the board after the jump lets store double-linked list of all frogs sorted by their positions. Technical part is to calculate time of the collision, but it can be easily done with the simple notion of linear movement of two points on a line. There could be at max n - 1 collisions, so whole solution will be .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23342",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 625\\s*E"
          },
          "content_length": 4020
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 1",
          "code": "x = raw_input() y = raw_input() print x.count(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 2",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 3",
          "code": "baaacd\naa                       \n          Answer = 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 4",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) - Codeforces - Code 5",
          "code": "String gog = in.next();\n        String tel = in.next();\n        int ans = 0;\n        int k = 0;\n        while (k + tel.length() <= gog.length()){\n            String s = gog.substring(k, k + tel.length());\n            if (s.equals(tel)){\n                ans++;\n                k = k + tel.length();\n            } else {\n                k++;\n            }\n        }\n        out.println(ans);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 1",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 2",
          "code": "print(input().count(input()))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 3",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 4",
          "code": "adding and subtracting 1\nfloor ( (n-c)/(b-c) -1 + 1)\n == floor ( (n-c + c -b)/(b-c) ) + 1\n == floor ( (n-b)/(b-c) ) + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 5",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 6",
          "code": "n-k*b + k*c < b\nn-b < k*(b-c)\n\nk = (n-b)/(b-c) + 1 \n\ntherefore ans = k + ( n- k*b + k*c)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 7",
          "code": "k > (n - b) / (b - c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 8",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #342 (Div. 2) : editorial - Codeforces - Code 9",
          "code": "k > (n-b)/(b-c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23342",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    ensuref(n <= m, \"n must be less than or equal to m\");\n\n    set<int> positions;\n    for (int i = 1; i <= n; ++i) {\n        int pi = inf.readInt(1, m, format(\"p[%d]\", i).c_str());\n        inf.readSpace();\n        int ai = inf.readInt(1, m, format(\"a[%d]\", i).c_str());\n        inf.readEoln();\n        ensuref(positions.count(pi) == 0, \"All positions (pi) must be distinct, but position %d occurs more than once\", pi);\n        positions.insert(pi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    ensuref(n <= m, \"n must be less than or equal to m\");\n\n    set<int> positions;\n    for (int i = 1; i <= n; ++i) {\n        int pi = inf.readInt(1, m, format(\"p[%d]\", i).c_str());\n        inf.readSpace();\n        int ai = inf.readInt(1, m, format(\"a[%d]\", i).c_str());\n        inf.readEoln();\n        ensuref(positions.count(pi) == 0, \"All positions (pi) must be distinct, but position %d occurs more than once\", pi);\n        positions.insert(pi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    ensuref(n <= m, \"n must be less than or equal to m\");\n\n    set<int> positions;\n    for (int i = 1; i <= n; ++i) {\n        int pi = inf.readInt(1, m, format(\"p[%d]\", i).c_str());\n        inf.readSpace();\n        int ai = inf.readInt(1, m, format(\"a[%d]\", i).c_str());\n        inf.readEoln();\n        ensuref(positions.count(pi) == 0, \"All positions (pi) must be distinct, but position %d occurs more than once\", pi);\n        positions.insert(pi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and m from the input file (inf)\n    n = inf.readInt();\n    m = inf.readInt();\n\n    // Skip reading the rest of the input as it's not needed for the checker\n\n    // Read jury's answer\n    int jury_k = ans.readInt(0, n, \"jury's number of frogs\");\n    vector<int> jury_frogs = ans.readInts(jury_k, 1, n);\n\n    // Read contestant's answer\n    int cont_k = ouf.readInt(0, n, \"contestant's number of frogs\");\n    vector<int> cont_frogs = ouf.readInts(cont_k, 1, n);\n\n    // Convert vectors to sets for unordered comparison\n    set<int> jury_set(jury_frogs.begin(), jury_frogs.end());\n    set<int> cont_set(cont_frogs.begin(), cont_frogs.end());\n\n    // Check for duplicates in contestant's output\n    if ((int)cont_set.size() != cont_k) {\n        quitf(_wa, \"contestant's output contains duplicate frog numbers\");\n    }\n\n    // Check if contestant's set matches the jury's set\n    if (cont_set != jury_set) {\n        quitf(_wa, \"incorrect set of remaining frogs\");\n    } else {\n        quitf(_ok, \"correct set of remaining frogs\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long m = opt<long long>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> pi(n), ai(n);\n\n    if (type == \"random\") {\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(1LL, m);\n        }\n    } else if (type == \"min_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = 1;\n        }\n    } else if (type == \"max_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = m;\n        }\n    } else if (type == \"small_ai\") {\n        // ai between 1 and 10\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(1LL, 10LL);\n        }\n    } else if (type == \"large_ai\") {\n        // ai between max(1, m-10) and m\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(max(1LL, m - 10LL), m);\n        }\n    } else if (type == \"decreasing_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n        }\n        long long step = m / n;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max(1LL, m - step * i);\n        }\n    } else if (type == \"increasing_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n        }\n        long long step = m / n;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min(m, 1LL + step * i);\n        }\n    } else if (type == \"edge_overlap\") {\n        // Set pi[i] = i + 1\n        if (m < n) {\n            fprintf(stderr, \"Error: m should be at least n for edge_overlap type\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            pi[i] = i + 1;\n            ai[i] = m / 2;\n        }\n    } else if (type == \"aggressive_frog\") {\n        if (n < 2) {\n            fprintf(stderr, \"Error: n should be at least 2 for aggressive_frog type\\n\");\n            exit(1);\n        }\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n        }\n        ai[0] = m; // First frog has large ai\n        for (int i = 1; i < n; ++i) {\n            ai[i] = rnd.next(1LL, 10LL); // Others have small ai\n        }\n    } else {\n        // Default to random\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(1LL, m);\n        }\n    }\n\n    printf(\"%d %lld\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", pi[i], ai[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long m = opt<long long>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> pi(n), ai(n);\n\n    if (type == \"random\") {\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(1LL, m);\n        }\n    } else if (type == \"min_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = 1;\n        }\n    } else if (type == \"max_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = m;\n        }\n    } else if (type == \"small_ai\") {\n        // ai between 1 and 10\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(1LL, 10LL);\n        }\n    } else if (type == \"large_ai\") {\n        // ai between max(1, m-10) and m\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(max(1LL, m - 10LL), m);\n        }\n    } else if (type == \"decreasing_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n        }\n        long long step = m / n;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max(1LL, m - step * i);\n        }\n    } else if (type == \"increasing_ai\") {\n        // Generate pi as above\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n        }\n        long long step = m / n;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min(m, 1LL + step * i);\n        }\n    } else if (type == \"edge_overlap\") {\n        // Set pi[i] = i + 1\n        if (m < n) {\n            fprintf(stderr, \"Error: m should be at least n for edge_overlap type\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            pi[i] = i + 1;\n            ai[i] = m / 2;\n        }\n    } else if (type == \"aggressive_frog\") {\n        if (n < 2) {\n            fprintf(stderr, \"Error: n should be at least 2 for aggressive_frog type\\n\");\n            exit(1);\n        }\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n        }\n        ai[0] = m; // First frog has large ai\n        for (int i = 1; i < n; ++i) {\n            ai[i] = rnd.next(1LL, 10LL); // Others have small ai\n        }\n    } else {\n        // Default to random\n        set<long long> pi_set;\n        for (int i = 0; i < n; ++i) {\n            long long x;\n            do {\n                x = rnd.next(1LL, m);\n            } while (pi_set.count(x));\n            pi_set.insert(x);\n            pi[i] = x;\n            ai[i] = rnd.next(1LL, m);\n        }\n    }\n\n    printf(\"%d %lld\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", pi[i], ai[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 100 -type random\n\n./gen -n 2 -m 10 -type min_ai\n./gen -n 2 -m 10 -type max_ai\n\n./gen -n 10 -m 10 -type small_ai\n./gen -n 10 -m 10 -type large_ai\n\n./gen -n 5 -m 20 -type decreasing_ai\n./gen -n 5 -m 20 -type increasing_ai\n\n./gen -n 100 -m 1000 -type random\n./gen -n 1000 -m 1000000 -type random\n\n./gen -n 100000 -m 1000000000 -type random\n\n./gen -n 100000 -m 1000000000 -type min_ai\n./gen -n 100000 -m 1000000000 -type max_ai\n\n./gen -n 100000 -m 1000000000 -type small_ai\n./gen -n 100000 -m 1000000000 -type large_ai\n\n./gen -n 100000 -m 1000000000 -type decreasing_ai\n./gen -n 100000 -m 1000000000 -type increasing_ai\n\n./gen -n 10 -m 10 -type edge_overlap\n./gen -n 100000 -m 1000000000 -type edge_overlap\n\n./gen -n 2 -m 100 -type aggressive_frog\n./gen -n 100 -m 10000 -type aggressive_frog\n./gen -n 100000 -m 1000000000 -type aggressive_frog\n\n./gen -n 1 -m 1000000000 -type random\n\n./gen -n 99999 -m 1000000000 -type small_ai\n\n./gen -n 100000 -m 1000000000 -type large_ai\n\n./gen -n 99999 -m 1000000000 -type decreasing_ai\n\n./gen -n 100000 -m 1000000000 -type increasing_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:17.247115",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/A",
      "title": "A. Robot Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single positive integer, n (1 ≤ n ≤ 200) — the number of commands.The next line contains n characters, each either 'U', 'R', 'D', or 'L' — Calvin's source code.",
      "output_spec": "OutputPrint a single integer — the number of contiguous substrings that Calvin can execute and return to his starting square.",
      "sample_tests": "ExamplesInputCopy6URLLDROutputCopy2InputCopy4DLUUOutputCopy0InputCopy7RLRLRLROutputCopy12",
      "description": "A. Robot Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single positive integer, n (1 ≤ n ≤ 200) — the number of commands.The next line contains n characters, each either 'U', 'R', 'D', or 'L' — Calvin's source code.\n\nOutputPrint a single integer — the number of contiguous substrings that Calvin can execute and return to his starting square.\n\nInputCopy6URLLDROutputCopy2InputCopy4DLUUOutputCopy0InputCopy7RLRLRLROutputCopy12\n\nInputCopy6URLLDR\n\nOutputCopy2\n\nInputCopy4DLUU\n\nOutputCopy0\n\nInputCopy7RLRLRLR\n\nOutputCopy12\n\nNoteIn the first case, the entire source code works, as well as the \"RL\" substring in the second and third characters.Note that, in the third case, the substring \"LR\" appears three times, and is therefore counted three times to the total result.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*A"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n    string pattern = \"[URDL]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"source code\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n    string pattern = \"[URDL]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"source code\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n    string pattern = \"[URDL]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"source code\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n\n    if (type == \"all_U\") {\n        s = string(n, 'U');\n    } else if (type == \"all_D\") {\n        s = string(n, 'D');\n    } else if (type == \"all_L\") {\n        s = string(n, 'L');\n    } else if (type == \"all_R\") {\n        s = string(n, 'R');\n    } else if (type == \"alternating_LR\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"alternating_UD\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0) ? 'U' : 'D';\n        }\n    } else if (type == \"cycles\") {\n        string cycle = \"URDL\";\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += cycle[i % 4];\n        }\n    } else if (type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            int x = rnd.next(0, 3);\n            char c = \"UDLR\"[x];\n            s += c;\n        }\n    } else if (type == \"max_solutions\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"no_solution\") {\n        s = string(n, 'U');\n    } else {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            int x = rnd.next(0, 3);\n            char c = \"UDLR\"[x];\n            s += c;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n\n    if (type == \"all_U\") {\n        s = string(n, 'U');\n    } else if (type == \"all_D\") {\n        s = string(n, 'D');\n    } else if (type == \"all_L\") {\n        s = string(n, 'L');\n    } else if (type == \"all_R\") {\n        s = string(n, 'R');\n    } else if (type == \"alternating_LR\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"alternating_UD\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0) ? 'U' : 'D';\n        }\n    } else if (type == \"cycles\") {\n        string cycle = \"URDL\";\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += cycle[i % 4];\n        }\n    } else if (type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            int x = rnd.next(0, 3);\n            char c = \"UDLR\"[x];\n            s += c;\n        }\n    } else if (type == \"max_solutions\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"no_solution\") {\n        s = string(n, 'U');\n    } else {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            int x = rnd.next(0, 3);\n            char c = \"UDLR\"[x];\n            s += c;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_U\n./gen -n 1 -type all_D\n./gen -n 1 -type all_L\n./gen -n 1 -type all_R\n\n./gen -n 2 -type alternating_LR\n./gen -n 2 -type alternating_UD\n./gen -n 2 -type cycles\n./gen -n 2 -type random\n./gen -n 2 -type no_solution\n\n./gen -n 5 -type all_U\n./gen -n 5 -type alternating_LR\n./gen -n 5 -type alternating_UD\n./gen -n 5 -type cycles\n./gen -n 5 -type random\n./gen -n 5 -type max_solutions\n./gen -n 5 -type no_solution\n\n./gen -n 10 -type all_D\n./gen -n 10 -type alternating_LR\n./gen -n 10 -type alternating_UD\n./gen -n 10 -type cycles\n./gen -n 10 -type random\n./gen -n 10 -type max_solutions\n\n./gen -n 50 -type random\n./gen -n 50 -type alternating_LR\n./gen -n 50 -type alternating_UD\n./gen -n 50 -type cycles\n./gen -n 50 -type max_solutions\n\n./gen -n 100 -type random\n./gen -n 100 -type max_solutions\n\n./gen -n 199 -type random\n./gen -n 199 -type cycles\n\n./gen -n 200 -type random\n./gen -n 200 -type max_solutions\n./gen -n 200 -type no_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:19.515852",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/B",
      "title": "B. Cards",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (1 ≤ n ≤ 200) — the total number of cards.The next line contains a string s of length n — the colors of the cards. s contains only the characters 'B', 'G', and 'R', representing blue, green, and red, respectively.",
      "output_spec": "OutputPrint a single string of up to three characters — the possible colors of the final card (using the same symbols as the input) in alphabetical order.",
      "sample_tests": "ExamplesInputCopy2RBOutputCopyGInputCopy3GRGOutputCopyBRInputCopy5BBBBBOutputCopyB",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (1 ≤ n ≤ 200) — the total number of cards.The next line contains a string s of length n — the colors of the cards. s contains only the characters 'B', 'G', and 'R', representing blue, green, and red, respectively.\n\nOutputPrint a single string of up to three characters — the possible colors of the final card (using the same symbols as the input) in alphabetical order.\n\nInputCopy2RBOutputCopyGInputCopy3GRGOutputCopyBRInputCopy5BBBBBOutputCopyB\n\nInputCopy2RB\n\nOutputCopyG\n\nInputCopy3GRG\n\nOutputCopyBR\n\nInputCopy5BBBBB\n\nOutputCopyB\n\nNoteIn the first sample, Catherine has one red card and one blue card, which she must exchange for a green card.In the second sample, Catherine has two green cards and one red card. She has two options: she can exchange the two green cards for a green card, then exchange the new green card and the red card for a blue card. Alternatively, she can exchange a green and a red card for a blue card, then exchange the blue card and remaining green card for a red card.In the third sample, Catherine only has blue cards, so she can only exchange them for more blue cards.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*B"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[BGR]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[BGR]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[BGR]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> colors(n);\n    string available_colors = \"RGB\"; // Possible colors\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            colors[i] = available_colors[rnd.next(3)]; // Randomly select one of 'R', 'G', 'B'\n        }\n    } else if (type == \"all_same\") {\n        string color = opt<string>(\"color\");\n        if (color.size() != 1 || available_colors.find(color) == string::npos) {\n            cerr << \"Invalid color specified for all_same type\" << endl;\n            return 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            colors[i] = color[0];\n        }\n    } else if (type == \"two_colors\") {\n        string colors_param = opt<string>(\"colors\");\n        if (colors_param.size() != 2 ||\n            available_colors.find(colors_param[0]) == string::npos ||\n            available_colors.find(colors_param[1]) == string::npos ||\n            colors_param[0] == colors_param[1]) {\n            cerr << \"Invalid colors specified for two_colors type\" << endl;\n            return 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            colors[i] = colors_param[rnd.next(2)]; // Randomly select one of the two colors\n        }\n    } else if (type == \"specific_counts\") {\n        int R = opt<int>(\"R\", 0);\n        int G = opt<int>(\"G\", 0);\n        int B = opt<int>(\"B\", 0);\n        if (R + G + B != n) {\n            cerr << \"Sum of R, G, B must equal n\" << endl;\n            return 1;\n        }\n        vector<char> temp_colors;\n        temp_colors.insert(temp_colors.end(), R, 'R');\n        temp_colors.insert(temp_colors.end(), G, 'G');\n        temp_colors.insert(temp_colors.end(), B, 'B');\n        // Shuffle the colors\n        shuffle(temp_colors.begin(), temp_colors.end());\n        colors = temp_colors;\n    } else {\n        cerr << \"Invalid type specified\" << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output s\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c\", colors[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> colors(n);\n    string available_colors = \"RGB\"; // Possible colors\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            colors[i] = available_colors[rnd.next(3)]; // Randomly select one of 'R', 'G', 'B'\n        }\n    } else if (type == \"all_same\") {\n        string color = opt<string>(\"color\");\n        if (color.size() != 1 || available_colors.find(color) == string::npos) {\n            cerr << \"Invalid color specified for all_same type\" << endl;\n            return 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            colors[i] = color[0];\n        }\n    } else if (type == \"two_colors\") {\n        string colors_param = opt<string>(\"colors\");\n        if (colors_param.size() != 2 ||\n            available_colors.find(colors_param[0]) == string::npos ||\n            available_colors.find(colors_param[1]) == string::npos ||\n            colors_param[0] == colors_param[1]) {\n            cerr << \"Invalid colors specified for two_colors type\" << endl;\n            return 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            colors[i] = colors_param[rnd.next(2)]; // Randomly select one of the two colors\n        }\n    } else if (type == \"specific_counts\") {\n        int R = opt<int>(\"R\", 0);\n        int G = opt<int>(\"G\", 0);\n        int B = opt<int>(\"B\", 0);\n        if (R + G + B != n) {\n            cerr << \"Sum of R, G, B must equal n\" << endl;\n            return 1;\n        }\n        vector<char> temp_colors;\n        temp_colors.insert(temp_colors.end(), R, 'R');\n        temp_colors.insert(temp_colors.end(), G, 'G');\n        temp_colors.insert(temp_colors.end(), B, 'B');\n        // Shuffle the colors\n        shuffle(temp_colors.begin(), temp_colors.end());\n        colors = temp_colors;\n    } else {\n        cerr << \"Invalid type specified\" << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output s\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c\", colors[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with small n\n./gen -n 1 -type random\n./gen -n 1 -type all_same -color R\n./gen -n 1 -type all_same -color G\n./gen -n 1 -type all_same -color B\n\n./gen -n 2 -type random\n./gen -n 2 -type all_same -color R\n./gen -n 2 -type two_colors -colors RG\n./gen -n 2 -type two_colors -colors RB\n./gen -n 2 -type two_colors -colors GB\n\n./gen -n 3 -type random\n./gen -n 3 -type all_same -color G\n./gen -n 3 -type specific_counts -R 1 -G 1 -B 1\n\n# Test cases with medium n\n./gen -n 50 -type random\n./gen -n 50 -type all_same -color B\n./gen -n 50 -type two_colors -colors RG\n./gen -n 50 -type specific_counts -R 25 -G 25 -B 0\n\n# Test cases with large n\n./gen -n 100 -type random\n./gen -n 100 -type all_same -color R\n./gen -n 100 -type two_colors -colors GB\n./gen -n 100 -type specific_counts -R 33 -G 33 -B 34\n\n# Test cases with maximum n\n./gen -n 200 -type random\n./gen -n 200 -type all_same -color G\n./gen -n 200 -type specific_counts -R 100 -G 50 -B 50\n./gen -n 200 -type specific_counts -R 100 -G 0 -B 100\n./gen -n 200 -type specific_counts -R 1 -G 1 -B 198\n./gen -n 200 -type specific_counts -R 67 -G 67 -B 66\n\n# Test cases focusing on two colors\n./gen -n 200 -type two_colors -colors RG\n./gen -n 200 -type two_colors -colors RB\n./gen -n 200 -type two_colors -colors GB\n\n# Test cases with only one color\n./gen -n 200 -type specific_counts -R 0 -G 0 -B 200\n./gen -n 200 -type specific_counts -R 0 -G 200 -B 0\n\n# Edge cases with specific parity\n./gen -n 200 -type specific_counts -R 100 -G 100 -B 0\n./gen -n 200 -type specific_counts -R 99 -G 99 -B 2\n./gen -n 200 -type specific_counts -R 1 -G 1 -B 198\n./gen -n 200 -type specific_counts -R 100 -G 0 -B 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:21.711953",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/C",
      "title": "C. Башни из кубиков",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны два числа n и m (0 ≤ n, m ≤ 1 000 000, n + m > 0) — количество студентов, использующих блоки из двух кубиков, и количество студентов, использующих блоки из трёх кубиков, соответственно.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимально возможную высоту самой высокой башни, если высоты всех башен положительны и различны.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 3Выходные данныеСкопировать9Входные данныеСкопировать3 2Выходные данныеСкопировать8Входные данныеСкопировать5 0Выходные данныеСкопировать10",
      "description": "C. Башни из кубиков\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны два числа n и m (0 ≤ n, m ≤ 1 000 000, n + m > 0) — количество студентов, использующих блоки из двух кубиков, и количество студентов, использующих блоки из трёх кубиков, соответственно.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимально возможную высоту самой высокой башни, если высоты всех башен положительны и различны.\n\nВыходные данные\n\nВходные данныеСкопировать1 3Выходные данныеСкопировать9Входные данныеСкопировать3 2Выходные данныеСкопировать8Входные данныеСкопировать5 0Выходные данныеСкопировать10\n\nВходные данныеСкопировать1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере студент, использующий блоки из двух кубиков, может построить башню высоты 4, а студенты, использующие блоки из трёх кубиков, — башни высоты 3, 6 и 9. Самая высокая башня будет иметь высоту 9 кубиков.Во втором примере студенты могут построить башни высотой 2, 4 и 8, используя блоки по два кубика, и башни высотой 3 и 6, используя блоки по три кубика.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*C"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    ensuref(n + m > 0, \"n + m must be greater than 0, but n=%d and m=%d\", n, m);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    ensuref(n + m > 0, \"n + m must be greater than 0, but n=%d and m=%d\", n, m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    ensuref(n + m > 0, \"n + m must be greater than 0, but n=%d and m=%d\", n, m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n\n    int n = 0, m = 0;\n\n    if (type == \"sample1\") {\n        // Sample Input 1: 1 3\n        n = 1;\n        m = 3;\n    } else if (type == \"sample2\") {\n        // Sample Input 2: 3 2\n        n = 3;\n        m = 2;\n    } else if (type == \"n_zero\") {\n        // n = 0, m > 0\n        n = 0;\n        m = rnd.next(1, 1000000);\n    } else if (type == \"m_zero\") {\n        // n > 0, m = 0\n        n = rnd.next(1, 1000000);\n        m = 0;\n    } else if (type == \"max_n\") {\n        // n maximum, m small\n        n = 1000000;\n        m = rnd.next(1, 10);\n    } else if (type == \"max_m\") {\n        // m maximum, n small\n        n = rnd.next(1, 10);\n        m = 1000000;\n    } else if (type == \"max_both\") {\n        // Both n and m maximum\n        n = 1000000;\n        m = 1000000;\n    } else if (type == \"n_eq_m\") {\n        // n equals m\n        n = m = rnd.next(1, 1000000);\n    } else if (type == \"n_gt_m\") {\n        // n greater than m\n        m = rnd.next(1, 999999);\n        n = rnd.next(m + 1, 1000000);\n    } else if (type == \"m_gt_n\") {\n        // m greater than n\n        n = rnd.next(1, 999999);\n        m = rnd.next(n + 1, 1000000);\n    } else if (type == \"random_small\") {\n        // Small random n and m\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 1000);\n    } else if (type == \"random_large\") {\n        // Large random n and m\n        n = rnd.next(1, 1000000);\n        m = rnd.next(1, 1000000);\n    } else {\n        // Default case: random small n and m\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 1000);\n    }\n\n    // Ensure that n and m satisfy the constraints\n    // 0 ≤ n, m ≤ 1 000 000, n + m > 0\n\n    if (n < 0 || n > 1000000 || m < 0 || m > 1000000 || n + m == 0) {\n        fprintf(stderr, \"Invalid n or m generated: n = %d, m = %d\\n\", n, m);\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n\n    int n = 0, m = 0;\n\n    if (type == \"sample1\") {\n        // Sample Input 1: 1 3\n        n = 1;\n        m = 3;\n    } else if (type == \"sample2\") {\n        // Sample Input 2: 3 2\n        n = 3;\n        m = 2;\n    } else if (type == \"n_zero\") {\n        // n = 0, m > 0\n        n = 0;\n        m = rnd.next(1, 1000000);\n    } else if (type == \"m_zero\") {\n        // n > 0, m = 0\n        n = rnd.next(1, 1000000);\n        m = 0;\n    } else if (type == \"max_n\") {\n        // n maximum, m small\n        n = 1000000;\n        m = rnd.next(1, 10);\n    } else if (type == \"max_m\") {\n        // m maximum, n small\n        n = rnd.next(1, 10);\n        m = 1000000;\n    } else if (type == \"max_both\") {\n        // Both n and m maximum\n        n = 1000000;\n        m = 1000000;\n    } else if (type == \"n_eq_m\") {\n        // n equals m\n        n = m = rnd.next(1, 1000000);\n    } else if (type == \"n_gt_m\") {\n        // n greater than m\n        m = rnd.next(1, 999999);\n        n = rnd.next(m + 1, 1000000);\n    } else if (type == \"m_gt_n\") {\n        // m greater than n\n        n = rnd.next(1, 999999);\n        m = rnd.next(n + 1, 1000000);\n    } else if (type == \"random_small\") {\n        // Small random n and m\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 1000);\n    } else if (type == \"random_large\") {\n        // Large random n and m\n        n = rnd.next(1, 1000000);\n        m = rnd.next(1, 1000000);\n    } else {\n        // Default case: random small n and m\n        n = rnd.next(1, 1000);\n        m = rnd.next(1, 1000);\n    }\n\n    // Ensure that n and m satisfy the constraints\n    // 0 ≤ n, m ≤ 1 000 000, n + m > 0\n\n    if (n < 0 || n > 1000000 || m < 0 || m > 1000000 || n + m == 0) {\n        fprintf(stderr, \"Invalid n or m generated: n = %d, m = %d\\n\", n, m);\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample1\n./gen -type sample2\n./gen -type n_zero\n./gen -type m_zero\n./gen -type n_zero\n./gen -type m_zero\n./gen -type max_n\n./gen -type max_n\n./gen -type max_m\n./gen -type max_m\n./gen -type max_both\n./gen -type n_eq_m\n./gen -type n_eq_m\n./gen -type n_eq_m\n./gen -type n_gt_m\n./gen -type n_gt_m\n./gen -type n_gt_m\n./gen -type m_gt_n\n./gen -type m_gt_n\n./gen -type m_gt_n\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:23.601100",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/D",
      "title": "D. Jerry's Protest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (2 ≤ n ≤ 2000) — the number of balls in the jar.The second line contains n integers ai (1 ≤ ai ≤ 5000) — the number written on the ith ball. It is guaranteed that no two balls have the same number.",
      "output_spec": "OutputPrint a single real value — the probability that Jerry has a higher total, given that Andrew wins the first two rounds and Jerry wins the third. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy0.0000000000InputCopy31 2 10OutputCopy0.0740740741",
      "description": "D. Jerry's Protest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains a single integer n (2 ≤ n ≤ 2000) — the number of balls in the jar.The second line contains n integers ai (1 ≤ ai ≤ 5000) — the number written on the ith ball. It is guaranteed that no two balls have the same number.\n\nOutputPrint a single real value — the probability that Jerry has a higher total, given that Andrew wins the first two rounds and Jerry wins the third. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy21 2OutputCopy0.0000000000InputCopy31 2 10OutputCopy0.0740740741\n\nInputCopy21 2\n\nOutputCopy0.0000000000\n\nInputCopy31 2 10\n\nOutputCopy0.0740740741\n\nNoteIn the first case, there are only two balls. In the first two rounds, Andrew must have drawn the 2 and Jerry must have drawn the 1, and vice versa in the final round. Thus, Andrew's sum is 5 and Jerry's sum is 4, so Jerry never has a higher total.In the second case, each game could've had three outcomes — 10 - 2, 10 - 1, or 2 - 1. Jerry has a higher total if and only if Andrew won 2 - 1 in both of the first two rounds, and Jerry drew the 10 in the last round. This has probability .",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*D"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 5000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 5000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 5000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        // Generate n distinct integers between 1 and 5000\n        set<int> s;\n        while ((int)s.size() < n) {\n            s.insert(rnd.next(1, 5000));\n        }\n        ai.assign(s.begin(), s.end());\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"small\") {\n        // Generate n distinct integers between 1 and min(5000, n*10)\n        int max_val = min(5000, n * 10);\n        vector<int> candidates;\n        for (int i = 1; i <= max_val; ++i) {\n            candidates.push_back(i);\n        }\n        shuffle(candidates.begin(), candidates.end());\n        ai.assign(candidates.begin(), candidates.begin() + n);\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"large\") {\n        // Generate n distinct integers between 5000 - n*10 + 1 and 5000\n        int start = max(1, 5000 - n * 10 + 1);\n        vector<int> candidates;\n        for (int i = start; i <= 5000; ++i) {\n            candidates.push_back(i);\n        }\n        shuffle(candidates.begin(), candidates.end());\n        ai.assign(candidates.begin(), candidates.begin() + n);\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"increasing\") {\n        // Generate n increasing integers starting from 1\n        for (int i = 0; i < n; ++i) {\n            ai[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate n decreasing integers starting from 5000\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 5000 - i;\n        }\n    } else if (type == \"alternating\") {\n        // Generate n integers alternating between low and high values\n        int low = 1;\n        int high = 5000;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ai[i] = low++;\n            } else {\n                ai[i] = high--;\n            }\n        }\n    } else if (type == \"same_sum\") {\n        // Attempt to generate ai's that make the sums of Andrew and Jerry equal\n        // Adjustments are made to ensure that all ai's are distinct\n        if (n >= 6) {\n            for (int i = 0; i < n; ++i) {\n                ai[i] = 1000 + i;\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                ai[i] = (i + 1) * 5;\n            }\n        }\n    } else if (type == \"max_ai\") {\n        // Place maximum ai at the end\n        for (int i = 0; i < n - 1; ++i) {\n            ai[i] = i + 1;\n        }\n        ai[n - 1] = 5000;\n    } else {\n        // Default is random\n        set<int> s;\n        while ((int)s.size() < n) {\n            s.insert(rnd.next(1, 5000));\n        }\n        ai.assign(s.begin(), s.end());\n        shuffle(ai.begin(), ai.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        // Generate n distinct integers between 1 and 5000\n        set<int> s;\n        while ((int)s.size() < n) {\n            s.insert(rnd.next(1, 5000));\n        }\n        ai.assign(s.begin(), s.end());\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"small\") {\n        // Generate n distinct integers between 1 and min(5000, n*10)\n        int max_val = min(5000, n * 10);\n        vector<int> candidates;\n        for (int i = 1; i <= max_val; ++i) {\n            candidates.push_back(i);\n        }\n        shuffle(candidates.begin(), candidates.end());\n        ai.assign(candidates.begin(), candidates.begin() + n);\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"large\") {\n        // Generate n distinct integers between 5000 - n*10 + 1 and 5000\n        int start = max(1, 5000 - n * 10 + 1);\n        vector<int> candidates;\n        for (int i = start; i <= 5000; ++i) {\n            candidates.push_back(i);\n        }\n        shuffle(candidates.begin(), candidates.end());\n        ai.assign(candidates.begin(), candidates.begin() + n);\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"increasing\") {\n        // Generate n increasing integers starting from 1\n        for (int i = 0; i < n; ++i) {\n            ai[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate n decreasing integers starting from 5000\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 5000 - i;\n        }\n    } else if (type == \"alternating\") {\n        // Generate n integers alternating between low and high values\n        int low = 1;\n        int high = 5000;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ai[i] = low++;\n            } else {\n                ai[i] = high--;\n            }\n        }\n    } else if (type == \"same_sum\") {\n        // Attempt to generate ai's that make the sums of Andrew and Jerry equal\n        // Adjustments are made to ensure that all ai's are distinct\n        if (n >= 6) {\n            for (int i = 0; i < n; ++i) {\n                ai[i] = 1000 + i;\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                ai[i] = (i + 1) * 5;\n            }\n        }\n    } else if (type == \"max_ai\") {\n        // Place maximum ai at the end\n        for (int i = 0; i < n - 1; ++i) {\n            ai[i] = i + 1;\n        }\n        ai[n - 1] = 5000;\n    } else {\n        // Default is random\n        set<int> s;\n        while ((int)s.size() < n) {\n            s.insert(rnd.next(1, 5000));\n        }\n        ai.assign(s.begin(), s.end());\n        shuffle(ai.begin(), ai.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type small\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type same_sum\n\n./gen -n 3 -type random\n./gen -n 3 -type small\n./gen -n 3 -type increasing\n./gen -n 3 -type decreasing\n./gen -n 3 -type alternating\n./gen -n 3 -type same_sum\n\n./gen -n 10 -type random\n./gen -n 10 -type small\n./gen -n 10 -type large\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type same_sum\n./gen -n 10 -type max_ai\n\n./gen -n 100 -type random\n./gen -n 100 -type small\n./gen -n 100 -type large\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n\n./gen -n 2000 -type random\n./gen -n 2000 -type small\n./gen -n 2000 -type large\n./gen -n 2000 -type increasing\n./gen -n 2000 -type decreasing\n./gen -n 2000 -type alternating\n./gen -n 2000 -type max_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:25.935371",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/E",
      "title": "E. Простая асимметрия",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано число n (1 ≤ n ≤ 200 000) — количество чисел в наборе.Во второй строке записано n целых чисел xi (0 ≤ xi ≤ 1 000 000) — элементы набора.",
      "output_spec": "Выходные данныеВ первой строке выведите число k (1 ≤ k ≤ n) — размер подмножества.Во второй строке выведите k чисел — элементы выбранного подмножества в любом порядке.Если оптимальных ответов несколько, то разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать41 2 3 12Выходные данныеСкопировать31 2 12 Входные данныеСкопировать41 1 2 2Выходные данныеСкопировать31 1 2 Входные данныеСкопировать21 2Выходные данныеСкопировать21 2",
      "description": "E. Простая асимметрия\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано число n (1 ≤ n ≤ 200 000) — количество чисел в наборе.Во второй строке записано n целых чисел xi (0 ≤ xi ≤ 1 000 000) — элементы набора.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите число k (1 ≤ k ≤ n) — размер подмножества.Во второй строке выведите k чисел — элементы выбранного подмножества в любом порядке.Если оптимальных ответов несколько, то разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать41 2 3 12Выходные данныеСкопировать31 2 12 Входные данныеСкопировать41 1 2 2Выходные данныеСкопировать31 1 2 Входные данныеСкопировать21 2Выходные данныеСкопировать21 2\n\nВходные данныеСкопировать41 2 3 12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 2 12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 1 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 1 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оптимальным подмножеством является  со средним значением 5, медианой 2 и значением простой асимметрии 5 - 2 = 3.Во втором примере оптимальным подмножеством является . Обратите внимание, что разрешены одинаковые элементы.В последнем примере у любого подмножества среднее значение равно медиане, поэтому максимальная простая асимметрия равна 0.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*E"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 0, 1000000, \"xi\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 0, 1000000, \"xi\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 0, 1000000, \"xi\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> xi;\nmap<int, int> xi_counts;\n\n// This function reads an answer from the given stream (ans or ouf),\n// validates it according to the problem constraints,\n// calculates the skewness numerator and denominator, and returns them.\n// If the answer is invalid, it reports _wa (for ouf) or _fail (for ans).\npair<long long, long long> readAns(InStream& stream) {\n    // Read k\n    int k = stream.readInt(1, 1000000, \"k\");\n    vector<int> yi(k);\n    map<int, int> yi_counts;\n    long long sum_yi = 0;\n    for (int i = 0; i < k; ++i) {\n        yi[i] = stream.readInt(0, 1000000, format(\"y[%d]\", i + 1).c_str());\n        if (xi_counts.find(yi[i]) == xi_counts.end()) {\n            stream.quitf(_wa, \"Element y[%d] = %d does not exist in the input list\", i + 1, yi[i]);\n        }\n        yi_counts[yi[i]]++;\n        if (yi_counts[yi[i]] > xi_counts[yi[i]]) {\n            stream.quitf(_wa, \"Element %d is used more times than it appears in the input list\", yi[i]);\n        }\n        sum_yi += yi[i];\n    }\n\n    // Compute median\n    sort(yi.begin(), yi.end());\n    long long median_numer, median_denom;\n    if (k % 2 == 1) {\n        // Odd k\n        median_numer = yi[k / 2];\n        median_denom = 1;\n    } else {\n        // Even k\n        median_numer = yi[k / 2 - 1] + yi[k / 2];\n        median_denom = 2;\n    }\n\n    // Compute skewness numerator and denominator\n    long long skewness_numer = sum_yi * median_denom - k * median_numer;\n    long long skewness_denom = k * median_denom;\n\n    return make_pair(skewness_numer, skewness_denom);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    n = inf.readInt();\n    xi.resize(n);\n    for (int i = 0; i < n; ++i) {\n        xi[i] = inf.readInt(0, 1000000);\n        xi_counts[xi[i]]++;\n    }\n\n    // Read jury's answer\n    pair<long long, long long> jury_skewness = readAns(ans);\n\n    // Read participant's answer\n    pair<long long, long long> participant_skewness = readAns(ouf);\n\n    // Compare skewness values\n    long long jury_numer = jury_skewness.first;\n    long long jury_denom = jury_skewness.second;\n    long long participant_numer = participant_skewness.first;\n    long long participant_denom = participant_skewness.second;\n\n    // Cross-multiply to compare fractions\n    long long lhs = participant_numer * jury_denom;\n    long long rhs = jury_numer * participant_denom;\n\n    if (lhs < rhs) {\n        quitf(_wa, \"Participant's skewness is less than jury's skewness\");\n    } else if (lhs == rhs) {\n        quitf(_ok, \"Correct answer\");\n    } else {\n        quitf(_fail, \"Participant's skewness is greater than jury's skewness\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n\n    if (type == \"all_zero\") {\n        /* All elements are zero */\n        for(int i = 0; i < n; ++i)\n            xi[i] = 0;\n    } else if (type == \"all_max\") {\n        /* All elements are maximum allowed value */\n        for(int i = 0; i < n; ++i)\n            xi[i] = 1000000;\n    } else if (type == \"increasing\") {\n        /* Elements are in increasing order from 0 to 1,000,000 */\n        if (n == 1) {\n            xi[0] = rnd.next(0, 1000000);\n        } else {\n            for(int i = 0; i < n; ++i)\n                xi[i] = (1000000 * i) / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        /* Elements are in decreasing order from 1,000,000 to 0 */\n        if (n == 1) {\n            xi[0] = rnd.next(0, 1000000);\n        } else {\n            for(int i = 0; i < n; ++i)\n                xi[i] = 1000000 - (1000000 * i) / (n - 1);\n        }\n    } else if (type == \"small_large_alternating\") {\n        /* Elements alternate between small and large numbers */\n        for(int i = 0; i < n; ++i)\n            xi[i] = (i % 2 == 0) ? 0 : 1000000;\n    } else if (type == \"random\") {\n        /* Random elements between 0 and 1,000,000 */\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 1000000);\n    } else if (type == \"few_unique\") {\n        /* Elements have few unique numbers */\n        int num_unique = opt<int>(\"u\", 2);\n        vector<int> unique_values;\n        for(int i = 0; i < num_unique; ++i)\n            unique_values.push_back(rnd.next(0, 1000000));\n        for(int i = 0; i < n; ++i)\n            xi[i] = unique_values[rnd.next(0, num_unique - 1)];\n    } else if (type == \"max_skewness\") {\n        /* Maximizes simple skewness */\n        int num_large = opt<int>(\"l\", 1);\n        int num_small = n - num_large;\n        int small_value = 0;\n        int large_value = 1000000;\n        for(int i = 0; i < num_small; ++i)\n            xi[i] = small_value;\n        for(int i = num_small; i < n; ++i)\n            xi[i] = large_value;\n        shuffle(xi.begin(), xi.end());\n    } else if (type == \"min_skewness\") {\n        /* Minimizes simple skewness */\n        int num_small = opt<int>(\"s\", 1);\n        int num_large = n - num_small;\n        int small_value = 0;\n        int large_value = 1000000;\n        for(int i = 0; i < num_large; ++i)\n            xi[i] = large_value;\n        for(int i = num_large; i < n; ++i)\n            xi[i] = small_value;\n        shuffle(xi.begin(), xi.end());\n    } else {\n        /* Default to random */\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 1000000);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output xi elements */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n\n    if (type == \"all_zero\") {\n        /* All elements are zero */\n        for(int i = 0; i < n; ++i)\n            xi[i] = 0;\n    } else if (type == \"all_max\") {\n        /* All elements are maximum allowed value */\n        for(int i = 0; i < n; ++i)\n            xi[i] = 1000000;\n    } else if (type == \"increasing\") {\n        /* Elements are in increasing order from 0 to 1,000,000 */\n        if (n == 1) {\n            xi[0] = rnd.next(0, 1000000);\n        } else {\n            for(int i = 0; i < n; ++i)\n                xi[i] = (1000000 * i) / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        /* Elements are in decreasing order from 1,000,000 to 0 */\n        if (n == 1) {\n            xi[0] = rnd.next(0, 1000000);\n        } else {\n            for(int i = 0; i < n; ++i)\n                xi[i] = 1000000 - (1000000 * i) / (n - 1);\n        }\n    } else if (type == \"small_large_alternating\") {\n        /* Elements alternate between small and large numbers */\n        for(int i = 0; i < n; ++i)\n            xi[i] = (i % 2 == 0) ? 0 : 1000000;\n    } else if (type == \"random\") {\n        /* Random elements between 0 and 1,000,000 */\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 1000000);\n    } else if (type == \"few_unique\") {\n        /* Elements have few unique numbers */\n        int num_unique = opt<int>(\"u\", 2);\n        vector<int> unique_values;\n        for(int i = 0; i < num_unique; ++i)\n            unique_values.push_back(rnd.next(0, 1000000));\n        for(int i = 0; i < n; ++i)\n            xi[i] = unique_values[rnd.next(0, num_unique - 1)];\n    } else if (type == \"max_skewness\") {\n        /* Maximizes simple skewness */\n        int num_large = opt<int>(\"l\", 1);\n        int num_small = n - num_large;\n        int small_value = 0;\n        int large_value = 1000000;\n        for(int i = 0; i < num_small; ++i)\n            xi[i] = small_value;\n        for(int i = num_small; i < n; ++i)\n            xi[i] = large_value;\n        shuffle(xi.begin(), xi.end());\n    } else if (type == \"min_skewness\") {\n        /* Minimizes simple skewness */\n        int num_small = opt<int>(\"s\", 1);\n        int num_large = n - num_small;\n        int small_value = 0;\n        int large_value = 1000000;\n        for(int i = 0; i < num_large; ++i)\n            xi[i] = large_value;\n        for(int i = num_large; i < n; ++i)\n            xi[i] = small_value;\n        shuffle(xi.begin(), xi.end());\n    } else {\n        /* Default to random */\n        for(int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, 1000000);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output xi elements */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_max\n\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n\n./gen -n 5 -type small_large_alternating\n\n./gen -n 10 -type random\n\n./gen -n 1000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 200000 -type random\n\n./gen -n 200000 -type all_zero\n\n./gen -n 200000 -type all_max\n\n./gen -n 200000 -type increasing\n./gen -n 200000 -type decreasing\n\n./gen -n 199999 -type small_large_alternating\n\n./gen -n 200000 -type few_unique -u 1\n./gen -n 200000 -type few_unique -u 2\n./gen -n 200000 -type few_unique -u 5\n./gen -n 200000 -type few_unique -u 10\n\n./gen -n 200000 -type max_skewness -l 1\n./gen -n 200000 -type max_skewness -l 2\n./gen -n 200000 -type max_skewness -l 1000\n\n./gen -n 200000 -type min_skewness -s 1\n./gen -n 200000 -type min_skewness -s 2\n./gen -n 200000 -type min_skewness -s 1000\n\n# Edge cases with n near minimum\n./gen -n 1 -type random\n./gen -n 2 -type max_skewness -l 1\n./gen -n 2 -type min_skewness -s 1\n\n# Edge cases with xi's all zero\n./gen -n 200000 -type all_zero\n\n# Edge cases with xi's all maximum\n./gen -n 200000 -type all_max\n\n# Additional test cases\n./gen -n 150000 -type random\n./gen -n 150000 -type few_unique -u 3\n./gen -n 150000 -type max_skewness -l 50000\n./gen -n 150000 -type min_skewness -s 50000\n./gen -n 50000 -type small_large_alternating\n./gen -n 10 -type few_unique -u 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:27.964137",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/F",
      "title": "F. Group Projects",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ n ≤ 200, 0 ≤ k ≤ 1000) — the number of students and the maximum total imbalance allowed, respectively.The second line contains n space-separated integers ai (1 ≤ ai ≤ 500) — the time it takes the i-th student to complete his/her independent piece of work.",
      "output_spec": "OutputPrint a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy3 22 4 5OutputCopy3InputCopy4 37 8 9 10OutputCopy13InputCopy4 05 10 20 21OutputCopy1",
      "description": "F. Group Projects\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers n and k (1 ≤ n ≤ 200, 0 ≤ k ≤ 1000) — the number of students and the maximum total imbalance allowed, respectively.The second line contains n space-separated integers ai (1 ≤ ai ≤ 500) — the time it takes the i-th student to complete his/her independent piece of work.\n\nOutputPrint a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 109 + 7.\n\nInputCopy3 22 4 5OutputCopy3InputCopy4 37 8 9 10OutputCopy13InputCopy4 05 10 20 21OutputCopy1\n\nInputCopy3 22 4 5\n\nOutputCopy3\n\nInputCopy4 37 8 9 10\n\nOutputCopy13\n\nInputCopy4 05 10 20 21\n\nOutputCopy1\n\nNoteIn the first sample, we have three options:   The first and second students form a group, and the third student forms a group. Total imbalance is 2 + 0 = 2.  The first student forms a group, and the second and third students form a group. Total imbalance is 0 + 1 = 1.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*F"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 500, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 500, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 500, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 500);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            a[i] = min(a[i-1] + rnd.next(0, 5), 500);\n        }\n    } else if (type == \"decreasing\") {\n        a[0] = rnd.next(490, 500);\n        for (int i = 1; i < n; ++i) {\n            a[i] = max(a[i-1] - rnd.next(0, 5), 1);\n        }\n    } else if (type == \"max_diff\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1) ? 1 : 500;\n        }\n    } else if (type == \"small_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"large_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(490, 500);\n        }\n    } else if (type == \"minmax_alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 500;\n        }\n    } else {\n        // Default to random if type not recognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, 500);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            a[i] = min(a[i-1] + rnd.next(0, 5), 500);\n        }\n    } else if (type == \"decreasing\") {\n        a[0] = rnd.next(490, 500);\n        for (int i = 1; i < n; ++i) {\n            a[i] = max(a[i-1] - rnd.next(0, 5), 1);\n        }\n    } else if (type == \"max_diff\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1) ? 1 : 500;\n        }\n    } else if (type == \"small_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"large_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(490, 500);\n        }\n    } else if (type == \"minmax_alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 500;\n        }\n    } else {\n        // Default to random if type not recognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type all_same\n./gen -n 1 -k 1000 -type random\n./gen -n 2 -k 0 -type all_same\n./gen -n 2 -k 1000 -type random\n./gen -n 2 -k 0 -type max_diff\n./gen -n 5 -k 0 -type random\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 1000 -type random\n./gen -n 50 -k 0 -type random\n./gen -n 50 -k 500 -type random\n./gen -n 50 -k 1000 -type random\n./gen -n 200 -k 0 -type random\n./gen -n 200 -k 500 -type random\n./gen -n 200 -k 1000 -type random\n./gen -n 50 -k 500 -type max_diff\n./gen -n 50 -k 500 -type small_values\n./gen -n 50 -k 500 -type large_values\n./gen -n 50 -k 500 -type increasing\n./gen -n 50 -k 500 -type decreasing\n./gen -n 200 -k 1000 -type minmax_alternating\n./gen -n 100 -k 123 -type random\n./gen -n 100 -k 0 -type all_same\n./gen -n 100 -k 1000 -type all_same\n./gen -n 200 -k 0 -type max_diff\n./gen -n 75 -k 250 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:29.744031",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "626/G",
      "title": "G. Raffles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, t, and q (1 ≤ n, t, q ≤ 200 000) — the number of raffles, the number of tickets Johnny has, and the total number of updates, respectively.The second line contains n space-separated integers pi (1 ≤ pi ≤ 1000) — the value of the i-th prize.The third line contains n space-separated integers li (1 ≤ li ≤ 1000) — the number of tickets initially in the i-th raffle.The last q lines contain the descriptions of the updates. Each description contains two integers tk, rk (1 ≤ tk ≤ 2, 1 ≤ rk ≤ n) — the type of the update and the raffle number. An update of type 1 represents another participant adding a ticket to raffle rk. An update of type 2 represents another participant removing a ticket from raffle rk.It is guaranteed that, after each update, each raffle has at least 1 ticket (not including Johnny's) in it.",
      "output_spec": "OutputPrint q lines, each containing a single real number — the maximum expected value of Johnny's winnings after the k-th update. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy2 1 34 51 21 11 22 1OutputCopy1.6666666671.3333333332.000000000InputCopy3 20 56 8 106 6 61 11 21 32 32 3OutputCopy12.00000000012.00000000011.76923076912.00000000012.000000000",
      "description": "time limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, t, and q (1 ≤ n, t, q ≤ 200 000) — the number of raffles, the number of tickets Johnny has, and the total number of updates, respectively.The second line contains n space-separated integers pi (1 ≤ pi ≤ 1000) — the value of the i-th prize.The third line contains n space-separated integers li (1 ≤ li ≤ 1000) — the number of tickets initially in the i-th raffle.The last q lines contain the descriptions of the updates. Each description contains two integers tk, rk (1 ≤ tk ≤ 2, 1 ≤ rk ≤ n) — the type of the update and the raffle number. An update of type 1 represents another participant adding a ticket to raffle rk. An update of type 2 represents another participant removing a ticket from raffle rk.It is guaranteed that, after each update, each raffle has at least 1 ticket (not including Johnny's) in it.\n\nOutputPrint q lines, each containing a single real number — the maximum expected value of Johnny's winnings after the k-th update. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy2 1 34 51 21 11 22 1OutputCopy1.6666666671.3333333332.000000000InputCopy3 20 56 8 106 6 61 11 21 32 32 3OutputCopy12.00000000012.00000000011.76923076912.00000000012.000000000\n\nInputCopy2 1 34 51 21 11 22 1\n\nOutputCopy1.6666666671.3333333332.000000000\n\nInputCopy3 20 56 8 106 6 61 11 21 32 32 3\n\nOutputCopy12.00000000012.00000000011.76923076912.00000000012.000000000\n\nNoteIn the first case, Johnny only has one ticket to distribute. The prizes are worth 4 and 5, and the raffles initially have 1 and 2 tickets, respectively. After the first update, each raffle has 2 tickets, so Johnny has expected value  of winning by placing his ticket into the second raffle. The second update adds a ticket to the second raffle, so Johnny can win  in the first raffle. After the final update, Johnny keeps his ticket in the first raffle and wins .In the second case, Johnny has more tickets than he is allowed to spend. In particular, after the first update, there are 7, 6, and 6 tickets in each raffle, respectively, so Johnny can only put in 19 tickets, winning each prize with probability . Also, note that after the last two updates, Johnny must remove a ticket from the last raffle in order to stay under  the tickets in the third raffle.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces",
          "content": "Hello everyone! The first round of the 8VC Venture Cup will be held on Saturday, February 13th at 12:35PM EST. ecnerwala and I are the problem setters. We want to thank GlebsHP for his help in preparing the contest, Delinur for translating the problems, and MikeMirzayanov for creating the Codeforces platformThe contest is for competitors in both divisions and contains seven problems. The scoring distribution is as follows:500 — 750 — 1000 — 1500 — 2000 — 2500 — 3000The contest will be slightly longer than usual — two and a half hours. The top 200 contestants will advance to the final round, and the top 20 local finishers will be invited to Woodside, CA to compete onsite. Good luck!UPD: System testing is now over. Congratulations to the top contestants: Petr jqdai0815 ilyakor bmerry Errichto The top 200 contestants will advance to the final round in two weeks. Congratulations!The editorial can be found here.",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/23515",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 920
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces",
          "content": "626A - Robot SequenceWe can simulate Calvin’s path on each substring, and check if he returns to the origin.Runtime: O(n3)626B - CardsNote that if we have exactly one card of each color, we can always make all three options (by symmetry). Thus, if we have at least one of each color, or at least two of each of two colors, we can make all three options. The remaining cases are: if we only have one color, that’s the only possible final card; if we have one of each of two colors, we can only make the third color; if we have at least two of one color and exactly one of a second, we can only make the second or third color (e.g. sample 2).Runtime: O(1)626C - Block TowersThere are a variety of ways to do this problem. Here is one way: if the answer is X, there must be at least n multiples of 2 below X, at least m multiples of 3 below X, and at least n + m multiples of 2 or 3 below X. These conditions are actually sufficient, so we need to find the smallest X such that , , and . We can do this with a linear search, or with an explicit formula.Runtime: O(1)626D - Jerry's ProtestWe do this algorithm in two phases: first, we compute the probability distribution of the difference between the winner and loser of each round. This takes O(n2) time. Then, we can iterate over the 2 differences which Andrew wins by and compute the probability that Jerry has a greater total using with suffix sums.Runtime: O(n2 + amax2)626E - Simple SkewnessWe can show that any subset with maximal simple skewness should have odd size (otherwise we drop the larger middle element: this decreases the median by more than it decreases the mean, assuming the mean is larger than the median).Let’s fix the median at xi (in the sorted list), and set the size of the set to 2j + 1. We’d like to maximize the mean, so we can greedily choose the largest j elements below the median and the largest j elements above the median: xi - j, ..., xi - 1 and xn - j + 1, ..., xn.Now, notice that by increasing j by 1, we add in the elements xi - j - 1 and xn - j, which decrease as j increases. Thus, for a fixed i, the overall mean is bitonic in j (it increases then decreases), so we can binary search on the marginal utility to find the optimum.Runtime: 626F - Group ProjectsThis is a dynamic programming problem. Notice that the total imbalance of the groups only depends on which students are the maximum in each group and which are the minimum in each group. We thus can think of groups as intervals bounded by the minimum and maximum student. Moreover, the total imbalance is the sum over all unit ranges of the number of intervals covering that range. We can use this formula to do our DP.If we sort the students in increasing size, DP state is as follows: the number of students processed so far, the number of g groups which are currently “open” (have a minimum but no maximum), and the total imbalance k so far. For each student, we first add the appropriate value to the total imbalance (g times the distance to the previous student), and then either put the student in his own group (doesn’t change g), start a new group (increment g), add the student to one of the g groups (doesn’t change g), or close one of the g groups (decrement g).Runtime: O(n2k)626G - RafflesFirst, note that the marginal utility of each additional ticket in a single raffle is decreasing. Thus, to solve the initial state, we can use a heap data structure to store the optimal raffles.Now, after each update, we can show that the distribution should not change by much. In particular, after one ticket is added to a raffle, Johnny should either remove one ticket from that raffle and place it elsewhere, not change anything, or, if the raffle was already full, put one more ticket in to keep it full. Similarly, after a ticket is removed, Johnny should either do nothing, remove one ticket to stay under the maximum, or add one ticket. (The proofs are fairly simple and involve looking at the “cutoff” marginal utility of Johnny’s tickets.) All of these operations can be performed using two heaps storing the optimal ticket to add and the optimal ticket to remove.Runtime:",
          "author": "ecnerwala",
          "url": "https://codeforces.com/blog/entry/23522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 626\\s*G"
          },
          "content_length": 4133
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 1",
          "code": "dp[open_intervals][cost_so_far]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 2",
          "code": "cost_so_far",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 3",
          "code": "cost_so_far + open_intervals * (t[i+1]-t[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 4",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 5",
          "code": "import matplotlib.pyplot as plt\n%matplotlib inline\nn1 = 100\nn2 = 10\nvals = [0.0] * n1 + [1.0] * n2 + [2.0] + [3.0] * n1 + [4.0] * n2\ndef Mean(count):\n    all = vals[n1 + n2 - count : n1 + n2 + 1] + vals[len(vals) - count:]\n    return sum(all) / len(all)\nplt.plot(range(n1 + n2 + 1), [Mean(x) for x in range(n1 + n2 + 1)])",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 6",
          "code": "int[][][] dp = new int[n + 1][n + 2][K + 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 7",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 8",
          "code": "if(b[i] && b[j] && i + j < 5200){\n    br += dp[i + j + 1] * b[i] * b[j];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 9",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 10",
          "code": "i + j + 1 < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 11",
          "code": "i + j + 1 < 5201",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Elimination Round - Codeforces - Code 12",
          "code": "i + j < 5200",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23515",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 1",
          "code": "n!/((n-2)!*2!)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 2",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 3",
          "code": "sum\nover {all unit ranges}\nof {the number of intervals covering that range}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        },
        {
          "title": "8VC Venture Cup 2016 -- Elimination Round Tutorial - Codeforces - Code 4",
          "code": "u = (n + m) * 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/23522",
          "author": "ecnerwala"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000, \"pi\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 1, 1000, \"li\");\n    inf.readEoln();\n\n    // Use long long to prevent overflows\n    vector<long long> li_long(li.begin(), li.end());\n\n    for (int i = 0; i < q; ++i) {\n        int tk = inf.readInt(1, 2, \"tk\");\n        inf.readSpace();\n        int rk = inf.readInt(1, n, \"rk\");\n        inf.readEoln();\n\n        rk -= 1; // Zero-based index\n\n        if (tk == 1) {\n            // Participant adds a ticket to raffle rk\n            li_long[rk] += 1;\n        } else {\n            // tk == 2, Participant removes a ticket from raffle rk\n            ensuref(li_long[rk] >= 2, \"After removing ticket, raffle %d would have less than 1 ticket (excluding Johnny's)\", rk + 1);\n            li_long[rk] -= 1;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000, \"pi\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 1, 1000, \"li\");\n    inf.readEoln();\n\n    // Use long long to prevent overflows\n    vector<long long> li_long(li.begin(), li.end());\n\n    for (int i = 0; i < q; ++i) {\n        int tk = inf.readInt(1, 2, \"tk\");\n        inf.readSpace();\n        int rk = inf.readInt(1, n, \"rk\");\n        inf.readEoln();\n\n        rk -= 1; // Zero-based index\n\n        if (tk == 1) {\n            // Participant adds a ticket to raffle rk\n            li_long[rk] += 1;\n        } else {\n            // tk == 2, Participant removes a ticket from raffle rk\n            ensuref(li_long[rk] >= 2, \"After removing ticket, raffle %d would have less than 1 ticket (excluding Johnny's)\", rk + 1);\n            li_long[rk] -= 1;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000, \"pi\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 1, 1000, \"li\");\n    inf.readEoln();\n\n    // Use long long to prevent overflows\n    vector<long long> li_long(li.begin(), li.end());\n\n    for (int i = 0; i < q; ++i) {\n        int tk = inf.readInt(1, 2, \"tk\");\n        inf.readSpace();\n        int rk = inf.readInt(1, n, \"rk\");\n        inf.readEoln();\n\n        rk -= 1; // Zero-based index\n\n        if (tk == 1) {\n            // Participant adds a ticket to raffle rk\n            li_long[rk] += 1;\n        } else {\n            // tk == 2, Participant removes a ticket from raffle rk\n            ensuref(li_long[rk] >= 2, \"After removing ticket, raffle %d would have less than 1 ticket (excluding Johnny's)\", rk + 1);\n            li_long[rk] -= 1;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nThis generator produces test cases for the problem where Johnny has to optimally distribute his tickets\namong raffles to maximize his expected winnings, considering the constraints given in the problem statement.\nIt accepts several parameters to generate a variety of test cases, including special cases to catch potential\nerrors in contestants' solutions.\n\nParameters:\n- n: Number of raffles (1 ≤ n ≤ 200,000).\n- t: Number of tickets Johnny has (1 ≤ t ≤ 200,000).\n- q: Number of updates (0 ≤ q ≤ 200,000).\n- pi_type: The type of prizes values 'pi'. Options are 'constant', 'max', 'increasing', 'random' (default).\n- pi_val: The value to use when pi_type is 'constant' (1 ≤ pi_val ≤ 1000).\n- li_type: The type of initial tickets 'li'. Options are 'constant', 'max', 'increasing', 'random' (default).\n- li_val: The value to use when li_type is 'constant' (1 ≤ li_val ≤ 1000).\n- update_type: The type of updates. Options are 'increase_only', 'decrease_only', 'one_raffle', 'random' (default).\n\nUsage:\n./gen -n [number] -t [number] -q [number] -pi_type [type] -li_type [type] -update_type [type]\n*/\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    int q = opt<int>(\"q\");\n    string pi_type = opt<string>(\"pi_type\", \"random\");\n    string li_type = opt<string>(\"li_type\", \"random\");\n    string update_type = opt<string>(\"update_type\", \"random\");\n\n    // Generate pi (prize values)\n    vector<int> pi(n);\n\n    if (pi_type == \"constant\") {\n        int pi_val = opt<int>(\"pi_val\", 1);\n        for (int i = 0; i < n; ++i) {\n            pi[i] = pi_val;\n        }\n    } else if (pi_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = 1000;\n        }\n    } else if (pi_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = i % 1000 + 1;\n        }\n    } else { // 'random' or any other option defaults to random\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Generate li (initial number of tickets in each raffle)\n    vector<int> li(n);\n\n    if (li_type == \"constant\") {\n        int li_val = opt<int>(\"li_val\", 1);\n        for (int i = 0; i < n; ++i) {\n            li[i] = li_val;\n        }\n    } else if (li_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            li[i] = 1000;\n        }\n    } else if (li_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            li[i] = i % 1000 + 1;\n        }\n    } else { // 'random' or any other option defaults to random\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Generate updates\n    vector<pair<int,int>> updates(q); // pair<type, raffle_number>\n    vector<int> current_li = li; // Keep track of li after updates\n\n    if (update_type == \"increase_only\") {\n        for (int i = 0; i < q; ++i) {\n            int rk = rnd.next(1, n);\n            updates[i] = {1, rk};\n            current_li[rk - 1]++;\n        }\n    } else if (update_type == \"decrease_only\") {\n        for (int i = 0; i < q; ++i) {\n            int rk = rnd.next(1, n);\n            if (current_li[rk - 1] > 1) {\n                updates[i] = {2, rk};\n                current_li[rk - 1]--;\n            } else {\n                updates[i] = {1, rk};\n                current_li[rk -1]++;\n            }\n        }\n    } else if (update_type == \"one_raffle\") {\n        int raffle = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1,2);\n            if (type == 2 && current_li[raffle - 1] == 1) {\n                type = 1; // Can't remove, change to add\n            }\n            updates[i] = {type, raffle};\n            if (type == 1) current_li[raffle - 1]++;\n            else current_li[raffle -1]--;\n        }\n    } else { // 'random' or any other option defaults to random\n        for (int i = 0; i < q; ++i) {\n            int rk = rnd.next(1, n);\n            int type = rnd.next(1,2);\n            if (type == 2 && current_li[rk - 1] == 1) {\n                type = 1; // Can't remove, change to add\n            }\n            updates[i] = {type, rk};\n            if (type == 1) current_li[rk -1]++;\n            else current_li[rk -1]--;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, t, q);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", pi[i], (i == n -1) ? '\\n' : ' ');\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", li[i], (i == n -1) ? '\\n' : ' ');\n    }\n\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", updates[i].first, updates[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nThis generator produces test cases for the problem where Johnny has to optimally distribute his tickets\namong raffles to maximize his expected winnings, considering the constraints given in the problem statement.\nIt accepts several parameters to generate a variety of test cases, including special cases to catch potential\nerrors in contestants' solutions.\n\nParameters:\n- n: Number of raffles (1 ≤ n ≤ 200,000).\n- t: Number of tickets Johnny has (1 ≤ t ≤ 200,000).\n- q: Number of updates (0 ≤ q ≤ 200,000).\n- pi_type: The type of prizes values 'pi'. Options are 'constant', 'max', 'increasing', 'random' (default).\n- pi_val: The value to use when pi_type is 'constant' (1 ≤ pi_val ≤ 1000).\n- li_type: The type of initial tickets 'li'. Options are 'constant', 'max', 'increasing', 'random' (default).\n- li_val: The value to use when li_type is 'constant' (1 ≤ li_val ≤ 1000).\n- update_type: The type of updates. Options are 'increase_only', 'decrease_only', 'one_raffle', 'random' (default).\n\nUsage:\n./gen -n [number] -t [number] -q [number] -pi_type [type] -li_type [type] -update_type [type]\n*/\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    int q = opt<int>(\"q\");\n    string pi_type = opt<string>(\"pi_type\", \"random\");\n    string li_type = opt<string>(\"li_type\", \"random\");\n    string update_type = opt<string>(\"update_type\", \"random\");\n\n    // Generate pi (prize values)\n    vector<int> pi(n);\n\n    if (pi_type == \"constant\") {\n        int pi_val = opt<int>(\"pi_val\", 1);\n        for (int i = 0; i < n; ++i) {\n            pi[i] = pi_val;\n        }\n    } else if (pi_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = 1000;\n        }\n    } else if (pi_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = i % 1000 + 1;\n        }\n    } else { // 'random' or any other option defaults to random\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Generate li (initial number of tickets in each raffle)\n    vector<int> li(n);\n\n    if (li_type == \"constant\") {\n        int li_val = opt<int>(\"li_val\", 1);\n        for (int i = 0; i < n; ++i) {\n            li[i] = li_val;\n        }\n    } else if (li_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            li[i] = 1000;\n        }\n    } else if (li_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            li[i] = i % 1000 + 1;\n        }\n    } else { // 'random' or any other option defaults to random\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Generate updates\n    vector<pair<int,int>> updates(q); // pair<type, raffle_number>\n    vector<int> current_li = li; // Keep track of li after updates\n\n    if (update_type == \"increase_only\") {\n        for (int i = 0; i < q; ++i) {\n            int rk = rnd.next(1, n);\n            updates[i] = {1, rk};\n            current_li[rk - 1]++;\n        }\n    } else if (update_type == \"decrease_only\") {\n        for (int i = 0; i < q; ++i) {\n            int rk = rnd.next(1, n);\n            if (current_li[rk - 1] > 1) {\n                updates[i] = {2, rk};\n                current_li[rk - 1]--;\n            } else {\n                updates[i] = {1, rk};\n                current_li[rk -1]++;\n            }\n        }\n    } else if (update_type == \"one_raffle\") {\n        int raffle = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1,2);\n            if (type == 2 && current_li[raffle - 1] == 1) {\n                type = 1; // Can't remove, change to add\n            }\n            updates[i] = {type, raffle};\n            if (type == 1) current_li[raffle - 1]++;\n            else current_li[raffle -1]--;\n        }\n    } else { // 'random' or any other option defaults to random\n        for (int i = 0; i < q; ++i) {\n            int rk = rnd.next(1, n);\n            int type = rnd.next(1,2);\n            if (type == 2 && current_li[rk - 1] == 1) {\n                type = 1; // Can't remove, change to add\n            }\n            updates[i] = {type, rk};\n            if (type == 1) current_li[rk -1]++;\n            else current_li[rk -1]--;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, t, q);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", pi[i], (i == n -1) ? '\\n' : ' ');\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", li[i], (i == n -1) ? '\\n' : ' ');\n    }\n\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", updates[i].first, updates[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -t 1 -q 1 -pi_type constant -pi_val 1 -li_type constant -li_val 1 -update_type increase_only\n./gen -n 1 -t 1 -q 1 -pi_type constant -pi_val 1000 -li_type constant -li_val 1 -update_type decrease_only\n./gen -n 1 -t 0 -q 0 -pi_type constant -pi_val 500 -li_type constant -li_val 1 -update_type random\n./gen -n 1 -t 200000 -q 200000 -pi_type constant -pi_val 1000 -li_type constant -li_val 1 -update_type increase_only\n./gen -n 2 -t 1 -q 10 -pi_type random -li_type constant -li_val 1 -update_type increase_only\n./gen -n 2 -t 1 -q 10 -pi_type max -li_type max -update_type decrease_only\n./gen -n 10 -t 1000 -q 1000 -pi_type random -li_type random -update_type random\n./gen -n 200000 -t 10 -q 10 -pi_type constant -pi_val 1000 -li_type constant -li_val 1 -update_type random\n./gen -n 200000 -t 0 -q 200000 -pi_type random -li_type random -update_type random\n./gen -n 200000 -t 200000 -q 200000 -pi_type random -li_type constant -li_val 1 -update_type increase_only\n./gen -n 200000 -t 100000 -q 200000 -pi_type increasing -li_type increasing -update_type one_raffle\n./gen -n 200000 -t 200000 -q 200000 -pi_type increasing -li_type max -update_type decrease_only\n./gen -n 1000 -t 1000 -q 0 -pi_type random -li_type random -update_type random\n./gen -n 100000 -t 1000 -q 100000 -pi_type random -li_type random -update_type random\n./gen -n 100000 -t 100000 -q 100000 -pi_type max -li_type max -update_type decrease_only\n./gen -n 100000 -t 100000 -q 100000 -pi_type random -li_type random -update_type increase_only\n./gen -n 3 -t 100 -q 1000 -pi_type random -li_type constant -li_val 1 -update_type random\n./gen -n 5 -t 1000 -q 5000 -pi_type constant -pi_val 1000 -li_type constant -li_val 1000 -update_type random\n./gen -n 10 -t 10 -q 10 -pi_type random -li_type random -update_type one_raffle\n./gen -n 200000 -t 100000 -q 0 -pi_type max -li_type max\n./gen -n 200000 -t 0 -q 200000 -pi_type constant -pi_val 1 -li_type constant -li_val 1 -update_type random\n./gen -n 123456 -t 654321 -q 98765 -pi_type random -li_type random -update_type random\n./gen -n 200000 -t 200000 -q 1 -pi_type random -li_type random -update_type random\n./gen -n 200000 -t 1 -q 200000 -pi_type random -li_type random -update_type random\n./gen -n 1 -t 200000 -q 200000 -pi_type max -li_type constant -li_val 1 -update_type random\n./gen -n 1 -t 1 -q 1 -pi_type constant -pi_val 1 -li_type constant -li_val 1 -update_type random\n./gen -n 2 -t 2 -q 2 -pi_type random -li_type constant -li_val 1 -update_type random\n./gen -n 3 -t 3 -q 0 -pi_type increasing -li_type increasing\n./gen -n 50 -t 100000 -q 200000 -pi_type random -li_type random -update_type random\n./gen -n 200000 -t 10000 -q 1000 -pi_type random -li_type random -update_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:31.919585",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "627/A",
      "title": "A. XOR Equation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers s and x (2 ≤ s ≤ 1012, 0 ≤ x ≤ 1012), the sum and bitwise xor of the pair of positive integers, respectively.",
      "output_spec": "OutputPrint a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.",
      "sample_tests": "ExamplesInputCopy9 5OutputCopy4InputCopy3 3OutputCopy2InputCopy5 2OutputCopy0",
      "description": "A. XOR Equation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers s and x (2 ≤ s ≤ 1012, 0 ≤ x ≤ 1012), the sum and bitwise xor of the pair of positive integers, respectively.\n\nOutputPrint a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.\n\nInputCopy9 5OutputCopy4InputCopy3 3OutputCopy2InputCopy5 2OutputCopy0\n\nInputCopy9 5\n\nOutputCopy4\n\nInputCopy3 3\n\nOutputCopy2\n\nInputCopy5 2\n\nOutputCopy0\n\nNoteIn the first sample, we have the following solutions: (2, 7), (3, 6), (6, 3), (7, 2).In the second sample, the only solutions are (1, 2) and (2, 1).",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces",
          "content": "Hello everyone!The final round of the 8VC Venture Cup will be held on Feb/28/2016 18:10 (UTC). ecnerwala and I are the problem setters. We want to thank GlebsHP and vnovakovski for help in preparing the contest, stella_marine for fixing the statements, and MikeMirzayanov for creating the Codeforces platform.The contest is by invitation only to the top 200 contestants and top local contestants from Round 1 and contains six problems. We will also hold rated, out-of-contest participation for both div1 and div2 contestants — all three groups will feature slightly different problemsets. Local contestants will compete onsite in Silicon Valley. OpenGov, one of the featured 8 | VC companies, has been generous to host this competition at their offices; see more details about this awesome company below: OpenGov transforms the way the world analyzes and allocates public money. With more than 700 government customers across 45 states in a rapidly expanding network, OpenGov is the market leader in cloud-based financial intelligence, budgeting, and transparency for government. The OpenGov platform transforms government financial data into intuitive, interactive visualizations for both internal government users and citizens.ABOUT 8 | PARTNERS8 | Partners, which consists of Joe Lonsdale (co-founder of Palantir) and his core team from Formation | 8, is a Silicon Valley venture capital firm that invests in industry-transforming technology companies. The team's investment portfolio includes companies such as those featured below, and a host of other top technology platforms that leverage modern algorithms and data science to power their core business processes. If you are interested to connect, please take a look at http://www.codeforces.com/8vc/apply.PRIZES Overall 1st place — $2500 Overall 2nd place — $1000 Overall 3rd-5th places — $500 each Overall 1-50th place — t-shirts with 8 | VC and company logos Local Winner — Dinner with Joe Lonsdale (founder of Palantir, Addepar, & 8 | Partners) and other Silicon Valley technologists Local top finishers — Opportunity to meet with leadership from 8 | VC portfolio companies The scoring distribution will be standard for all three divisions: 500 — 1000 — 1500 — 2000 — 2500 — 3000Good luck!UPD: Due to onsite awards presentation, we will hold final system testing until around one hour after the end of the contest.Congratulations to the top overall contestants: tourist Egor ikatanic enot110 DemiGuo As well as the top onsite contestants: winger waterfalls KADR Editorial can be found here.Thanks for participating!",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/43421",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2576
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round Editorial - Codeforces",
          "content": "635A - OrchestraWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.Runtime: O(n6)634A - Island PuzzleNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.Runtime: O(n)627A - XOR EquationFor any two integers a and b, we have , where is the xor and a&b is the bitwise AND. This is because is non-carrying binary addition. Thus, we can find a&b = (s - x) / 2 (if this is not an integer, there are no solutions).Now, for each bit, we have 4 cases: , and . If , then ai = bi, so we have one possibility: ai = bi = ai&bi. If , then we must have ai&bi = 0 (otherwise we print 0), and we have two choices: ai = 1 and bi = 0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a = 0 or b = 0 if necessary.)Runtime: 627B - Factory RepairsUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.Runtime: .627C - Package DeliveryWe solve this with a greedy algorithm: for each gas station, we fill our tank to min(n, d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.Alternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).Runtime: 627D - Preorder TestWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.Runtime: 627E - OrchestraWe can think of a rectangle in the grid as a pair of an (xlo, xhi) interval and a (ylo, yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m + 1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.As we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi = r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.Runtime: O(r2k + rnk)627F - Island PuzzleFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.Thus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).Now, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.To compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.Runtime: O(n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43467",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 627\\s*A"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 1",
          "code": "(2 ^ i - 1) (2 ^ i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 2",
          "code": "65535 65535",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 3",
          "code": "f(i, carry)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 4",
          "code": "(0 , i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 5",
          "code": "f(i + 1, 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 6",
          "code": "f(i + 1, 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 7",
          "code": "update(1, 0, n - 1, d - 1, get(1, 0, n - 1, d - 1, d - 1) + min(a, q));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 8",
          "code": "update(1, 0, n - 1, d - 1, min(TTT[d - 1], a * 1LL));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long s = inf.readLong(2LL, 1000000000000LL, \"s\");\n    inf.readSpace();\n    long long x = inf.readLong(0LL, 1000000000000LL, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long s = inf.readLong(2LL, 1000000000000LL, \"s\");\n    inf.readSpace();\n    long long x = inf.readLong(0LL, 1000000000000LL, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long s = inf.readLong(2LL, 1000000000000LL, \"s\");\n    inf.readSpace();\n    long long x = inf.readLong(0LL, 1000000000000LL, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\");\n    long long s = 0, x = 0;\n\n    if (type == \"random_valid\") {\n        // Generate s and x such that s - x >= 0 and (s - x) % 2 == 0\n        long long max_s = opt<long long>(\"s_max\", 1000000000000LL); // Default max_s = 1e12\n        long long max_x = opt<long long>(\"x_max\", 1000000000000LL); // Default max_x = 1e12\n\n        do {\n            s = rnd.next(2LL, max_s);\n            x = rnd.next(0LL, min(s, max_x));\n        } while ((s - x) < 0 || (s - x) % 2 != 0);\n    }\n    else if (type == \"random_invalid\") {\n        // Generate s and x such that s - x < 0 or (s - x) % 2 != 0\n        long long max_s = opt<long long>(\"s_max\", 1000000000000LL);\n        long long max_x = opt<long long>(\"x_max\", 1000000000000LL);\n\n        do {\n            s = rnd.next(2LL, max_s);\n            x = rnd.next(0LL, max_x);\n        } while ((s - x) >= 0 && (s - x) % 2 == 0);\n    }\n    else if (type == \"max_values\") {\n        s = 1000000000000LL; // 1e12\n        x = 1000000000000LL; // 1e12\n        // Adjust so that (s - x) >= 0 and even\n        if ((s - x) < 0 || (s - x) % 2 != 0) {\n            s -= ((s - x) % 2 != 0 ? 1 : 2);\n            if (s < 2) s = 2;\n        }\n    }\n    else if (type == \"min_values\") {\n        s = 2;\n        x = 0;\n    }\n    else if (type == \"s_eq_x\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = s;\n        if ((s - x) % 2 != 0) s += 1;\n        if (s > 1000000000000LL) s = 1000000000000LL;\n    }\n    else if (type == \"x_zero\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = 0;\n        if ((s - x) % 2 != 0) s += 1;\n        if (s > 1000000000000LL) s = 2;\n    }\n    else if (type == \"s_less_than_x\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = rnd.next(s + 1, 1000000000000LL);\n    }\n    else if (type == \"s_minus_x_odd\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = rnd.next(0LL, s);\n        if ((s - x) % 2 == 0) {\n            if (x > 0) x -= 1;\n            else x += 1;\n        }\n    }\n    else if (type == \"large_solutions\") {\n        // Maximize the number of solutions by setting x = 0\n        x = 0;\n        s = rnd.next(2LL, 1000000000000LL);\n        if ((s - x) % 2 != 0) s += 1;\n        if (s > 1000000000000LL) s = 1000000000000LL - 1;\n    }\n    else {\n        // Default case: random valid\n        s = rnd.next(2LL, 1000000000000LL);\n        x = rnd.next(0LL, s);\n        if ((s - x) < 0 || (s - x) % 2 != 0) {\n            if ((s - x) % 2 != 0) {\n                if (s >= 1000000000000LL) s -= 1;\n                else s += 1;\n            }\n            if ((s - x) < 0) x = s - rnd.next(0LL, s);\n        }\n    }\n\n    printf(\"%lld %lld\\n\", s, x);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\");\n    long long s = 0, x = 0;\n\n    if (type == \"random_valid\") {\n        // Generate s and x such that s - x >= 0 and (s - x) % 2 == 0\n        long long max_s = opt<long long>(\"s_max\", 1000000000000LL); // Default max_s = 1e12\n        long long max_x = opt<long long>(\"x_max\", 1000000000000LL); // Default max_x = 1e12\n\n        do {\n            s = rnd.next(2LL, max_s);\n            x = rnd.next(0LL, min(s, max_x));\n        } while ((s - x) < 0 || (s - x) % 2 != 0);\n    }\n    else if (type == \"random_invalid\") {\n        // Generate s and x such that s - x < 0 or (s - x) % 2 != 0\n        long long max_s = opt<long long>(\"s_max\", 1000000000000LL);\n        long long max_x = opt<long long>(\"x_max\", 1000000000000LL);\n\n        do {\n            s = rnd.next(2LL, max_s);\n            x = rnd.next(0LL, max_x);\n        } while ((s - x) >= 0 && (s - x) % 2 == 0);\n    }\n    else if (type == \"max_values\") {\n        s = 1000000000000LL; // 1e12\n        x = 1000000000000LL; // 1e12\n        // Adjust so that (s - x) >= 0 and even\n        if ((s - x) < 0 || (s - x) % 2 != 0) {\n            s -= ((s - x) % 2 != 0 ? 1 : 2);\n            if (s < 2) s = 2;\n        }\n    }\n    else if (type == \"min_values\") {\n        s = 2;\n        x = 0;\n    }\n    else if (type == \"s_eq_x\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = s;\n        if ((s - x) % 2 != 0) s += 1;\n        if (s > 1000000000000LL) s = 1000000000000LL;\n    }\n    else if (type == \"x_zero\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = 0;\n        if ((s - x) % 2 != 0) s += 1;\n        if (s > 1000000000000LL) s = 2;\n    }\n    else if (type == \"s_less_than_x\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = rnd.next(s + 1, 1000000000000LL);\n    }\n    else if (type == \"s_minus_x_odd\") {\n        s = rnd.next(2LL, 1000000000000LL);\n        x = rnd.next(0LL, s);\n        if ((s - x) % 2 == 0) {\n            if (x > 0) x -= 1;\n            else x += 1;\n        }\n    }\n    else if (type == \"large_solutions\") {\n        // Maximize the number of solutions by setting x = 0\n        x = 0;\n        s = rnd.next(2LL, 1000000000000LL);\n        if ((s - x) % 2 != 0) s += 1;\n        if (s > 1000000000000LL) s = 1000000000000LL - 1;\n    }\n    else {\n        // Default case: random valid\n        s = rnd.next(2LL, 1000000000000LL);\n        x = rnd.next(0LL, s);\n        if ((s - x) < 0 || (s - x) % 2 != 0) {\n            if ((s - x) % 2 != 0) {\n                if (s >= 1000000000000LL) s -= 1;\n                else s += 1;\n            }\n            if ((s - x) < 0) x = s - rnd.next(0LL, s);\n        }\n    }\n\n    printf(\"%lld %lld\\n\", s, x);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random_valid\n./gen -type random_valid\n./gen -type random_valid\n./gen -type random_invalid\n./gen -type random_invalid\n./gen -type random_invalid\n./gen -type max_values\n./gen -type min_values\n./gen -type s_eq_x\n./gen -type x_zero\n./gen -type s_less_than_x\n./gen -type s_minus_x_odd\n./gen -type large_solutions\n./gen -type s_eq_x\n./gen -type x_zero\n./gen -type s_minus_x_odd\n./gen -type s_less_than_x\n./gen -type random_valid -s_max 1000000 -x_max 1000000\n./gen -type random_valid -s_max 1000000000 -x_max 1000000000\n./gen -type random_valid -s_max 1000000000000 -x_max 1000000000000\n./gen -type random_invalid -s_max 1000000 -x_max 1000000\n./gen -type random_invalid -s_max 1000000000 -x_max 1000000000\n./gen -type random_invalid -s_max 1000000000000 -x_max 1000000000000\n./gen -type large_solutions\n./gen -type large_solutions\n./gen -type large_solutions\n./gen -type min_values\n./gen -type min_values\n./gen -type max_values\n./gen -type max_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:33.559967",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "627/B",
      "title": "B. Factory Repairs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains five integers n, k, a, b, and q (1 ≤ k ≤ n ≤ 200 000, 1 ≤ b < a ≤ 10 000, 1 ≤ q ≤ 200 000) — the number of days, the length of the repair time, the production rates of the factory, and the number of updates, respectively.The next q lines contain the descriptions of the queries. Each query is of one of the following two forms:   1 di ai (1 ≤ di ≤ n, 1 ≤ ai ≤ 10 000), representing an update of ai orders on day di, or  2 pi (1 ≤ pi ≤ n - k + 1), representing a question: at the moment, how many orders could be filled if the factory decided to commence repairs on day pi? It's guaranteed that the input will contain at least one query of the second type.",
      "output_spec": "OutputFor each query of the second type, print a line containing a single integer — the maximum number of orders that the factory can fill over all n days.",
      "sample_tests": "ExamplesInputCopy5 2 2 1 81 1 21 5 31 2 12 21 4 21 3 22 12 3OutputCopy364InputCopy5 4 10 1 61 1 51 5 51 3 21 5 22 12 2OutputCopy71",
      "description": "B. Factory Repairs\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains five integers n, k, a, b, and q (1 ≤ k ≤ n ≤ 200 000, 1 ≤ b < a ≤ 10 000, 1 ≤ q ≤ 200 000) — the number of days, the length of the repair time, the production rates of the factory, and the number of updates, respectively.The next q lines contain the descriptions of the queries. Each query is of one of the following two forms:   1 di ai (1 ≤ di ≤ n, 1 ≤ ai ≤ 10 000), representing an update of ai orders on day di, or  2 pi (1 ≤ pi ≤ n - k + 1), representing a question: at the moment, how many orders could be filled if the factory decided to commence repairs on day pi? It's guaranteed that the input will contain at least one query of the second type.\n\nOutputFor each query of the second type, print a line containing a single integer — the maximum number of orders that the factory can fill over all n days.\n\nInputCopy5 2 2 1 81 1 21 5 31 2 12 21 4 21 3 22 12 3OutputCopy364InputCopy5 4 10 1 61 1 51 5 51 3 21 5 22 12 2OutputCopy71\n\nInputCopy5 2 2 1 81 1 21 5 31 2 12 21 4 21 3 22 12 3\n\nOutputCopy364\n\nInputCopy5 4 10 1 61 1 51 5 51 3 21 5 22 12 2\n\nOutputCopy71\n\nNoteConsider the first sample.We produce up to 1 thimble a day currently and will produce up to 2 thimbles a day after repairs. Repairs take 2 days.For the first question, we are able to fill 1 order on day 1, no orders on days 2 and 3 since we are repairing, no orders on day 4 since no thimbles have been ordered for that day, and 2 orders for day 5 since we are limited to our production capacity, for a total of 3 orders filled.For the third question, we are able to fill 1 order on day 1, 1 order on day 2, and 2 orders on day 5, for a total of 4 orders.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces",
          "content": "Hello everyone!The final round of the 8VC Venture Cup will be held on Feb/28/2016 18:10 (UTC). ecnerwala and I are the problem setters. We want to thank GlebsHP and vnovakovski for help in preparing the contest, stella_marine for fixing the statements, and MikeMirzayanov for creating the Codeforces platform.The contest is by invitation only to the top 200 contestants and top local contestants from Round 1 and contains six problems. We will also hold rated, out-of-contest participation for both div1 and div2 contestants — all three groups will feature slightly different problemsets. Local contestants will compete onsite in Silicon Valley. OpenGov, one of the featured 8 | VC companies, has been generous to host this competition at their offices; see more details about this awesome company below: OpenGov transforms the way the world analyzes and allocates public money. With more than 700 government customers across 45 states in a rapidly expanding network, OpenGov is the market leader in cloud-based financial intelligence, budgeting, and transparency for government. The OpenGov platform transforms government financial data into intuitive, interactive visualizations for both internal government users and citizens.ABOUT 8 | PARTNERS8 | Partners, which consists of Joe Lonsdale (co-founder of Palantir) and his core team from Formation | 8, is a Silicon Valley venture capital firm that invests in industry-transforming technology companies. The team's investment portfolio includes companies such as those featured below, and a host of other top technology platforms that leverage modern algorithms and data science to power their core business processes. If you are interested to connect, please take a look at http://www.codeforces.com/8vc/apply.PRIZES Overall 1st place — $2500 Overall 2nd place — $1000 Overall 3rd-5th places — $500 each Overall 1-50th place — t-shirts with 8 | VC and company logos Local Winner — Dinner with Joe Lonsdale (founder of Palantir, Addepar, & 8 | Partners) and other Silicon Valley technologists Local top finishers — Opportunity to meet with leadership from 8 | VC portfolio companies The scoring distribution will be standard for all three divisions: 500 — 1000 — 1500 — 2000 — 2500 — 3000Good luck!UPD: Due to onsite awards presentation, we will hold final system testing until around one hour after the end of the contest.Congratulations to the top overall contestants: tourist Egor ikatanic enot110 DemiGuo As well as the top onsite contestants: winger waterfalls KADR Editorial can be found here.Thanks for participating!",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/43421",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2576
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round Editorial - Codeforces",
          "content": "635A - OrchestraWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.Runtime: O(n6)634A - Island PuzzleNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.Runtime: O(n)627A - XOR EquationFor any two integers a and b, we have , where is the xor and a&b is the bitwise AND. This is because is non-carrying binary addition. Thus, we can find a&b = (s - x) / 2 (if this is not an integer, there are no solutions).Now, for each bit, we have 4 cases: , and . If , then ai = bi, so we have one possibility: ai = bi = ai&bi. If , then we must have ai&bi = 0 (otherwise we print 0), and we have two choices: ai = 1 and bi = 0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a = 0 or b = 0 if necessary.)Runtime: 627B - Factory RepairsUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.Runtime: .627C - Package DeliveryWe solve this with a greedy algorithm: for each gas station, we fill our tank to min(n, d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.Alternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).Runtime: 627D - Preorder TestWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.Runtime: 627E - OrchestraWe can think of a rectangle in the grid as a pair of an (xlo, xhi) interval and a (ylo, yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m + 1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.As we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi = r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.Runtime: O(r2k + rnk)627F - Island PuzzleFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.Thus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).Now, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.To compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.Runtime: O(n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43467",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 627\\s*B"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 1",
          "code": "(2 ^ i - 1) (2 ^ i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 2",
          "code": "65535 65535",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 3",
          "code": "f(i, carry)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 4",
          "code": "(0 , i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 5",
          "code": "f(i + 1, 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 6",
          "code": "f(i + 1, 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 7",
          "code": "update(1, 0, n - 1, d - 1, get(1, 0, n - 1, d - 1, d - 1) + min(a, q));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 8",
          "code": "update(1, 0, n - 1, d - 1, min(TTT[d - 1], a * 1LL));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(2, 10000, \"a\"); // a ∈ [2, 10000]\n    inf.readSpace();\n    int b = inf.readInt(1, a - 1, \"b\"); // b ∈ [1, a - 1]\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    int count_type2 = 0;\n\n    for (int i = 0; i < q; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int di = inf.readInt(1, n, \"di\");\n            inf.readSpace();\n            int ai = inf.readInt(1, 10000, \"ai\");\n            inf.readEoln();\n        } else { // type == 2\n            inf.readSpace();\n            int pi = inf.readInt(1, n - k + 1, \"pi\");\n            inf.readEoln();\n            count_type2++;\n        }\n    }\n\n    ensuref(count_type2 >= 1, \"At least one query of type 2 is required\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(2, 10000, \"a\"); // a ∈ [2, 10000]\n    inf.readSpace();\n    int b = inf.readInt(1, a - 1, \"b\"); // b ∈ [1, a - 1]\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    int count_type2 = 0;\n\n    for (int i = 0; i < q; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int di = inf.readInt(1, n, \"di\");\n            inf.readSpace();\n            int ai = inf.readInt(1, 10000, \"ai\");\n            inf.readEoln();\n        } else { // type == 2\n            inf.readSpace();\n            int pi = inf.readInt(1, n - k + 1, \"pi\");\n            inf.readEoln();\n            count_type2++;\n        }\n    }\n\n    ensuref(count_type2 >= 1, \"At least one query of type 2 is required\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(2, 10000, \"a\"); // a ∈ [2, 10000]\n    inf.readSpace();\n    int b = inf.readInt(1, a - 1, \"b\"); // b ∈ [1, a - 1]\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    int count_type2 = 0;\n\n    for (int i = 0; i < q; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int di = inf.readInt(1, n, \"di\");\n            inf.readSpace();\n            int ai = inf.readInt(1, 10000, \"ai\");\n            inf.readEoln();\n        } else { // type == 2\n            inf.readSpace();\n            int pi = inf.readInt(1, n - k + 1, \"pi\");\n            inf.readEoln();\n            count_type2++;\n        }\n    }\n\n    ensuref(count_type2 >= 1, \"At least one query of type 2 is required\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");             // number of days\n    int k = opt<int>(\"k\");             // repair time\n    int a = opt<int>(\"a\");             // final production rate\n    int b = opt<int>(\"b\");             // initial production rate\n    int q = opt<int>(\"q\");             // number of queries\n    string type = opt<string>(\"type\", \"random\"); // test type\n\n    // Ensure constraints\n    ensure(1 <= k && k <= n && n <= 200000);\n    ensure(1 <= b && b < a && a <= 10000);\n    ensure(1 <= q && q <= 200000);\n\n    vector<string> queries;\n\n    if (type == \"random\") {\n        // Randomly generate q queries\n        int num_type2 = 0;\n        for (int i = 0; i < q; ++i) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi));\n                num_type2++;\n            }\n        }\n        if (num_type2 == 0) {\n            // Make sure at least one query of type 2 exists\n            int pi = rnd.next(1, n - k + 1);\n            queries[rnd.next(0, q-1)] = \"2 \" + to_string(pi);\n        }\n    } else if (type == \"max_orders\") {\n        // Maximize the number of orders\n        // All orders are placed for each day\n        for (int day = 1; day <= n; ++day) {\n            int ai = 10000; // maximum ai\n            queries.push_back(\"1 \" + to_string(day) + \" \" + to_string(ai));\n        }\n        // Add some type 2 queries\n        int num_type2 = min(q/10, n - k + 1);\n        for (int i = 0; i < num_type2; ++i) {\n            int pi = rnd.next(1, n - k + 1);\n            queries.push_back(\"2 \" + to_string(pi));\n        }\n        while (queries.size() < (size_t)q) {\n            int di = rnd.next(1, n);\n            int ai = 10000;\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n    } else if (type == \"min_orders\") {\n        // Minimal number of orders\n        // Only one order is placed\n        queries.push_back(\"1 \" + to_string(rnd.next(1, n)) + \" 1\");\n        // Add some type 2 queries\n        queries.push_back(\"2 \" + to_string(rnd.next(1, n - k +1)));\n        while (queries.size() < (size_t)q) {\n            queries.push_back(\"2 \" + to_string(rnd.next(1, n - k +1)));\n        }\n    } else if (type == \"orders_on_repair_days\") {\n        // Orders are placed on days when the factory is under repair\n        int pi = rnd.next(1, n - k + 1); // starting day for repair\n        // Place orders on days pi to pi + k -1\n        for (int i = pi; i < pi + k; ++i) {\n            int ai = rnd.next(1,10000);\n            queries.push_back(\"1 \" + to_string(i) + \" \" + to_string(ai));\n        }\n        // Add some type 2 queries\n        queries.push_back(\"2 \" + to_string(pi));\n        while (queries.size() < (size_t)q) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi_new = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi_new));\n            }\n        }\n    } else if (type == \"orders_on_non_repair_days\") {\n        // Orders are placed on days when the factory is not under repair\n        int pi = rnd.next(1, n - k +1); // starting day for repair\n        // Days before pi and after pi+k-1 are days when the factory is operating\n        for (int i = 1; i <= n; ++i) {\n            if (i < pi || i >= pi + k) {\n                int ai = rnd.next(1,10000);\n                queries.push_back(\"1 \" + to_string(i) + \" \" + to_string(ai));\n            }\n        }\n        // Add some type 2 queries\n        queries.push_back(\"2 \" + to_string(pi));\n        while (queries.size() < (size_t)q) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi_new = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi_new));\n            }\n        }\n    } else if (type == \"start_repair_early\") {\n        // Repairs start on day 1\n        int pi = 1;\n        queries.push_back(\"2 \" + to_string(pi));\n        // Place orders randomly\n        for (int i = 0; i < q-1; ++i){\n            int di = rnd.next(1, n);\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n    } else if (type == \"start_repair_late\") {\n        // Repairs start on the last possible day\n        int pi = n - k +1;\n        queries.push_back(\"2 \" + to_string(pi));\n        // Place orders randomly\n        for (int i = 0; i < q-1; ++i){\n            int di = rnd.next(1, n);\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n    } else if (type == \"orders_on_same_day\") {\n        // All orders are placed on the same day\n        int di = rnd.next(1, n);\n        for (int i = 0; i < q - 1; ++i) {\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n        // Add at least one query of type 2\n        int pi = rnd.next(1, n - k + 1);\n        queries.push_back(\"2 \" + to_string(pi));\n    } else if (type == \"all_type1\") {\n        // All but one query are type 1\n        int num_type2 = 1;\n        for (int i = 0; i < q - num_type2; ++i) {\n            int di = rnd.next(1, n);\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n        // At least one query of type 2\n        int pi = rnd.next(1, n - k + 1);\n        queries.push_back(\"2 \" + to_string(pi));\n    } else if (type == \"all_type2\") {\n        // All but one query are type 2\n        int num_type1 = 1;\n        for (int i = 0; i < q - num_type1; ++i) {\n            int pi = rnd.next(1, n - k + 1);\n            queries.push_back(\"2 \" + to_string(pi));\n        }\n        // At least one query of type 1\n        int di = rnd.next(1, n);\n        int ai = rnd.next(1, 10000);\n        queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n    } else {\n        // Default to random\n        // Randomly generate q queries\n        int num_type2 = 0;\n        for (int i = 0; i < q; ++i) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi));\n                num_type2++;\n            }\n        }\n        if (num_type2 == 0) {\n            // Make sure at least one query of type 2 exists\n            int pi = rnd.next(1, n - k + 1);\n            queries[rnd.next(0, q-1)] = \"2 \" + to_string(pi);\n        }\n    }\n\n    // Output the first line\n    printf(\"%d %d %d %d %d\\n\", n, k, a, b, q);\n    // Shuffle queries\n    shuffle(queries.begin(), queries.end());\n    for (auto &s : queries) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");             // number of days\n    int k = opt<int>(\"k\");             // repair time\n    int a = opt<int>(\"a\");             // final production rate\n    int b = opt<int>(\"b\");             // initial production rate\n    int q = opt<int>(\"q\");             // number of queries\n    string type = opt<string>(\"type\", \"random\"); // test type\n\n    // Ensure constraints\n    ensure(1 <= k && k <= n && n <= 200000);\n    ensure(1 <= b && b < a && a <= 10000);\n    ensure(1 <= q && q <= 200000);\n\n    vector<string> queries;\n\n    if (type == \"random\") {\n        // Randomly generate q queries\n        int num_type2 = 0;\n        for (int i = 0; i < q; ++i) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi));\n                num_type2++;\n            }\n        }\n        if (num_type2 == 0) {\n            // Make sure at least one query of type 2 exists\n            int pi = rnd.next(1, n - k + 1);\n            queries[rnd.next(0, q-1)] = \"2 \" + to_string(pi);\n        }\n    } else if (type == \"max_orders\") {\n        // Maximize the number of orders\n        // All orders are placed for each day\n        for (int day = 1; day <= n; ++day) {\n            int ai = 10000; // maximum ai\n            queries.push_back(\"1 \" + to_string(day) + \" \" + to_string(ai));\n        }\n        // Add some type 2 queries\n        int num_type2 = min(q/10, n - k + 1);\n        for (int i = 0; i < num_type2; ++i) {\n            int pi = rnd.next(1, n - k + 1);\n            queries.push_back(\"2 \" + to_string(pi));\n        }\n        while (queries.size() < (size_t)q) {\n            int di = rnd.next(1, n);\n            int ai = 10000;\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n    } else if (type == \"min_orders\") {\n        // Minimal number of orders\n        // Only one order is placed\n        queries.push_back(\"1 \" + to_string(rnd.next(1, n)) + \" 1\");\n        // Add some type 2 queries\n        queries.push_back(\"2 \" + to_string(rnd.next(1, n - k +1)));\n        while (queries.size() < (size_t)q) {\n            queries.push_back(\"2 \" + to_string(rnd.next(1, n - k +1)));\n        }\n    } else if (type == \"orders_on_repair_days\") {\n        // Orders are placed on days when the factory is under repair\n        int pi = rnd.next(1, n - k + 1); // starting day for repair\n        // Place orders on days pi to pi + k -1\n        for (int i = pi; i < pi + k; ++i) {\n            int ai = rnd.next(1,10000);\n            queries.push_back(\"1 \" + to_string(i) + \" \" + to_string(ai));\n        }\n        // Add some type 2 queries\n        queries.push_back(\"2 \" + to_string(pi));\n        while (queries.size() < (size_t)q) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi_new = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi_new));\n            }\n        }\n    } else if (type == \"orders_on_non_repair_days\") {\n        // Orders are placed on days when the factory is not under repair\n        int pi = rnd.next(1, n - k +1); // starting day for repair\n        // Days before pi and after pi+k-1 are days when the factory is operating\n        for (int i = 1; i <= n; ++i) {\n            if (i < pi || i >= pi + k) {\n                int ai = rnd.next(1,10000);\n                queries.push_back(\"1 \" + to_string(i) + \" \" + to_string(ai));\n            }\n        }\n        // Add some type 2 queries\n        queries.push_back(\"2 \" + to_string(pi));\n        while (queries.size() < (size_t)q) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi_new = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi_new));\n            }\n        }\n    } else if (type == \"start_repair_early\") {\n        // Repairs start on day 1\n        int pi = 1;\n        queries.push_back(\"2 \" + to_string(pi));\n        // Place orders randomly\n        for (int i = 0; i < q-1; ++i){\n            int di = rnd.next(1, n);\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n    } else if (type == \"start_repair_late\") {\n        // Repairs start on the last possible day\n        int pi = n - k +1;\n        queries.push_back(\"2 \" + to_string(pi));\n        // Place orders randomly\n        for (int i = 0; i < q-1; ++i){\n            int di = rnd.next(1, n);\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n    } else if (type == \"orders_on_same_day\") {\n        // All orders are placed on the same day\n        int di = rnd.next(1, n);\n        for (int i = 0; i < q - 1; ++i) {\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n        // Add at least one query of type 2\n        int pi = rnd.next(1, n - k + 1);\n        queries.push_back(\"2 \" + to_string(pi));\n    } else if (type == \"all_type1\") {\n        // All but one query are type 1\n        int num_type2 = 1;\n        for (int i = 0; i < q - num_type2; ++i) {\n            int di = rnd.next(1, n);\n            int ai = rnd.next(1, 10000);\n            queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n        }\n        // At least one query of type 2\n        int pi = rnd.next(1, n - k + 1);\n        queries.push_back(\"2 \" + to_string(pi));\n    } else if (type == \"all_type2\") {\n        // All but one query are type 2\n        int num_type1 = 1;\n        for (int i = 0; i < q - num_type1; ++i) {\n            int pi = rnd.next(1, n - k + 1);\n            queries.push_back(\"2 \" + to_string(pi));\n        }\n        // At least one query of type 1\n        int di = rnd.next(1, n);\n        int ai = rnd.next(1, 10000);\n        queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n    } else {\n        // Default to random\n        // Randomly generate q queries\n        int num_type2 = 0;\n        for (int i = 0; i < q; ++i) {\n            int qt = rnd.next(1,2);\n            if (qt == 1) {\n                int di = rnd.next(1, n);\n                int ai = rnd.next(1, 10000);\n                queries.push_back(\"1 \" + to_string(di) + \" \" + to_string(ai));\n            } else {\n                int pi = rnd.next(1, n - k + 1);\n                queries.push_back(\"2 \" + to_string(pi));\n                num_type2++;\n            }\n        }\n        if (num_type2 == 0) {\n            // Make sure at least one query of type 2 exists\n            int pi = rnd.next(1, n - k + 1);\n            queries[rnd.next(0, q-1)] = \"2 \" + to_string(pi);\n        }\n    }\n\n    // Output the first line\n    printf(\"%d %d %d %d %d\\n\", n, k, a, b, q);\n    // Shuffle queries\n    shuffle(queries.begin(), queries.end());\n    for (auto &s : queries) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -k 1 -a 2 -b 1 -q 1 -type min_orders\n./gen -n 5 -k 2 -a 5 -b 1 -q 5 -type random\n./gen -n 10 -k 5 -a 10 -b 5 -q 10 -type random\n./gen -n 50 -k 25 -a 50 -b 25 -q 100 -type random\n\n# Mid-size test cases\n./gen -n 1000 -k 100 -a 1000 -b 500 -q 1000 -type random\n./gen -n 1000 -k 100 -a 1000 -b 999 -q 1000 -type random\n\n# Max n and q\n./gen -n 200000 -k 100000 -a 10000 -b 1 -q 200000 -type random\n./gen -n 200000 -k 1 -a 10000 -b 1 -q 200000 -type random\n\n# Edge case where b = a - 1\n./gen -n 200000 -k 100 -a 10000 -b 9999 -q 200000 -type random\n\n# Max orders\n./gen -n 200000 -k 100000 -a 10000 -b 1 -q 200000 -type max_orders\n\n# Min orders\n./gen -n 200000 -k 100 -a 10000 -b 9999 -q 200000 -type min_orders\n\n# Orders on repair days\n./gen -n 100000 -k 50000 -a 10000 -b 1 -q 200000 -type orders_on_repair_days\n\n# Orders on non-repair days\n./gen -n 100000 -k 50000 -a 10000 -b 1 -q 200000 -type orders_on_non_repair_days\n\n# Start repair early\n./gen -n 200000 -k 100000 -a 10000 -b 1 -q 200000 -type start_repair_early\n\n# Start repair late\n./gen -n 200000 -k 100000 -a 10000 -b 1 -q 200000 -type start_repair_late\n\n# Edge case where k = n\n./gen -n 200000 -k 200000 -a 10000 -b 1 -q 200000 -type random\n\n# Edge case where k = 1\n./gen -n 200000 -k 1 -a 10000 -b 1 -q 200000 -type random\n\n# All orders on same day\n./gen -n 200000 -k 100 -a 10000 -b 1 -q 200000 -type orders_on_same_day\n\n# All queries are type 1 except one\n./gen -n 200000 -k 100000 -a 10000 -b 1 -q 200000 -type all_type1\n\n# All queries are type 2 except one\n./gen -n 200000 -k 100000 -a 10000 -b 1 -q 200000 -type all_type2\n\n# Max a and b\n./gen -n 200000 -k 100 -a 10000 -b 9999 -q 200000 -type random\n\n# Small k compared to n\n./gen -n 200000 -k 2 -a 10000 -b 1 -q 200000 -type random\n\n# Random test cases\n./gen -n 200000 -k 50000 -a 10000 -b 1 -q 200000 -type random\n./gen -n 200000 -k 50000 -a 10000 -b 1 -q 200000 -type default\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:35.798064",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "627/C",
      "title": "C. Package Delivery",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three space separated integers d, n, and m (1 ≤ n ≤ d ≤ 109, 1 ≤ m ≤ 200 000) — the total distance to the district center, the volume of the gas tank, and the number of gas stations, respectively.Each of the next m lines contains two integers xi, pi (1 ≤ xi ≤ d - 1, 1 ≤ pi ≤ 106) — the position and cost of gas at the i-th gas station. It is guaranteed that the positions of the gas stations are distinct.",
      "output_spec": "OutputPrint a single integer — the minimum cost to complete the delivery. If there is no way to complete the delivery, print -1.",
      "sample_tests": "ExamplesInputCopy10 4 43 55 86 38 4OutputCopy22InputCopy16 5 28 25 1OutputCopy-1",
      "description": "C. Package Delivery\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three space separated integers d, n, and m (1 ≤ n ≤ d ≤ 109, 1 ≤ m ≤ 200 000) — the total distance to the district center, the volume of the gas tank, and the number of gas stations, respectively.Each of the next m lines contains two integers xi, pi (1 ≤ xi ≤ d - 1, 1 ≤ pi ≤ 106) — the position and cost of gas at the i-th gas station. It is guaranteed that the positions of the gas stations are distinct.\n\nOutputPrint a single integer — the minimum cost to complete the delivery. If there is no way to complete the delivery, print -1.\n\nInputCopy10 4 43 55 86 38 4OutputCopy22InputCopy16 5 28 25 1OutputCopy-1\n\nInputCopy10 4 43 55 86 38 4\n\nOutputCopy22\n\nInputCopy16 5 28 25 1\n\nOutputCopy-1\n\nNoteIn the first sample, Johnny's truck holds 4 liters. He can drive 3 units to the first gas station, buy 2 liters of gas there (bringing the tank to 3 liters total), drive 3 more units to the third gas station, buy 4 liters there to fill up his tank, and then drive straight to the district center. His total cost is 2·5 + 4·3 = 22 dollars.In the second sample, there is no way for Johnny to make it to the district center, as his tank cannot hold enough gas to take him from the latest gas station to the district center.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces",
          "content": "Hello everyone!The final round of the 8VC Venture Cup will be held on Feb/28/2016 18:10 (UTC). ecnerwala and I are the problem setters. We want to thank GlebsHP and vnovakovski for help in preparing the contest, stella_marine for fixing the statements, and MikeMirzayanov for creating the Codeforces platform.The contest is by invitation only to the top 200 contestants and top local contestants from Round 1 and contains six problems. We will also hold rated, out-of-contest participation for both div1 and div2 contestants — all three groups will feature slightly different problemsets. Local contestants will compete onsite in Silicon Valley. OpenGov, one of the featured 8 | VC companies, has been generous to host this competition at their offices; see more details about this awesome company below: OpenGov transforms the way the world analyzes and allocates public money. With more than 700 government customers across 45 states in a rapidly expanding network, OpenGov is the market leader in cloud-based financial intelligence, budgeting, and transparency for government. The OpenGov platform transforms government financial data into intuitive, interactive visualizations for both internal government users and citizens.ABOUT 8 | PARTNERS8 | Partners, which consists of Joe Lonsdale (co-founder of Palantir) and his core team from Formation | 8, is a Silicon Valley venture capital firm that invests in industry-transforming technology companies. The team's investment portfolio includes companies such as those featured below, and a host of other top technology platforms that leverage modern algorithms and data science to power their core business processes. If you are interested to connect, please take a look at http://www.codeforces.com/8vc/apply.PRIZES Overall 1st place — $2500 Overall 2nd place — $1000 Overall 3rd-5th places — $500 each Overall 1-50th place — t-shirts with 8 | VC and company logos Local Winner — Dinner with Joe Lonsdale (founder of Palantir, Addepar, & 8 | Partners) and other Silicon Valley technologists Local top finishers — Opportunity to meet with leadership from 8 | VC portfolio companies The scoring distribution will be standard for all three divisions: 500 — 1000 — 1500 — 2000 — 2500 — 3000Good luck!UPD: Due to onsite awards presentation, we will hold final system testing until around one hour after the end of the contest.Congratulations to the top overall contestants: tourist Egor ikatanic enot110 DemiGuo As well as the top onsite contestants: winger waterfalls KADR Editorial can be found here.Thanks for participating!",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/43421",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2576
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round Editorial - Codeforces",
          "content": "635A - OrchestraWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.Runtime: O(n6)634A - Island PuzzleNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.Runtime: O(n)627A - XOR EquationFor any two integers a and b, we have , where is the xor and a&b is the bitwise AND. This is because is non-carrying binary addition. Thus, we can find a&b = (s - x) / 2 (if this is not an integer, there are no solutions).Now, for each bit, we have 4 cases: , and . If , then ai = bi, so we have one possibility: ai = bi = ai&bi. If , then we must have ai&bi = 0 (otherwise we print 0), and we have two choices: ai = 1 and bi = 0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a = 0 or b = 0 if necessary.)Runtime: 627B - Factory RepairsUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.Runtime: .627C - Package DeliveryWe solve this with a greedy algorithm: for each gas station, we fill our tank to min(n, d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.Alternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).Runtime: 627D - Preorder TestWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.Runtime: 627E - OrchestraWe can think of a rectangle in the grid as a pair of an (xlo, xhi) interval and a (ylo, yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m + 1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.As we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi = r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.Runtime: O(r2k + rnk)627F - Island PuzzleFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.Thus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).Now, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.To compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.Runtime: O(n)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/43467",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 627\\s*C"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 1",
          "code": "(2 ^ i - 1) (2 ^ i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 2",
          "code": "65535 65535",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 3",
          "code": "f(i, carry)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 4",
          "code": "(0 , i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 5",
          "code": "f(i + 1, 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 6",
          "code": "f(i + 1, 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 7",
          "code": "update(1, 0, n - 1, d - 1, get(1, 0, n - 1, d - 1, d - 1) + min(a, q));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 8",
          "code": "update(1, 0, n - 1, d - 1, min(TTT[d - 1], a * 1LL));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(2, 1000000000, \"d\");\n    inf.readSpace();\n    int n = inf.readInt(1, d, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n    \n    set<int> positions;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, d - 1, \"xi\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, \"pi\");\n        inf.readEoln();\n        ensuref(positions.count(xi) == 0, \"Gas station positions xi must be unique, xi=%d occurs more than once\", xi);\n        positions.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(2, 1000000000, \"d\");\n    inf.readSpace();\n    int n = inf.readInt(1, d, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n    \n    set<int> positions;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, d - 1, \"xi\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, \"pi\");\n        inf.readEoln();\n        ensuref(positions.count(xi) == 0, \"Gas station positions xi must be unique, xi=%d occurs more than once\", xi);\n        positions.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(2, 1000000000, \"d\");\n    inf.readSpace();\n    int n = inf.readInt(1, d, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n    \n    set<int> positions;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, d - 1, \"xi\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, \"pi\");\n        inf.readEoln();\n        ensuref(positions.count(xi) == 0, \"Gas station positions xi must be unique, xi=%d occurs more than once\", xi);\n        positions.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi;\n    vector<int> pi;\n\n    if (type == \"random\") {\n        // Generate m distinct random xi in [1, d - 1]\n        set<int> xi_set;\n        while ((int)xi_set.size() < m) {\n            int x = rnd.next(1, d - 1);\n            xi_set.insert(x);\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n\n        // Generate random pi in [1, 1e6]\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"impossible\") {\n        // Generate positions with a gap greater than n\n        vector<int> positions;\n        // Start from 1\n        int x0 = rnd.next(1, min(n, d - 1));\n        positions.push_back(x0);\n\n        // Let's force a gap at a random position\n        int gap_pos = rnd.next(1, m - 1);\n        for (int i = 1; i < gap_pos; ++i) {\n            int max_increment = min(n, d - 2 - positions.back());\n            if (max_increment <= 0) break;\n            int increment = rnd.next(1, max_increment);\n            positions.push_back(positions.back() + increment);\n        }\n        // Create a gap greater than n\n        int gap_size = rnd.next(n + 1, min(2 * n, d - 1 - positions.back()));\n        positions.push_back(positions.back() + gap_size);\n\n        // Fill the rest\n        while ((int)positions.size() < m) {\n            int max_increment = min(n, d - 2 - positions.back());\n            if (max_increment <= 0) break;\n            int increment = rnd.next(1, max_increment);\n            positions.push_back(positions.back() + increment);\n        }\n\n        xi = positions;\n\n        // Generate random pi\n        for (int i = 0; i < (int)xi.size(); ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"possible\") {\n        // Ensure that the distances between gas stations are ≤ n\n        vector<int> positions;\n\n        // First station within n from 0\n        int x0 = rnd.next(1, min(n, d - 1));\n        positions.push_back(x0);\n\n        for (int i = 1; i < m; ++i) {\n            int remaining_distance = d - 1 - positions.back();\n            if (remaining_distance == 0) break;\n            int max_increment = min(n, remaining_distance);\n            int increment = rnd.next(1, max_increment);\n            positions.push_back(positions.back() + increment);\n        }\n\n        // Ensure we can reach the destination from the last station\n        if (d - positions.back() > n) {\n            positions.push_back(d - n);\n        }\n\n        xi = positions;\n\n        // Generate random pi\n        for (int i = 0; i < (int)xi.size(); ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"no_stations\") {\n        m = 0;\n    } else if (type == \"max_m\") {\n        m = 200000;\n\n        // Generate m distinct random xi in [1, d - 1]\n        set<int> xi_set;\n        while ((int)xi_set.size() < m) {\n            int x = rnd.next(1, d - 1);\n            xi_set.insert(x);\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n\n        // Generate random pi in [1, 1e6]\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"cheapest_far\") {\n        // First station somewhere within reach\n        int x1 = rnd.next(1, min(n, d - 2));\n        xi.push_back(x1);\n        pi.push_back(rnd.next(500000, 1000000)); // Expensive\n\n        // Middle stations\n        for (int i = 1; i < m - 1; ++i) {\n            int x = rnd.next(xi.back() + 1, d - 2);\n            xi.push_back(x);\n            pi.push_back(rnd.next(500000, 1000000)); // Expensive\n        }\n\n        // Cheap gas station near the end\n        xi.push_back(d - 1);\n        pi.push_back(rnd.next(1, 1000)); // Cheap\n    }\n\n    // Ensure positions are unique and sorted\n    set<int> xi_set(xi.begin(), xi.end());\n    xi.assign(xi_set.begin(), xi_set.end());\n    m = xi.size();\n    pi.resize(m);\n\n    vector<pair<int, int>> stations;\n    for (int i = 0; i < m; ++i) {\n        stations.push_back({xi[i], pi[i]});\n    }\n    sort(stations.begin(), stations.end());\n\n    // Output\n    printf(\"%d %d %d\\n\", d, n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", stations[i].first, stations[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi;\n    vector<int> pi;\n\n    if (type == \"random\") {\n        // Generate m distinct random xi in [1, d - 1]\n        set<int> xi_set;\n        while ((int)xi_set.size() < m) {\n            int x = rnd.next(1, d - 1);\n            xi_set.insert(x);\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n\n        // Generate random pi in [1, 1e6]\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"impossible\") {\n        // Generate positions with a gap greater than n\n        vector<int> positions;\n        // Start from 1\n        int x0 = rnd.next(1, min(n, d - 1));\n        positions.push_back(x0);\n\n        // Let's force a gap at a random position\n        int gap_pos = rnd.next(1, m - 1);\n        for (int i = 1; i < gap_pos; ++i) {\n            int max_increment = min(n, d - 2 - positions.back());\n            if (max_increment <= 0) break;\n            int increment = rnd.next(1, max_increment);\n            positions.push_back(positions.back() + increment);\n        }\n        // Create a gap greater than n\n        int gap_size = rnd.next(n + 1, min(2 * n, d - 1 - positions.back()));\n        positions.push_back(positions.back() + gap_size);\n\n        // Fill the rest\n        while ((int)positions.size() < m) {\n            int max_increment = min(n, d - 2 - positions.back());\n            if (max_increment <= 0) break;\n            int increment = rnd.next(1, max_increment);\n            positions.push_back(positions.back() + increment);\n        }\n\n        xi = positions;\n\n        // Generate random pi\n        for (int i = 0; i < (int)xi.size(); ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"possible\") {\n        // Ensure that the distances between gas stations are ≤ n\n        vector<int> positions;\n\n        // First station within n from 0\n        int x0 = rnd.next(1, min(n, d - 1));\n        positions.push_back(x0);\n\n        for (int i = 1; i < m; ++i) {\n            int remaining_distance = d - 1 - positions.back();\n            if (remaining_distance == 0) break;\n            int max_increment = min(n, remaining_distance);\n            int increment = rnd.next(1, max_increment);\n            positions.push_back(positions.back() + increment);\n        }\n\n        // Ensure we can reach the destination from the last station\n        if (d - positions.back() > n) {\n            positions.push_back(d - n);\n        }\n\n        xi = positions;\n\n        // Generate random pi\n        for (int i = 0; i < (int)xi.size(); ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"no_stations\") {\n        m = 0;\n    } else if (type == \"max_m\") {\n        m = 200000;\n\n        // Generate m distinct random xi in [1, d - 1]\n        set<int> xi_set;\n        while ((int)xi_set.size() < m) {\n            int x = rnd.next(1, d - 1);\n            xi_set.insert(x);\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n\n        // Generate random pi in [1, 1e6]\n        for (int i = 0; i < m; ++i) {\n            pi.push_back(rnd.next(1, 1000000));\n        }\n    } else if (type == \"cheapest_far\") {\n        // First station somewhere within reach\n        int x1 = rnd.next(1, min(n, d - 2));\n        xi.push_back(x1);\n        pi.push_back(rnd.next(500000, 1000000)); // Expensive\n\n        // Middle stations\n        for (int i = 1; i < m - 1; ++i) {\n            int x = rnd.next(xi.back() + 1, d - 2);\n            xi.push_back(x);\n            pi.push_back(rnd.next(500000, 1000000)); // Expensive\n        }\n\n        // Cheap gas station near the end\n        xi.push_back(d - 1);\n        pi.push_back(rnd.next(1, 1000)); // Cheap\n    }\n\n    // Ensure positions are unique and sorted\n    set<int> xi_set(xi.begin(), xi.end());\n    xi.assign(xi_set.begin(), xi_set.end());\n    m = xi.size();\n    pi.resize(m);\n\n    vector<pair<int, int>> stations;\n    for (int i = 0; i < m; ++i) {\n        stations.push_back({xi[i], pi[i]});\n    }\n    sort(stations.begin(), stations.end());\n\n    // Output\n    printf(\"%d %d %d\\n\", d, n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", stations[i].first, stations[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -d 100 -m 5 -type random\n./gen -n 100 -d 1000 -m 10 -type random\n./gen -n 1000 -d 10000 -m 1000 -type random\n./gen -n 500000000 -d 1000000000 -m 200000 -type random\n\n./gen -n 5 -d 50 -m 0 -type no_stations\n./gen -n 100 -d 100 -m 0 -type no_stations\n./gen -n 1000 -d 1000000 -m 0 -type no_stations\n\n./gen -n 10 -d 100 -m 5 -type impossible\n./gen -n 50 -d 200 -m 10 -type impossible\n./gen -n 100 -d 1000 -m 100 -type impossible\n./gen -n 1000 -d 100000 -m 1000 -type impossible\n\n./gen -n 20 -d 100 -m 5 -type possible\n./gen -n 50 -d 200 -m 10 -type possible\n./gen -n 100 -d 1000 -m 50 -type possible\n./gen -n 500 -d 10000 -m 500 -type possible\n\n./gen -n 10 -d 100 -m 200000 -type max_m\n./gen -n 1000 -d 1000000 -m 200000 -type max_m\n./gen -n 1000000000 -d 1000000000 -m 200000 -type max_m\n\n./gen -n 10 -d 100 -m 5 -type cheapest_far\n./gen -n 50 -d 200 -m 10 -type cheapest_far\n./gen -n 100 -d 1000 -m 50 -type cheapest_far\n./gen -n 500 -d 5000 -m 100 -type cheapest_far\n\n# Additional test cases\n./gen -n 1 -d 1000000000 -m 1000 -type impossible\n./gen -n 1000000000 -d 1000000000 -m 0 -type no_stations\n./gen -n 1 -d 1 -m 0 -type no_stations\n./gen -n 1 -d 100 -m 100 -type possible\n./gen -n 1 -d 100 -m 100 -type impossible\n\n./gen -n 1 -d 1 -m 0 -type possible\n./gen -n 1 -d 2 -m 1 -type possible\n./gen -n 1 -d 2 -m 0 -type impossible\n\n./gen -n 1000000000 -d 1 -m 0 -type no_stations\n./gen -n 500000001 -d 1000000000 -m 200000 -type random\n./gen -n 999999999 -d 1000000000 -m 200000 -type cheapest_far\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:37.563566",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "627/D",
      "title": "D. Preorder Test",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test7 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two positive integers, n and k (2 ≤ n ≤ 200 000, 1 ≤ k ≤ n) — the number of balls in Jacob's tree and the number of balls the teacher will inspect.The second line contains n integers, ai (1 ≤ ai ≤ 1 000 000), the time Jacob used to build the i-th ball.Each of the next n - 1 lines contains two integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi) representing a connection in Jacob's tree between balls ui and vi.",
      "output_spec": "OutputPrint a single integer — the maximum grade Jacob can get by picking the right root of the tree and rearranging the list of neighbors.",
      "sample_tests": "ExamplesInputCopy5 33 6 1 4 21 22 42 51 3OutputCopy3InputCopy4 21 5 5 51 21 31 4OutputCopy1",
      "description": "D. Preorder Test\n\ntime limit per test7 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two positive integers, n and k (2 ≤ n ≤ 200 000, 1 ≤ k ≤ n) — the number of balls in Jacob's tree and the number of balls the teacher will inspect.The second line contains n integers, ai (1 ≤ ai ≤ 1 000 000), the time Jacob used to build the i-th ball.Each of the next n - 1 lines contains two integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi) representing a connection in Jacob's tree between balls ui and vi.\n\nOutputPrint a single integer — the maximum grade Jacob can get by picking the right root of the tree and rearranging the list of neighbors.\n\nInputCopy5 33 6 1 4 21 22 42 51 3OutputCopy3InputCopy4 21 5 5 51 21 31 4OutputCopy1\n\nInputCopy5 33 6 1 4 21 22 42 51 3\n\nOutputCopy3\n\nInputCopy4 21 5 5 51 21 31 4\n\nOutputCopy1\n\nNoteIn the first sample, Jacob can root the tree at node 2 and order 2's neighbors in the order 4, 1, 5 (all other nodes have at most two neighbors). The resulting preorder traversal is 2, 4, 1, 3, 5, and the minimum ai of the first 3 nodes is 3.In the second sample, it is clear that any preorder traversal will contain node 1 as either its first or second node, so Jacob cannot do better than a grade of 1.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces",
          "content": "Hello everyone!The final round of the 8VC Venture Cup will be held on Feb/28/2016 18:10 (UTC). ecnerwala and I are the problem setters. We want to thank GlebsHP and vnovakovski for help in preparing the contest, stella_marine for fixing the statements, and MikeMirzayanov for creating the Codeforces platform.The contest is by invitation only to the top 200 contestants and top local contestants from Round 1 and contains six problems. We will also hold rated, out-of-contest participation for both div1 and div2 contestants — all three groups will feature slightly different problemsets. Local contestants will compete onsite in Silicon Valley. OpenGov, one of the featured 8 | VC companies, has been generous to host this competition at their offices; see more details about this awesome company below: OpenGov transforms the way the world analyzes and allocates public money. With more than 700 government customers across 45 states in a rapidly expanding network, OpenGov is the market leader in cloud-based financial intelligence, budgeting, and transparency for government. The OpenGov platform transforms government financial data into intuitive, interactive visualizations for both internal government users and citizens.ABOUT 8 | PARTNERS8 | Partners, which consists of Joe Lonsdale (co-founder of Palantir) and his core team from Formation | 8, is a Silicon Valley venture capital firm that invests in industry-transforming technology companies. The team's investment portfolio includes companies such as those featured below, and a host of other top technology platforms that leverage modern algorithms and data science to power their core business processes. If you are interested to connect, please take a look at http://www.codeforces.com/8vc/apply.PRIZES Overall 1st place — $2500 Overall 2nd place — $1000 Overall 3rd-5th places — $500 each Overall 1-50th place — t-shirts with 8 | VC and company logos Local Winner — Dinner with Joe Lonsdale (founder of Palantir, Addepar, & 8 | Partners) and other Silicon Valley technologists Local top finishers — Opportunity to meet with leadership from 8 | VC portfolio companies The scoring distribution will be standard for all three divisions: 500 — 1000 — 1500 — 2000 — 2500 — 3000Good luck!UPD: Due to onsite awards presentation, we will hold final system testing until around one hour after the end of the contest.Congratulations to the top overall contestants: tourist Egor ikatanic enot110 DemiGuo As well as the top onsite contestants: winger waterfalls KADR Editorial can be found here.Thanks for participating!",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/43421",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2576
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round Editorial - Codeforces",
          "content": "635A - OrchestraWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.Runtime: O(n6)634A - Island PuzzleNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.Runtime: O(n)627A - XOR EquationFor any two integers a and b, we have , where is the xor and a&b is the bitwise AND. This is because is non-carrying binary addition. Thus, we can find a&b = (s - x) / 2 (if this is not an integer, there are no solutions).Now, for each bit, we have 4 cases: , and . If , then ai = bi, so we have one possibility: ai = bi = ai&bi. If , then we must have ai&bi = 0 (otherwise we print 0), and we have two choices: ai = 1 and bi = 0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a = 0 or b = 0 if necessary.)Runtime: 627B - Factory RepairsUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.Runtime: .627C - Package DeliveryWe solve this with a greedy algorithm: for each gas station, we fill our tank to min(n, d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.Alternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).Runtime: 627D - Preorder TestWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.Runtime: 627E - OrchestraWe can think of a rectangle in the grid as a pair of an (xlo, xhi) interval and a (ylo, yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m + 1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.As we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi = r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.Runtime: O(r2k + rnk)627F - Island PuzzleFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.Thus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).Now, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.To compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.Runtime: O(n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43467",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 627\\s*D"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 1",
          "code": "(2 ^ i - 1) (2 ^ i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 2",
          "code": "65535 65535",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 3",
          "code": "f(i, carry)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 4",
          "code": "(0 , i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 5",
          "code": "f(i + 1, 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 6",
          "code": "f(i + 1, 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 7",
          "code": "update(1, 0, n - 1, d - 1, get(1, 0, n - 1, d - 1, d - 1) + min(a, q));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 8",
          "code": "update(1, 0, n - 1, d - 1, min(TTT[d - 1], a * 1LL));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and k\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n    // Read edges\n    vector<int> u(n-1), v(n-1);\n    for(int i = 0; i < n - 1; i++) {\n        u[i] = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        v[i] = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u[i] != v[i], \"Edge cannot be a loop: u[%d] == v[%d]\", i+1, i+1);\n    }\n    // Check that the edges form a tree (connected and acyclic)\n    // Using DSU\n    vector<int> parent(n+1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n    function<int(int)> find = [&](int x) {\n        if(parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n    for(int i = 0; i < n - 1; i++) {\n        int pu = find(u[i]);\n        int pv = find(v[i]);\n        ensuref(pu != pv, \"Graph contains a cycle at edge %d connecting %d and %d\", i+1, u[i], v[i]);\n        parent[pu] = pv;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and k\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n    // Read edges\n    vector<int> u(n-1), v(n-1);\n    for(int i = 0; i < n - 1; i++) {\n        u[i] = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        v[i] = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u[i] != v[i], \"Edge cannot be a loop: u[%d] == v[%d]\", i+1, i+1);\n    }\n    // Check that the edges form a tree (connected and acyclic)\n    // Using DSU\n    vector<int> parent(n+1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n    function<int(int)> find = [&](int x) {\n        if(parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n    for(int i = 0; i < n - 1; i++) {\n        int pu = find(u[i]);\n        int pv = find(v[i]);\n        ensuref(pu != pv, \"Graph contains a cycle at edge %d connecting %d and %d\", i+1, u[i], v[i]);\n        parent[pu] = pv;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and k\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    // Read ai\n    vector<int> a = inf.readInts(n, 1, 1000000, \"ai\");\n    inf.readEoln();\n    // Read edges\n    vector<int> u(n-1), v(n-1);\n    for(int i = 0; i < n - 1; i++) {\n        u[i] = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        v[i] = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u[i] != v[i], \"Edge cannot be a loop: u[%d] == v[%d]\", i+1, i+1);\n    }\n    // Check that the edges form a tree (connected and acyclic)\n    // Using DSU\n    vector<int> parent(n+1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n    function<int(int)> find = [&](int x) {\n        if(parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n    for(int i = 0; i < n - 1; i++) {\n        int pu = find(u[i]);\n        int pv = find(v[i]);\n        ensuref(pu != pv, \"Graph contains a cycle at edge %d connecting %d and %d\", i+1, u[i], v[i]);\n        parent[pu] = pv;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a chain tree\nvector<pair<int,int>> generate_chain_tree(int n) {\n    vector<pair<int,int>> edges;\n    for(int i = 2; i <= n; i++) {\n        edges.push_back({i-1, i});\n    }\n    return edges;\n}\n\n// Function to generate a star tree\nvector<pair<int,int>> generate_star_tree(int n) {\n    vector<pair<int,int>> edges;\n    int center = 1;\n    for(int i = 2; i <= n; i++) {\n        edges.push_back({center, i});\n    }\n    return edges;\n}\n\n// Function to generate a random tree\nvector<pair<int,int>> generate_random_tree(int n) {\n    vector<int> p(n+1);\n    for(int i = 2; i <= n; i++) {\n        // Random parent from 1 to i-1\n        p[i] = rnd.next(1, i-1);\n    }\n    vector<pair<int,int>> edges;\n    for(int i = 2; i <= n; i++) {\n        edges.push_back({p[i], i});\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\n// Function to generate a balanced binary tree\nvector<pair<int,int>> generate_balanced_tree(int n) {\n    vector<pair<int,int>> edges;\n    int cnt = 1;\n    queue<int> q;\n    q.push(cnt++);\n    while(cnt <= n) {\n        int parent = q.front();\n        q.pop();\n        int left = cnt++;\n        edges.push_back({parent, left});\n        q.push(left);\n        if (cnt <= n) {\n            int right = cnt++;\n            edges.push_back({parent, right});\n            q.push(right);\n        }\n    }\n    return edges;\n}\n\n// Function to generate ai values\nvector<int> generate_ai(int n, string ai_type, int ai_max) {\n    vector<int> a(n+1);\n    if(ai_type == \"random\") {\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(1, ai_max);\n        }\n    } else if(ai_type == \"constant\") {\n        int val = rnd.next(1, ai_max);\n        for(int i = 1; i <= n; i++) {\n            a[i] = val;\n        }\n    } else if(ai_type == \"increasing\") {\n        for(int i = 1; i <= n; i++) {\n            a[i] = i;\n        }\n        // Scale to ai_max if necessary\n        if(n > ai_max) {\n            int factor = n / ai_max;\n            for(int i = 1; i <= n; i++) {\n                a[i] = (a[i]-1)/factor + 1;\n            }\n        }\n    } else if(ai_type == \"decreasing\") {\n        for(int i = 1; i <= n; i++) {\n            a[i] = n - i + 1;\n        }\n        if(n > ai_max) {\n            int factor = n / ai_max;\n            for(int i = 1; i <= n; i++) {\n                a[i] = (a[i]-1)/factor +1;\n            }\n        }\n    }\n    else if(ai_type == \"maxfirst\") {\n        // Assign maximum ai values to nodes\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(1, ai_max/2);\n        }\n        vector<int> indices(n);\n        for(int i = 1; i <= n; i++) indices[i-1]=i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < min(n, 100); i++) {\n            a[indices[i]] = ai_max - rnd.next(0, i);\n        }\n    }\n    else if(ai_type == \"minfirst\") {\n        // Assign minimum ai values to nodes\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(ai_max/2, ai_max);\n        }\n        vector<int> indices(n);\n        for(int i = 1; i <= n; i++) indices[i-1]=i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i< min(n,100); i++) {\n            a[indices[i]] = rnd.next(1, 10);\n        }\n    }\n    else {\n        // Default to random ai\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(1, ai_max);\n        }\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    int ai_max = opt<int>(\"ai_max\", 1000000);\n    \n    // Check constraints\n    ensure(2 <= n && n <= 200000);\n    ensure(1 <= k && k <= n);\n    ensure(1 <= ai_max && ai_max <= 1000000);\n\n    vector<pair<int,int>> edges;\n    if(tree_type == \"random\") {\n        edges = generate_random_tree(n);\n    } else if(tree_type == \"chain\") {\n        edges = generate_chain_tree(n);\n    } else if(tree_type == \"star\") {\n        edges = generate_star_tree(n);\n    } else if(tree_type == \"balanced\") {\n        edges = generate_balanced_tree(n);\n    } else {\n        // Default to random tree\n        edges = generate_random_tree(n);\n    }\n\n    // Generate ai values according to ai_type\n    vector<int> a = generate_ai(n, ai_type, ai_max);\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output ai values\n    for(int i = 1; i <= n; i++) {\n        printf(\"%d\", a[i]);\n        if(i < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Output edges\n    for(auto &e: edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a chain tree\nvector<pair<int,int>> generate_chain_tree(int n) {\n    vector<pair<int,int>> edges;\n    for(int i = 2; i <= n; i++) {\n        edges.push_back({i-1, i});\n    }\n    return edges;\n}\n\n// Function to generate a star tree\nvector<pair<int,int>> generate_star_tree(int n) {\n    vector<pair<int,int>> edges;\n    int center = 1;\n    for(int i = 2; i <= n; i++) {\n        edges.push_back({center, i});\n    }\n    return edges;\n}\n\n// Function to generate a random tree\nvector<pair<int,int>> generate_random_tree(int n) {\n    vector<int> p(n+1);\n    for(int i = 2; i <= n; i++) {\n        // Random parent from 1 to i-1\n        p[i] = rnd.next(1, i-1);\n    }\n    vector<pair<int,int>> edges;\n    for(int i = 2; i <= n; i++) {\n        edges.push_back({p[i], i});\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\n// Function to generate a balanced binary tree\nvector<pair<int,int>> generate_balanced_tree(int n) {\n    vector<pair<int,int>> edges;\n    int cnt = 1;\n    queue<int> q;\n    q.push(cnt++);\n    while(cnt <= n) {\n        int parent = q.front();\n        q.pop();\n        int left = cnt++;\n        edges.push_back({parent, left});\n        q.push(left);\n        if (cnt <= n) {\n            int right = cnt++;\n            edges.push_back({parent, right});\n            q.push(right);\n        }\n    }\n    return edges;\n}\n\n// Function to generate ai values\nvector<int> generate_ai(int n, string ai_type, int ai_max) {\n    vector<int> a(n+1);\n    if(ai_type == \"random\") {\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(1, ai_max);\n        }\n    } else if(ai_type == \"constant\") {\n        int val = rnd.next(1, ai_max);\n        for(int i = 1; i <= n; i++) {\n            a[i] = val;\n        }\n    } else if(ai_type == \"increasing\") {\n        for(int i = 1; i <= n; i++) {\n            a[i] = i;\n        }\n        // Scale to ai_max if necessary\n        if(n > ai_max) {\n            int factor = n / ai_max;\n            for(int i = 1; i <= n; i++) {\n                a[i] = (a[i]-1)/factor + 1;\n            }\n        }\n    } else if(ai_type == \"decreasing\") {\n        for(int i = 1; i <= n; i++) {\n            a[i] = n - i + 1;\n        }\n        if(n > ai_max) {\n            int factor = n / ai_max;\n            for(int i = 1; i <= n; i++) {\n                a[i] = (a[i]-1)/factor +1;\n            }\n        }\n    }\n    else if(ai_type == \"maxfirst\") {\n        // Assign maximum ai values to nodes\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(1, ai_max/2);\n        }\n        vector<int> indices(n);\n        for(int i = 1; i <= n; i++) indices[i-1]=i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < min(n, 100); i++) {\n            a[indices[i]] = ai_max - rnd.next(0, i);\n        }\n    }\n    else if(ai_type == \"minfirst\") {\n        // Assign minimum ai values to nodes\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(ai_max/2, ai_max);\n        }\n        vector<int> indices(n);\n        for(int i = 1; i <= n; i++) indices[i-1]=i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i< min(n,100); i++) {\n            a[indices[i]] = rnd.next(1, 10);\n        }\n    }\n    else {\n        // Default to random ai\n        for(int i = 1; i <= n; i++) {\n            a[i] = rnd.next(1, ai_max);\n        }\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    int ai_max = opt<int>(\"ai_max\", 1000000);\n    \n    // Check constraints\n    ensure(2 <= n && n <= 200000);\n    ensure(1 <= k && k <= n);\n    ensure(1 <= ai_max && ai_max <= 1000000);\n\n    vector<pair<int,int>> edges;\n    if(tree_type == \"random\") {\n        edges = generate_random_tree(n);\n    } else if(tree_type == \"chain\") {\n        edges = generate_chain_tree(n);\n    } else if(tree_type == \"star\") {\n        edges = generate_star_tree(n);\n    } else if(tree_type == \"balanced\") {\n        edges = generate_balanced_tree(n);\n    } else {\n        // Default to random tree\n        edges = generate_random_tree(n);\n    }\n\n    // Generate ai values according to ai_type\n    vector<int> a = generate_ai(n, ai_type, ai_max);\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output ai values\n    for(int i = 1; i <= n; i++) {\n        printf(\"%d\", a[i]);\n        if(i < n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Output edges\n    for(auto &e: edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random tree\n./gen -n 5 -k 3 -tree_type random -ai_type random\n\n# Small chain tree\n./gen -n 5 -k 3 -tree_type chain -ai_type random\n\n# Small star tree\n./gen -n 5 -k 3 -tree_type star -ai_type random\n\n# Small balanced tree\n./gen -n 7 -k 4 -tree_type balanced -ai_type random\n\n# All ai are equal\n./gen -n 1000 -k 500 -tree_type random -ai_type constant\n\n# Increasing ai\n./gen -n 1000 -k 500 -tree_type chain -ai_type increasing\n\n# Decreasing ai\n./gen -n 1000 -k 500 -tree_type chain -ai_type decreasing\n\n# Maxfirst ai\n./gen -n 1000 -k 500 -tree_type random -ai_type maxfirst\n\n# Minfirst ai\n./gen -n 1000 -k 500 -tree_type random -ai_type minfirst\n\n# Large n, random tree\n./gen -n 200000 -k 200000 -tree_type random -ai_type random\n\n# Large n, chain tree\n./gen -n 200000 -k 1 -tree_type chain -ai_type random\n\n# Large n, star tree\n./gen -n 200000 -k 100000 -tree_type star -ai_type random\n\n# k = 1, random tree\n./gen -n 50000 -k 1 -tree_type random -ai_type random\n\n# k = n, random tree\n./gen -n 50000 -k 50000 -tree_type random -ai_type random\n\n# All ai = 1\n./gen -n 200000 -k 100000 -tree_type random -ai_type constant -ai_max 1\n\n# Maximum ai_max\n./gen -n 200000 -k 200000 -tree_type random -ai_type random -ai_max 1000000\n\n# Tree with ai increasing from root\n./gen -n 10000 -k 10000 -tree_type balanced -ai_type increasing\n\n# Tree with ai decreasing from root\n./gen -n 10000 -k 10000 -tree_type balanced -ai_type decreasing\n\n# Random tree with ai_maxfirst\n./gen -n 100000 -k 50000 -tree_type random -ai_type maxfirst\n\n# Chain tree with ai_maxfirst\n./gen -n 100000 -k 50000 -tree_type chain -ai_type maxfirst\n\n# Chain tree with ai_minfirst\n./gen -n 100000 -k 50000 -tree_type chain -ai_type minfirst\n\n# Random tree with ai_minfirst\n./gen -n 100000 -k 50000 -tree_type random -ai_type minfirst\n\n# Random tree with ai_minfirst, k = n\n./gen -n 100000 -k 100000 -tree_type random -ai_type minfirst\n\n# Random tree with ai_maxfirst, k = 1\n./gen -n 100000 -k 1 -tree_type random -ai_type maxfirst\n\n# Balanced tree with ai_maxfirst\n./gen -n 100000 -k 50000 -tree_type balanced -ai_type maxfirst\n\n# Balanced tree with ai_minfirst\n./gen -n 100000 -k 50000 -tree_type balanced -ai_type minfirst\n\n# Random tree with ai_maxfirst, ai_max = 1e6\n./gen -n 200000 -k 100000 -tree_type random -ai_type maxfirst -ai_max 1000000\n\n# Test n = 2\n./gen -n 2 -k 1 -tree_type random -ai_type random\n\n# Test n = 2, k = 2\n./gen -n 2 -k 2 -tree_type random -ai_type random\n\n# Test n = 200000, k = 1\n./gen -n 200000 -k 1 -tree_type random -ai_type random\n\n# Test maximum ai_max with decreasing ai\n./gen -n 200000 -k 200000 -tree_type random -ai_type decreasing -ai_max 1000000\n\n# Test chain tree with maximum ai_max\n./gen -n 200000 -k 200000 -tree_type chain -ai_type random -ai_max 1000000\n\n# Random tree with ai_type constant and high ai_max\n./gen -n 200000 -k 150000 -tree_type random -ai_type constant -ai_max 999999\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:39.387772",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "627/E",
      "title": "E. Orchestra",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains four space-separated integers r, c, n, k (1 ≤ r, c, n ≤ 3000, 1 ≤ k ≤ min(n, 10)) — the number of rows and columns of the string section, the total number of violas, and the minimum number of violas Paul would like in his photograph, respectively.The next n lines each contain two integers xi and yi (1 ≤ xi ≤ r, 1 ≤ yi ≤ c): the position of the i-th viola. It is guaranteed that no location appears more than once in the input.",
      "output_spec": "OutputPrint a single integer — the number of photographs Paul can take which include at least k violas.",
      "sample_tests": "ExamplesInputCopy2 2 1 11 2OutputCopy4InputCopy3 2 3 31 13 12 2OutputCopy1InputCopy3 2 3 21 13 12 2OutputCopy4",
      "description": "E. Orchestra\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains four space-separated integers r, c, n, k (1 ≤ r, c, n ≤ 3000, 1 ≤ k ≤ min(n, 10)) — the number of rows and columns of the string section, the total number of violas, and the minimum number of violas Paul would like in his photograph, respectively.The next n lines each contain two integers xi and yi (1 ≤ xi ≤ r, 1 ≤ yi ≤ c): the position of the i-th viola. It is guaranteed that no location appears more than once in the input.\n\nOutputPrint a single integer — the number of photographs Paul can take which include at least k violas.\n\nInputCopy2 2 1 11 2OutputCopy4InputCopy3 2 3 31 13 12 2OutputCopy1InputCopy3 2 3 21 13 12 2OutputCopy4\n\nInputCopy2 2 1 11 2\n\nOutputCopy4\n\nInputCopy3 2 3 31 13 12 2\n\nOutputCopy1\n\nInputCopy3 2 3 21 13 12 2\n\nOutputCopy4\n\nNoteWe will use '*' to denote violinists and '#' to denote violists.In the first sample, the orchestra looks as follows: *#** Paul can take a photograph of just the viola, the 1 × 2 column containing the viola, the 2 × 1 row containing the viola, or the entire string section, for 4 pictures total.In the second sample, the orchestra looks as follows: #**##* Paul must take a photograph of the entire section.In the third sample, the orchestra looks the same as in the second sample.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces",
          "content": "Hello everyone!The final round of the 8VC Venture Cup will be held on Feb/28/2016 18:10 (UTC). ecnerwala and I are the problem setters. We want to thank GlebsHP and vnovakovski for help in preparing the contest, stella_marine for fixing the statements, and MikeMirzayanov for creating the Codeforces platform.The contest is by invitation only to the top 200 contestants and top local contestants from Round 1 and contains six problems. We will also hold rated, out-of-contest participation for both div1 and div2 contestants — all three groups will feature slightly different problemsets. Local contestants will compete onsite in Silicon Valley. OpenGov, one of the featured 8 | VC companies, has been generous to host this competition at their offices; see more details about this awesome company below: OpenGov transforms the way the world analyzes and allocates public money. With more than 700 government customers across 45 states in a rapidly expanding network, OpenGov is the market leader in cloud-based financial intelligence, budgeting, and transparency for government. The OpenGov platform transforms government financial data into intuitive, interactive visualizations for both internal government users and citizens.ABOUT 8 | PARTNERS8 | Partners, which consists of Joe Lonsdale (co-founder of Palantir) and his core team from Formation | 8, is a Silicon Valley venture capital firm that invests in industry-transforming technology companies. The team's investment portfolio includes companies such as those featured below, and a host of other top technology platforms that leverage modern algorithms and data science to power their core business processes. If you are interested to connect, please take a look at http://www.codeforces.com/8vc/apply.PRIZES Overall 1st place — $2500 Overall 2nd place — $1000 Overall 3rd-5th places — $500 each Overall 1-50th place — t-shirts with 8 | VC and company logos Local Winner — Dinner with Joe Lonsdale (founder of Palantir, Addepar, & 8 | Partners) and other Silicon Valley technologists Local top finishers — Opportunity to meet with leadership from 8 | VC portfolio companies The scoring distribution will be standard for all three divisions: 500 — 1000 — 1500 — 2000 — 2500 — 3000Good luck!UPD: Due to onsite awards presentation, we will hold final system testing until around one hour after the end of the contest.Congratulations to the top overall contestants: tourist Egor ikatanic enot110 DemiGuo As well as the top onsite contestants: winger waterfalls KADR Editorial can be found here.Thanks for participating!",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/43421",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2576
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round Editorial - Codeforces",
          "content": "635A - OrchestraWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.Runtime: O(n6)634A - Island PuzzleNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.Runtime: O(n)627A - XOR EquationFor any two integers a and b, we have , where is the xor and a&b is the bitwise AND. This is because is non-carrying binary addition. Thus, we can find a&b = (s - x) / 2 (if this is not an integer, there are no solutions).Now, for each bit, we have 4 cases: , and . If , then ai = bi, so we have one possibility: ai = bi = ai&bi. If , then we must have ai&bi = 0 (otherwise we print 0), and we have two choices: ai = 1 and bi = 0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a = 0 or b = 0 if necessary.)Runtime: 627B - Factory RepairsUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.Runtime: .627C - Package DeliveryWe solve this with a greedy algorithm: for each gas station, we fill our tank to min(n, d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.Alternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).Runtime: 627D - Preorder TestWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.Runtime: 627E - OrchestraWe can think of a rectangle in the grid as a pair of an (xlo, xhi) interval and a (ylo, yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m + 1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.As we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi = r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.Runtime: O(r2k + rnk)627F - Island PuzzleFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.Thus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).Now, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.To compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.Runtime: O(n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43467",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 627\\s*E"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 1",
          "code": "(2 ^ i - 1) (2 ^ i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 2",
          "code": "65535 65535",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 3",
          "code": "f(i, carry)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 4",
          "code": "(0 , i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 5",
          "code": "f(i + 1, 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 6",
          "code": "f(i + 1, 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 7",
          "code": "update(1, 0, n - 1, d - 1, get(1, 0, n - 1, d - 1, d - 1) + min(a, q));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 8",
          "code": "update(1, 0, n - 1, d - 1, min(TTT[d - 1], a * 1LL));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 3000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 3000, \"c\");\n    inf.readSpace();\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 10), \"k\");\n    inf.readEoln();\n\n    set<pair<int,int>> positions;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, r, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, c, \"yi\");\n        inf.readEoln();\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(positions.count(pos) == 0, \"Duplicate position (%d, %d)\", xi, yi);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 3000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 3000, \"c\");\n    inf.readSpace();\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 10), \"k\");\n    inf.readEoln();\n\n    set<pair<int,int>> positions;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, r, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, c, \"yi\");\n        inf.readEoln();\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(positions.count(pos) == 0, \"Duplicate position (%d, %d)\", xi, yi);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int r = inf.readInt(1, 3000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 3000, \"c\");\n    inf.readSpace();\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 10), \"k\");\n    inf.readEoln();\n\n    set<pair<int,int>> positions;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, r, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, c, \"yi\");\n        inf.readEoln();\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(positions.count(pos) == 0, \"Duplicate position (%d, %d)\", xi, yi);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure n does not exceed r * c or 3000\n    n = min(n, r * c);\n    n = min(n, 3000);\n\n    // Ensure k is at most min(n, 10)\n    k = min(k, min(n, 10));\n\n    vector<pair<int,int>> violists;\n    \n    if (type == \"random\") {\n        // Place n violists in random unique positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    } else if (type == \"cluster\") {\n        // Place violists in a cluster\n        int maxClusterSizeR = min(r, max(1, (int)sqrt(n)) + 10);\n        int maxClusterSizeC = min(c, max(1, (int)sqrt(n)) + 10);\n        int clusterR = min(r, rnd.next(1, maxClusterSizeR));\n        int clusterC = min(c, rnd.next(1, maxClusterSizeC));\n        int startX = rnd.next(1, r - clusterR +1);\n        int startY = rnd.next(1, c - clusterC +1);\n        \n        vector<pair<int,int>> positions;\n        for (int i = startX; i < startX + clusterR && (int)positions.size() < n; ++i) {\n            for (int j = startY; j < startY + clusterC && (int)positions.size() < n; ++j) {\n                positions.emplace_back(i, j);\n            }\n        }\n        // If not enough violists, fill randomly\n        set<pair<int,int>> unique_positions(positions.begin(), positions.end());\n        while ((int)unique_positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            unique_positions.emplace(x, y);\n        }\n        violists.assign(unique_positions.begin(), unique_positions.end());\n    } else if (type == \"line_row\") {\n        // Violists in a single row\n        int row = rnd.next(1, r);\n        set<int> columns;\n        while ((int)columns.size() < n) {\n            int y = rnd.next(1, c);\n            columns.insert(y);\n        }\n        for (int y : columns) {\n            violists.push_back({row, y});\n        }\n    } else if (type == \"line_column\") {\n        // Violists in a single column\n        int col = rnd.next(1, c);\n        set<int> rows;\n        while ((int)rows.size() < n) {\n            int x = rnd.next(1, r);\n            rows.insert(x);\n        }\n        for (int x : rows) {\n            violists.push_back({x, col});\n        }\n    } else if (type == \"chessboard\") {\n        // Violists placed on the cells with (x+y)%2 == 0\n        for (int x = 1; x <= r && (int)violists.size() < n; ++x) {\n            for (int y = 1; y <= c && (int)violists.size() < n; ++y) {\n                if ((x + y) % 2 == 0) {\n                    violists.emplace_back(x, y);\n                }\n            }\n        }\n        // If not enough violists, add random positions\n        set<pair<int,int>> positions(violists.begin(), violists.end());\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    } else if (type == \"full\") {\n        // Violists occupy the whole grid\n        for (int x = 1; x <= r; ++x) {\n            for (int y = 1; y <= c; ++y) {\n                violists.emplace_back(x, y);\n            }\n        }\n        // Shuffle if n < total cells\n        if ((int)violists.size() > n) {\n            shuffle(violists.begin(), violists.end());\n            violists.resize(n);\n        }\n    } else if (type == \"single\") {\n        // Only one violist\n        int x = rnd.next(1, r);\n        int y = rnd.next(1, c);\n        violists.push_back({x, y});\n    } else if (type == \"corners\") {\n        // Violists in the corners\n        vector<pair<int,int>> corners = {{1,1}, {1,c}, {r,1}, {r,c}};\n        for (int i = 0; i < n && i < 4; ++i) {\n            violists.push_back(corners[i]);\n        }\n        // If n > 4, fill randomly\n        set<pair<int,int>> positions(violists.begin(), violists.end());\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    } else {\n        // Default to random if unknown type\n        // Place n violists in random unique positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    }\n    \n    // Output r, c, n, k\n    printf(\"%d %d %d %d\\n\", r, c, n, k);\n    // Output violists' positions\n    for (auto& p : violists) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure n does not exceed r * c or 3000\n    n = min(n, r * c);\n    n = min(n, 3000);\n\n    // Ensure k is at most min(n, 10)\n    k = min(k, min(n, 10));\n\n    vector<pair<int,int>> violists;\n    \n    if (type == \"random\") {\n        // Place n violists in random unique positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    } else if (type == \"cluster\") {\n        // Place violists in a cluster\n        int maxClusterSizeR = min(r, max(1, (int)sqrt(n)) + 10);\n        int maxClusterSizeC = min(c, max(1, (int)sqrt(n)) + 10);\n        int clusterR = min(r, rnd.next(1, maxClusterSizeR));\n        int clusterC = min(c, rnd.next(1, maxClusterSizeC));\n        int startX = rnd.next(1, r - clusterR +1);\n        int startY = rnd.next(1, c - clusterC +1);\n        \n        vector<pair<int,int>> positions;\n        for (int i = startX; i < startX + clusterR && (int)positions.size() < n; ++i) {\n            for (int j = startY; j < startY + clusterC && (int)positions.size() < n; ++j) {\n                positions.emplace_back(i, j);\n            }\n        }\n        // If not enough violists, fill randomly\n        set<pair<int,int>> unique_positions(positions.begin(), positions.end());\n        while ((int)unique_positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            unique_positions.emplace(x, y);\n        }\n        violists.assign(unique_positions.begin(), unique_positions.end());\n    } else if (type == \"line_row\") {\n        // Violists in a single row\n        int row = rnd.next(1, r);\n        set<int> columns;\n        while ((int)columns.size() < n) {\n            int y = rnd.next(1, c);\n            columns.insert(y);\n        }\n        for (int y : columns) {\n            violists.push_back({row, y});\n        }\n    } else if (type == \"line_column\") {\n        // Violists in a single column\n        int col = rnd.next(1, c);\n        set<int> rows;\n        while ((int)rows.size() < n) {\n            int x = rnd.next(1, r);\n            rows.insert(x);\n        }\n        for (int x : rows) {\n            violists.push_back({x, col});\n        }\n    } else if (type == \"chessboard\") {\n        // Violists placed on the cells with (x+y)%2 == 0\n        for (int x = 1; x <= r && (int)violists.size() < n; ++x) {\n            for (int y = 1; y <= c && (int)violists.size() < n; ++y) {\n                if ((x + y) % 2 == 0) {\n                    violists.emplace_back(x, y);\n                }\n            }\n        }\n        // If not enough violists, add random positions\n        set<pair<int,int>> positions(violists.begin(), violists.end());\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    } else if (type == \"full\") {\n        // Violists occupy the whole grid\n        for (int x = 1; x <= r; ++x) {\n            for (int y = 1; y <= c; ++y) {\n                violists.emplace_back(x, y);\n            }\n        }\n        // Shuffle if n < total cells\n        if ((int)violists.size() > n) {\n            shuffle(violists.begin(), violists.end());\n            violists.resize(n);\n        }\n    } else if (type == \"single\") {\n        // Only one violist\n        int x = rnd.next(1, r);\n        int y = rnd.next(1, c);\n        violists.push_back({x, y});\n    } else if (type == \"corners\") {\n        // Violists in the corners\n        vector<pair<int,int>> corners = {{1,1}, {1,c}, {r,1}, {r,c}};\n        for (int i = 0; i < n && i < 4; ++i) {\n            violists.push_back(corners[i]);\n        }\n        // If n > 4, fill randomly\n        set<pair<int,int>> positions(violists.begin(), violists.end());\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    } else {\n        // Default to random if unknown type\n        // Place n violists in random unique positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, r);\n            int y = rnd.next(1, c);\n            positions.emplace(x, y);\n        }\n        violists.assign(positions.begin(), positions.end());\n    }\n    \n    // Output r, c, n, k\n    printf(\"%d %d %d %d\\n\", r, c, n, k);\n    // Output violists' positions\n    for (auto& p : violists) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Sample test cases from the problem\n\n./gen -r 2 -c 2 -n 1 -k 1 -type single\n# Corresponds to the first sample input\n\n./gen -r 3 -c 2 -n 3 -k 3 -type line_column\n# Corresponds to the second sample input\n\n./gen -r 3 -c 2 -n 3 -k 2 -type line_column\n# Corresponds to the third sample input\n\n# Small test cases\n\n./gen -r 5 -c 5 -n 5 -k 1 -type random\n\n./gen -r 5 -c 5 -n 10 -k 2 -type cluster\n\n./gen -r 5 -c 5 -n 5 -k 5 -type line_row\n\n# Violists in a single row\n\n./gen -r 100 -c 100 -n 100 -k 10 -type line_row\n\n# Violists in a single column\n\n./gen -r 100 -c 100 -n 100 -k 10 -type line_column\n\n# Maximal grid size with random violists\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type random\n\n# Grid fully occupied by violists\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type full\n\n# Maximum n with k = 1\n\n./gen -r 3000 -c 3000 -n 3000 -k 1 -type random\n\n# All violists in a corner cluster\n\n./gen -r 3000 -c 3000 -n 10 -k 10 -type cluster\n\n# Minimal grid size\n\n./gen -r 1 -c 1 -n 1 -k 1 -type single\n\n# Non-square grid with violists in a row\n\n./gen -r 1 -c 3000 -n 3000 -k 10 -type line_row\n\n# Non-square grid with violists in a column\n\n./gen -r 3000 -c 1 -n 3000 -k 10 -type line_column\n\n# Chessboard pattern of violists\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type chessboard\n\n# k equals n\n\n./gen -r 3000 -c 3000 -n 10 -k 10 -type random\n\n# Violists spread out randomly\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type random\n\n# Single violist with maximum grid size\n\n./gen -r 3000 -c 3000 -n 1 -k 1 -type single\n\n# All violists in the same row in a large grid\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type line_row\n\n# All violists in the same column in a large grid\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type line_column\n\n# Extreme case: Max r, min c\n\n./gen -r 3000 -c 1 -n 1 -k 1 -type line_column\n\n# Extreme case: Min r, Max c\n\n./gen -r 1 -c 3000 -n 1 -k 1 -type line_row\n\n# Violists in the corners of the grid\n\n./gen -r 3000 -c 3000 -n 4 -k 4 -type corners\n\n# Grid fully occupied with k = 10\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type full\n\n# Violists in a cluster in a small grid\n\n./gen -r 10 -c 10 -n 10 -k 5 -type cluster\n\n# Violists forming a diagonal line\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type diagonal\n\n# Nonexistent \"diagonal\" type will default to random\n\n# Minimal k and maximal n\n\n./gen -r 3000 -c 3000 -n 3000 -k 1 -type random\n\n# Violists occupying every other cell\n\n./gen -r 3000 -c 3000 -n 4500000 -k 10 -type chessboard\n\n# Testing k equal to 10 when n is small\n\n./gen -r 20 -c 20 -n 10 -k 10 -type random\n\n# Testing n exceeding grid size (n adjusted in generator)\n\n./gen -r 100 -c 100 -n 10000 -k 10 -type random\n\n# Violists randomly distributed in a large grid\n\n./gen -r 3000 -c 3000 -n 3000 -k 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:41.675802",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "627/F",
      "title": "F. Island Puzzle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 200 000) — the total number of islands.The second line contains n space-separated integers ai (0 ≤ ai ≤ n - 1) — the statue currently located on the i-th island. If ai = 0, then the island has no statue. It is guaranteed that the ai are distinct.The third line contains n space-separated integers bi (0 ≤ bi ≤ n - 1) — the desired statues of the i-th island. Once again, bi = 0 indicates the island desires no statue. It is guaranteed that the bi are distinct.The next n - 1 lines each contain two distinct space-separated integers ui and vi (1 ≤ ui, vi ≤ n) — the endpoints of the i-th bridge. Bridges form a tree, and it is guaranteed that no bridge is listed twice in the input.",
      "output_spec": "OutputPrint a single line of integers:If the rearrangement can be done in the existing network, output 0 t, where t is the number of moves necessary to perform the rearrangement.Otherwise, print u, v, and t (1 ≤ u < v ≤ n) — the two endpoints of the new bridge, and the minimum number of statue movements needed to perform the rearrangement.If the rearrangement cannot be done no matter how the new bridge is built, print a single line containing  - 1.",
      "sample_tests": "ExamplesInputCopy31 0 22 0 11 22 3OutputCopy1 3 3InputCopy21 00 11 2OutputCopy0 1InputCopy40 1 2 30 2 3 11 21 31 4OutputCopy-1",
      "description": "F. Island Puzzle\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 200 000) — the total number of islands.The second line contains n space-separated integers ai (0 ≤ ai ≤ n - 1) — the statue currently located on the i-th island. If ai = 0, then the island has no statue. It is guaranteed that the ai are distinct.The third line contains n space-separated integers bi (0 ≤ bi ≤ n - 1) — the desired statues of the i-th island. Once again, bi = 0 indicates the island desires no statue. It is guaranteed that the bi are distinct.The next n - 1 lines each contain two distinct space-separated integers ui and vi (1 ≤ ui, vi ≤ n) — the endpoints of the i-th bridge. Bridges form a tree, and it is guaranteed that no bridge is listed twice in the input.\n\nOutputPrint a single line of integers:If the rearrangement can be done in the existing network, output 0 t, where t is the number of moves necessary to perform the rearrangement.Otherwise, print u, v, and t (1 ≤ u < v ≤ n) — the two endpoints of the new bridge, and the minimum number of statue movements needed to perform the rearrangement.If the rearrangement cannot be done no matter how the new bridge is built, print a single line containing  - 1.\n\nInputCopy31 0 22 0 11 22 3OutputCopy1 3 3InputCopy21 00 11 2OutputCopy0 1InputCopy40 1 2 30 2 3 11 21 31 4OutputCopy-1\n\nInputCopy31 0 22 0 11 22 3\n\nOutputCopy1 3 3\n\nInputCopy21 00 11 2\n\nOutputCopy0 1\n\nInputCopy40 1 2 30 2 3 11 21 31 4\n\nOutputCopy-1\n\nNoteIn the first sample, the islanders can build a bridge connecting islands 1 and 3 and then make the following sequence of moves: first move statue 1 from island 1 to island 2, then move statue 2 from island 3 to island 1, and finally move statue 1 from island 2 to island 3 for a total of 3 moves.In the second sample, the islanders can simply move statue 1 from island 1 to island 2. No new bridges need to be built and only 1 move needs to be made.In the third sample, no added bridge and subsequent movements result in the desired position.",
      "solutions": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces",
          "content": "Hello everyone!The final round of the 8VC Venture Cup will be held on Feb/28/2016 18:10 (UTC). ecnerwala and I are the problem setters. We want to thank GlebsHP and vnovakovski for help in preparing the contest, stella_marine for fixing the statements, and MikeMirzayanov for creating the Codeforces platform.The contest is by invitation only to the top 200 contestants and top local contestants from Round 1 and contains six problems. We will also hold rated, out-of-contest participation for both div1 and div2 contestants — all three groups will feature slightly different problemsets. Local contestants will compete onsite in Silicon Valley. OpenGov, one of the featured 8 | VC companies, has been generous to host this competition at their offices; see more details about this awesome company below: OpenGov transforms the way the world analyzes and allocates public money. With more than 700 government customers across 45 states in a rapidly expanding network, OpenGov is the market leader in cloud-based financial intelligence, budgeting, and transparency for government. The OpenGov platform transforms government financial data into intuitive, interactive visualizations for both internal government users and citizens.ABOUT 8 | PARTNERS8 | Partners, which consists of Joe Lonsdale (co-founder of Palantir) and his core team from Formation | 8, is a Silicon Valley venture capital firm that invests in industry-transforming technology companies. The team's investment portfolio includes companies such as those featured below, and a host of other top technology platforms that leverage modern algorithms and data science to power their core business processes. If you are interested to connect, please take a look at http://www.codeforces.com/8vc/apply.PRIZES Overall 1st place — $2500 Overall 2nd place — $1000 Overall 3rd-5th places — $500 each Overall 1-50th place — t-shirts with 8 | VC and company logos Local Winner — Dinner with Joe Lonsdale (founder of Palantir, Addepar, & 8 | Partners) and other Silicon Valley technologists Local top finishers — Opportunity to meet with leadership from 8 | VC portfolio companies The scoring distribution will be standard for all three divisions: 500 — 1000 — 1500 — 2000 — 2500 — 3000Good luck!UPD: Due to onsite awards presentation, we will hold final system testing until around one hour after the end of the contest.Congratulations to the top overall contestants: tourist Egor ikatanic enot110 DemiGuo As well as the top onsite contestants: winger waterfalls KADR Editorial can be found here.Thanks for participating!",
          "author": "scott_wu",
          "url": "https://codeforces.com/blog/entry/43421",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2576
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round Editorial - Codeforces",
          "content": "635A - OrchestraWe can iterate over each possible rectangle and count the number of violists enclosed. This can be optimized with rectangular prefix sums, though the simple brute force is sufficient for this problem.Runtime: O(n6)634A - Island PuzzleNotice that, as we move the empty pedestal around the circle, we cyclically permute the statues (and the empty pedestal can be anywhere). Thus, we can reach one state from another if and only if, after removing the empty pedestal, they are cyclic shifts of each other. The starting and ending configurations are permutations, so we can check this in linear time.Runtime: O(n)627A - XOR EquationFor any two integers a and b, we have , where is the xor and a&b is the bitwise AND. This is because is non-carrying binary addition. Thus, we can find a&b = (s - x) / 2 (if this is not an integer, there are no solutions).Now, for each bit, we have 4 cases: , and . If , then ai = bi, so we have one possibility: ai = bi = ai&bi. If , then we must have ai&bi = 0 (otherwise we print 0), and we have two choices: ai = 1 and bi = 0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a = 0 or b = 0 if necessary.)Runtime: 627B - Factory RepairsUsing two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.Runtime: .627C - Package DeliveryWe solve this with a greedy algorithm: for each gas station, we fill our tank to min(n, d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.Alternatively, if we say that we always “use” the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).Runtime: 627D - Preorder TestWe binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.Runtime: 627E - OrchestraWe can think of a rectangle in the grid as a pair of an (xlo, xhi) interval and a (ylo, yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m + 1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.As we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi = r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.Runtime: O(r2k + rnk)627F - Island PuzzleFirst, if we never move the empty pedestal through any cycle, then moving the empty pedestal to and from any given position cannot change the location of the statues, as performing a move in the opposite direction as the previous undoes the previous move.Thus, in our graph with one cycle, we can only do the following two operations: move the empty pedestal from one location to another (without loss of generality, only using the original tree), and cyclically permute the elements along the one cycle (except the element closest to the root).Now, to check satisfiability, we can greedily first move the empty pedestal from its start position to its end position -- since this procedure can be undone, it will never change the satisfiability of the rearrangement. Then, we only have to check that all changed elements lie on a possible cycle. This uniquely determines the edge to be added.To compute the minimum number of moves, we compute the minimum moves to move the empty pedestal from the start to the cycle, the minimum moves to permute the cycle as desired, and the minimum moves from the cycle to the end point.Runtime: O(n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43467",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 627\\s*F"
          },
          "content_length": 5281
        }
      ],
      "code_examples": [
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 1",
          "code": "(2 ^ i - 1) (2 ^ i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 2",
          "code": "65535 65535",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 3",
          "code": "f(i, carry)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 4",
          "code": "(0 , i - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 5",
          "code": "f(i + 1, 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 6",
          "code": "f(i + 1, 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 7",
          "code": "update(1, 0, n - 1, d - 1, get(1, 0, n - 1, d - 1, d - 1) + min(a, q));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        },
        {
          "title": "8VC Venture Cup 2016 — Final Round - Codeforces - Code 8",
          "code": "update(1, 0, n - 1, d - 1, min(TTT[d - 1], a * 1LL));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43421",
          "author": "scott_wu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n    set<int> set_a(a.begin(), a.end());\n    ensuref(int(set_a.size()) == n, \"All elements of a_i must be distinct\");\n\n    vector<int> b = inf.readInts(n, 0, n - 1, \"b_i\");\n    inf.readEoln();\n    set<int> set_b(b.begin(), b.end());\n    ensuref(int(set_b.size()) == n, \"All elements of b_i must be distinct\");\n\n    set<pair<int, int>> edge_set;\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> findParent = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = findParent(parent[u]);\n        return parent[u];\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u_i and v_i must be different\", i + 1);\n\n        // Check for duplicate edges\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edge_set.count(edge) == 0, \"Edge between %d and %d is duplicated\", a, b);\n        edge_set.insert(edge);\n\n        // Union-Find to check for cycles\n        int pu = findParent(u);\n        int pv = findParent(v);\n        ensuref(pu != pv, \"Edge %d introduces a cycle in the graph\", i + 1);\n        parent[pu] = pv;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n    set<int> set_a(a.begin(), a.end());\n    ensuref(int(set_a.size()) == n, \"All elements of a_i must be distinct\");\n\n    vector<int> b = inf.readInts(n, 0, n - 1, \"b_i\");\n    inf.readEoln();\n    set<int> set_b(b.begin(), b.end());\n    ensuref(int(set_b.size()) == n, \"All elements of b_i must be distinct\");\n\n    set<pair<int, int>> edge_set;\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> findParent = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = findParent(parent[u]);\n        return parent[u];\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u_i and v_i must be different\", i + 1);\n\n        // Check for duplicate edges\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edge_set.count(edge) == 0, \"Edge between %d and %d is duplicated\", a, b);\n        edge_set.insert(edge);\n\n        // Union-Find to check for cycles\n        int pu = findParent(u);\n        int pv = findParent(v);\n        ensuref(pu != pv, \"Edge %d introduces a cycle in the graph\", i + 1);\n        parent[pu] = pv;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n    set<int> set_a(a.begin(), a.end());\n    ensuref(int(set_a.size()) == n, \"All elements of a_i must be distinct\");\n\n    vector<int> b = inf.readInts(n, 0, n - 1, \"b_i\");\n    inf.readEoln();\n    set<int> set_b(b.begin(), b.end());\n    ensuref(int(set_b.size()) == n, \"All elements of b_i must be distinct\");\n\n    set<pair<int, int>> edge_set;\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> findParent = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = findParent(parent[u]);\n        return parent[u];\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u_i and v_i must be different\", i + 1);\n\n        // Check for duplicate edges\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edge_set.count(edge) == 0, \"Edge between %d and %d is duplicated\", a, b);\n        edge_set.insert(edge);\n\n        // Union-Find to check for cycles\n        int pu = findParent(u);\n        int pv = findParent(v);\n        ensuref(pu != pv, \"Edge %d introduces a cycle in the graph\", i + 1);\n        parent[pu] = pv;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string aiType = opt<string>(\"aiType\", \"random\");\n    string biType = opt<string>(\"biType\", \"random\");\n\n    // Generate the tree\n    vector<pair<int, int>> edges;\n\n    if (treeType == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.emplace_back(i - 1, i);\n        }\n    } else if (treeType == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.emplace_back(1, i);\n        }\n    } else {\n        // Random tree\n        vector<int> p(n + 1); // p[1..n]\n        p[1] = 0; // Root node\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n            edges.emplace_back(p[i], i);\n        }\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Generate ai\n    vector<int> ai(n);\n    vector<int> statues(n - 1);\n    for (int i = 0; i < n - 1; ++i) statues[i] = i + 1; // Statues numbered from 1 to n - 1\n\n    if (aiType == \"ordered\") {\n        // Do nothing, statues are already ordered\n    } else if (aiType == \"reverse\") {\n        reverse(statues.begin(), statues.end());\n    } else if (aiType == \"random\") {\n        shuffle(statues.begin(), statues.end());\n    }\n    int zero_pos = rnd.next(0, n - 1); // Random position for zero\n    int idx = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == zero_pos) {\n            ai[i] = 0;\n        } else {\n            ai[i] = statues[idx++];\n        }\n    }\n\n    // Generate bi\n    vector<int> bi(n);\n    if (biType == \"same\") {\n        bi = ai;\n    } else {\n        statues = vector<int>(n - 1);\n        for (int i = 0; i < n - 1; ++i) statues[i] = i + 1; // Statues numbered from 1 to n - 1\n        if (biType == \"ordered\") {\n            // Do nothing\n        } else if (biType == \"reverse\") {\n            reverse(statues.begin(), statues.end());\n        } else if (biType == \"random\") {\n            shuffle(statues.begin(), statues.end());\n        }\n        zero_pos = rnd.next(0, n - 1); // Random position for zero\n        idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i == zero_pos) {\n                bi[i] = 0;\n            } else {\n                bi[i] = statues[idx++];\n            }\n        }\n    }\n\n    // Output ai[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output bi[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output edges\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string aiType = opt<string>(\"aiType\", \"random\");\n    string biType = opt<string>(\"biType\", \"random\");\n\n    // Generate the tree\n    vector<pair<int, int>> edges;\n\n    if (treeType == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.emplace_back(i - 1, i);\n        }\n    } else if (treeType == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.emplace_back(1, i);\n        }\n    } else {\n        // Random tree\n        vector<int> p(n + 1); // p[1..n]\n        p[1] = 0; // Root node\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n            edges.emplace_back(p[i], i);\n        }\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Generate ai\n    vector<int> ai(n);\n    vector<int> statues(n - 1);\n    for (int i = 0; i < n - 1; ++i) statues[i] = i + 1; // Statues numbered from 1 to n - 1\n\n    if (aiType == \"ordered\") {\n        // Do nothing, statues are already ordered\n    } else if (aiType == \"reverse\") {\n        reverse(statues.begin(), statues.end());\n    } else if (aiType == \"random\") {\n        shuffle(statues.begin(), statues.end());\n    }\n    int zero_pos = rnd.next(0, n - 1); // Random position for zero\n    int idx = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == zero_pos) {\n            ai[i] = 0;\n        } else {\n            ai[i] = statues[idx++];\n        }\n    }\n\n    // Generate bi\n    vector<int> bi(n);\n    if (biType == \"same\") {\n        bi = ai;\n    } else {\n        statues = vector<int>(n - 1);\n        for (int i = 0; i < n - 1; ++i) statues[i] = i + 1; // Statues numbered from 1 to n - 1\n        if (biType == \"ordered\") {\n            // Do nothing\n        } else if (biType == \"reverse\") {\n            reverse(statues.begin(), statues.end());\n        } else if (biType == \"random\") {\n            shuffle(statues.begin(), statues.end());\n        }\n        zero_pos = rnd.next(0, n - 1); // Random position for zero\n        idx = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i == zero_pos) {\n                bi[i] = 0;\n            } else {\n                bi[i] = statues[idx++];\n            }\n        }\n    }\n\n    // Output ai[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output bi[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output edges\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -treeType chain -aiType ordered -biType ordered\n./gen -n 2 -treeType chain -aiType ordered -biType reverse\n./gen -n 2 -treeType star -aiType ordered -biType ordered\n./gen -n 2 -treeType random -aiType random -biType random\n\n./gen -n 10 -treeType chain -aiType ordered -biType ordered\n./gen -n 10 -treeType chain -aiType ordered -biType reverse\n./gen -n 10 -treeType star -aiType random -biType random\n./gen -n 10 -treeType random -aiType random -biType random\n\n./gen -n 100 -treeType chain -aiType ordered -biType reverse\n./gen -n 100 -treeType star -aiType random -biType random\n./gen -n 100 -treeType random -aiType random -biType reverse\n\n./gen -n 1000 -treeType random -aiType random -biType random\n./gen -n 1000 -treeType chain -aiType ordered -biType reverse\n./gen -n 1000 -treeType star -aiType random -biType same\n\n./gen -n 10000 -treeType random -aiType random -biType random\n./gen -n 10000 -treeType chain -aiType random -biType reverse\n./gen -n 10000 -treeType star -aiType random -biType random\n\n./gen -n 200000 -treeType random -aiType random -biType random\n./gen -n 200000 -treeType chain -aiType reverse -biType ordered\n./gen -n 200000 -treeType star -aiType random -biType random\n\n./gen -n 2 -treeType chain -aiType random -biType same\n./gen -n 99999 -treeType random -aiType random -biType same\n./gen -n 200000 -treeType random -aiType random -biType same\n\n./gen -n 200000 -treeType chain -aiType random -biType random\n./gen -n 200000 -treeType chain -aiType reverse -biType reverse\n./gen -n 200000 -treeType chain -aiType ordered -biType ordered\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:43.369779",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "628/A",
      "title": "A. Tennis Tournament",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains three integers n, b, p (1 ≤ n, b, p ≤ 500) — the number of participants and the parameters described in the problem statement.",
      "output_spec": "OutputPrint two integers x and y — the number of bottles and towels need for the tournament.",
      "sample_tests": "ExamplesInputCopy5 2 3OutputCopy20 15InputCopy8 2 4OutputCopy35 32",
      "description": "A. Tennis Tournament\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains three integers n, b, p (1 ≤ n, b, p ≤ 500) — the number of participants and the parameters described in the problem statement.\n\nOutputPrint two integers x and y — the number of bottles and towels need for the tournament.\n\nInputCopy5 2 3OutputCopy20 15InputCopy8 2 4OutputCopy35 32\n\nInputCopy5 2 3\n\nOutputCopy20 15\n\nInputCopy8 2 4\n\nOutputCopy35 32\n\nNoteIn the first example will be three rounds:  in the first round will be two matches and for each match 5 bottles of water are needed (two for each of the participants and one for the judge),  in the second round will be only one match, so we need another 5 bottles of water,  in the third round will also be only one match, so we need another 5 bottles of water. So in total we need 20 bottles of water.In the second example no participant will move on to some round directly.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 8 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 8 will take place on 19 February 2016 at 18:00 MSK for the first and the second divisions. You can read about educational rounds here and here. I hope that the high density of contests on Codeforces will not startle you and you will participate in ER8.<The phrase about simple problems is added in the end>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.It seems that it is harder to invent interesting simple problems (like A and B) than difficult ones. So don't be afraid to suggest interesting simple or very simple tasks.</The phrase about simple problems is added in the end>This time (for the first time) the problemset was totally suggested by Codeforces users. The problem А suggested by user unprost. The problem B was taken form the problems sent by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. The problem D suggested by Kareem Mohamed Kareem_Mohamed (but I made it more difficult to make it more interesting for you :-)). The problem E sent Ali Ahmadi Kuzey. The problems C and F are suggested by Kamil Debowski Errichto.Thanks a lot to them and all others who are sending the problems or just ideas of the problems!This time the problems wasn't prepared only by me (Edvard Davtyan). Thanks a lot to Kamil Debowski Errichto who not only suggested the problems C and F, but also prepared them. Thanks to Maria Belova Delinur for checking the English statements. Also thanks a lot to Ali Ahmadi Kuzey who helped me with testing of some problems.A few words about the problems: A) Easy problem with the long statement; B) I hope you will not write hard solution; C) It's interesting; D) It's a little technical, but contains very useful technique; E) I like this problem; F) Very cool problem if you will not solve during the contest I recommend to solve it in practice.Good luck and have fun!UPD1: The first phase of the contest finished. Hacks started. The editorial is ready.By the reason that all the problems of Errichto are about a bears, below you can see the illustration for the problem C (it seems Limak is the leftmost):",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2481
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces",
          "content": "628A - Tennis TournamentThe problem was suggested by unprost.Here you can simply model the process. Or you can note that after each match some player drops out. In total n - 1 players will drop out. So the first answer is (n - 1) * (2b + 1). Obviously the second answer is np.С++ solution 1С++ solution 2Complexity: O(log2n), O(logn) or O(1) depends on the realization.628B - New SkateboardThis is one of the problems suggested by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.The key observation is that the number is divisible by 4 if and only if its last two digits forms a number divisible by 4. So to calculate the answer at first we should count the substrings of length one. Now let's consider pairs of consecutive digits. If they forms a two digit number that is divisible by 4 we should increase the answer by the index of the right one.C++ solutionComplexity: O(n).628C - Bear and String DistanceThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.There is no solution if the given required distance is too big. Let's think what is the maximum possible distance for the given string s. Or the more useful thing — how to construct a string s' to maximize the distance? We can treat each letter separately and replace it with the most distant letter. For example, we should replace 'c' with 'z', and we should replace 'y' with 'a'. To be more precise, for first 13 letters of the alphabet the most distant letter is 'z', and for other letters it is 'a'.Let's solve a problem now. We can iterate over letters and greedily change them. A word \"greedily\" means when changing a letter we don't care about the next letters. We generally want to choose distant letters, because we may not find a solution otherwise. For each letter si we change it into the most distant letter, unless the total distance would be too big. As we change letters, we should decrease the remaining required distance. So, for each letter si consider only letters not exceeding the remaining distance, and among them choose the most distant one. If you don't see how to implement it, refer to my C++ solution with comments.Other C++ solutionComplexity: O(n).628D - Magic NumbersKareem Mohamed Kareem_Mohamed suggested the simpler version of the problem.Denote the answer to the problem f(a, b). Note that f(a, b) = f(0, b) - f(0, a - 1) or what is the same f(a, b) = f(0, b) - f(0, a) + g(a), where g(a) equals to one if a is a magic number, otherwise g(a) equals to zero. Let's solve the problem for the segment [0, n].Here is described the standard technique for this kind of problems, sometimes it is called 'dynamic programming by digits'. It can be realized in a two ways. The first way is to iterate over the length of the common prefix with number n. Next digit should be less than corresponding digit in n and other digits can be arbitrary. Below is the description of the second approach.Let zijk be the number of magic prefixes of length i with remainder j modulo m. If k = 0 than the prefix should be less than the corresponding prefix in n and if k = 1 than the prefix should be equal to the prefix of n (it can not be greater). Let's do 'forward dynamic programming'. Let's iterate over digit in position i. We should check that if the position is even than p should be equal to d, otherwise it cannot be equal to d. Also we should check for k = 1 p should be not greater than corresponding digit in n. Now let's see what will be the next state. Of course i' = i + 1. By Horner scheme j' = (10j + p) mod m. Easy to see that . To update the next state we should increase it: zi'j'k' +  = zijk. Of course all calculations should be done modulo 109 + 7.C++ solutionComplexity: O(nm).628E - Zbazi in ZeydabadThe problem was suggested by Ali Ahmadi Kuzey.Let's precalculate the values zlij, zrij, zldij — the maximal number of letters 'z' to the left, to the right and to the left-down from the position (i, j). It's easy to do in O(nm) time. Let's fix some cell (i, j). Consider the value c = min(zlij, zldij). It's the maximum size of the square with upper right ceil in (i, j). But the number of z-patterns can be less than c. Consider some cell (x, y) diagonally down-left from (i, j) on the distance no more than c. The cells (i, j) and (x, y) forms z-pattern if y + zrxy > j.Let's maintain some data structure for each antidiagonal (it can be described by formula x + y) that can increment in a point and take the sum on a segment (Fenwick tree will be the best choice for that). Let's iterate over columns j from the right to the left and process the events: we have some cell (x, y) for which y + zrxy - 1 = j. In that case we should increment the position y in the tree number x + y by one. Now we should iterate over the cells (x, y) in the current column and add to the answer the value of the sum on the segment from j - c + 1 to j in the tree number i + j .С++ solutionComplexity: O(nmlogm).628F - Bear and Fair SetThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.At the beginning, to make things simpler, we should add a query (hint) with upTo = b, quantity = n, and then sort queries by upTo. Sorted queries (hints) divide interval [1, b] into q disjoint intervals. For each interval we know how many elements should be there.Let's build a graph and find a max flow there. The answer is \"YES\" only if the flow is n. The first group A contains 5 vertices, representing possible remainders. The second group B contains q vertices, representing intervals. Each vertex from A should be connected with the source by an edge with capacity n / 5. Each vertex from B should be connected with the sink by an edge with capacity equal to the size of the interval. Between each vertex x from A and y from B should be an edge with capacity equal to the number of numbers in the interval y, giving remainder x when divided by 5.You can also use see that it's similar to finding matching. In fact, we can use the Hall's marriage theorem. For each of 25 sets of vertices from A (sets of remainders) iterate over intervals and count how many numbers we can take from [1, b] with remainders from the fixed set of remainders.The implementation with the Hall's theorem: C++ solution.Complexity: O(2Cn). In our problem C = 5.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 628\\s*A"
          },
          "content_length": 6326
        }
      ],
      "code_examples": [
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 1",
          "code": "x = ...01111.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 2",
          "code": "...01111 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 3",
          "code": "...01110 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\"); inf.readSpace();\n    int b = inf.readInt(1, 500, \"b\"); inf.readSpace();\n    int p = inf.readInt(1, 500, \"p\"); inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\"); inf.readSpace();\n    int b = inf.readInt(1, 500, \"b\"); inf.readSpace();\n    int p = inf.readInt(1, 500, \"p\"); inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\"); inf.readSpace();\n    int b = inf.readInt(1, 500, \"b\"); inf.readSpace();\n    int p = inf.readInt(1, 500, \"p\"); inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    string type = opt<string>(\"type\", \"random\");\n    int n = opt<int>(\"n\", -1);\n    int b = opt<int>(\"b\", -1);\n    int p = opt<int>(\"p\", -1);\n\n    // Determine the value of n based on the type or use the provided n\n    if (n == -1) {\n        if (type == \"min_n\") {\n            n = 1;\n        } else if (type == \"max_n\") {\n            n = 500;\n        } else if (type == \"power_of_2\") {\n            int k = rnd.next(0, 8); // 2^0 to 2^8 (1 to 256)\n            n = 1 << k;\n            n = min(n, 500); // Ensure n ≤ 500\n        } else if (type == \"over_power_of_2\") {\n            int k = rnd.next(0, 8);\n            n = (1 << k) + 1;\n            n = min(n, 500);\n        } else if (type == \"under_power_of_2\") {\n            int k = rnd.next(1, 9); // From 2^1 - 1 to 2^9 - 1\n            n = (1 << k) - 1;\n            n = min(n, 500);\n        } else { // Random n\n            n = rnd.next(1, 500);\n        }\n    } else {\n        n = max(1, min(n, 500)); // Ensure n is within [1, 500]\n    }\n\n    // Determine b and p or use the provided values\n    if (b == -1) {\n        b = rnd.next(1, 500);\n    } else {\n        b = max(1, min(b, 500)); // Ensure b is within [1, 500]\n    }\n\n    if (p == -1) {\n        p = rnd.next(1, 500);\n    } else {\n        p = max(1, min(p, 500)); // Ensure p is within [1, 500]\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, b, p);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    string type = opt<string>(\"type\", \"random\");\n    int n = opt<int>(\"n\", -1);\n    int b = opt<int>(\"b\", -1);\n    int p = opt<int>(\"p\", -1);\n\n    // Determine the value of n based on the type or use the provided n\n    if (n == -1) {\n        if (type == \"min_n\") {\n            n = 1;\n        } else if (type == \"max_n\") {\n            n = 500;\n        } else if (type == \"power_of_2\") {\n            int k = rnd.next(0, 8); // 2^0 to 2^8 (1 to 256)\n            n = 1 << k;\n            n = min(n, 500); // Ensure n ≤ 500\n        } else if (type == \"over_power_of_2\") {\n            int k = rnd.next(0, 8);\n            n = (1 << k) + 1;\n            n = min(n, 500);\n        } else if (type == \"under_power_of_2\") {\n            int k = rnd.next(1, 9); // From 2^1 - 1 to 2^9 - 1\n            n = (1 << k) - 1;\n            n = min(n, 500);\n        } else { // Random n\n            n = rnd.next(1, 500);\n        }\n    } else {\n        n = max(1, min(n, 500)); // Ensure n is within [1, 500]\n    }\n\n    // Determine b and p or use the provided values\n    if (b == -1) {\n        b = rnd.next(1, 500);\n    } else {\n        b = max(1, min(b, 500)); // Ensure b is within [1, 500]\n    }\n\n    if (p == -1) {\n        p = rnd.next(1, 500);\n    } else {\n        p = max(1, min(p, 500)); // Ensure p is within [1, 500]\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, b, p);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n (n = 1), random b and p\n./gen -type min_n\n\n# Maximum n (n = 500), random b and p\n./gen -type max_n\n\n# n is a power of 2, random b and p\n./gen -type power_of_2\n\n# n is just over a power of 2, random b and p\n./gen -type over_power_of_2\n\n# n is just under a power of 2, random b and p\n./gen -type under_power_of_2\n\n# Random n, b, and p\n./gen -type random\n\n# Minimum b (b = 1), random n and p\n./gen -b 1\n\n# Maximum b (b = 500), random n and p\n./gen -b 500\n\n# Minimum p (p = 1), random n and b\n./gen -p 1\n\n# Maximum p (p = 500), random n and b\n./gen -p 500\n\n# All parameters at minimum values\n./gen -n 1 -b 1 -p 1\n\n# All parameters at maximum values\n./gen -n 500 -b 500 -p 500\n\n# n = 2 (small even number), random b and p\n./gen -n 2\n\n# n = 255 (just under 256), random b and p\n./gen -n 255\n\n# n = 256 (power of 2), random b and p\n./gen -n 256\n\n# n = 257 (just over 256), random b and p\n./gen -n 257\n\n# Random test cases (run multiple times for diversity)\n./gen\n./gen\n./gen\n./gen\n./gen\n\n# Edge cases for n\n./gen -n 499\n./gen -n 250\n./gen -n 100\n\n# Edge cases for b and p\n./gen -b 1 -p 500\n./gen -b 500 -p 1\n./gen -b 250 -p 250\n\n# Random test cases with fixed n\n./gen -n 300\n./gen -n 150\n\n# Random test cases with fixed b and p\n./gen -b 100 -p 200\n./gen -b 200 -p 100\n\n# Random n with b and p at extremes\n./gen -b 1 -p 1\n./gen -b 500 -p 500\n\n# Large n with minimum b and p\n./gen -n 500 -b 1 -p 1\n\n# Small n with maximum b and p\n./gen -n 1 -b 500 -p 500\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:45.462474",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "628/B",
      "title": "B. New Skateboard",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains string s (1 ≤ |s| ≤ 3·105). The string s contains only digits from 0 to 9.",
      "output_spec": "OutputPrint integer a — the number of substrings of the string s that are divisible by 4.Note that the answer can be huge, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",
      "sample_tests": "ExamplesInputCopy124OutputCopy4InputCopy04OutputCopy3InputCopy5810438174OutputCopy9",
      "description": "B. New Skateboard\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains string s (1 ≤ |s| ≤ 3·105). The string s contains only digits from 0 to 9.\n\nOutputPrint integer a — the number of substrings of the string s that are divisible by 4.Note that the answer can be huge, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\nInputCopy124OutputCopy4InputCopy04OutputCopy3InputCopy5810438174OutputCopy9\n\nInputCopy124\n\nOutputCopy4\n\nInputCopy04\n\nOutputCopy3\n\nInputCopy5810438174\n\nOutputCopy9",
      "solutions": [
        {
          "title": "Educational Codeforces Round 8 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 8 will take place on 19 February 2016 at 18:00 MSK for the first and the second divisions. You can read about educational rounds here and here. I hope that the high density of contests on Codeforces will not startle you and you will participate in ER8.<The phrase about simple problems is added in the end>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.It seems that it is harder to invent interesting simple problems (like A and B) than difficult ones. So don't be afraid to suggest interesting simple or very simple tasks.</The phrase about simple problems is added in the end>This time (for the first time) the problemset was totally suggested by Codeforces users. The problem А suggested by user unprost. The problem B was taken form the problems sent by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. The problem D suggested by Kareem Mohamed Kareem_Mohamed (but I made it more difficult to make it more interesting for you :-)). The problem E sent Ali Ahmadi Kuzey. The problems C and F are suggested by Kamil Debowski Errichto.Thanks a lot to them and all others who are sending the problems or just ideas of the problems!This time the problems wasn't prepared only by me (Edvard Davtyan). Thanks a lot to Kamil Debowski Errichto who not only suggested the problems C and F, but also prepared them. Thanks to Maria Belova Delinur for checking the English statements. Also thanks a lot to Ali Ahmadi Kuzey who helped me with testing of some problems.A few words about the problems: A) Easy problem with the long statement; B) I hope you will not write hard solution; C) It's interesting; D) It's a little technical, but contains very useful technique; E) I like this problem; F) Very cool problem if you will not solve during the contest I recommend to solve it in practice.Good luck and have fun!UPD1: The first phase of the contest finished. Hacks started. The editorial is ready.By the reason that all the problems of Errichto are about a bears, below you can see the illustration for the problem C (it seems Limak is the leftmost):",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2481
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces",
          "content": "628A - Tennis TournamentThe problem was suggested by unprost.Here you can simply model the process. Or you can note that after each match some player drops out. In total n - 1 players will drop out. So the first answer is (n - 1) * (2b + 1). Obviously the second answer is np.С++ solution 1С++ solution 2Complexity: O(log2n), O(logn) or O(1) depends on the realization.628B - New SkateboardThis is one of the problems suggested by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.The key observation is that the number is divisible by 4 if and only if its last two digits forms a number divisible by 4. So to calculate the answer at first we should count the substrings of length one. Now let's consider pairs of consecutive digits. If they forms a two digit number that is divisible by 4 we should increase the answer by the index of the right one.C++ solutionComplexity: O(n).628C - Bear and String DistanceThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.There is no solution if the given required distance is too big. Let's think what is the maximum possible distance for the given string s. Or the more useful thing — how to construct a string s' to maximize the distance? We can treat each letter separately and replace it with the most distant letter. For example, we should replace 'c' with 'z', and we should replace 'y' with 'a'. To be more precise, for first 13 letters of the alphabet the most distant letter is 'z', and for other letters it is 'a'.Let's solve a problem now. We can iterate over letters and greedily change them. A word \"greedily\" means when changing a letter we don't care about the next letters. We generally want to choose distant letters, because we may not find a solution otherwise. For each letter si we change it into the most distant letter, unless the total distance would be too big. As we change letters, we should decrease the remaining required distance. So, for each letter si consider only letters not exceeding the remaining distance, and among them choose the most distant one. If you don't see how to implement it, refer to my C++ solution with comments.Other C++ solutionComplexity: O(n).628D - Magic NumbersKareem Mohamed Kareem_Mohamed suggested the simpler version of the problem.Denote the answer to the problem f(a, b). Note that f(a, b) = f(0, b) - f(0, a - 1) or what is the same f(a, b) = f(0, b) - f(0, a) + g(a), where g(a) equals to one if a is a magic number, otherwise g(a) equals to zero. Let's solve the problem for the segment [0, n].Here is described the standard technique for this kind of problems, sometimes it is called 'dynamic programming by digits'. It can be realized in a two ways. The first way is to iterate over the length of the common prefix with number n. Next digit should be less than corresponding digit in n and other digits can be arbitrary. Below is the description of the second approach.Let zijk be the number of magic prefixes of length i with remainder j modulo m. If k = 0 than the prefix should be less than the corresponding prefix in n and if k = 1 than the prefix should be equal to the prefix of n (it can not be greater). Let's do 'forward dynamic programming'. Let's iterate over digit in position i. We should check that if the position is even than p should be equal to d, otherwise it cannot be equal to d. Also we should check for k = 1 p should be not greater than corresponding digit in n. Now let's see what will be the next state. Of course i' = i + 1. By Horner scheme j' = (10j + p) mod m. Easy to see that . To update the next state we should increase it: zi'j'k' +  = zijk. Of course all calculations should be done modulo 109 + 7.C++ solutionComplexity: O(nm).628E - Zbazi in ZeydabadThe problem was suggested by Ali Ahmadi Kuzey.Let's precalculate the values zlij, zrij, zldij — the maximal number of letters 'z' to the left, to the right and to the left-down from the position (i, j). It's easy to do in O(nm) time. Let's fix some cell (i, j). Consider the value c = min(zlij, zldij). It's the maximum size of the square with upper right ceil in (i, j). But the number of z-patterns can be less than c. Consider some cell (x, y) diagonally down-left from (i, j) on the distance no more than c. The cells (i, j) and (x, y) forms z-pattern if y + zrxy > j.Let's maintain some data structure for each antidiagonal (it can be described by formula x + y) that can increment in a point and take the sum on a segment (Fenwick tree will be the best choice for that). Let's iterate over columns j from the right to the left and process the events: we have some cell (x, y) for which y + zrxy - 1 = j. In that case we should increment the position y in the tree number x + y by one. Now we should iterate over the cells (x, y) in the current column and add to the answer the value of the sum on the segment from j - c + 1 to j in the tree number i + j .С++ solutionComplexity: O(nmlogm).628F - Bear and Fair SetThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.At the beginning, to make things simpler, we should add a query (hint) with upTo = b, quantity = n, and then sort queries by upTo. Sorted queries (hints) divide interval [1, b] into q disjoint intervals. For each interval we know how many elements should be there.Let's build a graph and find a max flow there. The answer is \"YES\" only if the flow is n. The first group A contains 5 vertices, representing possible remainders. The second group B contains q vertices, representing intervals. Each vertex from A should be connected with the source by an edge with capacity n / 5. Each vertex from B should be connected with the sink by an edge with capacity equal to the size of the interval. Between each vertex x from A and y from B should be an edge with capacity equal to the number of numbers in the interval y, giving remainder x when divided by 5.You can also use see that it's similar to finding matching. In fact, we can use the Hall's marriage theorem. For each of 25 sets of vertices from A (sets of remainders) iterate over intervals and count how many numbers we can take from [1, b] with remainders from the fixed set of remainders.The implementation with the Hall's theorem: C++ solution.Complexity: O(2Cn). In our problem C = 5.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 628\\s*B"
          },
          "content_length": 6326
        }
      ],
      "code_examples": [
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 1",
          "code": "x = ...01111.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 2",
          "code": "...01111 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 3",
          "code": "...01110 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[0-9]{1,300000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[0-9]{1,300000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[0-9]{1,300000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n\n    if(type == \"random\") {\n        // Random digits from '0' to '9'\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('0', '9');\n            s += c;\n        }\n    } else if(type == \"zeros\") {\n        // All zeros\n        s = string(n, '0');\n    } else if(type == \"ones\") {\n        // All ones\n        s = string(n, '1');\n    } else if(type == \"fours\") {\n        // All fours\n        s = string(n, '4');\n    } else if(type == \"alternating\") {\n        // Alternating '0' and '4'\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? '0' : '4';\n        }\n    } else if(type == \"small_numbers\") {\n        // Digits that are '0', '4', or '8'\n        string digits = \"048\";\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += digits[rnd.next(0, (int)digits.size() -1)];\n        }\n    } else if(type == \"large_numbers\") {\n        // Digits that are unlikely to form numbers divisible by 4\n        string digits = \"1235679\";\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += digits[rnd.next(0, (int)digits.size() -1)];\n        }\n    } else if(type == \"maximal\") {\n        // All zeros to maximize the number of substrings divisible by 4\n        s = string(n, '0');\n    } else if(type == \"pattern\") {\n        // A specific pattern\n        s = \"\";\n        string pattern = \"5810438174\";\n        for(int i = 0; i < n; ++i) {\n            s += pattern[i % pattern.size()];\n        }\n    } else {\n        // Default to random\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('0', '9');\n            s += c;\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n\n    if(type == \"random\") {\n        // Random digits from '0' to '9'\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('0', '9');\n            s += c;\n        }\n    } else if(type == \"zeros\") {\n        // All zeros\n        s = string(n, '0');\n    } else if(type == \"ones\") {\n        // All ones\n        s = string(n, '1');\n    } else if(type == \"fours\") {\n        // All fours\n        s = string(n, '4');\n    } else if(type == \"alternating\") {\n        // Alternating '0' and '4'\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? '0' : '4';\n        }\n    } else if(type == \"small_numbers\") {\n        // Digits that are '0', '4', or '8'\n        string digits = \"048\";\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += digits[rnd.next(0, (int)digits.size() -1)];\n        }\n    } else if(type == \"large_numbers\") {\n        // Digits that are unlikely to form numbers divisible by 4\n        string digits = \"1235679\";\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            s += digits[rnd.next(0, (int)digits.size() -1)];\n        }\n    } else if(type == \"maximal\") {\n        // All zeros to maximize the number of substrings divisible by 4\n        s = string(n, '0');\n    } else if(type == \"pattern\") {\n        // A specific pattern\n        s = \"\";\n        string pattern = \"5810438174\";\n        for(int i = 0; i < n; ++i) {\n            s += pattern[i % pattern.size()];\n        }\n    } else {\n        // Default to random\n        s = \"\";\n        for(int i = 0; i < n; ++i) {\n            char c = rnd.next('0', '9');\n            s += c;\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type fours\n./gen -n 1 -type random\n\n./gen -n 2 -type zeros\n./gen -n 2 -type alternating\n\n./gen -n 3 -type pattern\n\n./gen -n 10 -type zeros\n./gen -n 10 -type ones\n./gen -n 10 -type random\n\n./gen -n 50 -type small_numbers\n./gen -n 50 -type large_numbers\n\n./gen -n 100 -type maximal\n\n./gen -n 1000 -type zeros\n./gen -n 1000 -type random\n\n./gen -n 10000 -type zeros\n./gen -n 10000 -type maximal\n\n./gen -n 100000 -type random\n./gen -n 100000 -type ones\n./gen -n 100000 -type pattern\n\n./gen -n 300000 -type zeros\n./gen -n 300000 -type random\n./gen -n 300000 -type maximal\n\n./gen -n 299999 -type small_numbers\n./gen -n 300000 -type large_numbers\n\n./gen -n 300000 -type alternating\n\n./gen -n 300000 -type fours\n./gen -n 300000 -type ones\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n\n./gen -n 3 -type random\n\n./gen -n 1000 -type pattern\n\n./gen -n 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:47.592258",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "628/C",
      "title": "C. Медведь и расстояние между строками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится пара целых чисел n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ 106).Во второй строке находится строка s длины n, состоящая из строчных английских букв.",
      "output_spec": "Выходные данныеЕсли не существует строки s', удовлетворяющей условиям задачи выведите \"-1\" (без кавычек).В противном случае, выведите любую красивую строку s' такую, что .",
      "sample_tests": "ПримерыВходные данныеСкопировать4 26bearВыходные данныеСкопироватьroarВходные данныеСкопировать2 7afВыходные данныеСкопироватьdbВходные данныеСкопировать3 1000heyВыходные данныеСкопировать-1",
      "description": "C. Медведь и расстояние между строками\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится пара целых чисел n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ 106).Во второй строке находится строка s длины n, состоящая из строчных английских букв.\n\nВходные данные\n\nВыходные данныеЕсли не существует строки s', удовлетворяющей условиям задачи выведите \"-1\" (без кавычек).В противном случае, выведите любую красивую строку s' такую, что .\n\nВыходные данные\n\nВходные данныеСкопировать4 26bearВыходные данныеСкопироватьroarВходные данныеСкопировать2 7afВыходные данныеСкопироватьdbВходные данныеСкопировать3 1000heyВыходные данныеСкопировать-1\n\nВходные данныеСкопировать4 26bear\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьroar\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 7af\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьdb\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1000hey\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 8 - Codeforces",
          "content": "Привет, Codeforces!19 февраля 2016 года в 18:00 MSK состоится восьмой учебный раунд Educational Codeforces Round 8 для участников из первого и второго дивизионов. Надеюсь плотность контестов на Codeforces в эти несколько дней вас не спугнёт и вы напишете ER8.<В конце добавилась фраза про простые задачи>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день, в течение которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.Не стесняйтесь присылать простые (и даже очень простые) задачи (но обязательно интересные). Почти каждый раунд достаточно быстро выбираются кандидаты для задач C, D, E, F, а вот задача A обычно ставится самой последней, когда уже почти всё готово.</В конце добавилась фраза про простые задачи>В этот раз, впервые, полностью комплект задач был предложен участниками сообщества. Задача А была предложена пользователем unprost. Задача B взята из комплекта, который прислали Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. Задачу D предложил Kareem Mohamed Kareem_Mohamed (я её правда сильно усложнил, чтобы вам было интереснее :-)). Задачу E прислал Ali Ahmadi Kuzey. Задачи C и F были предложены Камилом Дебовски Errichto.Благодарю их и всех кто присылает задачи или просто наброски!Подготовкой задач в этот раз занимался не только я (Эдвард Давтян). Большое спасибо Камилу Дебовски Errichto, который не только предложил задачи C и F, но и подготовил их. Спасибо Маше Беловой Delinur за проверку английских текстов условий. Также большое спасибо Ali Ahmadi Kuzey, который помогал с тестированием задач.На этом раунде вам по традиции будет предложено шесть задач.Вкратце опишу задачи: A) Простая задача с немаленьким условием; B) Надеюсь вы не будете здесь писать ничего сложного; C) Интересная; D) Немного техническая, содержит очень полезную технику; E) Мне эта задача очень нравится; F) Супер клёвая задача, если не удастся сдать на контесте рекомендую дорешать.Good luck and have fun!UPD1: Первая фаза соревнования закончена. Начались взломы. Разбор задач готов.Поскольку все задачи Errichto про медведей ниже находится иллюстрация к задаче C (Limak кажется первый слева):",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2921
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces",
          "content": "628A - Теннисный турнирЗадача предложена пользователем unprost.В этой задаче можно было просто промоделировать процесс. А можно было заметить, что после каждого матча один игрок выбывает. Всего выбывших n - 1. Таким образом, всего нам нужно (n - 1) * (2b + 1) бутылок воды. Полотенец, конечно, нам нужно np штук.С++ solution 1С++ solution 2Сложность: O(log2n), O(logn) или O(1) в зависимости от реализации.628B - Новый скейтбордЭта одна из задач предложенных пользователями Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.Ключевым для решения задачи является наблюдение, что число делится на 4 тогда и только тогда, когда его последние две цифры делятся на 4. Таким образом, для подсчёта ответа достаточно сначала посчитать количество подстрок длины один. Далее нужно рассмотреть пары соседних цифр таких, что они образуют двузначное число кратное 4-м и прибавить к ответу индекс правого из них.C++ solutionСложность: O(n).628C - Медведь и расстояние между строкамиЗадачи предложена и подготовлена Камилем Дебовски Errichto.В этой задаче можно действовать жадно. Будем идти по строке слева направо. Рассмотрим наибольшее расстояние d, которое мы можем получить на этой позиции (это либо расстояние вниз до буквы 'a', либо вверх до буквы 'z'). Пусть v = min(d, k). Поставим на текущей позиции букву на расстоянии v (вниз или вверх), а значение k уменьшим на v. Если после обработки всей строки, k оказалось больше нуля, то ответа не существует. В противном случае мы нашли ответ.C++ solution 1C++ solution 2Сложность: O(n).628D - Волшебные числаБолее простую версию задачи предложил Kareem Mohamed Kareem_Mohamed.Обозначим ответ на задачу как f(a, b). Заметим, что f(a, b) = f(0, b) - f(0, a - 1) или что то же самое f(a, b) = f(0, b) - f(0, a) + g(a), где g(a) равно единице если a является волшебным число, иначе g(a) равно нулю. Далее будем решать задачу для отрезка [0, n].Далее приводится стандартная техника, которую иногда называют 'динамикой по цифрам'. Её можно реализовать двумя способами, в первом перебирается длина префикса числа, который совпадёт с префиксом числа n. Следующий символ может быть произвольным меньшим соответствующей цифры в n, а далее любые цифры. Но я расскажу о втором подходе.Пусть zijk равно количеству волшебных префиксов длины i, дающих остаток j при делении на m. При этом если k = 0, то префикс должен быть строго меньше префикса числа n, а если k = 1, то префикс должен быть равен префиксу числа n (больше он быть не может). Будем делать динамику вперёд. Переберём цифру , которую мы поставим на позиции i. При этом нам нужно проверить, что если позиция чётна то эта цифра должна быть равна d, а в противном случае она не может быть равна d. Также нужно проверить, что если k = 1, то эта цифра не может быть больше соответствующей цифры в числе n. Теперь поймём в какое состояние мы попадём после такого перехода. Конечно, i' = i + 1. Согласно схеме Горнера j' = (10j + p) mod m. Легко видеть, что . Для перехода нужно сделать zi'j'k' +  = zijk. Конечно, нужно не забыть делать все операции по модулю 109 + 7.C++ solutionСложность: O(nm).628E - Zbazi в ZeydabadЗадача предложена Ali Ahmadi Kuzey.Давайте сначала сделаем предподсчёт zlij, zrij, zldij — наибольшее количество букв 'z' влево, вправо и влево-вниз от позиции (i, j). Это легко сделать за O(nm). Пусть мы зафиксировали некоторую клетку (i, j). Рассмотрим величину c = min(zlij, zldij). Это наибольший допустимый размер квадрата с верхним правым углом в (i, j). Теперь поймём сколько таких квадратов. Рассмотрим произвольную клетку (x, y) по диагонали вниз-влево на расстоянии не более c. Пара клеток (i, j) и (x, y) образует z-паттерн, если y + zrxy > j.Отлично, теперь для решения задачи заведём структуру данных для каждой диагонали (она определяется формулой x + y), которая умеет прибавлять в точке и брать сумму на отрезке (лучше всего для этого подходит дерево Фенвика). Будем перебирать столбец j справа налево и обрабатывать события: некоторая клетка (x, y) такова, что y + zrxy - 1 = j. В этом случае нам нужно в дереве номер x + y сделать прибавление в точке y на единицу. Теперь будем перебирать клетку в текущем столбце (i, j). Тогда к ответу нужно прибавить величину суммы в дереве номер i + j на отрезке от j - c + 1 до j.С++ solutionСложность: O(nmlogm).628F - Медведь и справедливое множествоЗадача предложена и подготовлена Камилем Дебовски Errichto.Вначале для удобства добавим подсказку с upTo = b, quantity = n, а затем отсортируем подсказки по значению upTo. Отсортированные подсказки разбивают интервал [1, b] на q непересекающихся промежутка. Для каждого промежутка мы знаем количество элементов в нём.Для решения задачи построим сеть (описанную ниже) и найдём в ней максимальный поток. Ответ fair только если величина потока равна n. Первая группа вершин в сети A будет содержать 5 вершин, обозначающих возмоджные остатки. Вторая группа вершин B будет содержать q вершин, обозначающих промежутки. Соединим каждую вершину из A с истоком ребром пропускной способности . Каждую вершину из B соединим со стоком ребром пропускной способности равной количеству чисел в этом промежутке. Между всему вершинами x из A и y из B добавим ребро пропускной способности равной количеству чисел в промежутке с остатком x в промежутке y.Легко видеть, что поток в данной сети очень похож на паросочетание. В самом деле мы можем воспользоваться теоремой Холла. Для каждого из 25 множеств вершин из A (множества остатков) пройдём по всем промежуткам и посчитаем количество чисел, которые мы можем взять в [1, b] с остатками в заданном множестве.Реализицая с теоремой Холла: C++ solution.Сложность: O(2Cn), где в нашей задаче C = 5.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 628\\s*C"
          },
          "content_length": 5664
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 1",
          "code": "x = ...01111.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 2",
          "code": "...01111 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 3",
          "code": "...01110 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000, \"k\");\n    inf.readEoln();\n    \n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000, \"k\");\n    inf.readEoln();\n    \n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000, \"k\");\n    inf.readEoln();\n    \n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    int n = inf.readInt();\n    int k = inf.readInt();\n    string s = inf.readToken();\n\n    if ((int)s.size() != n) {\n        quitf(_fail, \"Input string length does not match n\");\n    }\n    \n    // Read jury's answer\n    string jans = ans.readToken();\n    \n    // Read contestant's answer\n    string pans = ouf.readToken();\n    \n    if (jans == \"-1\") {\n        // Jury says it's impossible\n        if (pans == \"-1\") {\n            quitf(_ok, \"Correct: both jury and contestant output -1\");\n        } else {\n            // Verify contestant's output\n            if ((int)pans.length() != n)\n                quitf(_wa, \"Contestant's output length is incorrect: expected length %d, found %d\", n, (int)pans.length());\n            for (int i = 0; i < n; ++i) {\n                if (pans[i] < 'a' || pans[i] > 'z')\n                    quitf(_wa, \"Contestant's output contains invalid character '%c' at position %d\", pans[i], i + 1);\n            }\n            // Compute total distance\n            int total_distance = 0;\n            for (int i = 0; i < n; ++i) {\n                total_distance += abs(pans[i] - s[i]);\n            }\n            if (total_distance == k) {\n                // Participant found a solution when jury said impossible\n                quitf(_fail, \"Participant found a valid solution, but jury says it's impossible\");\n            } else {\n                quitf(_wa, \"Contestant's output has total distance %d, expected %d\", total_distance, k);\n            }\n        }\n    } else {\n        // Jury found a valid solution\n        if (pans == \"-1\") {\n            quitf(_wa, \"Contestant outputs -1, but a valid solution exists\");\n        } else {\n            // Verify contestant's output\n            if ((int)pans.length() != n)\n                quitf(_wa, \"Contestant's output length is incorrect: expected length %d, found %d\", n, (int)pans.length());\n            for (int i = 0; i < n; ++i) {\n                if (pans[i] < 'a' || pans[i] > 'z')\n                    quitf(_wa, \"Contestant's output contains invalid character '%c' at position %d\", pans[i], i + 1);\n            }\n            // Compute total distance\n            int total_distance = 0;\n            for (int i = 0; i < n; ++i) {\n                total_distance += abs(pans[i] - s[i]);\n            }\n            if (total_distance == k) {\n                quitf(_ok, \"Correct: total distance is %d\", total_distance);\n            } else {\n                quitf(_wa, \"Contestant's output has total distance %d, expected %d\", total_distance, k);\n            }\n        }\n    }\n    \n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    string s;\n\n    if (type == \"possible\") {\n        // Generate s such that there is a possible answer\n        if (k == -1) {\n            // If k not provided, set k to a random value between 0 and n * 25\n            k = rnd.next(0, n * 25);\n        } else {\n            // Ensure k is within possible range\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25 for possible type\");\n        }\n        // Generate random s\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    } else if (type == \"impossible\") {\n        // Generate s such that it's impossible to find s' with given k\n        if (k == -1) {\n            // If k not provided, set k to a value outside possible range\n            k = n * 25 + rnd.next(1, 1000);\n        } else {\n            // Ensure k is outside possible range\n            ensuref(k < 0 || k > n * 25, \"k must be outside 0 to n*25 for impossible type\");\n        }\n        // Generate random s\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    } else if (type == \"k_zero\") {\n        // k = 0, s can be any string\n        k = 0;\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    } else if (type == \"k_max\") {\n        // k = n * 25\n        k = n * 25;\n        // s can be any string\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a';\n    } else if (type == \"same_letter\") {\n        // s consists of same letter\n        char c = 'a' + rnd.next(0,25);\n        s = string(n, c);\n        if (k == -1) {\n            k = rnd.next(0, n * 25);\n        } else {\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25\");\n        }\n    } else if (type == \"single_letter_change\") {\n        // Change only one letter to maximize k\n        s = string(n, 'a');\n        k = 25;\n    } else if (type == \"alternate_letters\") {\n        // s consists of alternating letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? 'a' : 'z';\n        if (k == -1) {\n            k = 25 * (n / 2);\n            if (n % 2 == 1) k += 0; // Adjust k if n is odd\n        } else {\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25\");\n        }\n    } else {\n        // Default, generate possible test case\n        if (k == -1) {\n            k = rnd.next(0, n * 25);\n        } else {\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25\");\n        }\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    string s;\n\n    if (type == \"possible\") {\n        // Generate s such that there is a possible answer\n        if (k == -1) {\n            // If k not provided, set k to a random value between 0 and n * 25\n            k = rnd.next(0, n * 25);\n        } else {\n            // Ensure k is within possible range\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25 for possible type\");\n        }\n        // Generate random s\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    } else if (type == \"impossible\") {\n        // Generate s such that it's impossible to find s' with given k\n        if (k == -1) {\n            // If k not provided, set k to a value outside possible range\n            k = n * 25 + rnd.next(1, 1000);\n        } else {\n            // Ensure k is outside possible range\n            ensuref(k < 0 || k > n * 25, \"k must be outside 0 to n*25 for impossible type\");\n        }\n        // Generate random s\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    } else if (type == \"k_zero\") {\n        // k = 0, s can be any string\n        k = 0;\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    } else if (type == \"k_max\") {\n        // k = n * 25\n        k = n * 25;\n        // s can be any string\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a';\n    } else if (type == \"same_letter\") {\n        // s consists of same letter\n        char c = 'a' + rnd.next(0,25);\n        s = string(n, c);\n        if (k == -1) {\n            k = rnd.next(0, n * 25);\n        } else {\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25\");\n        }\n    } else if (type == \"single_letter_change\") {\n        // Change only one letter to maximize k\n        s = string(n, 'a');\n        k = 25;\n    } else if (type == \"alternate_letters\") {\n        // s consists of alternating letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? 'a' : 'z';\n        if (k == -1) {\n            k = 25 * (n / 2);\n            if (n % 2 == 1) k += 0; // Adjust k if n is odd\n        } else {\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25\");\n        }\n    } else {\n        // Default, generate possible test case\n        if (k == -1) {\n            k = rnd.next(0, n * 25);\n        } else {\n            ensuref(0 <= k && k <= n * 25, \"k must be between 0 and n*25\");\n        }\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(0,25);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type possible -k 0\n./gen -n 1 -type possible -k 25\n./gen -n 1 -type impossible -k -1\n./gen -n 1 -type impossible -k 26\n\n./gen -n 2 -type possible -k 50\n./gen -n 2 -type impossible -k 51\n\n./gen -n 3 -type possible -k 75\n./gen -n 3 -type impossible -k 76\n\n./gen -n 5 -type single_letter_change\n./gen -n 10 -type alternate_letters\n./gen -n 100 -type alternate_letters\n\n./gen -n 500 -type possible -k 0\n./gen -n 500 -type possible -k 12500\n./gen -n 500 -type impossible -k -1\n./gen -n 500 -type impossible -k 12501\n\n./gen -n 1000 -type possible\n./gen -n 1000 -type impossible -k 25001\n\n./gen -n 5000 -type same_letter\n./gen -n 10000 -type same_letter\n\n./gen -n 50000 -type possible -k 0\n./gen -n 50000 -type possible -k 1250000\n./gen -n 50000 -type impossible -k -1\n./gen -n 50000 -type impossible -k 1250001\n\n./gen -n 99999 -type same_letter\n./gen -n 100000 -type same_letter\n\n./gen -n 100000 -type possible\n./gen -n 100000 -type possible -k 0\n./gen -n 100000 -type possible -k 2500000\n\n./gen -n 100000 -type impossible -k -1\n./gen -n 100000 -type impossible -k 2500001\n\n./gen -n 100000 -type k_zero\n./gen -n 100000 -type k_max\n\n./gen -n 100000 -type alternate_letters\n./gen -n 100000 -type single_letter_change\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:50.058686",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "628/D",
      "title": "D. Magic Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers m, d (1 ≤ m ≤ 2000, 0 ≤ d ≤ 9) — the parameters from the problem statement.The second line contains positive integer a in decimal presentation (without leading zeroes).The third line contains positive integer b in decimal presentation (without leading zeroes).It is guaranteed that a ≤ b, the number of digits in a and b are the same and don't exceed 2000.",
      "output_spec": "OutputPrint the only integer a — the remainder after dividing by 109 + 7 of the number of d-magic numbers in segment [a, b] that are multiple of m.",
      "sample_tests": "ExamplesInputCopy2 61099OutputCopy8InputCopy2 019OutputCopy4InputCopy19 710009999OutputCopy6",
      "description": "D. Magic Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers m, d (1 ≤ m ≤ 2000, 0 ≤ d ≤ 9) — the parameters from the problem statement.The second line contains positive integer a in decimal presentation (without leading zeroes).The third line contains positive integer b in decimal presentation (without leading zeroes).It is guaranteed that a ≤ b, the number of digits in a and b are the same and don't exceed 2000.\n\nOutputPrint the only integer a — the remainder after dividing by 109 + 7 of the number of d-magic numbers in segment [a, b] that are multiple of m.\n\nInputCopy2 61099OutputCopy8InputCopy2 019OutputCopy4InputCopy19 710009999OutputCopy6\n\nInputCopy2 61099\n\nOutputCopy8\n\nInputCopy2 019\n\nOutputCopy4\n\nInputCopy19 710009999\n\nOutputCopy6\n\nNoteThe numbers from the answer of the first example are 16, 26, 36, 46, 56, 76, 86 and 96.The numbers from the answer of the second example are 2, 4, 6 and 8.The numbers from the answer of the third example are 1767, 2717, 5757, 6707, 8797 and 9747.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 8 - Codeforces",
          "content": "Hello, Codeforces!Educational Codeforces Round 8 will take place on 19 February 2016 at 18:00 MSK for the first and the second divisions. You can read about educational rounds here and here. I hope that the high density of contests on Codeforces will not startle you and you will participate in ER8.<The phrase about simple problems is added in the end>The round will be unrated for all users and it will be held with extented ACM ICPC rules. You will have two hours to solve six problems. After that you will have one day to hack any solution you want. You will have access to copy any solution and test it locally.If you have ideas for some problems or maybe already prepared problems that you can't use in rounds or official competitions, you can write to me.It seems that it is harder to invent interesting simple problems (like A and B) than difficult ones. So don't be afraid to suggest interesting simple or very simple tasks.</The phrase about simple problems is added in the end>This time (for the first time) the problemset was totally suggested by Codeforces users. The problem А suggested by user unprost. The problem B was taken form the problems sent by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. The problem D suggested by Kareem Mohamed Kareem_Mohamed (but I made it more difficult to make it more interesting for you :-)). The problem E sent Ali Ahmadi Kuzey. The problems C and F are suggested by Kamil Debowski Errichto.Thanks a lot to them and all others who are sending the problems or just ideas of the problems!This time the problems wasn't prepared only by me (Edvard Davtyan). Thanks a lot to Kamil Debowski Errichto who not only suggested the problems C and F, but also prepared them. Thanks to Maria Belova Delinur for checking the English statements. Also thanks a lot to Ali Ahmadi Kuzey who helped me with testing of some problems.A few words about the problems: A) Easy problem with the long statement; B) I hope you will not write hard solution; C) It's interesting; D) It's a little technical, but contains very useful technique; E) I like this problem; F) Very cool problem if you will not solve during the contest I recommend to solve it in practice.Good luck and have fun!UPD1: The first phase of the contest finished. Hacks started. The editorial is ready.By the reason that all the problems of Errichto are about a bears, below you can see the illustration for the problem C (it seems Limak is the leftmost):",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2481
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces",
          "content": "628A - Tennis TournamentThe problem was suggested by unprost.Here you can simply model the process. Or you can note that after each match some player drops out. In total n - 1 players will drop out. So the first answer is (n - 1) * (2b + 1). Obviously the second answer is np.С++ solution 1С++ solution 2Complexity: O(log2n), O(logn) or O(1) depends on the realization.628B - New SkateboardThis is one of the problems suggested by Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.The key observation is that the number is divisible by 4 if and only if its last two digits forms a number divisible by 4. So to calculate the answer at first we should count the substrings of length one. Now let's consider pairs of consecutive digits. If they forms a two digit number that is divisible by 4 we should increase the answer by the index of the right one.C++ solutionComplexity: O(n).628C - Bear and String DistanceThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.There is no solution if the given required distance is too big. Let's think what is the maximum possible distance for the given string s. Or the more useful thing — how to construct a string s' to maximize the distance? We can treat each letter separately and replace it with the most distant letter. For example, we should replace 'c' with 'z', and we should replace 'y' with 'a'. To be more precise, for first 13 letters of the alphabet the most distant letter is 'z', and for other letters it is 'a'.Let's solve a problem now. We can iterate over letters and greedily change them. A word \"greedily\" means when changing a letter we don't care about the next letters. We generally want to choose distant letters, because we may not find a solution otherwise. For each letter si we change it into the most distant letter, unless the total distance would be too big. As we change letters, we should decrease the remaining required distance. So, for each letter si consider only letters not exceeding the remaining distance, and among them choose the most distant one. If you don't see how to implement it, refer to my C++ solution with comments.Other C++ solutionComplexity: O(n).628D - Magic NumbersKareem Mohamed Kareem_Mohamed suggested the simpler version of the problem.Denote the answer to the problem f(a, b). Note that f(a, b) = f(0, b) - f(0, a - 1) or what is the same f(a, b) = f(0, b) - f(0, a) + g(a), where g(a) equals to one if a is a magic number, otherwise g(a) equals to zero. Let's solve the problem for the segment [0, n].Here is described the standard technique for this kind of problems, sometimes it is called 'dynamic programming by digits'. It can be realized in a two ways. The first way is to iterate over the length of the common prefix with number n. Next digit should be less than corresponding digit in n and other digits can be arbitrary. Below is the description of the second approach.Let zijk be the number of magic prefixes of length i with remainder j modulo m. If k = 0 than the prefix should be less than the corresponding prefix in n and if k = 1 than the prefix should be equal to the prefix of n (it can not be greater). Let's do 'forward dynamic programming'. Let's iterate over digit in position i. We should check that if the position is even than p should be equal to d, otherwise it cannot be equal to d. Also we should check for k = 1 p should be not greater than corresponding digit in n. Now let's see what will be the next state. Of course i' = i + 1. By Horner scheme j' = (10j + p) mod m. Easy to see that . To update the next state we should increase it: zi'j'k' +  = zijk. Of course all calculations should be done modulo 109 + 7.C++ solutionComplexity: O(nm).628E - Zbazi in ZeydabadThe problem was suggested by Ali Ahmadi Kuzey.Let's precalculate the values zlij, zrij, zldij — the maximal number of letters 'z' to the left, to the right and to the left-down from the position (i, j). It's easy to do in O(nm) time. Let's fix some cell (i, j). Consider the value c = min(zlij, zldij). It's the maximum size of the square with upper right ceil in (i, j). But the number of z-patterns can be less than c. Consider some cell (x, y) diagonally down-left from (i, j) on the distance no more than c. The cells (i, j) and (x, y) forms z-pattern if y + zrxy > j.Let's maintain some data structure for each antidiagonal (it can be described by formula x + y) that can increment in a point and take the sum on a segment (Fenwick tree will be the best choice for that). Let's iterate over columns j from the right to the left and process the events: we have some cell (x, y) for which y + zrxy - 1 = j. In that case we should increment the position y in the tree number x + y by one. Now we should iterate over the cells (x, y) in the current column and add to the answer the value of the sum on the segment from j - c + 1 to j in the tree number i + j .С++ solutionComplexity: O(nmlogm).628F - Bear and Fair SetThe problem was suggested and prepared by Kamil Debowski Errichto. He also wrote the editorial.At the beginning, to make things simpler, we should add a query (hint) with upTo = b, quantity = n, and then sort queries by upTo. Sorted queries (hints) divide interval [1, b] into q disjoint intervals. For each interval we know how many elements should be there.Let's build a graph and find a max flow there. The answer is \"YES\" only if the flow is n. The first group A contains 5 vertices, representing possible remainders. The second group B contains q vertices, representing intervals. Each vertex from A should be connected with the source by an edge with capacity n / 5. Each vertex from B should be connected with the sink by an edge with capacity equal to the size of the interval. Between each vertex x from A and y from B should be an edge with capacity equal to the number of numbers in the interval y, giving remainder x when divided by 5.You can also use see that it's similar to finding matching. In fact, we can use the Hall's marriage theorem. For each of 25 sets of vertices from A (sets of remainders) iterate over intervals and count how many numbers we can take from [1, b] with remainders from the fixed set of remainders.The implementation with the Hall's theorem: C++ solution.Complexity: O(2Cn). In our problem C = 5.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 628\\s*D"
          },
          "content_length": 6326
        }
      ],
      "code_examples": [
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 1",
          "code": "x = ...01111.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 2",
          "code": "...01111 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Educational Codeforces Round 8 - Codeforces - Code 3",
          "code": "...01110 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, 9, \"d\");\n    inf.readEoln();\n\n    string a = inf.readToken(\"[1-9][0-9]*\", \"a\");\n    inf.readEoln();\n    string b = inf.readToken(\"[1-9][0-9]*\", \"b\");\n    inf.readEoln();\n\n    int la = a.length();\n    int lb = b.length();\n    ensuref(la <= 2000, \"Length of a (%d) must be ≤ 2000\", la);\n    ensuref(lb <= 2000, \"Length of b (%d) must be ≤ 2000\", lb);\n    ensuref(la == lb, \"Lengths of a (%d) and b (%d) must be equal\", la, lb);\n    ensuref(a <= b, \"a (%s) must be ≤ b (%s)\", a.c_str(), b.c_str());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, 9, \"d\");\n    inf.readEoln();\n\n    string a = inf.readToken(\"[1-9][0-9]*\", \"a\");\n    inf.readEoln();\n    string b = inf.readToken(\"[1-9][0-9]*\", \"b\");\n    inf.readEoln();\n\n    int la = a.length();\n    int lb = b.length();\n    ensuref(la <= 2000, \"Length of a (%d) must be ≤ 2000\", la);\n    ensuref(lb <= 2000, \"Length of b (%d) must be ≤ 2000\", lb);\n    ensuref(la == lb, \"Lengths of a (%d) and b (%d) must be equal\", la, lb);\n    ensuref(a <= b, \"a (%s) must be ≤ b (%s)\", a.c_str(), b.c_str());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int d = inf.readInt(0, 9, \"d\");\n    inf.readEoln();\n\n    string a = inf.readToken(\"[1-9][0-9]*\", \"a\");\n    inf.readEoln();\n    string b = inf.readToken(\"[1-9][0-9]*\", \"b\");\n    inf.readEoln();\n\n    int la = a.length();\n    int lb = b.length();\n    ensuref(la <= 2000, \"Length of a (%d) must be ≤ 2000\", la);\n    ensuref(lb <= 2000, \"Length of b (%d) must be ≤ 2000\", lb);\n    ensuref(la == lb, \"Lengths of a (%d) and b (%d) must be equal\", la, lb);\n    ensuref(a <= b, \"a (%s) must be ≤ b (%s)\", a.c_str(), b.c_str());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring gen_number(int len, int d = -1) {\n    string num = \"\";\n    for(int i = 0; i < len; i++) {\n        char c;\n        if (i == 0) {\n            c = '1' + rnd.next(9); // First digit can't be zero\n        } else {\n            c = '0' + rnd.next(10);\n        }\n        if (d != -1) {\n            if ((i+1)%2 == 0) {\n                c = '0' + d;\n            } else {\n                while(c - '0' == d){\n                    c = '0' + rnd.next(10);\n                }\n                if(i == 0 && c == '0') c = '1';\n            }\n        }\n        num += c;\n    }\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b;\n\n    if (type == \"minmax\") {\n        a = string(len, '0'); a[0] = '1';\n        b = string(len, '9');\n    } else if (type == \"same\") {\n        a = gen_number(len);\n        b = a;\n    } else if (type == \"max\") {\n        a = b = string(len, '9');\n    } else if (type == \"min\") {\n        a = b = string(len, '0'); a[0] = '1';\n    } else if (type == \"random\") {\n        a = gen_number(len);\n        b = gen_number(len);\n        if(a > b) swap(a, b);\n    } else if (type == \"a_equals_b\") {\n        a = gen_number(len);\n        b = a;\n    } else if (type == \"fixed_d\") {\n        a = gen_number(len, d);\n        b = a;\n    } else {\n        // Default to random\n        a = gen_number(len);\n        b = gen_number(len);\n        if(a > b) swap(a, b);\n    }\n\n    printf(\"%d %d\\n\", m, d);\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring gen_number(int len, int d = -1) {\n    string num = \"\";\n    for(int i = 0; i < len; i++) {\n        char c;\n        if (i == 0) {\n            c = '1' + rnd.next(9); // First digit can't be zero\n        } else {\n            c = '0' + rnd.next(10);\n        }\n        if (d != -1) {\n            if ((i+1)%2 == 0) {\n                c = '0' + d;\n            } else {\n                while(c - '0' == d){\n                    c = '0' + rnd.next(10);\n                }\n                if(i == 0 && c == '0') c = '1';\n            }\n        }\n        num += c;\n    }\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    int m = opt<int>(\"m\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b;\n\n    if (type == \"minmax\") {\n        a = string(len, '0'); a[0] = '1';\n        b = string(len, '9');\n    } else if (type == \"same\") {\n        a = gen_number(len);\n        b = a;\n    } else if (type == \"max\") {\n        a = b = string(len, '9');\n    } else if (type == \"min\") {\n        a = b = string(len, '0'); a[0] = '1';\n    } else if (type == \"random\") {\n        a = gen_number(len);\n        b = gen_number(len);\n        if(a > b) swap(a, b);\n    } else if (type == \"a_equals_b\") {\n        a = gen_number(len);\n        b = a;\n    } else if (type == \"fixed_d\") {\n        a = gen_number(len, d);\n        b = a;\n    } else {\n        // Default to random\n        a = gen_number(len);\n        b = gen_number(len);\n        if(a > b) swap(a, b);\n    }\n\n    printf(\"%d %d\\n\", m, d);\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -m 1 -d 0 -type random\n./gen -len 1 -m 2000 -d 9 -type random\n./gen -len 2 -m 500 -d 5 -type random\n\n./gen -len 5 -m 1000 -d 3 -type same\n\n./gen -len 10 -m 100 -d 7 -type minmax\n\n./gen -len 2000 -m 2000 -d 9 -type random\n\n./gen -len 2000 -m 1 -d 0 -type random\n\n./gen -len 50 -m 1234 -d 6 -type fixed_d\n\n./gen -len 100 -m 1000 -d 5 -type a_equals_b\n\n./gen -len 10 -m 1 -d 1 -type min\n\n./gen -len 10 -m 1 -d 1 -type max\n\n./gen -len 1000 -m 2000 -d 9 -type random\n\n./gen -len 1000 -m 1 -d 0 -type random\n\n./gen -len 20 -m 500 -d 2 -type random\n./gen -len 30 -m 600 -d 3 -type random\n./gen -len 40 -m 700 -d 4 -type random\n\n./gen -len 2000 -m 100 -d 8 -type fixed_d\n\n./gen -len 2000 -m 1 -d 7 -type fixed_d\n\n./gen -len 100 -m 100 -d 5 -type minmax\n./gen -len 500 -m 200 -d 6 -type minmax\n./gen -len 1000 -m 300 -d 7 -type minmax\n\n./gen -len 2000 -m 2000 -d 9 -type a_equals_b\n\n./gen -len 2000 -m 2000 -d 0 -type random\n\n./gen -len 2000 -m 2000 -d 9 -type min\n./gen -len 2000 -m 2000 -d 9 -type max\n\n./gen -len 2000 -m 1000 -d 3 -type min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:51.791472",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "628/E",
      "title": "E. Zbazi в Zeydabad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит пару целых чисел n, m (1 ≤ n, m ≤ 3000) — количество строк и столбцов, соответственно.Каждая из следующих n строк содержит m символов 'z' или '.' — описание страны Zeydabad.",
      "output_spec": "Выходные данныеВыведите целое число a — количество ''Z-паттернов\" в Zeydabad.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 4zzzzzzz..z..zzzzВыходные данныеСкопировать16Входные данныеСкопировать1 4z.z.Выходные данныеСкопировать2Входные данныеСкопировать2 2zzzzВыходные данныеСкопировать5",
      "description": "E. Zbazi в Zeydabad\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит пару целых чисел n, m (1 ≤ n, m ≤ 3000) — количество строк и столбцов, соответственно.Каждая из следующих n строк содержит m символов 'z' или '.' — описание страны Zeydabad.\n\nВходные данные\n\nВыходные данныеВыведите целое число a — количество ''Z-паттернов\" в Zeydabad.\n\nВыходные данные\n\nВходные данныеСкопировать4 4zzzzzzz..z..zzzzВыходные данныеСкопировать16Входные данныеСкопировать1 4z.z.Выходные данныеСкопировать2Входные данныеСкопировать2 2zzzzВыходные данныеСкопировать5\n\nВходные данныеСкопировать4 4zzzzzzz..z..zzzz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 4z.z.\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2zzzz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Educational Codeforces Round 8 - Codeforces",
          "content": "Привет, Codeforces!19 февраля 2016 года в 18:00 MSK состоится восьмой учебный раунд Educational Codeforces Round 8 для участников из первого и второго дивизионов. Надеюсь плотность контестов на Codeforces в эти несколько дней вас не спугнёт и вы напишете ER8.<В конце добавилась фраза про простые задачи>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день, в течение которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.Не стесняйтесь присылать простые (и даже очень простые) задачи (но обязательно интересные). Почти каждый раунд достаточно быстро выбираются кандидаты для задач C, D, E, F, а вот задача A обычно ставится самой последней, когда уже почти всё готово.</В конце добавилась фраза про простые задачи>В этот раз, впервые, полностью комплект задач был предложен участниками сообщества. Задача А была предложена пользователем unprost. Задача B взята из комплекта, который прислали Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. Задачу D предложил Kareem Mohamed Kareem_Mohamed (я её правда сильно усложнил, чтобы вам было интереснее :-)). Задачу E прислал Ali Ahmadi Kuzey. Задачи C и F были предложены Камилом Дебовски Errichto.Благодарю их и всех кто присылает задачи или просто наброски!Подготовкой задач в этот раз занимался не только я (Эдвард Давтян). Большое спасибо Камилу Дебовски Errichto, который не только предложил задачи C и F, но и подготовил их. Спасибо Маше Беловой Delinur за проверку английских текстов условий. Также большое спасибо Ali Ahmadi Kuzey, который помогал с тестированием задач.На этом раунде вам по традиции будет предложено шесть задач.Вкратце опишу задачи: A) Простая задача с немаленьким условием; B) Надеюсь вы не будете здесь писать ничего сложного; C) Интересная; D) Немного техническая, содержит очень полезную технику; E) Мне эта задача очень нравится; F) Супер клёвая задача, если не удастся сдать на контесте рекомендую дорешать.Good luck and have fun!UPD1: Первая фаза соревнования закончена. Начались взломы. Разбор задач готов.Поскольку все задачи Errichto про медведей ниже находится иллюстрация к задаче C (Limak кажется первый слева):",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2921
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces",
          "content": "628A - Теннисный турнирЗадача предложена пользователем unprost.В этой задаче можно было просто промоделировать процесс. А можно было заметить, что после каждого матча один игрок выбывает. Всего выбывших n - 1. Таким образом, всего нам нужно (n - 1) * (2b + 1) бутылок воды. Полотенец, конечно, нам нужно np штук.С++ solution 1С++ solution 2Сложность: O(log2n), O(logn) или O(1) в зависимости от реализации.628B - Новый скейтбордЭта одна из задач предложенных пользователями Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.Ключевым для решения задачи является наблюдение, что число делится на 4 тогда и только тогда, когда его последние две цифры делятся на 4. Таким образом, для подсчёта ответа достаточно сначала посчитать количество подстрок длины один. Далее нужно рассмотреть пары соседних цифр таких, что они образуют двузначное число кратное 4-м и прибавить к ответу индекс правого из них.C++ solutionСложность: O(n).628C - Медведь и расстояние между строкамиЗадачи предложена и подготовлена Камилем Дебовски Errichto.В этой задаче можно действовать жадно. Будем идти по строке слева направо. Рассмотрим наибольшее расстояние d, которое мы можем получить на этой позиции (это либо расстояние вниз до буквы 'a', либо вверх до буквы 'z'). Пусть v = min(d, k). Поставим на текущей позиции букву на расстоянии v (вниз или вверх), а значение k уменьшим на v. Если после обработки всей строки, k оказалось больше нуля, то ответа не существует. В противном случае мы нашли ответ.C++ solution 1C++ solution 2Сложность: O(n).628D - Волшебные числаБолее простую версию задачи предложил Kareem Mohamed Kareem_Mohamed.Обозначим ответ на задачу как f(a, b). Заметим, что f(a, b) = f(0, b) - f(0, a - 1) или что то же самое f(a, b) = f(0, b) - f(0, a) + g(a), где g(a) равно единице если a является волшебным число, иначе g(a) равно нулю. Далее будем решать задачу для отрезка [0, n].Далее приводится стандартная техника, которую иногда называют 'динамикой по цифрам'. Её можно реализовать двумя способами, в первом перебирается длина префикса числа, который совпадёт с префиксом числа n. Следующий символ может быть произвольным меньшим соответствующей цифры в n, а далее любые цифры. Но я расскажу о втором подходе.Пусть zijk равно количеству волшебных префиксов длины i, дающих остаток j при делении на m. При этом если k = 0, то префикс должен быть строго меньше префикса числа n, а если k = 1, то префикс должен быть равен префиксу числа n (больше он быть не может). Будем делать динамику вперёд. Переберём цифру , которую мы поставим на позиции i. При этом нам нужно проверить, что если позиция чётна то эта цифра должна быть равна d, а в противном случае она не может быть равна d. Также нужно проверить, что если k = 1, то эта цифра не может быть больше соответствующей цифры в числе n. Теперь поймём в какое состояние мы попадём после такого перехода. Конечно, i' = i + 1. Согласно схеме Горнера j' = (10j + p) mod m. Легко видеть, что . Для перехода нужно сделать zi'j'k' +  = zijk. Конечно, нужно не забыть делать все операции по модулю 109 + 7.C++ solutionСложность: O(nm).628E - Zbazi в ZeydabadЗадача предложена Ali Ahmadi Kuzey.Давайте сначала сделаем предподсчёт zlij, zrij, zldij — наибольшее количество букв 'z' влево, вправо и влево-вниз от позиции (i, j). Это легко сделать за O(nm). Пусть мы зафиксировали некоторую клетку (i, j). Рассмотрим величину c = min(zlij, zldij). Это наибольший допустимый размер квадрата с верхним правым углом в (i, j). Теперь поймём сколько таких квадратов. Рассмотрим произвольную клетку (x, y) по диагонали вниз-влево на расстоянии не более c. Пара клеток (i, j) и (x, y) образует z-паттерн, если y + zrxy > j.Отлично, теперь для решения задачи заведём структуру данных для каждой диагонали (она определяется формулой x + y), которая умеет прибавлять в точке и брать сумму на отрезке (лучше всего для этого подходит дерево Фенвика). Будем перебирать столбец j справа налево и обрабатывать события: некоторая клетка (x, y) такова, что y + zrxy - 1 = j. В этом случае нам нужно в дереве номер x + y сделать прибавление в точке y на единицу. Теперь будем перебирать клетку в текущем столбце (i, j). Тогда к ответу нужно прибавить величину суммы в дереве номер i + j на отрезке от j - c + 1 до j.С++ solutionСложность: O(nmlogm).628F - Медведь и справедливое множествоЗадача предложена и подготовлена Камилем Дебовски Errichto.Вначале для удобства добавим подсказку с upTo = b, quantity = n, а затем отсортируем подсказки по значению upTo. Отсортированные подсказки разбивают интервал [1, b] на q непересекающихся промежутка. Для каждого промежутка мы знаем количество элементов в нём.Для решения задачи построим сеть (описанную ниже) и найдём в ней максимальный поток. Ответ fair только если величина потока равна n. Первая группа вершин в сети A будет содержать 5 вершин, обозначающих возмоджные остатки. Вторая группа вершин B будет содержать q вершин, обозначающих промежутки. Соединим каждую вершину из A с истоком ребром пропускной способности . Каждую вершину из B соединим со стоком ребром пропускной способности равной количеству чисел в этом промежутке. Между всему вершинами x из A и y из B добавим ребро пропускной способности равной количеству чисел в промежутке с остатком x в промежутке y.Легко видеть, что поток в данной сети очень похож на паросочетание. В самом деле мы можем воспользоваться теоремой Холла. Для каждого из 25 множеств вершин из A (множества остатков) пройдём по всем промежуткам и посчитаем количество чисел, которые мы можем взять в [1, b] с остатками в заданном множестве.Реализицая с теоремой Холла: C++ solution.Сложность: O(2Cn), где в нашей задаче C = 5.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 628\\s*E"
          },
          "content_length": 5664
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 1",
          "code": "x = ...01111.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 2",
          "code": "...01111 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 3",
          "code": "...01110 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string regex = \"[z.]{\" + to_string(m) + \"}\";\n        string s = inf.readLine(regex, \"line \" + to_string(i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string regex = \"[z.]{\" + to_string(m) + \"}\";\n        string s = inf.readLine(regex, \"line \" + to_string(i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string regex = \"[z.]{\" + to_string(m) + \"}\";\n        string s = inf.readLine(regex, \"line \" + to_string(i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"full_z\") {\n        // Fill the grid entirely with 'z's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, 'z');\n        }\n    } else if (type == \"full_dot\") {\n        // Grid is already initialized with '.'\n        // Do nothing\n    } else if (type == \"border_z\") {\n        // Fill the borders with 'z's, inside with '.'\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = 'z';\n            grid[i][m - 1] = 'z';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = 'z';\n            grid[n - 1][j] = 'z';\n        }\n    } else if (type == \"random\") {\n        // Randomly fill the grid with 'z's and '.'s\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2) ? 'z' : '.';\n            }\n        }\n    } else if (type == \"zigzag\") {\n        // Create a zigzag pattern designed to have many overlapping Z-patterns\n        int k = min(n, m);\n        for (int size = 1; size <= k; ++size) {\n            for (int r = 0; r <= n - size; r += size) {\n                for (int c = 0; c <= m - size; c += size) {\n                    // Fill anti-diagonal and borders for squares starting at (r, c) of size 'size'\n                    for (int i = 0; i < size; ++i) {\n                        // Fill anti-diagonal\n                        int row = r + i;\n                        int col = c + size - 1 - i;\n                        grid[row][col] = 'z';\n                    }\n                    // Fill top and bottom rows\n                    for (int j = 0; j < size; ++j) {\n                        grid[r][c + j] = 'z';\n                        grid[r + size - 1][c + j] = 'z';\n                    }\n                }\n            }\n        }\n    } else if (type == \"single_z\") {\n        // Place a single 'z' in the corner\n        grid[0][0] = 'z';\n    } else if (type == \"checkerboard\") {\n        // Alternating 'z's and '.'s\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = ((i + j) % 2 == 0) ? 'z' : '.';\n            }\n        }\n    } else if (type == \"max_k\") {\n        // Create a maximum size Z-pattern\n        int size = min(n, m);\n        int r = 0, c = 0;\n        // Fill anti-diagonal\n        for (int i = 0; i < size; ++i) {\n            grid[r + i][c + size - 1 - i] = 'z';\n        }\n        // Fill top and bottom rows\n        for (int j = 0; j < size; ++j) {\n            grid[r][c + j] = 'z';\n            grid[r + size - 1][c + j] = 'z';\n        }\n    } else {\n        // Unknown type, default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2) ? 'z' : '.';\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"full_z\") {\n        // Fill the grid entirely with 'z's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, 'z');\n        }\n    } else if (type == \"full_dot\") {\n        // Grid is already initialized with '.'\n        // Do nothing\n    } else if (type == \"border_z\") {\n        // Fill the borders with 'z's, inside with '.'\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = 'z';\n            grid[i][m - 1] = 'z';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = 'z';\n            grid[n - 1][j] = 'z';\n        }\n    } else if (type == \"random\") {\n        // Randomly fill the grid with 'z's and '.'s\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2) ? 'z' : '.';\n            }\n        }\n    } else if (type == \"zigzag\") {\n        // Create a zigzag pattern designed to have many overlapping Z-patterns\n        int k = min(n, m);\n        for (int size = 1; size <= k; ++size) {\n            for (int r = 0; r <= n - size; r += size) {\n                for (int c = 0; c <= m - size; c += size) {\n                    // Fill anti-diagonal and borders for squares starting at (r, c) of size 'size'\n                    for (int i = 0; i < size; ++i) {\n                        // Fill anti-diagonal\n                        int row = r + i;\n                        int col = c + size - 1 - i;\n                        grid[row][col] = 'z';\n                    }\n                    // Fill top and bottom rows\n                    for (int j = 0; j < size; ++j) {\n                        grid[r][c + j] = 'z';\n                        grid[r + size - 1][c + j] = 'z';\n                    }\n                }\n            }\n        }\n    } else if (type == \"single_z\") {\n        // Place a single 'z' in the corner\n        grid[0][0] = 'z';\n    } else if (type == \"checkerboard\") {\n        // Alternating 'z's and '.'s\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = ((i + j) % 2 == 0) ? 'z' : '.';\n            }\n        }\n    } else if (type == \"max_k\") {\n        // Create a maximum size Z-pattern\n        int size = min(n, m);\n        int r = 0, c = 0;\n        // Fill anti-diagonal\n        for (int i = 0; i < size; ++i) {\n            grid[r + i][c + size - 1 - i] = 'z';\n        }\n        // Fill top and bottom rows\n        for (int j = 0; j < size; ++j) {\n            grid[r][c + j] = 'z';\n            grid[r + size - 1][c + j] = 'z';\n        }\n    } else {\n        // Unknown type, default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2) ? 'z' : '.';\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grids\n./gen -n 1 -m 1 -type full_z\n./gen -n 1 -m 1 -type full_dot\n./gen -n 1 -m 1 -type single_z\n./gen -n 2 -m 2 -type border_z\n./gen -n 5 -m 5 -type checkerboard\n./gen -n 10 -m 10 -type random\n\n# Grids with n or m = 1\n./gen -n 1 -m 3000 -type full_z\n./gen -n 1 -m 3000 -type random\n./gen -n 3000 -m 1 -type full_z\n./gen -n 3000 -m 1 -type random\n\n# Medium grids\n./gen -n 100 -m 100 -type checkerboard\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 200 -type border_z\n./gen -n 200 -m 100 -type border_z\n\n# Large grids\n./gen -n 3000 -m 3000 -type full_z\n./gen -n 3000 -m 3000 -type full_dot\n./gen -n 3000 -m 3000 -type checkerboard\n./gen -n 3000 -m 3000 -type random\n./gen -n 3000 -m 3000 -type zigzag\n./gen -n 3000 -m 3000 -type max_k\n\n# Grids with n and m prime numbers\n./gen -n 1009 -m 1013 -type random\n\n# Grids with different n and m\n./gen -n 10 -m 3000 -type border_z\n./gen -n 3000 -m 10 -type border_z\n\n# Single 'z' test case\n./gen -n 1000 -m 1000 -type single_z\n\n# More random grids\n./gen -n 3000 -m 3000 -type random\n./gen -n 3000 -m 3000 -type random\n./gen -n 3000 -m 3000 -type random\n\n# More zigzag grids\n./gen -n 3000 -m 3000 -type zigzag\n./gen -n 2000 -m 2000 -type zigzag\n./gen -n 1000 -m 1000 -type zigzag\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:53.775381",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "628/F",
      "title": "F. Медведь и справедливое множество",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся три целых числа n, b, q (5 ≤ n ≤ b ≤ 104, 1 ≤ q ≤ 104, n кратно 5) — количество элементов в множестве, верхняя граница для чисел множества и количество подсказок.В следующих q строках находятся описания подсказок. i-я из них содержит пару целых чисел upToi и quantityi (1 ≤ upToi ≤ b, 0 ≤ quantityi ≤ n).",
      "output_spec": "Выходные данныеВыведите ''fair\" если существует хотя бы одно множество, удовлетворяющее всем свойствам и подсказкам. В противном случае выведите ''unfair\".",
      "sample_tests": "ПримерыВходные данныеСкопировать10 20 110 10Выходные данныеСкопироватьfairВходные данныеСкопировать10 20 315 105 010 5Выходные данныеСкопироватьfairВходные данныеСкопировать10 20 215 320 10Выходные данныеСкопироватьunfair",
      "description": "F. Медведь и справедливое множество\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся три целых числа n, b, q (5 ≤ n ≤ b ≤ 104, 1 ≤ q ≤ 104, n кратно 5) — количество элементов в множестве, верхняя граница для чисел множества и количество подсказок.В следующих q строках находятся описания подсказок. i-я из них содержит пару целых чисел upToi и quantityi (1 ≤ upToi ≤ b, 0 ≤ quantityi ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите ''fair\" если существует хотя бы одно множество, удовлетворяющее всем свойствам и подсказкам. В противном случае выведите ''unfair\".\n\nВыходные данные\n\nВходные данныеСкопировать10 20 110 10Выходные данныеСкопироватьfairВходные данныеСкопировать10 20 315 105 010 5Выходные данныеСкопироватьfairВходные данныеСкопировать10 20 215 320 10Выходные данныеСкопироватьunfair\n\nВходные данныеСкопировать10 20 110 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьfair\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 20 315 105 010 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьfair\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 20 215 320 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьunfair\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере всем условиям удовлетворяет только множество {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.Во втором примере также существует только одно множество, удовлятворяющее всем условиям: {6, 7, 8, 9, 10, 11, 12, 13, 14, 15}.Легко видеть, что третий пример противоречив. Таким образом, Лимак вас обманул :-(",
      "solutions": [
        {
          "title": "Educational Codeforces Round 8 - Codeforces",
          "content": "Привет, Codeforces!19 февраля 2016 года в 18:00 MSK состоится восьмой учебный раунд Educational Codeforces Round 8 для участников из первого и второго дивизионов. Надеюсь плотность контестов на Codeforces в эти несколько дней вас не спугнёт и вы напишете ER8.<В конце добавилась фраза про простые задачи>О формате и деталях проведения учебных раундов я писал уже ранее. Также об учебных раундах вы можете прочитать здесь.Раунд будет нерейтинговым. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. На решение задач у вас будет два часа. После окончания раунда будет период времени длительностью в один день, в течение которых вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования. Таким образом вы можете локально тестировать решение, которое хотите взломать, или, например, запустить стресс-тест.Если у вас есть идеи каких-то задач, которые вам кажутся интересными, или может есть уже что-то почти готовое, что вы по каким-то причинам не можете дать на раунд (злой координатор сказал, что задача БАЯН), официальное соревнование (жюри не хочет переграбливать соревнование), можете писать мне.Не стесняйтесь присылать простые (и даже очень простые) задачи (но обязательно интересные). Почти каждый раунд достаточно быстро выбираются кандидаты для задач C, D, E, F, а вот задача A обычно ставится самой последней, когда уже почти всё готово.</В конце добавилась фраза про простые задачи>В этот раз, впервые, полностью комплект задач был предложен участниками сообщества. Задача А была предложена пользователем unprost. Задача B взята из комплекта, который прислали Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. Задачу D предложил Kareem Mohamed Kareem_Mohamed (я её правда сильно усложнил, чтобы вам было интереснее :-)). Задачу E прислал Ali Ahmadi Kuzey. Задачи C и F были предложены Камилом Дебовски Errichto.Благодарю их и всех кто присылает задачи или просто наброски!Подготовкой задач в этот раз занимался не только я (Эдвард Давтян). Большое спасибо Камилу Дебовски Errichto, который не только предложил задачи C и F, но и подготовил их. Спасибо Маше Беловой Delinur за проверку английских текстов условий. Также большое спасибо Ali Ahmadi Kuzey, который помогал с тестированием задач.На этом раунде вам по традиции будет предложено шесть задач.Вкратце опишу задачи: A) Простая задача с немаленьким условием; B) Надеюсь вы не будете здесь писать ничего сложного; C) Интересная; D) Немного техническая, содержит очень полезную технику; E) Мне эта задача очень нравится; F) Супер клёвая задача, если не удастся сдать на контесте рекомендую дорешать.Good luck and have fun!UPD1: Первая фаза соревнования закончена. Начались взломы. Разбор задач готов.Поскольку все задачи Errichto про медведей ниже находится иллюстрация к задаче C (Limak кажется первый слева):",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/23623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2921
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces",
          "content": "628A - Теннисный турнирЗадача предложена пользователем unprost.В этой задаче можно было просто промоделировать процесс. А можно было заметить, что после каждого матча один игрок выбывает. Всего выбывших n - 1. Таким образом, всего нам нужно (n - 1) * (2b + 1) бутылок воды. Полотенец, конечно, нам нужно np штук.С++ solution 1С++ solution 2Сложность: O(log2n), O(logn) или O(1) в зависимости от реализации.628B - Новый скейтбордЭта одна из задач предложенных пользователями Bayram Berdiyev bayram, Allanur Shiriyev Allanur, Bekmyrat Atayev Bekmyrat.A.Ключевым для решения задачи является наблюдение, что число делится на 4 тогда и только тогда, когда его последние две цифры делятся на 4. Таким образом, для подсчёта ответа достаточно сначала посчитать количество подстрок длины один. Далее нужно рассмотреть пары соседних цифр таких, что они образуют двузначное число кратное 4-м и прибавить к ответу индекс правого из них.C++ solutionСложность: O(n).628C - Медведь и расстояние между строкамиЗадачи предложена и подготовлена Камилем Дебовски Errichto.В этой задаче можно действовать жадно. Будем идти по строке слева направо. Рассмотрим наибольшее расстояние d, которое мы можем получить на этой позиции (это либо расстояние вниз до буквы 'a', либо вверх до буквы 'z'). Пусть v = min(d, k). Поставим на текущей позиции букву на расстоянии v (вниз или вверх), а значение k уменьшим на v. Если после обработки всей строки, k оказалось больше нуля, то ответа не существует. В противном случае мы нашли ответ.C++ solution 1C++ solution 2Сложность: O(n).628D - Волшебные числаБолее простую версию задачи предложил Kareem Mohamed Kareem_Mohamed.Обозначим ответ на задачу как f(a, b). Заметим, что f(a, b) = f(0, b) - f(0, a - 1) или что то же самое f(a, b) = f(0, b) - f(0, a) + g(a), где g(a) равно единице если a является волшебным число, иначе g(a) равно нулю. Далее будем решать задачу для отрезка [0, n].Далее приводится стандартная техника, которую иногда называют 'динамикой по цифрам'. Её можно реализовать двумя способами, в первом перебирается длина префикса числа, который совпадёт с префиксом числа n. Следующий символ может быть произвольным меньшим соответствующей цифры в n, а далее любые цифры. Но я расскажу о втором подходе.Пусть zijk равно количеству волшебных префиксов длины i, дающих остаток j при делении на m. При этом если k = 0, то префикс должен быть строго меньше префикса числа n, а если k = 1, то префикс должен быть равен префиксу числа n (больше он быть не может). Будем делать динамику вперёд. Переберём цифру , которую мы поставим на позиции i. При этом нам нужно проверить, что если позиция чётна то эта цифра должна быть равна d, а в противном случае она не может быть равна d. Также нужно проверить, что если k = 1, то эта цифра не может быть больше соответствующей цифры в числе n. Теперь поймём в какое состояние мы попадём после такого перехода. Конечно, i' = i + 1. Согласно схеме Горнера j' = (10j + p) mod m. Легко видеть, что . Для перехода нужно сделать zi'j'k' +  = zijk. Конечно, нужно не забыть делать все операции по модулю 109 + 7.C++ solutionСложность: O(nm).628E - Zbazi в ZeydabadЗадача предложена Ali Ahmadi Kuzey.Давайте сначала сделаем предподсчёт zlij, zrij, zldij — наибольшее количество букв 'z' влево, вправо и влево-вниз от позиции (i, j). Это легко сделать за O(nm). Пусть мы зафиксировали некоторую клетку (i, j). Рассмотрим величину c = min(zlij, zldij). Это наибольший допустимый размер квадрата с верхним правым углом в (i, j). Теперь поймём сколько таких квадратов. Рассмотрим произвольную клетку (x, y) по диагонали вниз-влево на расстоянии не более c. Пара клеток (i, j) и (x, y) образует z-паттерн, если y + zrxy > j.Отлично, теперь для решения задачи заведём структуру данных для каждой диагонали (она определяется формулой x + y), которая умеет прибавлять в точке и брать сумму на отрезке (лучше всего для этого подходит дерево Фенвика). Будем перебирать столбец j справа налево и обрабатывать события: некоторая клетка (x, y) такова, что y + zrxy - 1 = j. В этом случае нам нужно в дереве номер x + y сделать прибавление в точке y на единицу. Теперь будем перебирать клетку в текущем столбце (i, j). Тогда к ответу нужно прибавить величину суммы в дереве номер i + j на отрезке от j - c + 1 до j.С++ solutionСложность: O(nmlogm).628F - Медведь и справедливое множествоЗадача предложена и подготовлена Камилем Дебовски Errichto.Вначале для удобства добавим подсказку с upTo = b, quantity = n, а затем отсортируем подсказки по значению upTo. Отсортированные подсказки разбивают интервал [1, b] на q непересекающихся промежутка. Для каждого промежутка мы знаем количество элементов в нём.Для решения задачи построим сеть (описанную ниже) и найдём в ней максимальный поток. Ответ fair только если величина потока равна n. Первая группа вершин в сети A будет содержать 5 вершин, обозначающих возмоджные остатки. Вторая группа вершин B будет содержать q вершин, обозначающих промежутки. Соединим каждую вершину из A с истоком ребром пропускной способности . Каждую вершину из B соединим со стоком ребром пропускной способности равной количеству чисел в этом промежутке. Между всему вершинами x из A и y из B добавим ребро пропускной способности равной количеству чисел в промежутке с остатком x в промежутке y.Легко видеть, что поток в данной сети очень похож на паросочетание. В самом деле мы можем воспользоваться теоремой Холла. Для каждого из 25 множеств вершин из A (множества остатков) пройдём по всем промежуткам и посчитаем количество чисел, которые мы можем взять в [1, b] с остатками в заданном множестве.Реализицая с теоремой Холла: C++ solution.Сложность: O(2Cn), где в нашей задаче C = 5.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 628\\s*F"
          },
          "content_length": 5664
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 1",
          "code": "x = ...01111.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 2",
          "code": "...01111 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Educational Codeforces Round 8 - Codeforces - Code 3",
          "code": "...01110 + 1 =",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43203",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(5, 10000, \"n\");\n    inf.readSpace();\n    int b = inf.readInt(n, 10000, \"b\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n\n    ensuref(n % 5 == 0, \"n must be divisible by 5, but n mod 5 = %d\", n % 5);\n\n    for (int i = 0; i < q; i++) {\n        int upTo_i = inf.readInt(1, b, \"upTo_i\");\n        inf.readSpace();\n        int quantity_i = inf.readInt(0, n, \"quantity_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(5, 10000, \"n\");\n    inf.readSpace();\n    int b = inf.readInt(n, 10000, \"b\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n\n    ensuref(n % 5 == 0, \"n must be divisible by 5, but n mod 5 = %d\", n % 5);\n\n    for (int i = 0; i < q; i++) {\n        int upTo_i = inf.readInt(1, b, \"upTo_i\");\n        inf.readSpace();\n        int quantity_i = inf.readInt(0, n, \"quantity_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(5, 10000, \"n\");\n    inf.readSpace();\n    int b = inf.readInt(n, 10000, \"b\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n\n    ensuref(n % 5 == 0, \"n must be divisible by 5, but n mod 5 = %d\", n % 5);\n\n    for (int i = 0; i < q; i++) {\n        int upTo_i = inf.readInt(1, b, \"upTo_i\");\n        inf.readSpace();\n        int quantity_i = inf.readInt(0, n, \"quantity_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int b = opt<int>(\"b\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"fair\");\n\n    // Ensure n is divisible by 5\n    if (n % 5 != 0) {\n        n = n / 5 * 5;\n        if (n < 5) n = 5;\n    }\n    if (b < n) b = n;\n\n    if (type == \"fair\") {\n        // Prepare residue numbers\n        vector<int> residue_numbers[5];\n\n        int remainder = 1 % 5;\n        for (int r = 0; r < 5; ++r) {\n            int m_r;\n            if (remainder <= r)\n                m_r = 1 + (r - remainder);\n            else\n                m_r = 1 + (r - remainder + 5);\n            for (int num = m_r; num <= b; num +=5) {\n                residue_numbers[r].push_back(num);\n            }\n        }\n\n        // Check if there are enough numbers in each residue class\n        bool possible = true;\n        for (int r = 0; r < 5; ++r) {\n            if (residue_numbers[r].size() < n / 5) {\n                possible = false;\n                break;\n            }\n        }\n        if (!possible) {\n            // Adjust b\n            b += 5;\n            // Rebuild residue_numbers\n            for (int r = 0; r < 5; ++r) {\n                residue_numbers[r].clear();\n            }\n            for (int r = 0; r < 5; ++r) {\n                int m_r;\n                if (remainder <= r)\n                    m_r = 1 + (r - remainder);\n                else\n                    m_r = 1 + (r - remainder + 5);\n                for (int num = m_r; num <= b; num +=5) {\n                    residue_numbers[r].push_back(num);\n                }\n            }\n        }\n\n        // For each residue class, pick n/5 numbers\n        vector<int> S;\n\n        for (int r = 0; r < 5; ++r) {\n            // Shuffle residue_numbers[r]\n            shuffle(residue_numbers[r].begin(), residue_numbers[r].end());\n            // Take first n/5 numbers\n            for (int i = 0; i < n / 5; ++i) {\n                S.push_back(residue_numbers[r][i]);\n            }\n        }\n\n        // Sort S\n        sort(S.begin(), S.end());\n\n        // Generate hints\n        vector<pair<int,int>> hints;\n\n        for (int i = 0; i < q; ++i) {\n            int upTo_i = rnd.next(1, b);\n            int quantity_i = upper_bound(S.begin(), S.end(), upTo_i) - S.begin();\n            hints.push_back({upTo_i, quantity_i});\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, b, q);\n        for (auto h : hints) {\n            printf(\"%d %d\\n\", h.first, h.second);\n        }\n\n    } else if (type == \"unfair\") {\n        // Generate hints with contradictions\n\n        vector<pair<int,int>> hints;\n\n        for (int i = 0; i < q; ++i) {\n            int upTo_i = rnd.next(1, b);\n            int quantity_i = rnd.next(0, n);\n            hints.push_back({upTo_i, quantity_i});\n        }\n\n        // Introduce a contradiction\n        if (q >=2) {\n            int idx1 = rnd.next(0, q - 1);\n            int idx2 = rnd.next(0, q - 1);\n            while (idx2 == idx1) {\n                idx2 = rnd.next(0, q - 1);\n            }\n            // Set upTo_i equal\n            hints[idx1].first = hints[idx2].first;\n            // Ensure quantity_i != quantity_j\n            if (hints[idx1].second == hints[idx2].second) {\n                if (hints[idx1].second == n) {\n                    hints[idx1].second -= 1;\n                } else {\n                    hints[idx1].second += 1;\n                }\n                if (hints[idx1].second < 0) hints[idx1].second = 0;\n                if (hints[idx1].second > n) hints[idx1].second = n;\n            }\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, b, q);\n        for (auto h : hints) {\n            printf(\"%d %d\\n\", h.first, h.second);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int b = opt<int>(\"b\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"fair\");\n\n    // Ensure n is divisible by 5\n    if (n % 5 != 0) {\n        n = n / 5 * 5;\n        if (n < 5) n = 5;\n    }\n    if (b < n) b = n;\n\n    if (type == \"fair\") {\n        // Prepare residue numbers\n        vector<int> residue_numbers[5];\n\n        int remainder = 1 % 5;\n        for (int r = 0; r < 5; ++r) {\n            int m_r;\n            if (remainder <= r)\n                m_r = 1 + (r - remainder);\n            else\n                m_r = 1 + (r - remainder + 5);\n            for (int num = m_r; num <= b; num +=5) {\n                residue_numbers[r].push_back(num);\n            }\n        }\n\n        // Check if there are enough numbers in each residue class\n        bool possible = true;\n        for (int r = 0; r < 5; ++r) {\n            if (residue_numbers[r].size() < n / 5) {\n                possible = false;\n                break;\n            }\n        }\n        if (!possible) {\n            // Adjust b\n            b += 5;\n            // Rebuild residue_numbers\n            for (int r = 0; r < 5; ++r) {\n                residue_numbers[r].clear();\n            }\n            for (int r = 0; r < 5; ++r) {\n                int m_r;\n                if (remainder <= r)\n                    m_r = 1 + (r - remainder);\n                else\n                    m_r = 1 + (r - remainder + 5);\n                for (int num = m_r; num <= b; num +=5) {\n                    residue_numbers[r].push_back(num);\n                }\n            }\n        }\n\n        // For each residue class, pick n/5 numbers\n        vector<int> S;\n\n        for (int r = 0; r < 5; ++r) {\n            // Shuffle residue_numbers[r]\n            shuffle(residue_numbers[r].begin(), residue_numbers[r].end());\n            // Take first n/5 numbers\n            for (int i = 0; i < n / 5; ++i) {\n                S.push_back(residue_numbers[r][i]);\n            }\n        }\n\n        // Sort S\n        sort(S.begin(), S.end());\n\n        // Generate hints\n        vector<pair<int,int>> hints;\n\n        for (int i = 0; i < q; ++i) {\n            int upTo_i = rnd.next(1, b);\n            int quantity_i = upper_bound(S.begin(), S.end(), upTo_i) - S.begin();\n            hints.push_back({upTo_i, quantity_i});\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, b, q);\n        for (auto h : hints) {\n            printf(\"%d %d\\n\", h.first, h.second);\n        }\n\n    } else if (type == \"unfair\") {\n        // Generate hints with contradictions\n\n        vector<pair<int,int>> hints;\n\n        for (int i = 0; i < q; ++i) {\n            int upTo_i = rnd.next(1, b);\n            int quantity_i = rnd.next(0, n);\n            hints.push_back({upTo_i, quantity_i});\n        }\n\n        // Introduce a contradiction\n        if (q >=2) {\n            int idx1 = rnd.next(0, q - 1);\n            int idx2 = rnd.next(0, q - 1);\n            while (idx2 == idx1) {\n                idx2 = rnd.next(0, q - 1);\n            }\n            // Set upTo_i equal\n            hints[idx1].first = hints[idx2].first;\n            // Ensure quantity_i != quantity_j\n            if (hints[idx1].second == hints[idx2].second) {\n                if (hints[idx1].second == n) {\n                    hints[idx1].second -= 1;\n                } else {\n                    hints[idx1].second += 1;\n                }\n                if (hints[idx1].second < 0) hints[idx1].second = 0;\n                if (hints[idx1].second > n) hints[idx1].second = n;\n            }\n        }\n\n        // Output\n        printf(\"%d %d %d\\n\", n, b, q);\n        for (auto h : hints) {\n            printf(\"%d %d\\n\", h.first, h.second);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -b 5 -q 1 -type fair\n./gen -n 5 -b 5 -q 1 -type unfair\n\n./gen -n 10 -b 10 -q 5 -type fair\n./gen -n 10 -b 10 -q 3 -type unfair\n\n./gen -n 100 -b 200 -q 50 -type fair\n./gen -n 100 -b 200 -q 50 -type unfair\n\n./gen -n 1000 -b 1000 -q 500 -type fair\n./gen -n 1000 -b 1000 -q 500 -type unfair\n\n./gen -n 5000 -b 10000 -q 1000 -type fair\n./gen -n 5000 -b 10000 -q 1000 -type unfair\n\n./gen -n 10000 -b 10000 -q 10000 -type fair\n./gen -n 10000 -b 10000 -q 10000 -type unfair\n\n./gen -n 5 -b 10 -q 2 -type fair\n./gen -n 5 -b 10 -q 2 -type unfair\n\n./gen -n 15 -b 20 -q 10 -type fair\n./gen -n 15 -b 20 -q 10 -type unfair\n\n./gen -n 20 -b 50 -q 5 -type fair\n./gen -n 20 -b 50 -q 5 -type unfair\n\n./gen -n 25 -b 30 -q 5 -type fair\n./gen -n 25 -b 30 -q 5 -type unfair\n\n./gen -n 500 -b 500 -q 100 -type fair\n./gen -n 500 -b 500 -q 100 -type unfair\n\n./gen -n 1000 -b 10000 -q 1000 -type fair\n./gen -n 1000 -b 10000 -q 1000 -type unfair\n\n./gen -n 9995 -b 10000 -q 999 -type fair\n./gen -n 9995 -b 10000 -q 999 -type unfair\n\n./gen -n 5 -b 1000 -q 500 -type fair\n./gen -n 5 -b 1000 -q 500 -type unfair\n\n./gen -n 9995 -b 9995 -q 9995 -type fair\n./gen -n 9995 -b 9995 -q 9995 -type unfair\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:55.821692",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "629/A",
      "title": "A. Far Relative’s Birthday Cake",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line of the input, you are given a single integer n (1 ≤ n ≤ 100) — the length of the side of the cake.Then follow n lines, each containing n characters. Empty cells are denoted with '.', while cells that contain chocolates are denoted by 'C'.",
      "output_spec": "OutputPrint the value of Famil Door's happiness, i.e. the number of pairs of chocolate pieces that share the same row or the same column.",
      "sample_tests": "ExamplesInputCopy3.CCC..C.COutputCopy4InputCopy4CC..C..C.CC..CC.OutputCopy9",
      "description": "A. Far Relative’s Birthday Cake\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputIn the first line of the input, you are given a single integer n (1 ≤ n ≤ 100) — the length of the side of the cake.Then follow n lines, each containing n characters. Empty cells are denoted with '.', while cells that contain chocolates are denoted by 'C'.\n\nOutputPrint the value of Famil Door's happiness, i.e. the number of pairs of chocolate pieces that share the same row or the same column.\n\nInputCopy3.CCC..C.COutputCopy4InputCopy4CC..C..C.CC..CC.OutputCopy9\n\nInputCopy3.CCC..C.C\n\nOutputCopy4\n\nInputCopy4CC..C..C.CC..CC.\n\nOutputCopy9\n\nNoteIf we number rows from top to bottom and columns from left to right, then, pieces that share the same row in the first sample are:   (1, 2) and (1, 3)  (3, 1) and (3, 3)  Pieces that share the same column are:   (2, 1) and (3, 1)  (1, 3) and (3, 3)",
      "solutions": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I have the pleasure to invite you to the round #343 which is going to take place on Saturday! This round is consisted of 5 problems and you have 2 hours (as usual) to solve them.The problemsetters are Mohammad Amin Vahedinia (Me) (MrNull), Daneshvar Amrollahi (dkjsfkhg) and Alireza Tofighi (ATofighi). We would also like to thank Alireza Tofighi (ATofighi) and Ali Asadi (aliasadiiii) for testing this round and Ali Bahjati (LiTi) for helping us preparing this round.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, and, of course, MikeMirzayanov for unique Codeforces and Polygon platforms.This contest's Hero is Famile Door and his friends who are preparing his birthday party!UPDATE 1: Scoring Distribution is 500 — 1000 — 1750 — 2000 — 2500UPDATE 2: Editorial is ready HEREUPDATE 3: System Testing is finished you can see the standings here: standingsCongrats to the div2 Winners:1. rakhashov.maksat2. DarthMaul3. TakeTheAegisIDontNeedIt4. ykaya5. abcdef6199Also congrats to the div1 Winners:1. Um_nik2. anta3. Nerevar4. kmjp5. vintage_Vlad_MakeevBest of luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/24159",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1187
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces",
          "content": "Problem A:Consider that we have rowi chocolates in the i'th row and coli chocolates in the i'th column.The answer to the problem would be: . It is obvious that every pair would be calculated exactly once (as we have no more than one chocolate in the same square)Time Complexity: O(n2)C++ SolutionProblem B:Consider that we have boyi males in the i'th day of the year and girli females in the i'th day of the year. These arrays can be filled easily when you are reading the input (See the code). Then for the i'th day of the year, we could have 2 * min(boyi , girli) people which could come to the party. The answer would be maximum of this value between all days i (1 ≤ i ≤ 366)Time Complexity: O(366*n)C++ SolutionBonus: Try to solve this problem with O(n). For each interval given in the input, you don't need to iterate from day ai to day bi. This idea is used to solve problem 276C.Problem C:This problem can be solved with dynamic programming:1. Calculate dpi, j : How many sequences of brackets of length i has balance j and intermediate balance never goes below zero (They form a prefix of a valid sequence of brackets).2. For the given sequence of length n calculate the resulting balance a and the minimum balance b.3. Try the length of the sequence added at the beginning c and its balance d. If  - b ≤ d then add dpc, d × dpm - n - c, d + a to the answer.Time complexity: O((n - m)2)C++ SolutionProblem D:First of all, we calculate the volume of each cake: vi = π × hi × ri2. Now consider the sequence v1, v2, v3, ..., vn : The answer to the problem is the maximum sum of elements between all increasing sub-sequences of this sequence. How do we solve this? First to get rid of the decimals we can define a new sequence a1, a2, a3, ..., an such that We consider dpi as the maximum sum between all the sequences which end with ai anddpi = The answer to the problem is: π × maxi = 1ndp[i]Now how do we calculate ? We use a max-segment tree which does these two operations: 1. Change the i't member to v. 2. Find the maximum value in the interval 1 to i.Now we use this segment tree for the array dp and find the answer.Consider that a1, a2, a3, ..., an is sorted. We define bi as the position of ai. Now to fill dpi we find the maximum in the interval [1, bi) in segment and we call it x and we set the bi th index of the segment as ai + x. The answer to the problem would the maximum in the segment in the interval [1,n]Time complexity: O(nlgn)Thanks to ATofighi who helped a lot for writing the editorial of problem D.C++ SolutionProblem E:First of all, we assume that the tree is rooted! For this problem, first we need to compute some values for each vertex u: qdu and quu, cntu , paru, i and hu. qdu equals to the expected value of length of paths which start from vertex u, and ends in u’s subtree and also has length at least 1. quu equals to the expected value of length of paths which start from vertex u, and not ends in u’s subtree and also has length at least 1. to calculate this values we can use one dfs for qd, and one other dfs for qu. \\ cntu is the number of vertices in u’s subtree except u, paru, i is the 2i ‘th ancestor of u and finally hu is the height of the vertex u. \\ in first dfs (lets call it dfsdown) we can calculate qd, cnt and par array with this formulas: for ecah $v$ as child of u and paru, i = parparu, i - 1, i - 1in second dfs (lets call it dfsup) we calculate qu using this formula (for clearer formula, I may define some extra variables):there are two cases:u is the only child of its parent: let then \\u is not the only child of its parent: let then now we should process the queries. For each query u and v, we have to cases: one of the vertices is either one of the ancestors of the other one or not! In the first case, if we define w the vertex before u (u is assumed to be the vertex with lower height). In the path from v to u, the answer is .In the second case, if we assume w = LCA(u, v), then answer is To check if u is one of ancestors of v, you can check if their LCA equals to u or you can use dfs to find out their starting and finishing time. u is an ancestor of v if the interval of starting and finishing time of v is completely inside starting and finishing time of uThe time complexity for the whole solution is O(n + mlgn) (O(n) for dfs and O(lgn) for each query so O(mlgn) for queries!). C++ Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43227",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4370
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 1",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 2",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 3",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 4",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 5",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 6",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 1",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 2",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 3",
          "code": "Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 4",
          "code": "(cylinder_volume,max_total_volume_with_this_cylinder_at_top)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 5",
          "code": "(V , list[j-1].max_total_volume + V)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 6",
          "code": "max_total_volume value is <= list[j].max_total_volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 7",
          "code": "Now the key thing to realize here is, that number of expressions with balance X is equal to number of expressions with balance -X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 8",
          "code": "dp[prefix_length][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 9",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 10",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[\\\\.C]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[\\\\.C]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[\\\\.C]{\" + to_string(n) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"line\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    double density = opt<double>(\"density\", -1.0); // for 'random' type\n\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"empty\") {\n        // All cells are '.'\n        // grid already initialized to '.'\n    } else if (type == \"full\") {\n        // All cells are 'C'\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'C');\n        }\n    } else if (type == \"single\") {\n        // Only one 'C' at the center\n        grid[n / 2][n / 2] = 'C';\n    } else if (type == \"single-row\") {\n        // 'C's only in one row\n        int row = n / 2;\n        for (int j = 0; j < n; ++j) {\n            grid[row][j] = 'C';\n        }\n    } else if (type == \"single-column\") {\n        // 'C's only in one column\n        int col = n / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i][col] = 'C';\n        }\n    } else if (type == \"diagonal\") {\n        // 'C's along the main diagonal\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = 'C';\n        }\n    } else if (type == \"anti-diagonal\") {\n        // 'C's along the anti-diagonal\n        for (int i = 0; i < n; ++i) {\n            grid[i][n - i - 1] = 'C';\n        }\n    } else if (type == \"checkerboard\") {\n        // 'C's in a checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = 'C';\n            }\n        }\n    } else if (type == \"max-pairs\") {\n        // Grid designed to have maximum pairs\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'C');\n        }\n    } else if (type == \"min-pairs\") {\n        // Place 'C's such that no two 'C's are in the same row or column\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = 'C';\n        }\n    } else if (type == \"random\") {\n        // Random grid with specified density\n        if (density < 0 || density > 1) {\n            density = 0.5; // default density\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    } else if (type == \"random-sparse\") {\n        // Random grid with low density\n        density = 0.1;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    } else if (type == \"random-dense\") {\n        // Random grid with high density\n        density = 0.9;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    } else {\n        // Default to 'random' if unknown type\n        if (density < 0 || density > 1) {\n            density = 0.5; // default density\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    }\n\n    // Output n and the grid\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    double density = opt<double>(\"density\", -1.0); // for 'random' type\n\n    vector<string> grid(n, string(n, '.'));\n\n    if (type == \"empty\") {\n        // All cells are '.'\n        // grid already initialized to '.'\n    } else if (type == \"full\") {\n        // All cells are 'C'\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'C');\n        }\n    } else if (type == \"single\") {\n        // Only one 'C' at the center\n        grid[n / 2][n / 2] = 'C';\n    } else if (type == \"single-row\") {\n        // 'C's only in one row\n        int row = n / 2;\n        for (int j = 0; j < n; ++j) {\n            grid[row][j] = 'C';\n        }\n    } else if (type == \"single-column\") {\n        // 'C's only in one column\n        int col = n / 2;\n        for (int i = 0; i < n; ++i) {\n            grid[i][col] = 'C';\n        }\n    } else if (type == \"diagonal\") {\n        // 'C's along the main diagonal\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = 'C';\n        }\n    } else if (type == \"anti-diagonal\") {\n        // 'C's along the anti-diagonal\n        for (int i = 0; i < n; ++i) {\n            grid[i][n - i - 1] = 'C';\n        }\n    } else if (type == \"checkerboard\") {\n        // 'C's in a checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = 'C';\n            }\n        }\n    } else if (type == \"max-pairs\") {\n        // Grid designed to have maximum pairs\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, 'C');\n        }\n    } else if (type == \"min-pairs\") {\n        // Place 'C's such that no two 'C's are in the same row or column\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = 'C';\n        }\n    } else if (type == \"random\") {\n        // Random grid with specified density\n        if (density < 0 || density > 1) {\n            density = 0.5; // default density\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    } else if (type == \"random-sparse\") {\n        // Random grid with low density\n        density = 0.1;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    } else if (type == \"random-dense\") {\n        // Random grid with high density\n        density = 0.9;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    } else {\n        // Default to 'random' if unknown type\n        if (density < 0 || density > 1) {\n            density = 0.5; // default density\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (rnd.next() < density)\n                    grid[i][j] = 'C';\n            }\n    }\n\n    // Output n and the grid\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type empty\n./gen -n 1 -type full\n./gen -n 1 -type random\n\n./gen -n 2 -type empty\n./gen -n 2 -type full\n./gen -n 2 -type diagonal\n\n./gen -n 3 -type empty\n./gen -n 3 -type full\n./gen -n 3 -type diagonal\n./gen -n 3 -type anti-diagonal\n./gen -n 3 -type checkerboard\n./gen -n 3 -type random\n\n./gen -n 10 -type single\n./gen -n 10 -type single-row\n./gen -n 10 -type single-column\n./gen -n 10 -type checkerboard\n./gen -n 10 -type random\n\n./gen -n 50 -type empty\n./gen -n 50 -type full\n./gen -n 50 -type diagonal\n./gen -n 50 -type anti-diagonal\n./gen -n 50 -type random\n\n./gen -n 75 -type max-pairs\n./gen -n 75 -type min-pairs\n./gen -n 75 -type random-sparse\n./gen -n 75 -type random-dense\n\n./gen -n 100 -type empty\n./gen -n 100 -type full\n./gen -n 100 -type checkerboard\n./gen -n 100 -type random -density 0.25\n./gen -n 100 -type random -density 0.75\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:57.947329",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "629/B",
      "title": "B. Дальние-дальние друзья",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано единственное число n (1 ≤ n ≤ 5000) — количество друзей у Фомы Дора.Затем следует n строк, каждая из которых описывает одного друга. Строка начинается с заглавной английской 'F', если это друг женского пола, и заглавной английской 'M', если мужского. Затем идут два целых числа ai и bi (1 ≤ ai ≤ bi ≤ 366), которые означают, что i-й друг может приехать в любой день между ai и bi включительно.",
      "output_spec": "Выходные данныеВыведите максимально возможное количество гостей на вечеринке Фомы Дора.",
      "sample_tests": "ПримерыВходные данныеСкопировать4M 151 307F 343 352F 117 145M 24 128Выходные данныеСкопировать2Входные данныеСкопировать6M 128 130F 128 131F 131 140F 131 141M 131 200M 140 200Выходные данныеСкопировать4",
      "description": "B. Дальние-дальние друзья\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано единственное число n (1 ≤ n ≤ 5000) — количество друзей у Фомы Дора.Затем следует n строк, каждая из которых описывает одного друга. Строка начинается с заглавной английской 'F', если это друг женского пола, и заглавной английской 'M', если мужского. Затем идут два целых числа ai и bi (1 ≤ ai ≤ bi ≤ 366), которые означают, что i-й друг может приехать в любой день между ai и bi включительно.\n\nВходные данные\n\nВыходные данныеВыведите максимально возможное количество гостей на вечеринке Фомы Дора.\n\nВыходные данные\n\nВходные данныеСкопировать4M 151 307F 343 352F 117 145M 24 128Выходные данныеСкопировать2Входные данныеСкопировать6M 128 130F 128 131F 131 140F 131 141M 131 200M 140 200Выходные данныеСкопировать4\n\nВходные данныеСкопировать4M 151 307F 343 352F 117 145M 24 128\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6M 128 130F 128 131F 131 140F 131 141M 131 200M 140 200\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере друзья 3 и 4 могут прийти в любой день между 117 и 128 включительно.Во втором примере друзья с номерами 3, 4, 5 и 6 могут прийти в день 140.",
      "solutions": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I have the pleasure to invite you to the round #343 which is going to take place on Saturday! This round is consisted of 5 problems and you have 2 hours (as usual) to solve them.The problemsetters are Mohammad Amin Vahedinia (Me) (MrNull), Daneshvar Amrollahi (dkjsfkhg) and Alireza Tofighi (ATofighi). We would also like to thank Alireza Tofighi (ATofighi) and Ali Asadi (aliasadiiii) for testing this round and Ali Bahjati (LiTi) for helping us preparing this round.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, and, of course, MikeMirzayanov for unique Codeforces and Polygon platforms.This contest's Hero is Famile Door and his friends who are preparing his birthday party!UPDATE 1: Scoring Distribution is 500 — 1000 — 1750 — 2000 — 2500UPDATE 2: Editorial is ready HEREUPDATE 3: System Testing is finished you can see the standings here: standingsCongrats to the div2 Winners:1. rakhashov.maksat2. DarthMaul3. TakeTheAegisIDontNeedIt4. ykaya5. abcdef6199Also congrats to the div1 Winners:1. Um_nik2. anta3. Nerevar4. kmjp5. vintage_Vlad_MakeevBest of luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/24159",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1187
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces",
          "content": "Problem A:Consider that we have rowi chocolates in the i'th row and coli chocolates in the i'th column.The answer to the problem would be: . It is obvious that every pair would be calculated exactly once (as we have no more than one chocolate in the same square)Time Complexity: O(n2)C++ SolutionProblem B:Consider that we have boyi males in the i'th day of the year and girli females in the i'th day of the year. These arrays can be filled easily when you are reading the input (See the code). Then for the i'th day of the year, we could have 2 * min(boyi , girli) people which could come to the party. The answer would be maximum of this value between all days i (1 ≤ i ≤ 366)Time Complexity: O(366*n)C++ SolutionBonus: Try to solve this problem with O(n). For each interval given in the input, you don't need to iterate from day ai to day bi. This idea is used to solve problem 276C.Problem C:This problem can be solved with dynamic programming:1. Calculate dpi, j : How many sequences of brackets of length i has balance j and intermediate balance never goes below zero (They form a prefix of a valid sequence of brackets).2. For the given sequence of length n calculate the resulting balance a and the minimum balance b.3. Try the length of the sequence added at the beginning c and its balance d. If  - b ≤ d then add dpc, d × dpm - n - c, d + a to the answer.Time complexity: O((n - m)2)C++ SolutionProblem D:First of all, we calculate the volume of each cake: vi = π × hi × ri2. Now consider the sequence v1, v2, v3, ..., vn : The answer to the problem is the maximum sum of elements between all increasing sub-sequences of this sequence. How do we solve this? First to get rid of the decimals we can define a new sequence a1, a2, a3, ..., an such that We consider dpi as the maximum sum between all the sequences which end with ai anddpi = The answer to the problem is: π × maxi = 1ndp[i]Now how do we calculate ? We use a max-segment tree which does these two operations: 1. Change the i't member to v. 2. Find the maximum value in the interval 1 to i.Now we use this segment tree for the array dp and find the answer.Consider that a1, a2, a3, ..., an is sorted. We define bi as the position of ai. Now to fill dpi we find the maximum in the interval [1, bi) in segment and we call it x and we set the bi th index of the segment as ai + x. The answer to the problem would the maximum in the segment in the interval [1,n]Time complexity: O(nlgn)Thanks to ATofighi who helped a lot for writing the editorial of problem D.C++ SolutionProblem E:First of all, we assume that the tree is rooted! For this problem, first we need to compute some values for each vertex u: qdu and quu, cntu , paru, i and hu. qdu equals to the expected value of length of paths which start from vertex u, and ends in u’s subtree and also has length at least 1. quu equals to the expected value of length of paths which start from vertex u, and not ends in u’s subtree and also has length at least 1. to calculate this values we can use one dfs for qd, and one other dfs for qu. \\ cntu is the number of vertices in u’s subtree except u, paru, i is the 2i ‘th ancestor of u and finally hu is the height of the vertex u. \\ in first dfs (lets call it dfsdown) we can calculate qd, cnt and par array with this formulas: for ecah $v$ as child of u and paru, i = parparu, i - 1, i - 1in second dfs (lets call it dfsup) we calculate qu using this formula (for clearer formula, I may define some extra variables):there are two cases:u is the only child of its parent: let then \\u is not the only child of its parent: let then now we should process the queries. For each query u and v, we have to cases: one of the vertices is either one of the ancestors of the other one or not! In the first case, if we define w the vertex before u (u is assumed to be the vertex with lower height). In the path from v to u, the answer is .In the second case, if we assume w = LCA(u, v), then answer is To check if u is one of ancestors of v, you can check if their LCA equals to u or you can use dfs to find out their starting and finishing time. u is an ancestor of v if the interval of starting and finishing time of v is completely inside starting and finishing time of uThe time complexity for the whole solution is O(n + mlgn) (O(n) for dfs and O(lgn) for each query so O(mlgn) for queries!). C++ Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43227",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4370
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 1",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 2",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 3",
          "code": "кол-во '(' >= кол-во ')'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 4",
          "code": "52224523173403512.0000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 5",
          "code": "52192519806537609.261718750",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 6",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 7",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 8",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 9",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 1",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 2",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 3",
          "code": "Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 4",
          "code": "(cylinder_volume,max_total_volume_with_this_cylinder_at_top)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 5",
          "code": "(V , list[j-1].max_total_volume + V)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 6",
          "code": "max_total_volume value is <= list[j].max_total_volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 7",
          "code": "Now the key thing to realize here is, that number of expressions with balance X is equal to number of expressions with balance -X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 8",
          "code": "dp[prefix_length][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 9",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 10",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        char gender = inf.readChar();\n        ensuref(gender == 'F' || gender == 'M', \"Gender must be 'F' or 'M', but found '%c'\", gender);\n\n        inf.readSpace();\n\n        int ai = inf.readInt(1, 366, \"ai\");\n\n        inf.readSpace();\n\n        int bi = inf.readInt(1, 366, \"bi\");\n\n        ensuref(ai <= bi, \"ai must be less than or equal to bi, but ai=%d, bi=%d\", ai, bi);\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        char gender = inf.readChar();\n        ensuref(gender == 'F' || gender == 'M', \"Gender must be 'F' or 'M', but found '%c'\", gender);\n\n        inf.readSpace();\n\n        int ai = inf.readInt(1, 366, \"ai\");\n\n        inf.readSpace();\n\n        int bi = inf.readInt(1, 366, \"bi\");\n\n        ensuref(ai <= bi, \"ai must be less than or equal to bi, but ai=%d, bi=%d\", ai, bi);\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        char gender = inf.readChar();\n        ensuref(gender == 'F' || gender == 'M', \"Gender must be 'F' or 'M', but found '%c'\", gender);\n\n        inf.readSpace();\n\n        int ai = inf.readInt(1, 366, \"ai\");\n\n        inf.readSpace();\n\n        int bi = inf.readInt(1, 366, \"bi\");\n\n        ensuref(ai <= bi, \"ai must be less than or equal to bi, but ai=%d, bi=%d\", ai, bi);\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> genders(n);\n    vector<int> a(n), b(n);\n\n    if (type == \"max_male\") {\n        // All male friends\n        for (int i = 0; i < n; ++i) {\n            genders[i] = 'M';\n        }\n        // Generate random ranges\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else if (type == \"max_female\") {\n        // All female friends\n        for (int i = 0; i < n; ++i) {\n            genders[i] = 'F';\n        }\n        // Generate random ranges\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else if (type == \"all_same_range\") {\n        // Alternate genders to have equal males and females\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = 100;\n            b[i] = 200;\n        }\n    } else if (type == \"non_overlapping\") {\n        // Non-overlapping ranges\n        int day = 1;\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = day;\n            b[i] = day;\n            day++;\n            if (day > 366) day = 1;\n        }\n    } else if (type == \"random\") {\n        // Random genders and ranges\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (rnd.next(0, 1) == 0) ? 'M' : 'F';\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else if (type == \"single_day_ranges\") {\n        // Ranges of length 1\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            int day = rnd.next(1, 366);\n            a[i] = b[i] = day;\n        }\n    } else if (type == \"full_range\") {\n        // Ranges from 1 to 366\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = 1;\n            b[i] = 366;\n        }\n    } else if (type == \"edge_days\") {\n        // Ranges at the start or end of the year\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            if (i % 2 == 0) {\n                a[i] = 1;\n                b[i] = rnd.next(1, 50);\n            } else {\n                a[i] = rnd.next(317, 366);\n                b[i] = 366;\n            }\n        }\n    } else if (type == \"alternating_genders\") {\n        // Alternate genders\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (rnd.next(0, 1) == 0) ? 'M' : 'F';\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c %d %d\\n\", genders[i], a[i], b[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> genders(n);\n    vector<int> a(n), b(n);\n\n    if (type == \"max_male\") {\n        // All male friends\n        for (int i = 0; i < n; ++i) {\n            genders[i] = 'M';\n        }\n        // Generate random ranges\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else if (type == \"max_female\") {\n        // All female friends\n        for (int i = 0; i < n; ++i) {\n            genders[i] = 'F';\n        }\n        // Generate random ranges\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else if (type == \"all_same_range\") {\n        // Alternate genders to have equal males and females\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = 100;\n            b[i] = 200;\n        }\n    } else if (type == \"non_overlapping\") {\n        // Non-overlapping ranges\n        int day = 1;\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = day;\n            b[i] = day;\n            day++;\n            if (day > 366) day = 1;\n        }\n    } else if (type == \"random\") {\n        // Random genders and ranges\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (rnd.next(0, 1) == 0) ? 'M' : 'F';\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else if (type == \"single_day_ranges\") {\n        // Ranges of length 1\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            int day = rnd.next(1, 366);\n            a[i] = b[i] = day;\n        }\n    } else if (type == \"full_range\") {\n        // Ranges from 1 to 366\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = 1;\n            b[i] = 366;\n        }\n    } else if (type == \"edge_days\") {\n        // Ranges at the start or end of the year\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            if (i % 2 == 0) {\n                a[i] = 1;\n                b[i] = rnd.next(1, 50);\n            } else {\n                a[i] = rnd.next(317, 366);\n                b[i] = 366;\n            }\n        }\n    } else if (type == \"alternating_genders\") {\n        // Alternate genders\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (i % 2 == 0) ? 'M' : 'F';\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            genders[i] = (rnd.next(0, 1) == 0) ? 'M' : 'F';\n            a[i] = rnd.next(1, 366);\n            b[i] = rnd.next(a[i], 366);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c %d %d\\n\", genders[i], a[i], b[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type full_range\n./gen -n 2 -type max_male\n./gen -n 2 -type max_female\n./gen -n 2 -type all_same_range\n./gen -n 2 -type non_overlapping\n\n./gen -n 10 -type random\n./gen -n 10 -type all_same_range\n./gen -n 10 -type non_overlapping\n./gen -n 10 -type single_day_ranges\n./gen -n 10 -type full_range\n./gen -n 10 -type edge_days\n\n./gen -n 100 -type random\n./gen -n 100 -type all_same_range\n./gen -n 100 -type non_overlapping\n./gen -n 100 -type single_day_ranges\n./gen -n 100 -type full_range\n./gen -n 100 -type edge_days\n./gen -n 100 -type max_male\n./gen -n 100 -type max_female\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_same_range\n./gen -n 1000 -type non_overlapping\n./gen -n 1000 -type single_day_ranges\n./gen -n 1000 -type full_range\n./gen -n 1000 -type edge_days\n./gen -n 1000 -type alternating_genders\n\n./gen -n 5000 -type random\n./gen -n 5000 -type all_same_range\n./gen -n 5000 -type non_overlapping\n./gen -n 5000 -type single_day_ranges\n./gen -n 5000 -type full_range\n./gen -n 5000 -type edge_days\n./gen -n 5000 -type alternating_genders\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:01:59.847698",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "629/C",
      "title": "C. Famil Door and Brackets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains n and m (1 ≤ m ≤ n ≤ 100 000, n - m ≤ 2000) — the desired length of the string and the length of the string bought by Gabi, respectively.The second line contains string s of length m consisting of characters '(' and ')' only.",
      "output_spec": "OutputPrint the number of pairs of string p and q such that p + s + q is a valid sequence of round brackets modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy4 1(OutputCopy4InputCopy4 4(())OutputCopy1InputCopy4 3(((OutputCopy0",
      "description": "C. Famil Door and Brackets\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line contains n and m (1 ≤ m ≤ n ≤ 100 000, n - m ≤ 2000) — the desired length of the string and the length of the string bought by Gabi, respectively.The second line contains string s of length m consisting of characters '(' and ')' only.\n\nOutputPrint the number of pairs of string p and q such that p + s + q is a valid sequence of round brackets modulo 109 + 7.\n\nInputCopy4 1(OutputCopy4InputCopy4 4(())OutputCopy1InputCopy4 3(((OutputCopy0\n\nInputCopy4 1(\n\nOutputCopy4\n\nInputCopy4 4(())\n\nOutputCopy1\n\nInputCopy4 3(((\n\nOutputCopy0\n\nNoteIn the first sample there are four different valid pairs:   p = \"(\", q = \"))\"  p = \"()\", q = \")\"  p = \"\", q = \"())\"  p = \"\", q = \")()\" In the second sample the only way to obtain a desired string is choose empty p and q.In the third sample there is no way to get a valid sequence of brackets.",
      "solutions": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I have the pleasure to invite you to the round #343 which is going to take place on Saturday! This round is consisted of 5 problems and you have 2 hours (as usual) to solve them.The problemsetters are Mohammad Amin Vahedinia (Me) (MrNull), Daneshvar Amrollahi (dkjsfkhg) and Alireza Tofighi (ATofighi). We would also like to thank Alireza Tofighi (ATofighi) and Ali Asadi (aliasadiiii) for testing this round and Ali Bahjati (LiTi) for helping us preparing this round.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, and, of course, MikeMirzayanov for unique Codeforces and Polygon platforms.This contest's Hero is Famile Door and his friends who are preparing his birthday party!UPDATE 1: Scoring Distribution is 500 — 1000 — 1750 — 2000 — 2500UPDATE 2: Editorial is ready HEREUPDATE 3: System Testing is finished you can see the standings here: standingsCongrats to the div2 Winners:1. rakhashov.maksat2. DarthMaul3. TakeTheAegisIDontNeedIt4. ykaya5. abcdef6199Also congrats to the div1 Winners:1. Um_nik2. anta3. Nerevar4. kmjp5. vintage_Vlad_MakeevBest of luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/24159",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1187
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces",
          "content": "Problem A:Consider that we have rowi chocolates in the i'th row and coli chocolates in the i'th column.The answer to the problem would be: . It is obvious that every pair would be calculated exactly once (as we have no more than one chocolate in the same square)Time Complexity: O(n2)C++ SolutionProblem B:Consider that we have boyi males in the i'th day of the year and girli females in the i'th day of the year. These arrays can be filled easily when you are reading the input (See the code). Then for the i'th day of the year, we could have 2 * min(boyi , girli) people which could come to the party. The answer would be maximum of this value between all days i (1 ≤ i ≤ 366)Time Complexity: O(366*n)C++ SolutionBonus: Try to solve this problem with O(n). For each interval given in the input, you don't need to iterate from day ai to day bi. This idea is used to solve problem 276C.Problem C:This problem can be solved with dynamic programming:1. Calculate dpi, j : How many sequences of brackets of length i has balance j and intermediate balance never goes below zero (They form a prefix of a valid sequence of brackets).2. For the given sequence of length n calculate the resulting balance a and the minimum balance b.3. Try the length of the sequence added at the beginning c and its balance d. If  - b ≤ d then add dpc, d × dpm - n - c, d + a to the answer.Time complexity: O((n - m)2)C++ SolutionProblem D:First of all, we calculate the volume of each cake: vi = π × hi × ri2. Now consider the sequence v1, v2, v3, ..., vn : The answer to the problem is the maximum sum of elements between all increasing sub-sequences of this sequence. How do we solve this? First to get rid of the decimals we can define a new sequence a1, a2, a3, ..., an such that We consider dpi as the maximum sum between all the sequences which end with ai anddpi = The answer to the problem is: π × maxi = 1ndp[i]Now how do we calculate ? We use a max-segment tree which does these two operations: 1. Change the i't member to v. 2. Find the maximum value in the interval 1 to i.Now we use this segment tree for the array dp and find the answer.Consider that a1, a2, a3, ..., an is sorted. We define bi as the position of ai. Now to fill dpi we find the maximum in the interval [1, bi) in segment and we call it x and we set the bi th index of the segment as ai + x. The answer to the problem would the maximum in the segment in the interval [1,n]Time complexity: O(nlgn)Thanks to ATofighi who helped a lot for writing the editorial of problem D.C++ SolutionProblem E:First of all, we assume that the tree is rooted! For this problem, first we need to compute some values for each vertex u: qdu and quu, cntu , paru, i and hu. qdu equals to the expected value of length of paths which start from vertex u, and ends in u’s subtree and also has length at least 1. quu equals to the expected value of length of paths which start from vertex u, and not ends in u’s subtree and also has length at least 1. to calculate this values we can use one dfs for qd, and one other dfs for qu. \\ cntu is the number of vertices in u’s subtree except u, paru, i is the 2i ‘th ancestor of u and finally hu is the height of the vertex u. \\ in first dfs (lets call it dfsdown) we can calculate qd, cnt and par array with this formulas: for ecah $v$ as child of u and paru, i = parparu, i - 1, i - 1in second dfs (lets call it dfsup) we calculate qu using this formula (for clearer formula, I may define some extra variables):there are two cases:u is the only child of its parent: let then \\u is not the only child of its parent: let then now we should process the queries. For each query u and v, we have to cases: one of the vertices is either one of the ancestors of the other one or not! In the first case, if we define w the vertex before u (u is assumed to be the vertex with lower height). In the path from v to u, the answer is .In the second case, if we assume w = LCA(u, v), then answer is To check if u is one of ancestors of v, you can check if their LCA equals to u or you can use dfs to find out their starting and finishing time. u is an ancestor of v if the interval of starting and finishing time of v is completely inside starting and finishing time of uThe time complexity for the whole solution is O(n + mlgn) (O(n) for dfs and O(lgn) for each query so O(mlgn) for queries!). C++ Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43227",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4370
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 1",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 2",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 3",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 4",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 5",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 6",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 1",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 2",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 3",
          "code": "Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 4",
          "code": "(cylinder_volume,max_total_volume_with_this_cylinder_at_top)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 5",
          "code": "(V , list[j-1].max_total_volume + V)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 6",
          "code": "max_total_volume value is <= list[j].max_total_volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 7",
          "code": "Now the key thing to realize here is, that number of expressions with balance X is equal to number of expressions with balance -X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 8",
          "code": "dp[prefix_length][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 9",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 10",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    ensuref(n - m <= 2000, \"n - m must be ≤ 2000, but n=%d, m=%d\", n, m);\n\n    string s = inf.readLine(\"^[()]{\" + to_string(m) + \"}$\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    ensuref(n - m <= 2000, \"n - m must be ≤ 2000, but n=%d, m=%d\", n, m);\n\n    string s = inf.readLine(\"^[()]{\" + to_string(m) + \"}$\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    ensuref(n - m <= 2000, \"n - m must be ≤ 2000, but n=%d, m=%d\", n, m);\n\n    string s = inf.readLine(\"^[()]{\" + to_string(m) + \"}$\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_balanced_sequence(int m) {\n    int half_open = m / 2;\n    int half_close = m - half_open;\n    string s(half_open, '(');\n    s += string(half_close, ')');\n    return s;\n}\n\nstring generate_open_heavy_sequence(int m) {\n    int num_open = (m + 1) / 2; // Ensure num_open ≥ num_close\n    int num_close = m - num_open;\n    string s(num_open, '(');\n    s += string(num_close, ')');\n    return s;\n}\n\nstring generate_invalid_prefix_sequence(int m) {\n    string s;\n    s.reserve(m);\n    s += ')'; // First character makes prefix invalid\n    for (int i = 1; i < m; ++i) {\n        if (rnd.next(2))\n            s += '(';\n        else\n            s += ')';\n    }\n    return s;\n}\n\nstring generate_random_valid_sequence(int m) {\n    int n = m;\n    int open_remaining = n / 2;\n    int close_remaining = n - open_remaining;\n    int balance = 0;\n    string s;\n    s.reserve(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if (open_remaining == n - i) {\n            s += '(';\n            open_remaining--;\n            balance++;\n        } else if (close_remaining == n - i) {\n            s += ')';\n            close_remaining--;\n            balance--;\n        } else {\n            if (balance == 0 || (open_remaining > 0 && rnd.next(2))) {\n                s += '(';\n                open_remaining--;\n                balance++;\n            } else {\n                s += ')';\n                close_remaining--;\n                balance--;\n            }\n        }\n    }\n    return s;\n}\n\nstring generate_random_invalid_sequence(int m) {\n    string s;\n    s.reserve(m);\n    for (int i = 0; i < m; ++i) {\n        if (rnd.next(2))\n            s += '(';\n        else\n            s += ')';\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type_s = opt<string>(\"type_s\", \"random\");\n\n    ensure(1 <= m && m <= n && n <= 100000);\n    ensure(n - m <= 2000);\n\n    string s;\n    if (type_s == \"balanced\") {\n        s = generate_balanced_sequence(m);\n    } else if (type_s == \"open_heavy\") {\n        s = generate_open_heavy_sequence(m);\n    } else if (type_s == \"invalid_prefix\") {\n        s = generate_invalid_prefix_sequence(m);\n    } else if (type_s == \"random_valid\") {\n        s = generate_random_valid_sequence(m);\n    } else if (type_s == \"random_invalid\") {\n        s = generate_random_invalid_sequence(m);\n    } else {\n        ensure(false);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_balanced_sequence(int m) {\n    int half_open = m / 2;\n    int half_close = m - half_open;\n    string s(half_open, '(');\n    s += string(half_close, ')');\n    return s;\n}\n\nstring generate_open_heavy_sequence(int m) {\n    int num_open = (m + 1) / 2; // Ensure num_open ≥ num_close\n    int num_close = m - num_open;\n    string s(num_open, '(');\n    s += string(num_close, ')');\n    return s;\n}\n\nstring generate_invalid_prefix_sequence(int m) {\n    string s;\n    s.reserve(m);\n    s += ')'; // First character makes prefix invalid\n    for (int i = 1; i < m; ++i) {\n        if (rnd.next(2))\n            s += '(';\n        else\n            s += ')';\n    }\n    return s;\n}\n\nstring generate_random_valid_sequence(int m) {\n    int n = m;\n    int open_remaining = n / 2;\n    int close_remaining = n - open_remaining;\n    int balance = 0;\n    string s;\n    s.reserve(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if (open_remaining == n - i) {\n            s += '(';\n            open_remaining--;\n            balance++;\n        } else if (close_remaining == n - i) {\n            s += ')';\n            close_remaining--;\n            balance--;\n        } else {\n            if (balance == 0 || (open_remaining > 0 && rnd.next(2))) {\n                s += '(';\n                open_remaining--;\n                balance++;\n            } else {\n                s += ')';\n                close_remaining--;\n                balance--;\n            }\n        }\n    }\n    return s;\n}\n\nstring generate_random_invalid_sequence(int m) {\n    string s;\n    s.reserve(m);\n    for (int i = 0; i < m; ++i) {\n        if (rnd.next(2))\n            s += '(';\n        else\n            s += ')';\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type_s = opt<string>(\"type_s\", \"random\");\n\n    ensure(1 <= m && m <= n && n <= 100000);\n    ensure(n - m <= 2000);\n\n    string s;\n    if (type_s == \"balanced\") {\n        s = generate_balanced_sequence(m);\n    } else if (type_s == \"open_heavy\") {\n        s = generate_open_heavy_sequence(m);\n    } else if (type_s == \"invalid_prefix\") {\n        s = generate_invalid_prefix_sequence(m);\n    } else if (type_s == \"random_valid\") {\n        s = generate_random_valid_sequence(m);\n    } else if (type_s == \"random_invalid\") {\n        s = generate_random_invalid_sequence(m);\n    } else {\n        ensure(false);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type_s balanced\n./gen -n 2 -m 2 -type_s open_heavy\n./gen -n 2 -m 2 -type_s invalid_prefix\n\n./gen -n 1000 -m 1000 -type_s balanced\n./gen -n 1000 -m 1000 -type_s random_valid\n./gen -n 1000 -m 1000 -type_s random_invalid\n\n./gen -n 100000 -m 100000 -type_s balanced\n./gen -n 100000 -m 100000 -type_s random_valid\n./gen -n 100000 -m 100000 -type_s invalid_prefix\n\n./gen -n 100000 -m 98000 -type_s balanced\n./gen -n 100000 -m 98000 -type_s random_valid\n./gen -n 100000 -m 98000 -type_s random_invalid\n\n./gen -n 3000 -m 1000 -type_s random_valid\n./gen -n 3000 -m 1000 -type_s random_invalid\n\n./gen -n 1 -m 1 -type_s invalid_prefix\n./gen -n 1 -m 1 -type_s open_heavy\n\n./gen -n 5 -m 3 -type_s random_valid\n./gen -n 5 -m 3 -type_s random_invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:02:02.094685",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "629/D",
      "title": "D. Babaei and Birthday Cake",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.Each of the following n lines contains two integers ri and hi (1 ≤ ri, hi ≤ 10 000), giving the radius and height of the i-th cake.",
      "output_spec": "OutputPrint the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy2100 3040 10OutputCopy942477.796077000InputCopy41 19 71 410 7OutputCopy3983.539484752",
      "description": "D. Babaei and Birthday Cake\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.Each of the following n lines contains two integers ri and hi (1 ≤ ri, hi ≤ 10 000), giving the radius and height of the i-th cake.\n\nOutputPrint the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy2100 3040 10OutputCopy942477.796077000InputCopy41 19 71 410 7OutputCopy3983.539484752\n\nInputCopy2100 3040 10\n\nOutputCopy942477.796077000\n\nInputCopy41 19 71 410 7\n\nOutputCopy3983.539484752\n\nNoteIn first sample, the optimal way is to choose the cake number 1.In second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.",
      "solutions": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I have the pleasure to invite you to the round #343 which is going to take place on Saturday! This round is consisted of 5 problems and you have 2 hours (as usual) to solve them.The problemsetters are Mohammad Amin Vahedinia (Me) (MrNull), Daneshvar Amrollahi (dkjsfkhg) and Alireza Tofighi (ATofighi). We would also like to thank Alireza Tofighi (ATofighi) and Ali Asadi (aliasadiiii) for testing this round and Ali Bahjati (LiTi) for helping us preparing this round.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, and, of course, MikeMirzayanov for unique Codeforces and Polygon platforms.This contest's Hero is Famile Door and his friends who are preparing his birthday party!UPDATE 1: Scoring Distribution is 500 — 1000 — 1750 — 2000 — 2500UPDATE 2: Editorial is ready HEREUPDATE 3: System Testing is finished you can see the standings here: standingsCongrats to the div2 Winners:1. rakhashov.maksat2. DarthMaul3. TakeTheAegisIDontNeedIt4. ykaya5. abcdef6199Also congrats to the div1 Winners:1. Um_nik2. anta3. Nerevar4. kmjp5. vintage_Vlad_MakeevBest of luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/24159",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1187
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces",
          "content": "Problem A:Consider that we have rowi chocolates in the i'th row and coli chocolates in the i'th column.The answer to the problem would be: . It is obvious that every pair would be calculated exactly once (as we have no more than one chocolate in the same square)Time Complexity: O(n2)C++ SolutionProblem B:Consider that we have boyi males in the i'th day of the year and girli females in the i'th day of the year. These arrays can be filled easily when you are reading the input (See the code). Then for the i'th day of the year, we could have 2 * min(boyi , girli) people which could come to the party. The answer would be maximum of this value between all days i (1 ≤ i ≤ 366)Time Complexity: O(366*n)C++ SolutionBonus: Try to solve this problem with O(n). For each interval given in the input, you don't need to iterate from day ai to day bi. This idea is used to solve problem 276C.Problem C:This problem can be solved with dynamic programming:1. Calculate dpi, j : How many sequences of brackets of length i has balance j and intermediate balance never goes below zero (They form a prefix of a valid sequence of brackets).2. For the given sequence of length n calculate the resulting balance a and the minimum balance b.3. Try the length of the sequence added at the beginning c and its balance d. If  - b ≤ d then add dpc, d × dpm - n - c, d + a to the answer.Time complexity: O((n - m)2)C++ SolutionProblem D:First of all, we calculate the volume of each cake: vi = π × hi × ri2. Now consider the sequence v1, v2, v3, ..., vn : The answer to the problem is the maximum sum of elements between all increasing sub-sequences of this sequence. How do we solve this? First to get rid of the decimals we can define a new sequence a1, a2, a3, ..., an such that We consider dpi as the maximum sum between all the sequences which end with ai anddpi = The answer to the problem is: π × maxi = 1ndp[i]Now how do we calculate ? We use a max-segment tree which does these two operations: 1. Change the i't member to v. 2. Find the maximum value in the interval 1 to i.Now we use this segment tree for the array dp and find the answer.Consider that a1, a2, a3, ..., an is sorted. We define bi as the position of ai. Now to fill dpi we find the maximum in the interval [1, bi) in segment and we call it x and we set the bi th index of the segment as ai + x. The answer to the problem would the maximum in the segment in the interval [1,n]Time complexity: O(nlgn)Thanks to ATofighi who helped a lot for writing the editorial of problem D.C++ SolutionProblem E:First of all, we assume that the tree is rooted! For this problem, first we need to compute some values for each vertex u: qdu and quu, cntu , paru, i and hu. qdu equals to the expected value of length of paths which start from vertex u, and ends in u’s subtree and also has length at least 1. quu equals to the expected value of length of paths which start from vertex u, and not ends in u’s subtree and also has length at least 1. to calculate this values we can use one dfs for qd, and one other dfs for qu. \\ cntu is the number of vertices in u’s subtree except u, paru, i is the 2i ‘th ancestor of u and finally hu is the height of the vertex u. \\ in first dfs (lets call it dfsdown) we can calculate qd, cnt and par array with this formulas: for ecah $v$ as child of u and paru, i = parparu, i - 1, i - 1in second dfs (lets call it dfsup) we calculate qu using this formula (for clearer formula, I may define some extra variables):there are two cases:u is the only child of its parent: let then \\u is not the only child of its parent: let then now we should process the queries. For each query u and v, we have to cases: one of the vertices is either one of the ancestors of the other one or not! In the first case, if we define w the vertex before u (u is assumed to be the vertex with lower height). In the path from v to u, the answer is .In the second case, if we assume w = LCA(u, v), then answer is To check if u is one of ancestors of v, you can check if their LCA equals to u or you can use dfs to find out their starting and finishing time. u is an ancestor of v if the interval of starting and finishing time of v is completely inside starting and finishing time of uThe time complexity for the whole solution is O(n + mlgn) (O(n) for dfs and O(lgn) for each query so O(mlgn) for queries!). C++ Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43227",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4370
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 1",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 2",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 3",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 4",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 5",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 6",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 1",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 2",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 3",
          "code": "Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 4",
          "code": "(cylinder_volume,max_total_volume_with_this_cylinder_at_top)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 5",
          "code": "(V , list[j-1].max_total_volume + V)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 6",
          "code": "max_total_volume value is <= list[j].max_total_volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 7",
          "code": "Now the key thing to realize here is, that number of expressions with balance X is equal to number of expressions with balance -X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 8",
          "code": "dp[prefix_length][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 9",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 10",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 10000, \"hi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 10000, \"hi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 10000, \"hi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> r;\n    vector<int> h;\n\n    if (type == \"n_equals_1\") {\n        n = 1;\n    }\n\n    if (type == \"increasing\") {\n        // Generate cakes with increasing volumes\n        int min_rh = 1;\n        int max_rh = 10000;\n\n        int r_curr = min_rh;\n        int h_curr = min_rh;\n\n        for (int i = 0; i < n; ++i) {\n            r.push_back(r_curr);\n            h.push_back(h_curr);\n\n            // Increase radius and height for the next cake\n            int r_increment = rnd.next(1, max((max_rh - r_curr) / (n - i), 1));\n            int h_increment = rnd.next(1, max((max_rh - h_curr) / (n - i),1));\n\n            r_curr += r_increment;\n            h_curr += h_increment;\n\n            if (r_curr > max_rh) r_curr = max_rh;\n            if (h_curr > max_rh) h_curr = max_rh;\n        }\n    } else if (type == \"decreasing\") {\n        int min_rh = 1;\n        int max_rh = 10000;\n\n        int r_curr = max_rh;\n        int h_curr = max_rh;\n\n        for (int i = 0; i < n; ++i) {\n            r.push_back(r_curr);\n            h.push_back(h_curr);\n\n            // Decrease radius and height for the next cake\n            int r_decrement = rnd.next(1, max((r_curr - min_rh) / (n - i), 1));\n            int h_decrement = rnd.next(1, max((h_curr - min_rh) / (n - i),1));\n\n            r_curr -= r_decrement;\n            h_curr -= h_decrement;\n\n            if (r_curr < min_rh) r_curr = min_rh;\n            if (h_curr < min_rh) h_curr = min_rh;\n        }\n    } else if (type == \"equal\") {\n        int rh = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            r.push_back(rh);\n            h.push_back(rh);\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            r.push_back(10000);\n            h.push_back(10000);\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i) {\n            r.push_back(1);\n            h.push_back(1);\n        }\n    } else if (type == \"small_variance\") {\n        int base_rh = rnd.next(5000, 5000);\n        for (int i = 0; i < n; ++i) {\n            int r_i = base_rh + rnd.next(-5, 5);\n            int h_i = base_rh + rnd.next(-5, 5);\n            if (r_i < 1) r_i = 1;\n            if (r_i > 10000) r_i = 10000;\n            if (h_i < 1) h_i = 1;\n            if (h_i > 10000) h_i = 10000;\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    } else if (type == \"big_variance\") {\n        for (int i = 0; i < n; ++i) {\n            int r_i = rnd.next(1, 10000);\n            int h_i = rnd.next(1, 10000);\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    } else if (type == \"wave\") {\n        // Create volumes that alternate between high and low to form a wave pattern\n        int high_rh = 10000;\n        int low_rh = 1;\n        for (int i = 0; i < n; ++i) {\n            int r_i = (i % 2 == 0) ? high_rh : low_rh;\n            int h_i = (i % 2 == 0) ? high_rh : low_rh;\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    } else if (type == \"n_equals_1\") {\n        int r_i = rnd.next(1, 10000);\n        int h_i = rnd.next(1, 10000);\n        r.push_back(r_i);\n        h.push_back(h_i);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int r_i = rnd.next(1, 10000);\n            int h_i = rnd.next(1, 10000);\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output r_i and h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", r[i], h[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> r;\n    vector<int> h;\n\n    if (type == \"n_equals_1\") {\n        n = 1;\n    }\n\n    if (type == \"increasing\") {\n        // Generate cakes with increasing volumes\n        int min_rh = 1;\n        int max_rh = 10000;\n\n        int r_curr = min_rh;\n        int h_curr = min_rh;\n\n        for (int i = 0; i < n; ++i) {\n            r.push_back(r_curr);\n            h.push_back(h_curr);\n\n            // Increase radius and height for the next cake\n            int r_increment = rnd.next(1, max((max_rh - r_curr) / (n - i), 1));\n            int h_increment = rnd.next(1, max((max_rh - h_curr) / (n - i),1));\n\n            r_curr += r_increment;\n            h_curr += h_increment;\n\n            if (r_curr > max_rh) r_curr = max_rh;\n            if (h_curr > max_rh) h_curr = max_rh;\n        }\n    } else if (type == \"decreasing\") {\n        int min_rh = 1;\n        int max_rh = 10000;\n\n        int r_curr = max_rh;\n        int h_curr = max_rh;\n\n        for (int i = 0; i < n; ++i) {\n            r.push_back(r_curr);\n            h.push_back(h_curr);\n\n            // Decrease radius and height for the next cake\n            int r_decrement = rnd.next(1, max((r_curr - min_rh) / (n - i), 1));\n            int h_decrement = rnd.next(1, max((h_curr - min_rh) / (n - i),1));\n\n            r_curr -= r_decrement;\n            h_curr -= h_decrement;\n\n            if (r_curr < min_rh) r_curr = min_rh;\n            if (h_curr < min_rh) h_curr = min_rh;\n        }\n    } else if (type == \"equal\") {\n        int rh = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            r.push_back(rh);\n            h.push_back(rh);\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            r.push_back(10000);\n            h.push_back(10000);\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i) {\n            r.push_back(1);\n            h.push_back(1);\n        }\n    } else if (type == \"small_variance\") {\n        int base_rh = rnd.next(5000, 5000);\n        for (int i = 0; i < n; ++i) {\n            int r_i = base_rh + rnd.next(-5, 5);\n            int h_i = base_rh + rnd.next(-5, 5);\n            if (r_i < 1) r_i = 1;\n            if (r_i > 10000) r_i = 10000;\n            if (h_i < 1) h_i = 1;\n            if (h_i > 10000) h_i = 10000;\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    } else if (type == \"big_variance\") {\n        for (int i = 0; i < n; ++i) {\n            int r_i = rnd.next(1, 10000);\n            int h_i = rnd.next(1, 10000);\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    } else if (type == \"wave\") {\n        // Create volumes that alternate between high and low to form a wave pattern\n        int high_rh = 10000;\n        int low_rh = 1;\n        for (int i = 0; i < n; ++i) {\n            int r_i = (i % 2 == 0) ? high_rh : low_rh;\n            int h_i = (i % 2 == 0) ? high_rh : low_rh;\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    } else if (type == \"n_equals_1\") {\n        int r_i = rnd.next(1, 10000);\n        int h_i = rnd.next(1, 10000);\n        r.push_back(r_i);\n        h.push_back(h_i);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int r_i = rnd.next(1, 10000);\n            int h_i = rnd.next(1, 10000);\n            r.push_back(r_i);\n            h.push_back(h_i);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output r_i and h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", r[i], h[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type n_equals_1\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 5 -type min_values\n./gen -n 5 -type max_values\n./gen -n 10 -type equal\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type small_variance\n./gen -n 10 -type big_variance\n./gen -n 100 -type random\n./gen -n 100 -type equal\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 1000 -type random\n./gen -n 1000 -type equal\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 10000 -type random\n./gen -n 10000 -type big_variance\n./gen -n 10000 -type small_variance\n./gen -n 1000 -type wave\n./gen -n 100000 -type random\n./gen -n 100000 -type equal\n./gen -n 100000 -type max_values\n./gen -n 100000 -type min_values\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type small_variance\n./gen -n 100000 -type big_variance\n./gen -n 100000 -type wave\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:02:04.176043",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "629/E",
      "title": "E. Famil Door and Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains integers n and m (2 ≤ n,  m ≤ 100 000) — the number of the intersections in the Treeland and the number of Famil Door's friends.Then follow n - 1 lines describing bidirectional roads. Each of them contains two integers ai and bi (1 ≤ ai, bi ≤ n) — the indices of intersections connected by the i-th road.Last m lines of the input describe Famil Door's friends. The i-th of these lines contain two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — indices of intersections where the i-th friend lives and works.",
      "output_spec": "OutputFor each friend you should print the expected value of pleasure if he will be happy. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy4 32 44 13 23 12 34 1OutputCopy4.000000003.000000003.00000000InputCopy3 31 21 31 21 32 3OutputCopy2.500000002.500000003.00000000",
      "description": "E. Famil Door and Roads\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers n and m (2 ≤ n,  m ≤ 100 000) — the number of the intersections in the Treeland and the number of Famil Door's friends.Then follow n - 1 lines describing bidirectional roads. Each of them contains two integers ai and bi (1 ≤ ai, bi ≤ n) — the indices of intersections connected by the i-th road.Last m lines of the input describe Famil Door's friends. The i-th of these lines contain two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — indices of intersections where the i-th friend lives and works.\n\nOutputFor each friend you should print the expected value of pleasure if he will be happy. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy4 32 44 13 23 12 34 1OutputCopy4.000000003.000000003.00000000InputCopy3 31 21 31 21 32 3OutputCopy2.500000002.500000003.00000000\n\nInputCopy4 32 44 13 23 12 34 1\n\nOutputCopy4.000000003.000000003.00000000\n\nInputCopy3 31 21 31 21 32 3\n\nOutputCopy2.500000002.500000003.00000000\n\nNoteConsider the second sample.   Both roads (1, 2) and (2, 3) work, so the expected length if   Roads (1, 3) and (2, 3) make the second friend happy. Same as for friend 1 the answer is 2.5  The only way to make the third friend happy is to add road (2, 3), so the answer is 3",
      "solutions": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I have the pleasure to invite you to the round #343 which is going to take place on Saturday! This round is consisted of 5 problems and you have 2 hours (as usual) to solve them.The problemsetters are Mohammad Amin Vahedinia (Me) (MrNull), Daneshvar Amrollahi (dkjsfkhg) and Alireza Tofighi (ATofighi). We would also like to thank Alireza Tofighi (ATofighi) and Ali Asadi (aliasadiiii) for testing this round and Ali Bahjati (LiTi) for helping us preparing this round.We thank Gleb Evstropov (GlebsHP) for his help in preparing the contest, Maria Belova (Delinur) for translating the statements into Russian, and, of course, MikeMirzayanov for unique Codeforces and Polygon platforms.This contest's Hero is Famile Door and his friends who are preparing his birthday party!UPDATE 1: Scoring Distribution is 500 — 1000 — 1750 — 2000 — 2500UPDATE 2: Editorial is ready HEREUPDATE 3: System Testing is finished you can see the standings here: standingsCongrats to the div2 Winners:1. rakhashov.maksat2. DarthMaul3. TakeTheAegisIDontNeedIt4. ykaya5. abcdef6199Also congrats to the div1 Winners:1. Um_nik2. anta3. Nerevar4. kmjp5. vintage_Vlad_MakeevBest of luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/24159",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1187
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces",
          "content": "Problem A:Consider that we have rowi chocolates in the i'th row and coli chocolates in the i'th column.The answer to the problem would be: . It is obvious that every pair would be calculated exactly once (as we have no more than one chocolate in the same square)Time Complexity: O(n2)C++ SolutionProblem B:Consider that we have boyi males in the i'th day of the year and girli females in the i'th day of the year. These arrays can be filled easily when you are reading the input (See the code). Then for the i'th day of the year, we could have 2 * min(boyi , girli) people which could come to the party. The answer would be maximum of this value between all days i (1 ≤ i ≤ 366)Time Complexity: O(366*n)C++ SolutionBonus: Try to solve this problem with O(n). For each interval given in the input, you don't need to iterate from day ai to day bi. This idea is used to solve problem 276C.Problem C:This problem can be solved with dynamic programming:1. Calculate dpi, j : How many sequences of brackets of length i has balance j and intermediate balance never goes below zero (They form a prefix of a valid sequence of brackets).2. For the given sequence of length n calculate the resulting balance a and the minimum balance b.3. Try the length of the sequence added at the beginning c and its balance d. If  - b ≤ d then add dpc, d × dpm - n - c, d + a to the answer.Time complexity: O((n - m)2)C++ SolutionProblem D:First of all, we calculate the volume of each cake: vi = π × hi × ri2. Now consider the sequence v1, v2, v3, ..., vn : The answer to the problem is the maximum sum of elements between all increasing sub-sequences of this sequence. How do we solve this? First to get rid of the decimals we can define a new sequence a1, a2, a3, ..., an such that We consider dpi as the maximum sum between all the sequences which end with ai anddpi = The answer to the problem is: π × maxi = 1ndp[i]Now how do we calculate ? We use a max-segment tree which does these two operations: 1. Change the i't member to v. 2. Find the maximum value in the interval 1 to i.Now we use this segment tree for the array dp and find the answer.Consider that a1, a2, a3, ..., an is sorted. We define bi as the position of ai. Now to fill dpi we find the maximum in the interval [1, bi) in segment and we call it x and we set the bi th index of the segment as ai + x. The answer to the problem would the maximum in the segment in the interval [1,n]Time complexity: O(nlgn)Thanks to ATofighi who helped a lot for writing the editorial of problem D.C++ SolutionProblem E:First of all, we assume that the tree is rooted! For this problem, first we need to compute some values for each vertex u: qdu and quu, cntu , paru, i and hu. qdu equals to the expected value of length of paths which start from vertex u, and ends in u’s subtree and also has length at least 1. quu equals to the expected value of length of paths which start from vertex u, and not ends in u’s subtree and also has length at least 1. to calculate this values we can use one dfs for qd, and one other dfs for qu. \\ cntu is the number of vertices in u’s subtree except u, paru, i is the 2i ‘th ancestor of u and finally hu is the height of the vertex u. \\ in first dfs (lets call it dfsdown) we can calculate qd, cnt and par array with this formulas: for ecah $v$ as child of u and paru, i = parparu, i - 1, i - 1in second dfs (lets call it dfsup) we calculate qu using this formula (for clearer formula, I may define some extra variables):there are two cases:u is the only child of its parent: let then \\u is not the only child of its parent: let then now we should process the queries. For each query u and v, we have to cases: one of the vertices is either one of the ancestors of the other one or not! In the first case, if we define w the vertex before u (u is assumed to be the vertex with lower height). In the path from v to u, the answer is .In the second case, if we assume w = LCA(u, v), then answer is To check if u is one of ancestors of v, you can check if their LCA equals to u or you can use dfs to find out their starting and finishing time. u is an ancestor of v if the interval of starting and finishing time of v is completely inside starting and finishing time of uThe time complexity for the whole solution is O(n + mlgn) (O(n) for dfs and O(lgn) for each query so O(mlgn) for queries!). C++ Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/43227",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4370
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 1",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 2",
          "code": "Solution verdict:\nOK\n\nChecker:\nok found '3141592653590.0000000', expected '3141592653590.0000000', error '0.0000000'\n\nInput:\n1\n10000 10000\n\nOutput:\n3141592653590.0000000\n\nAnswer:\n3141592653590.000061512\n\nTime:\n0\n\nMemory:\n901120",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 3",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 4",
          "code": "ret += 1.0 * countLengthSum[b] / countNodes[b];\nif(lca != a)\n    ret += 1.0 * countLengthSum[b] / countNodes[b];  // <-- It should be a instead of b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 5",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #343 (Div. 2) - Codeforces - Code 6",
          "code": "4\nM 1 4\nM 1 4\nF 1 2\nF 3 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/24159",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 1",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 2",
          "code": "dp(0, 0) = 1\nif (j > 0) dp(i, j) += dp(i - 1, j - 1)\nif (j < 2000) dp(i, j) += dp(i - 1, j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 3",
          "code": "Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 4",
          "code": "(cylinder_volume,max_total_volume_with_this_cylinder_at_top)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 5",
          "code": "(V , list[j-1].max_total_volume + V)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 6",
          "code": "max_total_volume value is <= list[j].max_total_volume",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 7",
          "code": "Now the key thing to realize here is, that number of expressions with balance X is equal to number of expressions with balance -X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 8",
          "code": "dp[prefix_length][balance]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 9",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Codeforces Round #343 (Div.2) - Codeforces - Code 10",
          "code": "dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/43227",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    // Initialize DSU\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n -1; ++i) {\n        int ai = inf.readInt(1, n);\n        inf.readSpace();\n        int bi = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Edge %d: Edge cannot connect a node to itself (%d, %d)\", i+1, ai, bi);\n\n        int root_a = find(ai);\n        int root_b = find(bi);\n\n        ensuref(root_a != root_b, \"Edge %d: Edge creates a cycle (%d, %d)\", i+1, ai, bi);\n\n        parent[root_a] = root_b;\n\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n);\n        inf.readSpace();\n        int vi = inf.readInt(1, n);\n\n        ensuref(ui != vi, \"Friend %d: ui and vi must be different (%d, %d)\", i+1, ui, vi);\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    // Initialize DSU\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n -1; ++i) {\n        int ai = inf.readInt(1, n);\n        inf.readSpace();\n        int bi = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Edge %d: Edge cannot connect a node to itself (%d, %d)\", i+1, ai, bi);\n\n        int root_a = find(ai);\n        int root_b = find(bi);\n\n        ensuref(root_a != root_b, \"Edge %d: Edge creates a cycle (%d, %d)\", i+1, ai, bi);\n\n        parent[root_a] = root_b;\n\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n);\n        inf.readSpace();\n        int vi = inf.readInt(1, n);\n\n        ensuref(ui != vi, \"Friend %d: ui and vi must be different (%d, %d)\", i+1, ui, vi);\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    // Initialize DSU\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n -1; ++i) {\n        int ai = inf.readInt(1, n);\n        inf.readSpace();\n        int bi = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Edge %d: Edge cannot connect a node to itself (%d, %d)\", i+1, ai, bi);\n\n        int root_a = find(ai);\n        int root_b = find(bi);\n\n        ensuref(root_a != root_b, \"Edge %d: Edge creates a cycle (%d, %d)\", i+1, ai, bi);\n\n        parent[root_a] = root_b;\n\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n);\n        inf.readSpace();\n        int vi = inf.readInt(1, n);\n\n        ensuref(ui != vi, \"Friend %d: ui and vi must be different (%d, %d)\", i+1, ui, vi);\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string friend_type = opt<string>(\"friend\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else { // random tree\n        vector<int> p(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n            edges.push_back({p[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    vector<pair<int, int>> friends;\n\n    if (friend_type == \"random\") {\n        set<pair<int, int>> used_pairs;\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while (u == v || used_pairs.count({u, v}));\n            used_pairs.insert({u, v});\n            friends.push_back({u, v});\n        }\n    } else if (friend_type == \"opposite\") {\n        for (int i = 0; i < m; ++i) {\n            friends.push_back({1, n});\n        }\n    } else if (friend_type == \"leaf\") {\n        vector<int> degree(n + 1, 0);\n        for (const auto &e : edges) {\n            degree[e.first]++;\n            degree[e.second]++;\n        }\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if (leaves.size() < 2) {\n            for (int i = 0; i < m; ++i) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                while (u == v) {\n                    v = rnd.next(1, n);\n                }\n                friends.push_back({u, v});\n            }\n        } else {\n            for (int i = 0; i < m; ++i) {\n                int u = leaves[rnd.next(0, (int)leaves.size() - 1)];\n                int v = leaves[rnd.next(0, (int)leaves.size() - 1)];\n                while (u == v) {\n                    v = leaves[rnd.next(0, (int)leaves.size() - 1)];\n                }\n                friends.push_back({u, v});\n            }\n        }\n    } else if (friend_type == \"pairwise\") {\n        for (int u = 1; u <= n && (int)friends.size() < m; ++u) {\n            for (int v = u + 1; v <= n && (int)friends.size() < m; ++v) {\n                friends.push_back({u, v});\n            }\n        }\n        while ((int)friends.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            friends.push_back({u, v});\n        }\n    } else { // default random friends\n        set<pair<int, int>> used_pairs;\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while (u == v || used_pairs.count({u, v}));\n            used_pairs.insert({u, v});\n            friends.push_back({u, v});\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (const auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    for (const auto &f : friends) {\n        printf(\"%d %d\\n\", f.first, f.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string friend_type = opt<string>(\"friend\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else { // random tree\n        vector<int> p(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n            edges.push_back({p[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    vector<pair<int, int>> friends;\n\n    if (friend_type == \"random\") {\n        set<pair<int, int>> used_pairs;\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while (u == v || used_pairs.count({u, v}));\n            used_pairs.insert({u, v});\n            friends.push_back({u, v});\n        }\n    } else if (friend_type == \"opposite\") {\n        for (int i = 0; i < m; ++i) {\n            friends.push_back({1, n});\n        }\n    } else if (friend_type == \"leaf\") {\n        vector<int> degree(n + 1, 0);\n        for (const auto &e : edges) {\n            degree[e.first]++;\n            degree[e.second]++;\n        }\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if (leaves.size() < 2) {\n            for (int i = 0; i < m; ++i) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                while (u == v) {\n                    v = rnd.next(1, n);\n                }\n                friends.push_back({u, v});\n            }\n        } else {\n            for (int i = 0; i < m; ++i) {\n                int u = leaves[rnd.next(0, (int)leaves.size() - 1)];\n                int v = leaves[rnd.next(0, (int)leaves.size() - 1)];\n                while (u == v) {\n                    v = leaves[rnd.next(0, (int)leaves.size() - 1)];\n                }\n                friends.push_back({u, v});\n            }\n        }\n    } else if (friend_type == \"pairwise\") {\n        for (int u = 1; u <= n && (int)friends.size() < m; ++u) {\n            for (int v = u + 1; v <= n && (int)friends.size() < m; ++v) {\n                friends.push_back({u, v});\n            }\n        }\n        while ((int)friends.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            friends.push_back({u, v});\n        }\n    } else { // default random friends\n        set<pair<int, int>> used_pairs;\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while (u == v || used_pairs.count({u, v}));\n            used_pairs.insert({u, v});\n            friends.push_back({u, v});\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (const auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    for (const auto &f : friends) {\n        printf(\"%d %d\\n\", f.first, f.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -tree chain -friend opposite\n./gen -n 2 -m 1 -tree chain -friend leaf\n\n./gen -n 10 -m 5 -tree chain -friend random\n./gen -n 10 -m 5 -tree star -friend random\n./gen -n 10 -m 5 -tree random -friend random\n./gen -n 10 -m 5 -tree chain -friend opposite\n./gen -n 10 -m 5 -tree star -friend opposite\n./gen -n 10 -m 5 -tree random -friend opposite\n./gen -n 10 -m 5 -tree chain -friend leaf\n./gen -n 10 -m 5 -tree star -friend leaf\n./gen -n 10 -m 5 -tree random -friend leaf\n\n./gen -n 50 -m 100 -tree chain -friend random\n./gen -n 50 -m 100 -tree star -friend random\n./gen -n 50 -m 100 -tree random -friend random\n\n./gen -n 1000 -m 1000 -tree chain -friend random\n./gen -n 1000 -m 1000 -tree star -friend random\n./gen -n 1000 -m 1000 -tree random -friend random\n./gen -n 1000 -m 1000 -tree chain -friend opposite\n./gen -n 1000 -m 1000 -tree star -friend opposite\n./gen -n 1000 -m 1000 -tree random -friend opposite\n./gen -n 1000 -m 1000 -tree chain -friend leaf\n./gen -n 1000 -m 1000 -tree star -friend leaf\n./gen -n 1000 -m 1000 -tree random -friend leaf\n\n./gen -n 100000 -m 100000 -tree chain -friend random\n./gen -n 100000 -m 100000 -tree star -friend random\n./gen -n 100000 -m 100000 -tree random -friend random\n./gen -n 100000 -m 100000 -tree chain -friend opposite\n./gen -n 100000 -m 100000 -tree star -friend opposite\n./gen -n 100000 -m 100000 -tree random -friend opposite\n./gen -n 100000 -m 100000 -tree chain -friend leaf\n./gen -n 100000 -m 100000 -tree star -friend leaf\n./gen -n 100000 -m 100000 -tree random -friend leaf\n\n# Test with m = 1\n./gen -n 100000 -m 1 -tree random -friend random\n./gen -n 100000 -m 1 -tree random -friend leaf\n\n# Test with m less than n\n./gen -n 100000 -m 50000 -tree random -friend random\n\n# Test with n and m close to the maximum\n./gen -n 99999 -m 99999 -tree random -friend random\n\n# Test with friends as all possible pairwise combinations (small n)\n./gen -n 1000 -m 100000 -tree random -friend pairwise\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T21:02:06.303742",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}