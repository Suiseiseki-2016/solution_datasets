{
  "metadata": {
    "batch_number": 72,
    "total_batches": 73,
    "problems_in_batch": 61,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:42.661515",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "99/C",
      "title": "C. Help Victoria the Wise",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains exactly 6 characters without spaces from the set {R, O, Y, G, B, V} — they are the colors of gems with which the box should be decorated.",
      "output_spec": "OutputPrint the required number of different ways to decorate the box.",
      "sample_tests": "ExamplesInputCopyYYYYYYOutputCopy1InputCopyBOOOOBOutputCopy2InputCopyROYGBVOutputCopy30",
      "description": "C. Help Victoria the Wise\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains exactly 6 characters without spaces from the set {R, O, Y, G, B, V} — they are the colors of gems with which the box should be decorated.\n\nOutputPrint the required number of different ways to decorate the box.\n\nInputCopyYYYYYYOutputCopy1InputCopyBOOOOBOutputCopy2InputCopyROYGBVOutputCopy30\n\nInputCopyYYYYYY\n\nOutputCopy1\n\nInputCopyBOOOOB\n\nOutputCopy2\n\nInputCopyROYGBV\n\nOutputCopy30",
      "solutions": [
        {
          "title": "Codeforces Beta Round #78 - Codeforces",
          "content": "Hi there!Me - Sergey Vedernikov - is the author of today's CF beta round.During the round you'll assist far away kingdom citizens in solving everyday problems, and sometimes - just to fight for your survival.This round is \"red\" =), therefore the problems should not appear too difficult, and you should get pleasure from solving them.To those who know Russian language I recommend to read problem statements in Russian. Not because of the quality of translation - English just poorly communicates Russian folklore language style.Finally I want to thank Artem Rakhov for invaluable help during the round preparation, Maria Belova for the qualitative translation of the problems, Mikhail Mirzayanov for excellent CF system and all participants for not leaving this event without your attention.More AC verdicts and high rating to all of you! gl & hfUPD: Unfortunately, problem B (div. 1) / D (div. 2) appeared to be more difficult, and author's solution appeared wrong. The round will be unrated. I apologise for this to all participants.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2319",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1036
        },
        {
          "title": "Codeforces Beta Round #78 Div 2 (ABC solutions) - Codeforces",
          "content": "I ended up solving 3 questions.. the 3rd one took me a lot of time because I manually pre-computed all the configurations and wrote them in my code.Here is a short description on how I solved the 3 problems hopefully it is helpful.Problem AThe first problem required manual checking. As I use Java, StringTokenizer helped me to break the string using '.' as the delimiter. As I had 2 strings I could check for the last character of the first string and if it was equal to 9 I printed \"GOTO Vasilisa.\" and for the other case I checked if the first char of the other string was greater than '5' if yes I added 1 to the first strings last char else print the same string.Problem BProblem B was easier considering the mathematical nature of the problem. There were a few cases to take care of and a score of 900+ was easily get able. On summing up the volumes if they don't divide equally among the n cups, then the answer is unrecoverable. If all of the values are equal to the average then the pages did not play any prank. On the other hand if more than 2 cups deviate from the average the answer is again unrecoverable. If the number of cups that deviate is 2. We can find the cups which were used for transfer and find the volume transferred by calculating the difference of the values from the mean.Problem CThe problem is easy but during the contest I could not come with a very good approach in one go. I started waywardly and in the end pre computed all the 24 configurations which are equal to each other. Then I just checked how many different configurations can be made using the colors given. Generate all the 720 permutations of the string for that.For the generation of the 24 configurations I fixed a top and then rotated the cube by 90 degs again and again to get all the 4 configurations for that top. Fixing all the  6 tops. We get in total 6*4=24 configurations as equivalent to each other.code snippet//24 configurations givenconfigs[]={\"012345\",\"031425\",\"043215\",\"024135\",\"103254\",\"120534\",\"152304\",\"135024\",\"254103\",\"215043\",\"201453\",\"240513\",\"310542\",\"351402\",\"345012\",\"304152\",\"453201\",\"425031\",\"402351\",\"430521\",\"513240\",\"521430\",\"542310\",\"534120\"};for(int i=0;i<720;i++){                boolean different=different(in,conf[i]);                for(int j=0;j<i;j++)                    if(!different(conf[i],conf[j]))                    {                        different=false;                        break;                    }                if(different)                    tot++;}boolean different(String a,String b)    {        for(int i=0;i<24;i++)        {            boolean equal=true;            for(int j=0;j<6;j++)            {                if(a.charAt(j)!=b.charAt(configs[i].charAt(j)-'0'))                    equal=false;            }            if(equal)                return false;        }return true;    }",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2848
        },
        {
          "title": "Editorial for Codeforces Beta Round #78 - Codeforces",
          "content": "Hi there!Here is editorial for the round #78.Russian editorial will be published a bit later - I supposed that there are more people who can understand English (or who can do English -> Russian web page translation) than vice versa.Again, I'm very sorry for the situation with problem B (div. 1) / D (div. 2). Also, I'm sorry that I underestimated difficulty of the problems. At least, I hope the problems appeared interesting for many contestants.Problem A (div. 2) - Help Far Away KingdomHere the problem was to round a number up according to the usual mathematical rules with the exception that if the last digit of integer part is equal to 9, you should output \"GOTO Vasilisa.\". One may notice that to check whether number's fractional part is not less than 0.5 only one digit just after the decimal point should be analysed. If it is '5' or greater - add one to the last digit of the integer part, and the problem is solved. Probably, the simplest way to deal with the input data was using of the string variables.Problem B (div. 2) - Help Chef GerasimThe problem was to accurately check what is required in the problem statement. First of all, check whether all volumes in the input are equal. In this case output \"Exemplary pages.\". Otherwise find two cups with largest and smallest volumes. Suppose their numbers are a and b, and their volumes are v[a] and v[b]. Now suppose that before pouring their volumes were equal to V. Then they contained 2V units of juice before (and after) pouring. So, you need to check whether (v[a] + v[b]) is divisible by 2. If this is not so - output \"Unrecoverable confihuration.\". Otherwise assign to the cups presumable old volume v[a] = v[b] = (v[a] + v[b])/2. Now if only one pouring have been made, volumes of juice in all cups should be equal, and you print corresponding message \"... ml. from ... to ...\". If volumes are not equal, print \"Unrecoverable configuration\" instead.Problem A (div. 1) / C (div. 2) - Help Victoria the WiseIn this problem you were required to find the number of sufficiently different colorings of a cube faces with predefined six colors. The most trivial solution is to introduce some ordering of the cube faces (say, 0 - front, 1 - back, 2 - up, 3 - down, 4 - left, 5 - right), then consider 720 = 6! arrangements of colors over these 6 faces. Each arrangement is some permutation of characters from the input. For each arrangement we find all its 24 rotations - and get 24 strings. Lexicographically smallest string will be representative of this coloring. The answer is the number of different representatives.Problem B (div. 1) / D (div. 2) - Help KingUnfortunately, initial author's solution for this problem appeared wrong. However, the optimality of the below algo was proved by Knuth and Yao in 1976. Limitation for n in the problem now changed to 10000.The process of tossing a coin and making decisions regarding which alternative to choose may be naturally described as drawing some (possibly infinite) binary tree. Each toss \"draws\" two new branches from every free node of the tree (initially the tree consists of one free node). Whenever the number of free nodes becomes >= n, you turn n free nodes into leaves (onle leaf for each alternative), and proceed with the other free nodes in a similar way. For example, for n == 3 we get the following infitite tree:            o         /      \\      o          o   /     \\      /     \\1        2  3        o                     /      \\                   ...      ...Now we should evaluate expected length of a random path in this infinite tree now. One may notice that the tree is recursive: since the number of free nodes at every level is strictly less than n, the situation will repeat after maximum of n steps. Once one notices this, it is not so hard to derive formulas for the answer. Since numbers in the answer could be of the order 2^n, one needs to write \"long arithmetics\", or use Java.BigInteger.Problem C (div. 1) / E (div. 2) - Help Greg the DwarfFor this problem I assumed numerical solution. But there are several cases to consider. Below without loss of generality we assume a <= b.1. l <= a <= b. In this case the answer is restricted by the length of the coffin, so the answer is l and it is clear that the coffin l x l can be brought through the corridor (a, b) - let's denote corridor's sizes in this way.2. a < l <= b. In this case the answer is a, and it is clear that no larger number can be an answer. Indeed, otherwise the coffin (w > a) x (l > a) is impossible to drag through the corridor (a, b).3. a <= b < l. This is the most general case, where we should rotate the coffin inside the corridor where it has a kink. To maximise the width of the coffin, we want to move it in such a way that one corner of the coffin touches one outer wall of the corridor (suppose bottommost on the picture), and another corner adjacent to the same long side of the coffin touches another outer wall of the corridor (leftmost on the picture). Let's introduce coordinate system in such a way that bottommost wall be OX axis, and leftmost wall - OY axis. Suppose that during the \"rotation\" process one corner of the coffin is at the point (x,0) (0 <= x <= l), then another corner should be at the point (0,sqrt(l*l-x*x)). And the answer we search for is min {distance from the segment (x,0) - (0,sqrt(l*l-x*x)) to the point (a,b) }, where you take min{} over all 0 <= x <= l. Let this distance at point x be f(x). Since f(x*) is minimal in some point x* and increases everywere to the left and to the right from x*, one may use ternary search to find its minimum.Exact solution for this problem is also possible: you can reduce the problem to minimizing the dot product of the vectors (a-x,b) and (-x,sqrt(l*l-x*x)) over x. But this leads to the neccessity to find the roots of the fourth-degree polynomial, which is not the best idea during the contest.Problem D (div. 1) - Help MonksThis problem was about famous puzzle \"Hanoi towers\", but diameters of some discs might be equal. How to solve that? A good thing to do is to write BFS solution to check optimality of your ideas for small inputs (by the way, BSF works quickly for almost all towers that have up to 10 discs) and then try to create an algo which solves the puzzle in an optimal way.Let C (x1, x2, ..., xn) be a solution (under \"solution\" here we mean optimal number of moves - the moves itself is easy to get with one recursive procedure; also \"solution\" is the number of moves to move group of discs from one peg to any other (and not some particular) ) to the puzzle when we have a puzzle with x1 equal largest discs, x2 equal second largest discs and so on. And let U (x1, x2, ..., xn) be a solution to the puzzle when you are allowed not to save the order of the discs (you should still follow the restriction of the initial puzzle not to put larger discs onto the smaller ones, but at the end discs of the same diameter may be in any order).Then one of the optimal solutions to the problem is the following:C (x1, x2, ..., xn) = U (x1, x2, ..., xn) if x1 = 1 (*)C (x1, x2, ..., xn) = 2*x1 - 1 if n = 1 (**)C (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) + x1 + C (x2, ..., xn). (***)U (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) (****)Why so? One can notice that U() is \"almost\" solution for our problem: it \"flips\" order of the bottommost group of equal discs, the order of the rest of the discs remains the same! (try to understand why)That's why (*) is correct.The (**) is quite obvious.The (***) does the following: move (x2, ..., xn) from peg 1 to peg 2 without saving the order. Then move x1 equal discs from peg 1 to peg 3, then move (x2, ..., xn) from peg 2 to peg 1 without saving the order (but it occurs that after we apply U() to the same group of discs twice, the order restored!), then move x1 equal discs from peg 3 to peg 2, and then use C() to move (x2, ..., xn) from peg 1 to peg 2 (here we use C() since we should preserve the order). So, (***) is correct.And (****) is quite straightforward expression for U(): move all discs but the largest group with the same algo, then move largest discs (that's why if x1 > 1, the group of discs \"flips\"), and then move all discs but the largest group onto the same peg with x1.Problem E (div. 1) - Help Shrek and DonkeyThis problem was about optimally playing this simple-at-first-glance game. The key thing to recognize in the statement was that it is not always optimal to name card which you don't have. Sometimes it is optimal to confuse the opponent by naming card which you have on hand. In this case... yes, he may think that the card you named is card on the table and lose during the next turn. Now the problem is to understand when to use the strategy of reduction of opponent's cards, when to bluff in the abovementioned sense and when to try to determine which card is on the table. But instead of \"when\" the right question is \"how frequently\" since we have nothing else but usual constant-sum matrix game, and optimal strategy is the mixture of these three. Let's construct a matrix first. Player 1 has three pure strategies: \"playing\" (when he plays the game and really tries to determine opponent's cards and card on the table), \"guessing\" (when he guesses which card is lying on the table) and \"bluffing\" (when he tries to confuse his opponent to force him to lose by naming card in his own hand). In turn, if the first player used \"bluffing\" strategy, or during the \"playing\" strategy named card on the table, his opponent has two strategies: \"check\" (i.e. to believe the first player that he doesn't own the card he named and guess it as the card on the table) and \"move on\" (i.e. to decide that it was a \"bluffing\" strategy and the game should be continued, but with notice that the first player has named card on hands). Let's denote P(m,n) probability to win the game when the first player has m cards and the second player has n cards. Then P(m,n) is the value of the matrix game with the following matrix (rows - strategies of the first player, two numbers in the rows - probabilities to win when the second player uses strategies \"check\" and \"move on\" correspondingly:                                \"check\"                                    \"move on\"\"playing\"        n/(n+1)*(1-P(n-1,m))        1/(n+1) + n/(n+1)*(1-P(n-1,m))\"guessing\"                 1/(n+1)                                     1/(n+1)\"bluffing\"                       1                                       1-P(n,m-1)How to get these numbers in the matrix? Consider the first row: \"playing\" strategy of the first player, \"check\" strategy of the second. First just names one of the n+1 cards. With probability 1/(n+1) he names card on the table, seconds checks it and wins (so, probability to with for the first is 0), with probability n/(n+1) the first names one of the cards on hands of the second player, so the game continues, second wins with prob. P(n-1,m) in this case. Then the overall probability for the first to win with such combination of pure strategies is n/(n+1)*(1-P(n-1,m)). In the same manner we fill other cells of the matrix. Finally we solve the game (this can be done straightforwardly, or with one formula if one notices that the \"guessing\" strategy is suboptimal everywhere when m>=1 and n>=1 and that the game doesn't have saddle points) and get answer to the problem - P(m,n).And the last thing to note: when m==0 it is clear that during his move the second wins, so the first should guess, and P(0,n) = 1/(n+1). When n==0 P(m,0)==1 sinse we just do one rightguessing.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2323",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 1",
          "code": "0,0,0,1,0,0,0,1,0,0,0,1,2,0,0,0,1,0,0,0,1,0,0,0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 2",
          "code": "---------------------------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 3",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 1 |\n     +---+---+---+---+\n     | 5 | 0 | 4 | 2 | \n     +---+---+---+---+\n         | 3 |\n         +---+1:         +---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 5 |\n     +---+---+---+---+\n     | 0 | 1 | 2 | 3 | \n     +---+---+---+---+\n         | 4 |\n         +---+2:         +---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 1 |\n     +---+---+---+---+\n     | 4 | 2 | 5 | 0 | \n     +---+---+---+---+\n         | 3 |\n         +---+http://codeforces.com/blog/entry/2325",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 4",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 5",
          "code": "+---+\n         | 1 |\n     +---+---+---+---+\n     | 5 | 0 | 4 | 2 | \n     +---+---+---+---+\n         | 3 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 6",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 7",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 0 | 1 | 2 | 3 | \n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 8",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 9",
          "code": "+---+\n         | 1 |\n     +---+---+---+---+\n     | 4 | 2 | 5 | 0 | \n     +---+---+---+---+\n         | 3 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 10",
          "code": "Unrecoverable configuration",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ROYGBV]{6}\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ROYGBV]{6}\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[ROYGBV]{6}\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> colors = {'R', 'O', 'Y', 'G', 'B', 'V'};\n    vector<char> gems;\n\n    if (type == \"same\") {\n        // All gems are the same color\n        char c = colors[rnd.next(6)];\n        gems.assign(6, c);\n    } else if (type == \"all-different\") {\n        // All gems are different colors\n        gems = colors;\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"two-same\") {\n        // Exactly two gems are the same, rest are different\n        char c = colors[rnd.next(6)];\n        vector<char> other_colors;\n        for (char col : colors) {\n            if (col != c)\n                other_colors.push_back(col);\n        }\n        gems.push_back(c);\n        gems.push_back(c);\n        shuffle(other_colors.begin(), other_colors.end());\n        for (int i = 0; i < 4; ++i) {\n            gems.push_back(other_colors[i]);\n        }\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"three-same\") {\n        // Exactly three gems are the same, rest are different\n        char c = colors[rnd.next(6)];\n        vector<char> other_colors;\n        for (char col : colors) {\n            if (col != c)\n                other_colors.push_back(col);\n        }\n        gems.push_back(c);\n        gems.push_back(c);\n        gems.push_back(c);\n        shuffle(other_colors.begin(), other_colors.end());\n        for (int i = 0; i < 3; ++i) {\n            gems.push_back(other_colors[i]);\n        }\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"pairs\") {\n        // Three pairs of same-colored gems\n        vector<char> colors_copy = colors;\n        shuffle(colors_copy.begin(), colors_copy.end());\n        for (int i = 0; i < 3; ++i) {\n            gems.push_back(colors_copy[i]);\n            gems.push_back(colors_copy[i]);\n        }\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"custom\") {\n        // Read counts for each color from parameters\n        int count_R = opt<int>(\"R\", 0);\n        int count_O = opt<int>(\"O\", 0);\n        int count_Y = opt<int>(\"Y\", 0);\n        int count_G = opt<int>(\"G\", 0);\n        int count_B = opt<int>(\"B\", 0);\n        int count_V = opt<int>(\"V\", 0);\n        int total = count_R + count_O + count_Y + count_G + count_B + count_V;\n        ensuref(total == 6, \"Total number of gems must be exactly 6\");\n        for (int i = 0; i < count_R; ++i)\n            gems.push_back('R');\n        for (int i = 0; i < count_O; ++i)\n            gems.push_back('O');\n        for (int i = 0; i < count_Y; ++i)\n            gems.push_back('Y');\n        for (int i = 0; i < count_G; ++i)\n            gems.push_back('G');\n        for (int i = 0; i < count_B; ++i)\n            gems.push_back('B');\n        for (int i = 0; i < count_V; ++i)\n            gems.push_back('V');\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"random\") {\n        // Random colors\n        for (int i = 0; i < 6; ++i) {\n            char c = colors[rnd.next(6)];\n            gems.push_back(c);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output the gems as a six-character string\n    for (char c : gems)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> colors = {'R', 'O', 'Y', 'G', 'B', 'V'};\n    vector<char> gems;\n\n    if (type == \"same\") {\n        // All gems are the same color\n        char c = colors[rnd.next(6)];\n        gems.assign(6, c);\n    } else if (type == \"all-different\") {\n        // All gems are different colors\n        gems = colors;\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"two-same\") {\n        // Exactly two gems are the same, rest are different\n        char c = colors[rnd.next(6)];\n        vector<char> other_colors;\n        for (char col : colors) {\n            if (col != c)\n                other_colors.push_back(col);\n        }\n        gems.push_back(c);\n        gems.push_back(c);\n        shuffle(other_colors.begin(), other_colors.end());\n        for (int i = 0; i < 4; ++i) {\n            gems.push_back(other_colors[i]);\n        }\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"three-same\") {\n        // Exactly three gems are the same, rest are different\n        char c = colors[rnd.next(6)];\n        vector<char> other_colors;\n        for (char col : colors) {\n            if (col != c)\n                other_colors.push_back(col);\n        }\n        gems.push_back(c);\n        gems.push_back(c);\n        gems.push_back(c);\n        shuffle(other_colors.begin(), other_colors.end());\n        for (int i = 0; i < 3; ++i) {\n            gems.push_back(other_colors[i]);\n        }\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"pairs\") {\n        // Three pairs of same-colored gems\n        vector<char> colors_copy = colors;\n        shuffle(colors_copy.begin(), colors_copy.end());\n        for (int i = 0; i < 3; ++i) {\n            gems.push_back(colors_copy[i]);\n            gems.push_back(colors_copy[i]);\n        }\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"custom\") {\n        // Read counts for each color from parameters\n        int count_R = opt<int>(\"R\", 0);\n        int count_O = opt<int>(\"O\", 0);\n        int count_Y = opt<int>(\"Y\", 0);\n        int count_G = opt<int>(\"G\", 0);\n        int count_B = opt<int>(\"B\", 0);\n        int count_V = opt<int>(\"V\", 0);\n        int total = count_R + count_O + count_Y + count_G + count_B + count_V;\n        ensuref(total == 6, \"Total number of gems must be exactly 6\");\n        for (int i = 0; i < count_R; ++i)\n            gems.push_back('R');\n        for (int i = 0; i < count_O; ++i)\n            gems.push_back('O');\n        for (int i = 0; i < count_Y; ++i)\n            gems.push_back('Y');\n        for (int i = 0; i < count_G; ++i)\n            gems.push_back('G');\n        for (int i = 0; i < count_B; ++i)\n            gems.push_back('B');\n        for (int i = 0; i < count_V; ++i)\n            gems.push_back('V');\n        shuffle(gems.begin(), gems.end());\n    } else if (type == \"random\") {\n        // Random colors\n        for (int i = 0; i < 6; ++i) {\n            char c = colors[rnd.next(6)];\n            gems.push_back(c);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output the gems as a six-character string\n    for (char c : gems)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# All gems are the same color\n./gen -type same\n./gen -type same\n./gen -type same\n\n# All gems are different colors\n./gen -type all-different\n./gen -type all-different\n./gen -type all-different\n\n# Exactly two gems are the same\n./gen -type two-same\n./gen -type two-same\n./gen -type two-same\n\n# Exactly three gems are the same\n./gen -type three-same\n./gen -type three-same\n./gen -type three-same\n\n# Three pairs of gems\n./gen -type pairs\n./gen -type pairs\n./gen -type pairs\n\n# Random colors\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Custom test cases\n# All gems are 'R'\n./gen -type custom -R 6\n# All gems are 'O'\n./gen -type custom -O 6\n# All gems are 'Y'\n./gen -type custom -Y 6\n# All gems are 'G'\n./gen -type custom -G 6\n# All gems are 'B'\n./gen -type custom -B 6\n# All gems are 'V'\n./gen -type custom -V 6\n\n# One gem of each color\n./gen -type custom -R 1 -O 1 -Y 1 -G 1 -B 1 -V 1\n\n# Four 'R's and two 'O's\n./gen -type custom -R 4 -O 2\n# Three 'R's and three 'G's\n./gen -type custom -R 3 -G 3\n# Two 'R's, two 'O's, two 'Y's\n./gen -type custom -R 2 -O 2 -Y 2\n# Two 'R's, one 'Y', one 'G', one 'B', one 'V'\n./gen -type custom -R 2 -Y 1 -G 1 -B 1 -V 1\n# Two 'R's, two 'O's, one 'G', one 'B'\n./gen -type custom -R 2 -O 2 -G 1 -B 1\n# Three 'R's, one 'O', one 'Y', one 'G'\n./gen -type custom -R 3 -O 1 -Y 1 -G 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:32.841798",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "99/D",
      "title": "D. Help King",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n from the problem's statement (1 ≤ n ≤ 10000).",
      "output_spec": "OutputPrint the sought expected number of tosses as an irreducible fraction in the following form: \"a/b\" (without the quotes) without leading zeroes.",
      "sample_tests": "ExamplesInputCopy2OutputCopy1/1InputCopy3OutputCopy8/3InputCopy4OutputCopy2/1",
      "description": "D. Help King\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n from the problem's statement (1 ≤ n ≤ 10000).\n\nOutputPrint the sought expected number of tosses as an irreducible fraction in the following form: \"a/b\" (without the quotes) without leading zeroes.\n\nInputCopy2OutputCopy1/1InputCopy3OutputCopy8/3InputCopy4OutputCopy2/1\n\nOutputCopy1/1\n\nOutputCopy8/3\n\nOutputCopy2/1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #78 - Codeforces",
          "content": "Hi there!Me - Sergey Vedernikov - is the author of today's CF beta round.During the round you'll assist far away kingdom citizens in solving everyday problems, and sometimes - just to fight for your survival.This round is \"red\" =), therefore the problems should not appear too difficult, and you should get pleasure from solving them.To those who know Russian language I recommend to read problem statements in Russian. Not because of the quality of translation - English just poorly communicates Russian folklore language style.Finally I want to thank Artem Rakhov for invaluable help during the round preparation, Maria Belova for the qualitative translation of the problems, Mikhail Mirzayanov for excellent CF system and all participants for not leaving this event without your attention.More AC verdicts and high rating to all of you! gl & hfUPD: Unfortunately, problem B (div. 1) / D (div. 2) appeared to be more difficult, and author's solution appeared wrong. The round will be unrated. I apologise for this to all participants.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/2319",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1036
        },
        {
          "title": "Codeforces Beta Round #78 Div 2 (ABC solutions) - Codeforces",
          "content": "I ended up solving 3 questions.. the 3rd one took me a lot of time because I manually pre-computed all the configurations and wrote them in my code.Here is a short description on how I solved the 3 problems hopefully it is helpful.Problem AThe first problem required manual checking. As I use Java, StringTokenizer helped me to break the string using '.' as the delimiter. As I had 2 strings I could check for the last character of the first string and if it was equal to 9 I printed \"GOTO Vasilisa.\" and for the other case I checked if the first char of the other string was greater than '5' if yes I added 1 to the first strings last char else print the same string.Problem BProblem B was easier considering the mathematical nature of the problem. There were a few cases to take care of and a score of 900+ was easily get able. On summing up the volumes if they don't divide equally among the n cups, then the answer is unrecoverable. If all of the values are equal to the average then the pages did not play any prank. On the other hand if more than 2 cups deviate from the average the answer is again unrecoverable. If the number of cups that deviate is 2. We can find the cups which were used for transfer and find the volume transferred by calculating the difference of the values from the mean.Problem CThe problem is easy but during the contest I could not come with a very good approach in one go. I started waywardly and in the end pre computed all the 24 configurations which are equal to each other. Then I just checked how many different configurations can be made using the colors given. Generate all the 720 permutations of the string for that.For the generation of the 24 configurations I fixed a top and then rotated the cube by 90 degs again and again to get all the 4 configurations for that top. Fixing all the  6 tops. We get in total 6*4=24 configurations as equivalent to each other.code snippet//24 configurations givenconfigs[]={\"012345\",\"031425\",\"043215\",\"024135\",\"103254\",\"120534\",\"152304\",\"135024\",\"254103\",\"215043\",\"201453\",\"240513\",\"310542\",\"351402\",\"345012\",\"304152\",\"453201\",\"425031\",\"402351\",\"430521\",\"513240\",\"521430\",\"542310\",\"534120\"};for(int i=0;i<720;i++){                boolean different=different(in,conf[i]);                for(int j=0;j<i;j++)                    if(!different(conf[i],conf[j]))                    {                        different=false;                        break;                    }                if(different)                    tot++;}boolean different(String a,String b)    {        for(int i=0;i<24;i++)        {            boolean equal=true;            for(int j=0;j<6;j++)            {                if(a.charAt(j)!=b.charAt(configs[i].charAt(j)-'0'))                    equal=false;            }            if(equal)                return false;        }return true;    }",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/2326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2848
        },
        {
          "title": "Editorial for Codeforces Beta Round #78 - Codeforces",
          "content": "Hi there!Here is editorial for the round #78.Russian editorial will be published a bit later - I supposed that there are more people who can understand English (or who can do English -> Russian web page translation) than vice versa.Again, I'm very sorry for the situation with problem B (div. 1) / D (div. 2). Also, I'm sorry that I underestimated difficulty of the problems. At least, I hope the problems appeared interesting for many contestants.Problem A (div. 2) - Help Far Away KingdomHere the problem was to round a number up according to the usual mathematical rules with the exception that if the last digit of integer part is equal to 9, you should output \"GOTO Vasilisa.\". One may notice that to check whether number's fractional part is not less than 0.5 only one digit just after the decimal point should be analysed. If it is '5' or greater - add one to the last digit of the integer part, and the problem is solved. Probably, the simplest way to deal with the input data was using of the string variables.Problem B (div. 2) - Help Chef GerasimThe problem was to accurately check what is required in the problem statement. First of all, check whether all volumes in the input are equal. In this case output \"Exemplary pages.\". Otherwise find two cups with largest and smallest volumes. Suppose their numbers are a and b, and their volumes are v[a] and v[b]. Now suppose that before pouring their volumes were equal to V. Then they contained 2V units of juice before (and after) pouring. So, you need to check whether (v[a] + v[b]) is divisible by 2. If this is not so - output \"Unrecoverable confihuration.\". Otherwise assign to the cups presumable old volume v[a] = v[b] = (v[a] + v[b])/2. Now if only one pouring have been made, volumes of juice in all cups should be equal, and you print corresponding message \"... ml. from ... to ...\". If volumes are not equal, print \"Unrecoverable configuration\" instead.Problem A (div. 1) / C (div. 2) - Help Victoria the WiseIn this problem you were required to find the number of sufficiently different colorings of a cube faces with predefined six colors. The most trivial solution is to introduce some ordering of the cube faces (say, 0 - front, 1 - back, 2 - up, 3 - down, 4 - left, 5 - right), then consider 720 = 6! arrangements of colors over these 6 faces. Each arrangement is some permutation of characters from the input. For each arrangement we find all its 24 rotations - and get 24 strings. Lexicographically smallest string will be representative of this coloring. The answer is the number of different representatives.Problem B (div. 1) / D (div. 2) - Help KingUnfortunately, initial author's solution for this problem appeared wrong. However, the optimality of the below algo was proved by Knuth and Yao in 1976. Limitation for n in the problem now changed to 10000.The process of tossing a coin and making decisions regarding which alternative to choose may be naturally described as drawing some (possibly infinite) binary tree. Each toss \"draws\" two new branches from every free node of the tree (initially the tree consists of one free node). Whenever the number of free nodes becomes >= n, you turn n free nodes into leaves (onle leaf for each alternative), and proceed with the other free nodes in a similar way. For example, for n == 3 we get the following infitite tree:            o         /      \\      o          o   /     \\      /     \\1        2  3        o                     /      \\                   ...      ...Now we should evaluate expected length of a random path in this infinite tree now. One may notice that the tree is recursive: since the number of free nodes at every level is strictly less than n, the situation will repeat after maximum of n steps. Once one notices this, it is not so hard to derive formulas for the answer. Since numbers in the answer could be of the order 2^n, one needs to write \"long arithmetics\", or use Java.BigInteger.Problem C (div. 1) / E (div. 2) - Help Greg the DwarfFor this problem I assumed numerical solution. But there are several cases to consider. Below without loss of generality we assume a <= b.1. l <= a <= b. In this case the answer is restricted by the length of the coffin, so the answer is l and it is clear that the coffin l x l can be brought through the corridor (a, b) - let's denote corridor's sizes in this way.2. a < l <= b. In this case the answer is a, and it is clear that no larger number can be an answer. Indeed, otherwise the coffin (w > a) x (l > a) is impossible to drag through the corridor (a, b).3. a <= b < l. This is the most general case, where we should rotate the coffin inside the corridor where it has a kink. To maximise the width of the coffin, we want to move it in such a way that one corner of the coffin touches one outer wall of the corridor (suppose bottommost on the picture), and another corner adjacent to the same long side of the coffin touches another outer wall of the corridor (leftmost on the picture). Let's introduce coordinate system in such a way that bottommost wall be OX axis, and leftmost wall - OY axis. Suppose that during the \"rotation\" process one corner of the coffin is at the point (x,0) (0 <= x <= l), then another corner should be at the point (0,sqrt(l*l-x*x)). And the answer we search for is min {distance from the segment (x,0) - (0,sqrt(l*l-x*x)) to the point (a,b) }, where you take min{} over all 0 <= x <= l. Let this distance at point x be f(x). Since f(x*) is minimal in some point x* and increases everywere to the left and to the right from x*, one may use ternary search to find its minimum.Exact solution for this problem is also possible: you can reduce the problem to minimizing the dot product of the vectors (a-x,b) and (-x,sqrt(l*l-x*x)) over x. But this leads to the neccessity to find the roots of the fourth-degree polynomial, which is not the best idea during the contest.Problem D (div. 1) - Help MonksThis problem was about famous puzzle \"Hanoi towers\", but diameters of some discs might be equal. How to solve that? A good thing to do is to write BFS solution to check optimality of your ideas for small inputs (by the way, BSF works quickly for almost all towers that have up to 10 discs) and then try to create an algo which solves the puzzle in an optimal way.Let C (x1, x2, ..., xn) be a solution (under \"solution\" here we mean optimal number of moves - the moves itself is easy to get with one recursive procedure; also \"solution\" is the number of moves to move group of discs from one peg to any other (and not some particular) ) to the puzzle when we have a puzzle with x1 equal largest discs, x2 equal second largest discs and so on. And let U (x1, x2, ..., xn) be a solution to the puzzle when you are allowed not to save the order of the discs (you should still follow the restriction of the initial puzzle not to put larger discs onto the smaller ones, but at the end discs of the same diameter may be in any order).Then one of the optimal solutions to the problem is the following:C (x1, x2, ..., xn) = U (x1, x2, ..., xn) if x1 = 1 (*)C (x1, x2, ..., xn) = 2*x1 - 1 if n = 1 (**)C (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) + x1 + C (x2, ..., xn). (***)U (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) (****)Why so? One can notice that U() is \"almost\" solution for our problem: it \"flips\" order of the bottommost group of equal discs, the order of the rest of the discs remains the same! (try to understand why)That's why (*) is correct.The (**) is quite obvious.The (***) does the following: move (x2, ..., xn) from peg 1 to peg 2 without saving the order. Then move x1 equal discs from peg 1 to peg 3, then move (x2, ..., xn) from peg 2 to peg 1 without saving the order (but it occurs that after we apply U() to the same group of discs twice, the order restored!), then move x1 equal discs from peg 3 to peg 2, and then use C() to move (x2, ..., xn) from peg 1 to peg 2 (here we use C() since we should preserve the order). So, (***) is correct.And (****) is quite straightforward expression for U(): move all discs but the largest group with the same algo, then move largest discs (that's why if x1 > 1, the group of discs \"flips\"), and then move all discs but the largest group onto the same peg with x1.Problem E (div. 1) - Help Shrek and DonkeyThis problem was about optimally playing this simple-at-first-glance game. The key thing to recognize in the statement was that it is not always optimal to name card which you don't have. Sometimes it is optimal to confuse the opponent by naming card which you have on hand. In this case... yes, he may think that the card you named is card on the table and lose during the next turn. Now the problem is to understand when to use the strategy of reduction of opponent's cards, when to bluff in the abovementioned sense and when to try to determine which card is on the table. But instead of \"when\" the right question is \"how frequently\" since we have nothing else but usual constant-sum matrix game, and optimal strategy is the mixture of these three. Let's construct a matrix first. Player 1 has three pure strategies: \"playing\" (when he plays the game and really tries to determine opponent's cards and card on the table), \"guessing\" (when he guesses which card is lying on the table) and \"bluffing\" (when he tries to confuse his opponent to force him to lose by naming card in his own hand). In turn, if the first player used \"bluffing\" strategy, or during the \"playing\" strategy named card on the table, his opponent has two strategies: \"check\" (i.e. to believe the first player that he doesn't own the card he named and guess it as the card on the table) and \"move on\" (i.e. to decide that it was a \"bluffing\" strategy and the game should be continued, but with notice that the first player has named card on hands). Let's denote P(m,n) probability to win the game when the first player has m cards and the second player has n cards. Then P(m,n) is the value of the matrix game with the following matrix (rows - strategies of the first player, two numbers in the rows - probabilities to win when the second player uses strategies \"check\" and \"move on\" correspondingly:                                \"check\"                                    \"move on\"\"playing\"        n/(n+1)*(1-P(n-1,m))        1/(n+1) + n/(n+1)*(1-P(n-1,m))\"guessing\"                 1/(n+1)                                     1/(n+1)\"bluffing\"                       1                                       1-P(n,m-1)How to get these numbers in the matrix? Consider the first row: \"playing\" strategy of the first player, \"check\" strategy of the second. First just names one of the n+1 cards. With probability 1/(n+1) he names card on the table, seconds checks it and wins (so, probability to with for the first is 0), with probability n/(n+1) the first names one of the cards on hands of the second player, so the game continues, second wins with prob. P(n-1,m) in this case. Then the overall probability for the first to win with such combination of pure strategies is n/(n+1)*(1-P(n-1,m)). In the same manner we fill other cells of the matrix. Finally we solve the game (this can be done straightforwardly, or with one formula if one notices that the \"guessing\" strategy is suboptimal everywhere when m>=1 and n>=1 and that the game doesn't have saddle points) and get answer to the problem - P(m,n).And the last thing to note: when m==0 it is clear that during his move the second wins, so the first should guess, and P(0,n) = 1/(n+1). When n==0 P(m,0)==1 sinse we just do one rightguessing.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/2323",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 1",
          "code": "0,0,0,1,0,0,0,1,0,0,0,1,2,0,0,0,1,0,0,0,1,0,0,0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 2",
          "code": "---------------------------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 3",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 1 |\n     +---+---+---+---+\n     | 5 | 0 | 4 | 2 | \n     +---+---+---+---+\n         | 3 |\n         +---+1:         +---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 5 |\n     +---+---+---+---+\n     | 0 | 1 | 2 | 3 | \n     +---+---+---+---+\n         | 4 |\n         +---+2:         +---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 1 |\n     +---+---+---+---+\n     | 4 | 2 | 5 | 0 | \n     +---+---+---+---+\n         | 3 |\n         +---+http://codeforces.com/blog/entry/2325",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 4",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 5",
          "code": "+---+\n         | 1 |\n     +---+---+---+---+\n     | 5 | 0 | 4 | 2 | \n     +---+---+---+---+\n         | 3 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 6",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 7",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 0 | 1 | 2 | 3 | \n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 8",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 9",
          "code": "+---+\n         | 1 |\n     +---+---+---+---+\n     | 4 | 2 | 5 | 0 | \n     +---+---+---+---+\n         | 3 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 10",
          "code": "Unrecoverable configuration",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read a single integer 'n' with 1 ≤ n ≤ 10000\n    int n = inf.readInt(1, 10000, \"n\");\n    // End of line\n    inf.readEoln();\n    // End of file\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read a single integer 'n' with 1 ≤ n ≤ 10000\n    int n = inf.readInt(1, 10000, \"n\");\n    // End of line\n    inf.readEoln();\n    // End of file\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read a single integer 'n' with 1 ≤ n ≤ 10000\n    int n = inf.readInt(1, 10000, \"n\");\n    // End of line\n    inf.readEoln();\n    // End of file\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single integer n (1 <= n <= 10000) for the problem:\n  \"Given n knights, compute the expected number of coin tosses (with a fair coin\n   and an optimal strategy) to choose exactly one knight out of n with probability 1/n.\"\n\n  It supports multiple \"type\" modes so that when you run it with different parameters,\n  it can produce various corner cases, random cases, powers of two, primes, etc.\n\n  Usage examples:\n    ./gen -type min\n    ./gen -type power2\n    ./gen -type random -minN 1 -maxN 10000\n    ...\n*/\n\nstatic const int MAX_N = 10000;\n\n// Precompute primes up to MAX_N using a sieve.\nvector<int> buildPrimes() {\n    vector<bool> isPrime(MAX_N + 1, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for(int i = 2; i * i <= MAX_N; i++) {\n        if(isPrime[i]) {\n            for(int j = i * i; j <= MAX_N; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    vector<int> primes;\n    for(int i = 2; i <= MAX_N; i++) {\n        if(isPrime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Precompute powers of two up to MAX_N.\nvector<int> buildPowersOf2() {\n    vector<int> pows;\n    int val = 1;\n    while(val <= MAX_N) {\n        pows.push_back(val);\n        val <<= 1;\n    }\n    return pows;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // parse arguments\n    // \"type\" => type of test to generate\n    // \"minN\" => lower bound for random generation\n    // \"maxN\" => upper bound for random generation\n    string type = opt<string>(\"type\", \"random\");\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", 10000);\n\n    // clamp the bounds to [1, 10000]\n    minN = max(1, minN);\n    maxN = min(MAX_N, maxN);\n    if(minN > maxN) {\n        // if user gives bad range, swap or set defaults\n        // but ideally just swap them\n        int tmp = minN;\n        minN = maxN;\n        maxN = tmp;\n    }\n\n    static vector<int> primes = buildPrimes();\n    static vector<int> pows   = buildPowersOf2();\n\n    int n;\n\n    if(type == \"min\") {\n        // Produce the minimal value: 1\n        n = 1;\n    }\n    else if(type == \"max\") {\n        // Produce the maximal value: 10000\n        n = 10000;\n    }\n    else if(type == \"random\") {\n        // Produce a random n in [minN..maxN]\n        n = rnd.next(minN, maxN);\n    }\n    else if(type == \"randomSmall\") {\n        // Produce a random n in [1..100] for smaller tests\n        int low = 1, high = 100;\n        n = rnd.next(low, min(high, MAX_N));\n    }\n    else if(type == \"randomLarge\") {\n        // Produce a random n in [9000..10000]\n        int low = 9000, high = 10000;\n        // clamp them again\n        low = max(low, 1);\n        high = min(high, MAX_N);\n        n = rnd.next(low, high);\n    }\n    else if(type == \"prime\") {\n        // Choose a random prime from [2..maxN]\n        // clamp to [2..10000] because 1 is not prime\n        vector<int> validPrimes;\n        for(int p : primes) {\n            if(p >= minN && p <= maxN)\n                validPrimes.push_back(p);\n        }\n        // If no valid prime, default to 2\n        if(validPrimes.empty()) {\n            n = 2; \n        } else {\n            n = validPrimes[rnd.next((int)validPrimes.size())];\n        }\n    }\n    else if(type == \"power2\") {\n        // Choose a random power of 2 in [1..maxN]\n        vector<int> validPowers;\n        for(int v : pows){\n            if(v >= minN && v <= maxN) {\n                validPowers.push_back(v);\n            }\n        }\n        // If no valid power of two, pick 1\n        if(validPowers.empty()) {\n            n = 1;\n        } else {\n            n = validPowers[rnd.next((int)validPowers.size())];\n        }\n    }\n    else {\n        // default behavior: random in [minN..maxN]\n        n = rnd.next(minN, maxN);\n    }\n\n    // Output the single integer\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single integer n (1 <= n <= 10000) for the problem:\n  \"Given n knights, compute the expected number of coin tosses (with a fair coin\n   and an optimal strategy) to choose exactly one knight out of n with probability 1/n.\"\n\n  It supports multiple \"type\" modes so that when you run it with different parameters,\n  it can produce various corner cases, random cases, powers of two, primes, etc.\n\n  Usage examples:\n    ./gen -type min\n    ./gen -type power2\n    ./gen -type random -minN 1 -maxN 10000\n    ...\n*/\n\nstatic const int MAX_N = 10000;\n\n// Precompute primes up to MAX_N using a sieve.\nvector<int> buildPrimes() {\n    vector<bool> isPrime(MAX_N + 1, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for(int i = 2; i * i <= MAX_N; i++) {\n        if(isPrime[i]) {\n            for(int j = i * i; j <= MAX_N; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    vector<int> primes;\n    for(int i = 2; i <= MAX_N; i++) {\n        if(isPrime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Precompute powers of two up to MAX_N.\nvector<int> buildPowersOf2() {\n    vector<int> pows;\n    int val = 1;\n    while(val <= MAX_N) {\n        pows.push_back(val);\n        val <<= 1;\n    }\n    return pows;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // parse arguments\n    // \"type\" => type of test to generate\n    // \"minN\" => lower bound for random generation\n    // \"maxN\" => upper bound for random generation\n    string type = opt<string>(\"type\", \"random\");\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", 10000);\n\n    // clamp the bounds to [1, 10000]\n    minN = max(1, minN);\n    maxN = min(MAX_N, maxN);\n    if(minN > maxN) {\n        // if user gives bad range, swap or set defaults\n        // but ideally just swap them\n        int tmp = minN;\n        minN = maxN;\n        maxN = tmp;\n    }\n\n    static vector<int> primes = buildPrimes();\n    static vector<int> pows   = buildPowersOf2();\n\n    int n;\n\n    if(type == \"min\") {\n        // Produce the minimal value: 1\n        n = 1;\n    }\n    else if(type == \"max\") {\n        // Produce the maximal value: 10000\n        n = 10000;\n    }\n    else if(type == \"random\") {\n        // Produce a random n in [minN..maxN]\n        n = rnd.next(minN, maxN);\n    }\n    else if(type == \"randomSmall\") {\n        // Produce a random n in [1..100] for smaller tests\n        int low = 1, high = 100;\n        n = rnd.next(low, min(high, MAX_N));\n    }\n    else if(type == \"randomLarge\") {\n        // Produce a random n in [9000..10000]\n        int low = 9000, high = 10000;\n        // clamp them again\n        low = max(low, 1);\n        high = min(high, MAX_N);\n        n = rnd.next(low, high);\n    }\n    else if(type == \"prime\") {\n        // Choose a random prime from [2..maxN]\n        // clamp to [2..10000] because 1 is not prime\n        vector<int> validPrimes;\n        for(int p : primes) {\n            if(p >= minN && p <= maxN)\n                validPrimes.push_back(p);\n        }\n        // If no valid prime, default to 2\n        if(validPrimes.empty()) {\n            n = 2; \n        } else {\n            n = validPrimes[rnd.next((int)validPrimes.size())];\n        }\n    }\n    else if(type == \"power2\") {\n        // Choose a random power of 2 in [1..maxN]\n        vector<int> validPowers;\n        for(int v : pows){\n            if(v >= minN && v <= maxN) {\n                validPowers.push_back(v);\n            }\n        }\n        // If no valid power of two, pick 1\n        if(validPowers.empty()) {\n            n = 1;\n        } else {\n            n = validPowers[rnd.next((int)validPowers.size())];\n        }\n    }\n    else {\n        // default behavior: random in [minN..maxN]\n        n = rnd.next(minN, maxN);\n    }\n\n    // Output the single integer\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1. Minimal value test\n./gen -type min\n\n# 2. Maximal value test\n./gen -type max\n\n# 3. Random in the full range [1..10000]\n./gen -type random\n\n# 4. Another random in the full range\n./gen -type random\n\n# 5. Random small (1..100)\n./gen -type randomSmall\n\n# 6. Another random small\n./gen -type randomSmall\n\n# 7. Random large (9000..10000)\n./gen -type randomLarge\n\n# 8. Another random large\n./gen -type randomLarge\n\n# 9. Prime in the full range [1..10000]\n./gen -type prime\n\n# 10. Another prime in the full range\n./gen -type prime\n\n# 11. Power of 2 in the full range\n./gen -type power2\n\n# 12. Another power of 2 in the full range\n./gen -type power2\n\n# 13. Random in [1..10]\n./gen -type random -minN 1 -maxN 10\n\n# 14. Another random in [1..10]\n./gen -type random -minN 1 -maxN 10\n\n# 15. Random in [9000..9005]\n./gen -type random -minN 9000 -maxN 9005\n\n# 16. Random in [9000..9005]\n./gen -type random -minN 9000 -maxN 9005\n\n# 17. Prime in [2..100]\n./gen -type prime -minN 2 -maxN 100\n\n# 18. Another prime in [2..100]\n./gen -type prime -minN 2 -maxN 100\n\n# 19. Power of 2 in [1..100]\n./gen -type power2 -minN 1 -maxN 100\n\n# 20. Power of 2 in [9000..10000]\n./gen -type power2 -minN 9000 -maxN 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:34.940329",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "99/E",
      "title": "E. Help Greg the Dwarf",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers a, b and l from the problem's statement (1 ≤ a, b, l ≤ 104).",
      "output_spec": "OutputPrint the maximally possible width of a coffin with absolute or relative error no more than 10 - 7. If a coffin with the given length and positive width (the coffin that would meet the conditions from the problem's statement) does not exist, print \"My poor head =(\" (without quotes).It is guaranteed that if the answer is positive, it will be not less than 10 - 7. All the hacks will also be checked to meet that condition.",
      "sample_tests": "ExamplesInputCopy2 2 1OutputCopy1.0000000InputCopy2 2 2OutputCopy2.0000000InputCopy2 2 3OutputCopy1.3284271InputCopy2 2 6OutputCopyMy poor head =(",
      "description": "E. Help Greg the Dwarf\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers a, b and l from the problem's statement (1 ≤ a, b, l ≤ 104).\n\nOutputPrint the maximally possible width of a coffin with absolute or relative error no more than 10 - 7. If a coffin with the given length and positive width (the coffin that would meet the conditions from the problem's statement) does not exist, print \"My poor head =(\" (without quotes).It is guaranteed that if the answer is positive, it will be not less than 10 - 7. All the hacks will also be checked to meet that condition.\n\nInputCopy2 2 1OutputCopy1.0000000InputCopy2 2 2OutputCopy2.0000000InputCopy2 2 3OutputCopy1.3284271InputCopy2 2 6OutputCopyMy poor head =(\n\nInputCopy2 2 1\n\nOutputCopy1.0000000\n\nInputCopy2 2 2\n\nOutputCopy2.0000000\n\nInputCopy2 2 3\n\nOutputCopy1.3284271\n\nInputCopy2 2 6\n\nOutputCopyMy poor head =(\n\nNoteIn the first example the answer is restricted by the coffin's length (remember — coffin's widths should not be larger than it's length).In the second example it is possible to drag the coffin through the corridor thanks to rotating wheels: firstly, drag it forward by one side while it will not be hampered by the wall, then move it forward by adjacent side perpendicularly to the initial movement direction (remember — arbitrary moves and rotations of the coffin are possible).",
      "solutions": [
        {
          "title": "Codeforces Beta Round #78 - Codeforces",
          "content": "Hi there!Me - Sergey Vedernikov - is the author of today's CF beta round.During the round you'll assist far away kingdom citizens in solving everyday problems, and sometimes - just to fight for your survival.This round is \"red\" =), therefore the problems should not appear too difficult, and you should get pleasure from solving them.To those who know Russian language I recommend to read problem statements in Russian. Not because of the quality of translation - English just poorly communicates Russian folklore language style.Finally I want to thank Artem Rakhov for invaluable help during the round preparation, Maria Belova for the qualitative translation of the problems, Mikhail Mirzayanov for excellent CF system and all participants for not leaving this event without your attention.More AC verdicts and high rating to all of you! gl & hfUPD: Unfortunately, problem B (div. 1) / D (div. 2) appeared to be more difficult, and author's solution appeared wrong. The round will be unrated. I apologise for this to all participants.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2319",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1036
        },
        {
          "title": "Codeforces Beta Round #78 Div 2 (ABC solutions) - Codeforces",
          "content": "I ended up solving 3 questions.. the 3rd one took me a lot of time because I manually pre-computed all the configurations and wrote them in my code.Here is a short description on how I solved the 3 problems hopefully it is helpful.Problem AThe first problem required manual checking. As I use Java, StringTokenizer helped me to break the string using '.' as the delimiter. As I had 2 strings I could check for the last character of the first string and if it was equal to 9 I printed \"GOTO Vasilisa.\" and for the other case I checked if the first char of the other string was greater than '5' if yes I added 1 to the first strings last char else print the same string.Problem BProblem B was easier considering the mathematical nature of the problem. There were a few cases to take care of and a score of 900+ was easily get able. On summing up the volumes if they don't divide equally among the n cups, then the answer is unrecoverable. If all of the values are equal to the average then the pages did not play any prank. On the other hand if more than 2 cups deviate from the average the answer is again unrecoverable. If the number of cups that deviate is 2. We can find the cups which were used for transfer and find the volume transferred by calculating the difference of the values from the mean.Problem CThe problem is easy but during the contest I could not come with a very good approach in one go. I started waywardly and in the end pre computed all the 24 configurations which are equal to each other. Then I just checked how many different configurations can be made using the colors given. Generate all the 720 permutations of the string for that.For the generation of the 24 configurations I fixed a top and then rotated the cube by 90 degs again and again to get all the 4 configurations for that top. Fixing all the  6 tops. We get in total 6*4=24 configurations as equivalent to each other.code snippet//24 configurations givenconfigs[]={\"012345\",\"031425\",\"043215\",\"024135\",\"103254\",\"120534\",\"152304\",\"135024\",\"254103\",\"215043\",\"201453\",\"240513\",\"310542\",\"351402\",\"345012\",\"304152\",\"453201\",\"425031\",\"402351\",\"430521\",\"513240\",\"521430\",\"542310\",\"534120\"};for(int i=0;i<720;i++){                boolean different=different(in,conf[i]);                for(int j=0;j<i;j++)                    if(!different(conf[i],conf[j]))                    {                        different=false;                        break;                    }                if(different)                    tot++;}boolean different(String a,String b)    {        for(int i=0;i<24;i++)        {            boolean equal=true;            for(int j=0;j<6;j++)            {                if(a.charAt(j)!=b.charAt(configs[i].charAt(j)-'0'))                    equal=false;            }            if(equal)                return false;        }return true;    }",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2326",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2848
        },
        {
          "title": "Editorial for Codeforces Beta Round #78 - Codeforces",
          "content": "Hi there!Here is editorial for the round #78.Russian editorial will be published a bit later - I supposed that there are more people who can understand English (or who can do English -> Russian web page translation) than vice versa.Again, I'm very sorry for the situation with problem B (div. 1) / D (div. 2). Also, I'm sorry that I underestimated difficulty of the problems. At least, I hope the problems appeared interesting for many contestants.Problem A (div. 2) - Help Far Away KingdomHere the problem was to round a number up according to the usual mathematical rules with the exception that if the last digit of integer part is equal to 9, you should output \"GOTO Vasilisa.\". One may notice that to check whether number's fractional part is not less than 0.5 only one digit just after the decimal point should be analysed. If it is '5' or greater - add one to the last digit of the integer part, and the problem is solved. Probably, the simplest way to deal with the input data was using of the string variables.Problem B (div. 2) - Help Chef GerasimThe problem was to accurately check what is required in the problem statement. First of all, check whether all volumes in the input are equal. In this case output \"Exemplary pages.\". Otherwise find two cups with largest and smallest volumes. Suppose their numbers are a and b, and their volumes are v[a] and v[b]. Now suppose that before pouring their volumes were equal to V. Then they contained 2V units of juice before (and after) pouring. So, you need to check whether (v[a] + v[b]) is divisible by 2. If this is not so - output \"Unrecoverable confihuration.\". Otherwise assign to the cups presumable old volume v[a] = v[b] = (v[a] + v[b])/2. Now if only one pouring have been made, volumes of juice in all cups should be equal, and you print corresponding message \"... ml. from ... to ...\". If volumes are not equal, print \"Unrecoverable configuration\" instead.Problem A (div. 1) / C (div. 2) - Help Victoria the WiseIn this problem you were required to find the number of sufficiently different colorings of a cube faces with predefined six colors. The most trivial solution is to introduce some ordering of the cube faces (say, 0 - front, 1 - back, 2 - up, 3 - down, 4 - left, 5 - right), then consider 720 = 6! arrangements of colors over these 6 faces. Each arrangement is some permutation of characters from the input. For each arrangement we find all its 24 rotations - and get 24 strings. Lexicographically smallest string will be representative of this coloring. The answer is the number of different representatives.Problem B (div. 1) / D (div. 2) - Help KingUnfortunately, initial author's solution for this problem appeared wrong. However, the optimality of the below algo was proved by Knuth and Yao in 1976. Limitation for n in the problem now changed to 10000.The process of tossing a coin and making decisions regarding which alternative to choose may be naturally described as drawing some (possibly infinite) binary tree. Each toss \"draws\" two new branches from every free node of the tree (initially the tree consists of one free node). Whenever the number of free nodes becomes >= n, you turn n free nodes into leaves (onle leaf for each alternative), and proceed with the other free nodes in a similar way. For example, for n == 3 we get the following infitite tree:            o         /      \\      o          o   /     \\      /     \\1        2  3        o                     /      \\                   ...      ...Now we should evaluate expected length of a random path in this infinite tree now. One may notice that the tree is recursive: since the number of free nodes at every level is strictly less than n, the situation will repeat after maximum of n steps. Once one notices this, it is not so hard to derive formulas for the answer. Since numbers in the answer could be of the order 2^n, one needs to write \"long arithmetics\", or use Java.BigInteger.Problem C (div. 1) / E (div. 2) - Help Greg the DwarfFor this problem I assumed numerical solution. But there are several cases to consider. Below without loss of generality we assume a <= b.1. l <= a <= b. In this case the answer is restricted by the length of the coffin, so the answer is l and it is clear that the coffin l x l can be brought through the corridor (a, b) - let's denote corridor's sizes in this way.2. a < l <= b. In this case the answer is a, and it is clear that no larger number can be an answer. Indeed, otherwise the coffin (w > a) x (l > a) is impossible to drag through the corridor (a, b).3. a <= b < l. This is the most general case, where we should rotate the coffin inside the corridor where it has a kink. To maximise the width of the coffin, we want to move it in such a way that one corner of the coffin touches one outer wall of the corridor (suppose bottommost on the picture), and another corner adjacent to the same long side of the coffin touches another outer wall of the corridor (leftmost on the picture). Let's introduce coordinate system in such a way that bottommost wall be OX axis, and leftmost wall - OY axis. Suppose that during the \"rotation\" process one corner of the coffin is at the point (x,0) (0 <= x <= l), then another corner should be at the point (0,sqrt(l*l-x*x)). And the answer we search for is min {distance from the segment (x,0) - (0,sqrt(l*l-x*x)) to the point (a,b) }, where you take min{} over all 0 <= x <= l. Let this distance at point x be f(x). Since f(x*) is minimal in some point x* and increases everywere to the left and to the right from x*, one may use ternary search to find its minimum.Exact solution for this problem is also possible: you can reduce the problem to minimizing the dot product of the vectors (a-x,b) and (-x,sqrt(l*l-x*x)) over x. But this leads to the neccessity to find the roots of the fourth-degree polynomial, which is not the best idea during the contest.Problem D (div. 1) - Help MonksThis problem was about famous puzzle \"Hanoi towers\", but diameters of some discs might be equal. How to solve that? A good thing to do is to write BFS solution to check optimality of your ideas for small inputs (by the way, BSF works quickly for almost all towers that have up to 10 discs) and then try to create an algo which solves the puzzle in an optimal way.Let C (x1, x2, ..., xn) be a solution (under \"solution\" here we mean optimal number of moves - the moves itself is easy to get with one recursive procedure; also \"solution\" is the number of moves to move group of discs from one peg to any other (and not some particular) ) to the puzzle when we have a puzzle with x1 equal largest discs, x2 equal second largest discs and so on. And let U (x1, x2, ..., xn) be a solution to the puzzle when you are allowed not to save the order of the discs (you should still follow the restriction of the initial puzzle not to put larger discs onto the smaller ones, but at the end discs of the same diameter may be in any order).Then one of the optimal solutions to the problem is the following:C (x1, x2, ..., xn) = U (x1, x2, ..., xn) if x1 = 1 (*)C (x1, x2, ..., xn) = 2*x1 - 1 if n = 1 (**)C (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) + x1 + C (x2, ..., xn). (***)U (x1, x2, ..., xn) = U (x2, ..., xn) + x1 + U (x2, ..., xn) (****)Why so? One can notice that U() is \"almost\" solution for our problem: it \"flips\" order of the bottommost group of equal discs, the order of the rest of the discs remains the same! (try to understand why)That's why (*) is correct.The (**) is quite obvious.The (***) does the following: move (x2, ..., xn) from peg 1 to peg 2 without saving the order. Then move x1 equal discs from peg 1 to peg 3, then move (x2, ..., xn) from peg 2 to peg 1 without saving the order (but it occurs that after we apply U() to the same group of discs twice, the order restored!), then move x1 equal discs from peg 3 to peg 2, and then use C() to move (x2, ..., xn) from peg 1 to peg 2 (here we use C() since we should preserve the order). So, (***) is correct.And (****) is quite straightforward expression for U(): move all discs but the largest group with the same algo, then move largest discs (that's why if x1 > 1, the group of discs \"flips\"), and then move all discs but the largest group onto the same peg with x1.Problem E (div. 1) - Help Shrek and DonkeyThis problem was about optimally playing this simple-at-first-glance game. The key thing to recognize in the statement was that it is not always optimal to name card which you don't have. Sometimes it is optimal to confuse the opponent by naming card which you have on hand. In this case... yes, he may think that the card you named is card on the table and lose during the next turn. Now the problem is to understand when to use the strategy of reduction of opponent's cards, when to bluff in the abovementioned sense and when to try to determine which card is on the table. But instead of \"when\" the right question is \"how frequently\" since we have nothing else but usual constant-sum matrix game, and optimal strategy is the mixture of these three. Let's construct a matrix first. Player 1 has three pure strategies: \"playing\" (when he plays the game and really tries to determine opponent's cards and card on the table), \"guessing\" (when he guesses which card is lying on the table) and \"bluffing\" (when he tries to confuse his opponent to force him to lose by naming card in his own hand). In turn, if the first player used \"bluffing\" strategy, or during the \"playing\" strategy named card on the table, his opponent has two strategies: \"check\" (i.e. to believe the first player that he doesn't own the card he named and guess it as the card on the table) and \"move on\" (i.e. to decide that it was a \"bluffing\" strategy and the game should be continued, but with notice that the first player has named card on hands). Let's denote P(m,n) probability to win the game when the first player has m cards and the second player has n cards. Then P(m,n) is the value of the matrix game with the following matrix (rows - strategies of the first player, two numbers in the rows - probabilities to win when the second player uses strategies \"check\" and \"move on\" correspondingly:                                \"check\"                                    \"move on\"\"playing\"        n/(n+1)*(1-P(n-1,m))        1/(n+1) + n/(n+1)*(1-P(n-1,m))\"guessing\"                 1/(n+1)                                     1/(n+1)\"bluffing\"                       1                                       1-P(n,m-1)How to get these numbers in the matrix? Consider the first row: \"playing\" strategy of the first player, \"check\" strategy of the second. First just names one of the n+1 cards. With probability 1/(n+1) he names card on the table, seconds checks it and wins (so, probability to with for the first is 0), with probability n/(n+1) the first names one of the cards on hands of the second player, so the game continues, second wins with prob. P(n-1,m) in this case. Then the overall probability for the first to win with such combination of pure strategies is n/(n+1)*(1-P(n-1,m)). In the same manner we fill other cells of the matrix. Finally we solve the game (this can be done straightforwardly, or with one formula if one notices that the \"guessing\" strategy is suboptimal everywhere when m>=1 and n>=1 and that the game doesn't have saddle points) and get answer to the problem - P(m,n).And the last thing to note: when m==0 it is clear that during his move the second wins, so the first should guess, and P(0,n) = 1/(n+1). When n==0 P(m,0)==1 sinse we just do one rightguessing.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2323",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 1",
          "code": "0,0,0,1,0,0,0,1,0,0,0,1,2,0,0,0,1,0,0,0,1,0,0,0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 2",
          "code": "---------------------------------------------------",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 3",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 1 |\n     +---+---+---+---+\n     | 5 | 0 | 4 | 2 | \n     +---+---+---+---+\n         | 3 |\n         +---+1:         +---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 5 |\n     +---+---+---+---+\n     | 0 | 1 | 2 | 3 | \n     +---+---+---+---+\n         | 4 |\n         +---+2:         +---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+         +---+\n         | 1 |\n     +---+---+---+---+\n     | 4 | 2 | 5 | 0 | \n     +---+---+---+---+\n         | 3 |\n         +---+http://codeforces.com/blog/entry/2325",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 4",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 5",
          "code": "+---+\n         | 1 |\n     +---+---+---+---+\n     | 5 | 0 | 4 | 2 | \n     +---+---+---+---+\n         | 3 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 6",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 7",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 0 | 1 | 2 | 3 | \n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 8",
          "code": "+---+\n         | 5 |\n     +---+---+---+---+\n     | 3 | 0 | 1 | 2 | ----->\n     +---+---+---+---+\n         | 4 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 9",
          "code": "+---+\n         | 1 |\n     +---+---+---+---+\n     | 4 | 2 | 5 | 0 | \n     +---+---+---+---+\n         | 3 |\n         +---+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #78 - Codeforces - Code 10",
          "code": "Unrecoverable configuration",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2319",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 10000, \"b\");\n    inf.readSpace();\n    int l = inf.readInt(1, 10000, \"l\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 10000, \"b\");\n    inf.readSpace();\n    int l = inf.readInt(1, 10000, \"l\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 10000, \"b\");\n    inf.readSpace();\n    int l = inf.readInt(1, 10000, \"l\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to attempt parsing a string into a double\nbool parseDouble(const string& s, double& val) {\n    std::istringstream iss(s);\n    iss >> val;\n    return !iss.fail() && iss.eof();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string judgeAnsLine = ans.readLine();\n    string contAnsLine = ouf.readLine();\n\n    // Trim leading and trailing whitespaces\n    judgeAnsLine = trim(judgeAnsLine);\n    contAnsLine = trim(contAnsLine);\n\n    double judgeValue, contValue;\n    bool judgeIsNumber = parseDouble(judgeAnsLine, judgeValue);\n    bool contIsNumber = parseDouble(contAnsLine, contValue);\n\n    if (!judgeIsNumber) {\n        // Judge's answer is \"My poor head =(\"\n        if (judgeAnsLine != \"My poor head =(\")\n            quitf(_fail, \"Invalid judge's answer: '%s'\", judgeAnsLine.c_str());\n        // Now check contestant's output\n        if (contIsNumber)\n            quitf(_wa, \"Expected 'My poor head =(', found number %.10f\", contValue);\n        else if (contAnsLine != \"My poor head =(\")\n            quitf(_wa, \"Expected 'My poor head =(', found '%s'\", compress(contAnsLine).c_str());\n        else\n            quitf(_ok, \"Output is correct: 'My poor head =('\");\n    } else {\n        // Judge's answer is a number\n        if (!contIsNumber)\n            quitf(_wa, \"Expected a number, found '%s'\", compress(contAnsLine).c_str());\n        // Compare values within the required absolute or relative error\n        double maxError = 1e-7;\n        if (doubleCompare(judgeValue, contValue, maxError))\n            quitf(_ok, \"Correct answer within absolute or relative error 1e-7\");\n        else\n            quitf(_wa, \"Wrong answer: Expected %.10f, Found %.10f\", judgeValue, contValue);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int l = opt<int>(\"l\", -1);\n\n    if (type == \"min_limits\"){\n        a = b = l = 1;\n    }\n    else if (type == \"max_limits\"){\n        a = b = l = 10000;\n    }\n    else if (type == \"impossible\"){\n        // Generate a case where the coffin cannot pass through the corridor\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        l = a + b + rnd.next(1, 10000);\n    }\n    else if (type == \"max_width_equals_l\"){\n        // Generate a case where the maximum possible width equals l\n        l = rnd.next(1, 10000);\n        a = b = rnd.next(l, 10000);\n    }\n    else if (type == \"precision\"){\n        // Generate a case that requires high precision\n        a = b = rnd.next(1, 10000);\n        l = int(sqrt(a * a + b * b)) - rnd.next(0, 5);\n        if (l < 1) l = 1;\n    }\n    else if (type == \"random\"){\n        if (a == -1) a = rnd.next(1, 10000);\n        if (b == -1) b = rnd.next(1, 10000);\n        if (l == -1) l = rnd.next(1, 10000);\n    }\n    else{\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", a, b, l);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int l = opt<int>(\"l\", -1);\n\n    if (type == \"min_limits\"){\n        a = b = l = 1;\n    }\n    else if (type == \"max_limits\"){\n        a = b = l = 10000;\n    }\n    else if (type == \"impossible\"){\n        // Generate a case where the coffin cannot pass through the corridor\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        l = a + b + rnd.next(1, 10000);\n    }\n    else if (type == \"max_width_equals_l\"){\n        // Generate a case where the maximum possible width equals l\n        l = rnd.next(1, 10000);\n        a = b = rnd.next(l, 10000);\n    }\n    else if (type == \"precision\"){\n        // Generate a case that requires high precision\n        a = b = rnd.next(1, 10000);\n        l = int(sqrt(a * a + b * b)) - rnd.next(0, 5);\n        if (l < 1) l = 1;\n    }\n    else if (type == \"random\"){\n        if (a == -1) a = rnd.next(1, 10000);\n        if (b == -1) b = rnd.next(1, 10000);\n        if (l == -1) l = rnd.next(1, 10000);\n    }\n    else{\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", a, b, l);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_limits\n./gen -type max_limits\n\n./gen -type impossible\n./gen -type impossible\n./gen -type impossible\n\n./gen -type max_width_equals_l\n./gen -type max_width_equals_l\n\n./gen -type precision\n./gen -type precision\n./gen -type precision\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Asymmetric cases\n./gen -type random -a 10000 -b 1 -l 5000\n./gen -type random -a 1 -b 10000 -l 5000\n\n# Symmetric cases\n./gen -type random -a 5000 -b 5000 -l 7000\n./gen -type random -a 10000 -b 10000 -l 10000\n\n# Cases where 'l' is minimal\n./gen -type random -l 1\n./gen -type random -l 2\n./gen -type random -l 3\n\n# Cases where 'l' is maximal\n./gen -type random -l 9998\n./gen -type random -l 9999\n./gen -type random -l 10000\n\n# Cases with specified 'a' and 'b'\n./gen -type random -a 1000 -b 2000\n./gen -type random -a 3000 -b 1500\n./gen -type random -a 5000 -b 5000\n\n# Edge cases\n./gen -type impossible -a 1 -b 1 -l 10000\n./gen -type impossible -a 1 -b 1 -l 50000\n\n# Additional random cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:36.819162",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/A",
      "title": "A. Commentary Boxes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains four integer numbers nn, mm, aa and bb (1≤n,m≤10121≤n,m≤1012, 1≤a,b≤1001≤a,b≤100), where nn is the initial number of the commentary boxes, mm is the number of delegations to come, aa is the fee to build a box and bb is the fee to demolish a box.",
      "output_spec": "OutputOutput the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by mm). It is allowed that the final number of the boxes is equal to 00.",
      "sample_tests": "ExamplesInputCopy9 7 3 8OutputCopy15InputCopy2 7 3 7OutputCopy14InputCopy30 6 17 19OutputCopy0",
      "description": "A. Commentary Boxes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains four integer numbers nn, mm, aa and bb (1≤n,m≤10121≤n,m≤1012, 1≤a,b≤1001≤a,b≤100), where nn is the initial number of the commentary boxes, mm is the number of delegations to come, aa is the fee to build a box and bb is the fee to demolish a box.\n\nOutputOutput the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by mm). It is allowed that the final number of the boxes is equal to 00.\n\nInputCopy9 7 3 8OutputCopy15InputCopy2 7 3 7OutputCopy14InputCopy30 6 17 19OutputCopy0\n\nInputCopy9 7 3 8\n\nOutputCopy15\n\nInputCopy2 7 3 7\n\nOutputCopy14\n\nInputCopy30 6 17 19\n\nOutputCopy0\n\nNoteIn the first example organizers can build 55 boxes to make the total of 1414 paying 33 burles for the each of them.In the second example organizers can demolish 22 boxes to make the total of 00 paying 77 burles for the each of them.In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get 55 boxes.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces",
          "content": "Hello Codeforces!On Sunday, June 10, 2018 at 18:05UTC+8 Educational Codeforces Round 45 will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Adilbek adedalic Dalabaev, Roman Roms Glazov, Ivan BledDest Androsov, Mike MikeMirzayanov Mirzayanov and me.Good luck to all participants!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 KrK 7 225 2 isaf27 7 231 3 BigBag 7 325 4 Motarack 7 327 5 TangentDay 7 331 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 202:-52 2 2014CAIS01 26:-2 3 djm03178 20 4 bitcoin 19 5 antguz 25:-17 549 successful hacks and 525 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A tzuyu_chou 0:01 B DoomzGay 0:05 C 562225807 0:08 D teja349 0:12 E eddy1021 0:18 F nhho 0:45 G AChen142857 0:14 UPD: Editorial is out",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/59919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1384
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces",
          "content": "990A - Commentary Boxes Tutorial990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to nn and the closest one greater than nn. Distances to them are (nmodm)(nmodm) and (m−(nmodm))(m−(nmodm)) respectively. Now you should multiply the first result by bb, the second result by aa and compare the products.Overall complexity: O(1)O(1). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}990B - Micro-World Tutorial990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria ii you need to check existence of any bacteria jj satisfying condition ai<aj≤ai+Kai<aj≤ai+K.There plenty of ways to check this condition. One of them is to sort array aa and for each ii find minimal aj>aiaj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai≤106ai≤106 and build solution around it.Result complexity is O(nlogn)O(nlog⁡n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}990C - Bracket Sequences Concatenation Problem Tutorial990C - Bracket Sequences Concatenation ProblemLet f(s)f(s) be the mirror reflection of the string ss. For example: ff(\"((\") = \"))\", ff(\"))(\") = \")((\", ff(\"()\") = \"()\".Let string be good if it does not have a prefix, which have more closing brackets than opening ones. For example, \"((\", \"(())(\", \"()()\" are good, and \"())\", \")((\", \"()())\" are not.The balance bal(s)bal(s) of the string ss is the difference between number of opening and closing brackets in ss. For example, balbal(\"(()\") = 1, balbal(\"()\") = 0.Let cnt[x]cnt[x] be the number of good strings with a balance xx.The answer to the problem is ∑s, where f(s) is goodcnt[bal(f(s))]∑s, where f(s) is goodcnt[bal(f(s))]. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}990D - Graph And Its Complement Tutorial990D - Graph And Its ComplementLet's prove that if a>1a>1, then b=1b=1. Let GG be the original graph, and HH — the complement of the graph GG. Let's look at each pair of vertices (u,v)(u,v). If uu and vv belong to different components of the graph GG, then there is an edge between them in the graph HH. Otherwise, uu and vv belong to the same component of the graph GG, but since GG has more than one component, there is vertex xx in other component of GG, and there are edges {u,x}{u,x} and {v,x}{v,x} in HH. That's why, there is a connected path for any pair of vertices (u,v)(u,v), and the graph HH is connected. Similarly, the case b>1b>1 is proved.So, if min(a,b)>1min(a,b)>1, then the answer is \"NO\". Otherwise, min(a,b)=1min(a,b)=1. Consider the case where b=1b=1 (if b>ab>a, we can swap aa and bb, and output complement of the constructed graph). To have aa components in the graph GG, it is enough to connect the vertex 11 with the vertex 22, the vertex 22 with the vertex 33, ⋯⋯, the vertex n−an−a with the vertex n−a+1n−a+1. A particular cases are the tests n=2,a=1,b=1n=2,a=1,b=1 and n=3,a=1,b=1n=3,a=1,b=1. There is no suitable graph for them. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}990E - Post Lamps Tutorial990E - Post LampsLet's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider 00 to be covered. Function f(i)f(i) — the minimal number of post lamps to cover segment [0;i][0;i] is clearly monotonous, thus you want to update states as early as possible.Okay, now you iterate over all l∈[1;k]l∈[1;k] and update the answer with the results multiplied by cost.Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by k+1k+1 positions or return -1. This can be easily proven by contradiction.Overall complexity: O(n⋅logn)O(n⋅log⁡n), as you do about nlnl steps for each ll and that is a common series sum. Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}990F - Flow Control Tutorial990F - Flow ControlThe answer is \"Impossible\" if and only if the sum of values is not equal to 00. Writing some number on edge does not change the total sum and the goal of the problem is to make 00 in each vertex, thus getting 00 in total.The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and 00 for the rest of edges.Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has 00. This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.Overall complexity: O(n+m)O(n+m). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tdfs(0, -1);\n\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}990G - GCD Counting Tutorial990G - GCD CountingFirstly, for every i∈[1,2⋅105]i∈[1,2⋅105] we can calculate the number of paths such that g(x,y)g(x,y) is divisible by ii. We can do it as follows: generate all divisors of numbers aiai (numbers not exceeding 2⋅1052⋅105 have at most 160160 divisors, so this will be fast enough), and then for every i∈[1,2⋅105]i∈[1,2⋅105] analyze the graph containing the vertices that have ii as its divisor. Each component of this graph gives us k(k+1)2k(k+1)2 paths (if its size is kk), and this is the only formula we need to calculate the number of paths where g(x,y)g(x,y) is divisible by ii (let this be h(i)h(i)).How can we get the answer if we know the values of h(i)h(i)? We can use inclusion-exclusion with Mobius function, for example, to prove that ans(1)=∑i=12⋅105μ(i)h(i)ans(1)=∑i=12⋅105μ(i)h(i); and then if we want to apply the same technique for finding ans(x)ans(x) with any possible xx, we could divide all numbers aiai by xx and do the same thing. But it might be too slow, so it's better to rewrite this formula as ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi)ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi), because we will do exactly the same when dividing all numbers by xx.In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.This problem can also be solved with centroid decomposition. Solution with Möbius (Bleddest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n hd = 0;\n tl = 0;\n q[tl++] = x;\n used[x] = cc;\n while(hd < tl)\n {\n int z = q[hd++];\n for(auto y : g[z])\n {\n if(good[a[y]] == cc && used[y] < cc)\n {\n used[y] = cc;\n q[tl++] = y;\n }\n }\n }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t for(auto x : need_bfs[j])\n\t\t {\n\t\t if(used[x] == cc) continue;\n\t\t\t int z = bfs(x, i);\n\t\t\t ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t }\n\t for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n} Solution with centroid (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\n//\tcerr << \"C = \"<< c << endl;\n\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\n\tT++;\n\taddDiv(a[c], 1);\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\n\tmemset(res, 0, sizeof res);\n\n\tT = 0;\n\tcalc(0);\n\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59962",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 990\\s*A"
          },
          "content_length": 17061
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "what I did in C was ignored all cases of brackets which gave )( this sort of thing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 15",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 17",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 18",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\"); // 1 ≤ n ≤ 1e12\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\"); // 1 ≤ m ≤ 1e12\n    inf.readSpace();\n    int a = inf.readInt(1, 100, \"a\"); // 1 ≤ a ≤ 100\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\"); // 1 ≤ b ≤ 100\n    inf.readEoln();\n\n    inf.readEof(); // Ensure no extra input\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\"); // 1 ≤ n ≤ 1e12\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\"); // 1 ≤ m ≤ 1e12\n    inf.readSpace();\n    int a = inf.readInt(1, 100, \"a\"); // 1 ≤ a ≤ 100\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\"); // 1 ≤ b ≤ 100\n    inf.readEoln();\n\n    inf.readEof(); // Ensure no extra input\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\"); // 1 ≤ n ≤ 1e12\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000000LL, \"m\"); // 1 ≤ m ≤ 1e12\n    inf.readSpace();\n    int a = inf.readInt(1, 100, \"a\"); // 1 ≤ a ≤ 100\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\"); // 1 ≤ b ≤ 100\n    inf.readEoln();\n\n    inf.readEof(); // Ensure no extra input\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    // Read the test case type from the arguments\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long n = 0, m = 0;\n    int a = 0, b = 0;\n\n    // Constants for the constraints\n    const long long n_min = 1;\n    const long long n_max = 1000000000000LL; // 1e12\n    const long long m_min = 1;\n    const long long m_max = 1000000000000LL; // 1e12\n    const int a_min = 1;\n    const int a_max = 100;\n    const int b_min = 1;\n    const int b_max = 100;\n    \n    if (type == \"random\") {\n        // Random values for n and m within constraints\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    } else if (type == \"max_values\") {\n        // Maximum values for n and m\n        n = n_max;\n        m = m_max;\n    } else if (type == \"min_values\") {\n        // Minimum values for n and m\n        n = n_min;\n        m = m_min;\n    } else if (type == \"n_divisible_by_m\") {\n        // n is a multiple of m\n        m = rnd.next(m_min, m_max);\n        long long k_max = n_max / m;\n        if (k_max == 0) k_max = 1;\n        long long k = rnd.next(1LL, k_max);\n        n = k * m;\n    } else if (type == \"n_one_less_than_multiple_of_m\") {\n        // n is one less than a multiple of m\n        m = rnd.next(2LL, m_max);\n        long long k_max = n_max / m;\n        if (k_max == 0) k_max = 1;\n        long long k = rnd.next(1LL, k_max);\n        n = k * m - 1;\n        if (n < n_min) n = n_min;\n    } else if (type == \"n_one_more_than_multiple_of_m\") {\n        // n is one more than a multiple of m\n        m = rnd.next(m_min, m_max / 2);\n        long long k_max = (n_max - 1) / m;\n        if (k_max == 0) k_max = 1;\n        long long k = rnd.next(1LL, k_max);\n        n = k * m + 1;\n        if (n > n_max) n = n_max;\n    } else if (type == \"n_and_m_coprime\") {\n        // n and m are coprime\n        n = rnd.next(n_min, n_max);\n        int attempts = 0;\n        do {\n            m = rnd.next(m_min, m_max);\n            attempts++;\n            if (attempts > 1000) {\n                n = 2;\n                m = 3;\n                break;\n            }\n        } while (__gcd(n, m) != 1);\n    } else if (type == \"n_equals_m\") {\n        // n equals m\n        n = rnd.next(n_min, n_max);\n        m = n;\n    } else if (type == \"n_m_large_coprime\") {\n        // Large n and m that are coprime\n        int attempts = 0;\n        do {\n            n = rnd.next(n_max / 2, n_max);\n            m = rnd.next(m_max / 2, m_max);\n            attempts++;\n            if (attempts > 1000) {\n                n = n_max - 1;\n                m = n_max - 2;\n                break;\n            }\n        } while (__gcd(n, m) != 1);\n    } else if (type == \"a_greater_than_b\") {\n        // a is greater than b\n        a = rnd.next(2, a_max);\n        b = rnd.next(b_min, a - 1);\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    } else if (type == \"b_greater_than_a\") {\n        // b is greater than a\n        b = rnd.next(2, b_max);\n        a = rnd.next(a_min, b - 1);\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    } else {\n        // Default to random values\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    }\n    \n    // Generate random values for a and b if not set\n    if (a == 0 || b == 0) {\n        a = rnd.next(a_min, a_max);\n        b = rnd.next(b_min, b_max);\n    }\n    \n    // Output n, m, a, and b\n    printf(\"%lld %lld %d %d\\n\", n, m, a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    \n    // Read the test case type from the arguments\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long n = 0, m = 0;\n    int a = 0, b = 0;\n\n    // Constants for the constraints\n    const long long n_min = 1;\n    const long long n_max = 1000000000000LL; // 1e12\n    const long long m_min = 1;\n    const long long m_max = 1000000000000LL; // 1e12\n    const int a_min = 1;\n    const int a_max = 100;\n    const int b_min = 1;\n    const int b_max = 100;\n    \n    if (type == \"random\") {\n        // Random values for n and m within constraints\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    } else if (type == \"max_values\") {\n        // Maximum values for n and m\n        n = n_max;\n        m = m_max;\n    } else if (type == \"min_values\") {\n        // Minimum values for n and m\n        n = n_min;\n        m = m_min;\n    } else if (type == \"n_divisible_by_m\") {\n        // n is a multiple of m\n        m = rnd.next(m_min, m_max);\n        long long k_max = n_max / m;\n        if (k_max == 0) k_max = 1;\n        long long k = rnd.next(1LL, k_max);\n        n = k * m;\n    } else if (type == \"n_one_less_than_multiple_of_m\") {\n        // n is one less than a multiple of m\n        m = rnd.next(2LL, m_max);\n        long long k_max = n_max / m;\n        if (k_max == 0) k_max = 1;\n        long long k = rnd.next(1LL, k_max);\n        n = k * m - 1;\n        if (n < n_min) n = n_min;\n    } else if (type == \"n_one_more_than_multiple_of_m\") {\n        // n is one more than a multiple of m\n        m = rnd.next(m_min, m_max / 2);\n        long long k_max = (n_max - 1) / m;\n        if (k_max == 0) k_max = 1;\n        long long k = rnd.next(1LL, k_max);\n        n = k * m + 1;\n        if (n > n_max) n = n_max;\n    } else if (type == \"n_and_m_coprime\") {\n        // n and m are coprime\n        n = rnd.next(n_min, n_max);\n        int attempts = 0;\n        do {\n            m = rnd.next(m_min, m_max);\n            attempts++;\n            if (attempts > 1000) {\n                n = 2;\n                m = 3;\n                break;\n            }\n        } while (__gcd(n, m) != 1);\n    } else if (type == \"n_equals_m\") {\n        // n equals m\n        n = rnd.next(n_min, n_max);\n        m = n;\n    } else if (type == \"n_m_large_coprime\") {\n        // Large n and m that are coprime\n        int attempts = 0;\n        do {\n            n = rnd.next(n_max / 2, n_max);\n            m = rnd.next(m_max / 2, m_max);\n            attempts++;\n            if (attempts > 1000) {\n                n = n_max - 1;\n                m = n_max - 2;\n                break;\n            }\n        } while (__gcd(n, m) != 1);\n    } else if (type == \"a_greater_than_b\") {\n        // a is greater than b\n        a = rnd.next(2, a_max);\n        b = rnd.next(b_min, a - 1);\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    } else if (type == \"b_greater_than_a\") {\n        // b is greater than a\n        b = rnd.next(2, b_max);\n        a = rnd.next(a_min, b - 1);\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    } else {\n        // Default to random values\n        n = rnd.next(n_min, n_max);\n        m = rnd.next(m_min, m_max);\n    }\n    \n    // Generate random values for a and b if not set\n    if (a == 0 || b == 0) {\n        a = rnd.next(a_min, a_max);\n        b = rnd.next(b_min, b_max);\n    }\n    \n    // Output n, m, a, and b\n    printf(\"%lld %lld %d %d\\n\", n, m, a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max_values\n./gen -type min_values\n\n./gen -type n_divisible_by_m\n./gen -type n_divisible_by_m\n./gen -type n_one_less_than_multiple_of_m\n./gen -type n_one_less_than_multiple_of_m\n./gen -type n_one_more_than_multiple_of_m\n./gen -type n_one_more_than_multiple_of_m\n\n./gen -type n_and_m_coprime\n./gen -type n_and_m_coprime\n./gen -type n_equals_m\n./gen -type n_equals_m\n./gen -type n_m_large_coprime\n./gen -type n_m_large_coprime\n\n./gen -type a_greater_than_b\n./gen -type a_greater_than_b\n./gen -type b_greater_than_a\n./gen -type b_greater_than_a\n\n# Special cases to test n at the minimum and maximum values\n./gen -type min_values\n./gen -type max_values\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:39.163147",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/B",
      "title": "B. Микромир",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых положительных числа через пробел nn и KK (1≤n≤2⋅1051≤n≤2⋅105, 1≤K≤1061≤K≤106) — количество бактерий и межгалактическая константа KK.Вторая строка содержит nn целых чисел через пробел a1,a2,…,ana1,a2,…,an (1≤ai≤1061≤ai≤106) — размеры бактерий в Вашей чашке.",
      "output_spec": "Выходные данныеВыведите единственное число — наименьшее возможное количество оставшихся бактерий.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 1101 53 42 102 101 55 54Выходные данныеСкопировать3Входные данныеСкопировать6 520 15 10 15 20 25Выходные данныеСкопировать1Входные данныеСкопировать7 10000001 1 1 1 1 1 1Выходные данныеСкопировать7",
      "description": "B. Микромир\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых положительных числа через пробел nn и KK (1≤n≤2⋅1051≤n≤2⋅105, 1≤K≤1061≤K≤106) — количество бактерий и межгалактическая константа KK.Вторая строка содержит nn целых чисел через пробел a1,a2,…,ana1,a2,…,an (1≤ai≤1061≤ai≤106) — размеры бактерий в Вашей чашке.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — наименьшее возможное количество оставшихся бактерий.\n\nВыходные данные\n\nВходные данныеСкопировать7 1101 53 42 102 101 55 54Выходные данныеСкопировать3Входные данныеСкопировать6 520 15 10 15 20 25Выходные данныеСкопировать1Входные данныеСкопировать7 10000001 1 1 1 1 1 1Выходные данныеСкопировать7\n\nВходные данныеСкопировать7 1101 53 42 102 101 55 54\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 520 15 10 15 20 25\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 10000001 1 1 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый пример описан в условии задачи.Во втором примере одно из оптимальных решений следующее: [20,15,10,15,20–––,25][20,15,10,15,20_,25] →→ [20,15,10,15–––,25][20,15,10,15_,25] →→ [20,15,10–––,25][20,15,10_,25] →→ [20,15–––,25][20,15_,25] →→ [20–––,25][20_,25] →→ [25][25].В третьем примере никакая бактерия не может поглотить никакую другую.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 45 [рейтинговый для Div. 2] - Codeforces",
          "content": "Привет, Codeforces!В воскресенье, 10 июня 2018 г. в 18:05UTC+8 состоится Educational Codeforces Round 45.Продолжается серия образовательных раундов в рамках инициативы Harbour.Space University! Подробности о сотрудничестве Harbour.Space University и Codeforces можно прочитать в посте.Этот раунд будет рейтинговым для участников с рейтингом менее 2100. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. После окончания раунда будет период времени длительностью в 12 часов, в течение которого вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования.Вам будет предложено 7 задач на 2 часа. Мы надеемся, что вам они покажутся интересными.Задачи вместе со мной придумывали и готовили Адилбек adedalic Далабаев, Роман Roms Глазов, Иван BledDest Андросов и Михаил MikeMirzayanov Мирзаянов.Удачи в раунде! Успешных решений!Поздравляем победителей: Место Участник Задач решено Штраф 1 KrK 7 225 2 isaf27 7 231 3 BigBag 7 325 4 Motarack 7 327 5 TangentDay 7 331 Поздравляем лучших взломщиков: Место Участник Число взломов 1 halyavin 202:-52 2 2014CAIS01 26:-2 3 djm03178 20 4 bitcoin 19 5 antguz 25:-17 Было сделано 549 успешных и 525 неудачных взломов.И, наконец, поздравляем людей, отправивших первое полное решение по задаче: Задача Участник Штраф A tzuyu_chou 0:01 B DoomzGay 0:05 C 562225807 0:08 D teja349 0:12 E eddy1021 0:18 F nhho 0:45 G AChen142857 0:14 UPD: Разбор опубликован",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/59919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1502
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces",
          "content": "990A - Комментаторские кабинки Разбор990A - Комментаторские кабинкиЗаметим, что достаточно проверить только два числа: ближайшее меньшее или равное nn и ближайшее большее nn. Расстояния до них равны (nmodm)(nmodm) и (m−(nmodm))(m−(nmodm)) соответственно. Осталось домножить первый результат на bb, второй результат на aa и сравнить произведения.Асимптотика решения: O(1)O(1). Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}990B - Микромир Разбор990B - МикромирМожно доказать, что оптимальный ответ равен количеству бактерий таких, что их не может поглотить никакая другая бактерия. Поэтому, для каждой бактерии ii необходимо проверить наличие другой бактерии jj, удовлетворяющей условию ai<aj≤ai+Kai<aj≤ai+K.Есть множество способов проверить данное условие. Одно из них следующее: отсортируем массив aa и для каждого ii найдем минимальное aj>aiaj>ai с помощью upper_bound или метода двух указателей. Или можно воспользоваться фактом, что ai≤106ai≤106, и построить решение вокруг него.Результирующая асимптотика — O(nlogn)O(nlog⁡n). Решение (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}990C - Конкатенация скобочных последовательностей РазборTutorial is loading... Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}990D - Граф и его дополнение Разбор990D - Граф и его дополнениеДокажем, что если a>1a>1, то b=1b=1. Пусть GG – исходный граф, а HH — дополнение графа GG. Рассмотрим любую пару вершин (u,v)(u,v). Если они лежат в разных компонентах связанности графа GG, то в графе HH между ними есть ребро (иначе они были бы в одной компоненте связанности в графе GG). Если же вершины uu и vv лежат в одной компоненте связанности графа GG, то в графе HH мы можем перейти из вершины uu в любую вершину xx, лежащую в другой компоненте связанности графа GG, а затем из вершины xx перейти в вершину vv. Таким образом, для любой пары вершин (u,v)(u,v) существует связывающий их путь, а значит граф HH связанный. Аналогично доказывается случай b>1b>1.Таким образом, если min(a,b)>1min(a,b)>1, то ответ «NO». Осталось рассмотреть случай, когда min(a,b)=1min(a,b)=1. Рассмотрим случай, когда b=1b=1 (если это не так, мы можем поменять местами aa и bb, а затем вывести дополнение полученного графа). Чтобы в графе GG было aa компонент, достаточно вершину 11 соединить с вершиной 22, вершину 22 с вершиной 33, ⋯⋯ , вершину n−an−a с вершиной n−a+1n−a+1.Частным случаем является тесты n=2,a=1,b=1n=2,a=1,b=1 и n=3,a=1,b=1n=3,a=1,b=1. Для них не существует подходящий графов. Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}990E - Уличные фонари Разбор990E - Уличные фонариНачнем с того, что научимся ставить лампы фиксированной мощности так, чтобы покрыть весь отрезок минимальным количеством. Работает следующая жадность: будем находить самую правую незаблокированную позицию и ставить туда лампу, пока либо не будет покрыт весь отрезок, либо эта позиция окажется левее последней поставленной лампы. Изначально считаем только 00 покрытым. Функция f(i)f(i) — минимальное количество ламп, требуемых для покрытия отрезка [0;i][0;i] очевидно монотонная, поэтому обновлять состояния мы хотим как можно раньше.Теперь переберем все l∈[1;k]l∈[1;k] и обновим ответ результатом, домноженным на цену.Ага, теперь почему это быстро? Разумеется, предпосчитаем самую правую свободную позицию для каждого префикс-сегмента. Если существуют свободные позиции справа от последней поставленной лампы, то самая правая из них всегда будет самой правой для всего префикс-сегмента. Наконец, любые две последовательные итерации алгоритма либо подвинут на k+1k+1 позицию, либо вернут -1. Это можно легко доказать с помощью противоречия.Асимптотика решения: O(n⋅logn)O(n⋅log⁡n), так для каждого ll получается примерно nlnl шагов, а это уже известная сумма ряда. Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}990F - Управление потоками РазборTutorial is loading... Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tdfs(0, -1);\n\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}990G - Подсчёт GCD Разбор990G - Подсчёт GCDСначала для каждого i∈[1,2⋅105]i∈[1,2⋅105] подсчитаем количество таких путей, что g(x,y)g(x,y) делится на ii. Это можно сделать следующим образом: найдем все делители всех чисел aa (числа до 2⋅1052⋅105 имеют не более 160160 делителей, поэтому эта часть решения не будет долгой), и потом для каждого i∈[1,2⋅105]i∈[1,2⋅105] проанализируем граф, построенный на вершинах, для которых ii является делителем. Каждая компонента связности этого графа содержит k(k+1)2k(k+1)2 путей (если ее размер равен kk), и это на самом деле единственная формула, которая нам нужна, чтобы подсчитать количество путей, для которых g(x,y)g(x,y) делится на ii (обозначим это как h(i)h(i)).Как из значений h(i)h(i) получить ответ на исходную задачу? Например, можно при помощи формулы включений-исключений с функцией Мебиуса доказать, что ans(1)=∑i=12⋅105μ(i)h(i)ans(1)=∑i=12⋅105μ(i)h(i), а ans(x)ans(x) для остальных xx можно найти, поделив все числа aiai на xx и сделав все то же самое. Но это может быть слишком медленно, поэтому лучше переписать это в виде формулы ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi)ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi) — именно это мы получим, если поделим все числа на xx.Многие участники написали более простую версию этого решения, поэтому оно может казаться чересчур сложным по сравнению с тем, что сдавали на самом деле.Также эту задачу можно решить при помощи центроидной декомпозиции. Решение с Мёбиусом (Bleddest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n hd = 0;\n tl = 0;\n q[tl++] = x;\n used[x] = cc;\n while(hd < tl)\n {\n int z = q[hd++];\n for(auto y : g[z])\n {\n if(good[a[y]] == cc && used[y] < cc)\n {\n used[y] = cc;\n q[tl++] = y;\n }\n }\n }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t for(auto x : need_bfs[j])\n\t\t {\n\t\t if(used[x] == cc) continue;\n\t\t\t int z = bfs(x, i);\n\t\t\t ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t }\n\t for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n} Решение с центроидом (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\n//\tcerr << \"C = \"<< c << endl;\n\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\n\tT++;\n\taddDiv(a[c], 1);\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\n\tmemset(res, 0, sizeof res);\n\n\tT = 0;\n\tcalc(0);\n\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59962",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 990\\s*B"
          },
          "content_length": 15548
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 45 [рейтинговый для Div. 2] - Codeforces - Code 1",
          "code": "what I did in C was ignored all cases of brackets which gave )( this sort of thing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [рейтинговый для Div. 2] - Codeforces - Code 2",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [рейтинговый для Div. 2] - Codeforces - Code 3",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 15",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 17",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 45 - Codeforces - Code 18",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2 * 100000, \"n\");\n    inf.readSpace();\n    int K = inf.readInt(1, 1000000, \"K\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2 * 100000, \"n\");\n    inf.readSpace();\n    int K = inf.readInt(1, 1000000, \"K\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2 * 100000, \"n\");\n    inf.readSpace();\n    int K = inf.readInt(1, 1000000, \"K\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int K = opt<int>(\"K\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxA = 1000000;\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1, maxA - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"max_swallow\") {\n        int big = maxA;\n        a[0] = big;\n        for (int i = 1; i < n; ++i) {\n            // Ensure big > a[i] and big ≤ a[i] + K\n            a[i] = rnd.next(big - K, big - 1);\n        }\n    } else if (type == \"no_swallow\") {\n        // No bacteria can swallow any other bacteria\n        for (int i = 0; i < n; ++i) {\n            a[i] = i * (K + 1) + rnd.next(1, K); // Ensure differences are at least K+1\n            if (a[i] > maxA) a[i] = maxA;\n        }\n    } else if (type == \"zigzag\") {\n        int val1 = rnd.next(1, maxA / 2);\n        int val2 = val1 + K / 2;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, K);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int K = opt<int>(\"K\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxA = 1000000;\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1, maxA - n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"max_swallow\") {\n        int big = maxA;\n        a[0] = big;\n        for (int i = 1; i < n; ++i) {\n            // Ensure big > a[i] and big ≤ a[i] + K\n            a[i] = rnd.next(big - K, big - 1);\n        }\n    } else if (type == \"no_swallow\") {\n        // No bacteria can swallow any other bacteria\n        for (int i = 0; i < n; ++i) {\n            a[i] = i * (K + 1) + rnd.next(1, K); // Ensure differences are at least K+1\n            if (a[i] > maxA) a[i] = maxA;\n        }\n    } else if (type == \"zigzag\") {\n        int val1 = rnd.next(1, maxA / 2);\n        int val2 = val1 + K / 2;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, K);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -K 1 -type random\n./gen -n 2 -K 1 -type random\n./gen -n 3 -K 1 -type random\n./gen -n 4 -K 1 -type random\n./gen -n 5 -K 1 -type random\n./gen -n 6 -K 1 -type random\n./gen -n 7 -K 1 -type random\n./gen -n 1 -K 1000000 -type random\n./gen -n 2 -K 1000000 -type equal\n./gen -n 5 -K 10 -type increasing\n./gen -n 5 -K 10 -type decreasing\n./gen -n 10 -K 1000000 -type max_swallow\n./gen -n 100 -K 1 -type zigzag\n./gen -n 1000 -K 1000 -type random\n./gen -n 10000 -K 50000 -type increasing\n./gen -n 10000 -K 50000 -type decreasing\n./gen -n 10000 -K 1000000 -type equal\n./gen -n 20000 -K 1 -type no_swallow\n./gen -n 50000 -K 100 -type zigzag\n./gen -n 100000 -K 999999 -type random\n./gen -n 150000 -K 1000000 -type max_swallow\n./gen -n 200000 -K 1 -type max_swallow\n./gen -n 200000 -K 1 -type equal\n./gen -n 200000 -K 1000000 -type no_swallow\n./gen -n 200000 -K 500000 -type increasing\n./gen -n 200000 -K 500000 -type decreasing\n./gen -n 200000 -K 500000 -type zigzag\n./gen -n 200000 -K 1000000 -type random\n./gen -n 200000 -K 1 -type random\n./gen -n 200000 -K 1000000 -type max_swallow\n./gen -n 199999 -K 999999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:41.453424",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/C",
      "title": "C. Bracket Sequences Concatenation Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer n(1≤n≤3⋅105)n(1≤n≤3⋅105) — the number of bracket sequences. The following nn lines contain bracket sequences — non-empty strings consisting only of characters \"(\" and \")\". The sum of lengths of all bracket sequences does not exceed 3⋅1053⋅105.",
      "output_spec": "OutputIn the single line print a single integer — the number of pairs i,j(1≤i,j≤n)i,j(1≤i,j≤n) such that the bracket sequence si+sjsi+sj is a regular bracket sequence.",
      "sample_tests": "ExamplesInputCopy3)()(OutputCopy2InputCopy2()()OutputCopy4",
      "description": "C. Bracket Sequences Concatenation Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer n(1≤n≤3⋅105)n(1≤n≤3⋅105) — the number of bracket sequences. The following nn lines contain bracket sequences — non-empty strings consisting only of characters \"(\" and \")\". The sum of lengths of all bracket sequences does not exceed 3⋅1053⋅105.\n\nOutputIn the single line print a single integer — the number of pairs i,j(1≤i,j≤n)i,j(1≤i,j≤n) such that the bracket sequence si+sjsi+sj is a regular bracket sequence.\n\nInputCopy3)()(OutputCopy2InputCopy2()()OutputCopy4\n\nInputCopy3)()(\n\nOutputCopy2\n\nInputCopy2()()\n\nOutputCopy4\n\nNoteIn the first example, suitable pairs are (3,1)(3,1) and (2,2)(2,2).In the second example, any pair is suitable, namely (1,1),(1,2),(2,1),(2,2)(1,1),(1,2),(2,1),(2,2).",
      "solutions": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces",
          "content": "Hello Codeforces!On Sunday, June 10, 2018 at 18:05UTC+8 Educational Codeforces Round 45 will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Adilbek adedalic Dalabaev, Roman Roms Glazov, Ivan BledDest Androsov, Mike MikeMirzayanov Mirzayanov and me.Good luck to all participants!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 KrK 7 225 2 isaf27 7 231 3 BigBag 7 325 4 Motarack 7 327 5 TangentDay 7 331 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 202:-52 2 2014CAIS01 26:-2 3 djm03178 20 4 bitcoin 19 5 antguz 25:-17 549 successful hacks and 525 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A tzuyu_chou 0:01 B DoomzGay 0:05 C 562225807 0:08 D teja349 0:12 E eddy1021 0:18 F nhho 0:45 G AChen142857 0:14 UPD: Editorial is out",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/59919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1384
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces",
          "content": "990A - Commentary Boxes Tutorial990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to nn and the closest one greater than nn. Distances to them are (nmodm)(nmodm) and (m−(nmodm))(m−(nmodm)) respectively. Now you should multiply the first result by bb, the second result by aa and compare the products.Overall complexity: O(1)O(1). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}990B - Micro-World Tutorial990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria ii you need to check existence of any bacteria jj satisfying condition ai<aj≤ai+Kai<aj≤ai+K.There plenty of ways to check this condition. One of them is to sort array aa and for each ii find minimal aj>aiaj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai≤106ai≤106 and build solution around it.Result complexity is O(nlogn)O(nlog⁡n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}990C - Bracket Sequences Concatenation Problem Tutorial990C - Bracket Sequences Concatenation ProblemLet f(s)f(s) be the mirror reflection of the string ss. For example: ff(\"((\") = \"))\", ff(\"))(\") = \")((\", ff(\"()\") = \"()\".Let string be good if it does not have a prefix, which have more closing brackets than opening ones. For example, \"((\", \"(())(\", \"()()\" are good, and \"())\", \")((\", \"()())\" are not.The balance bal(s)bal(s) of the string ss is the difference between number of opening and closing brackets in ss. For example, balbal(\"(()\") = 1, balbal(\"()\") = 0.Let cnt[x]cnt[x] be the number of good strings with a balance xx.The answer to the problem is ∑s, where f(s) is goodcnt[bal(f(s))]∑s, where f(s) is goodcnt[bal(f(s))]. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}990D - Graph And Its Complement Tutorial990D - Graph And Its ComplementLet's prove that if a>1a>1, then b=1b=1. Let GG be the original graph, and HH — the complement of the graph GG. Let's look at each pair of vertices (u,v)(u,v). If uu and vv belong to different components of the graph GG, then there is an edge between them in the graph HH. Otherwise, uu and vv belong to the same component of the graph GG, but since GG has more than one component, there is vertex xx in other component of GG, and there are edges {u,x}{u,x} and {v,x}{v,x} in HH. That's why, there is a connected path for any pair of vertices (u,v)(u,v), and the graph HH is connected. Similarly, the case b>1b>1 is proved.So, if min(a,b)>1min(a,b)>1, then the answer is \"NO\". Otherwise, min(a,b)=1min(a,b)=1. Consider the case where b=1b=1 (if b>ab>a, we can swap aa and bb, and output complement of the constructed graph). To have aa components in the graph GG, it is enough to connect the vertex 11 with the vertex 22, the vertex 22 with the vertex 33, ⋯⋯, the vertex n−an−a with the vertex n−a+1n−a+1. A particular cases are the tests n=2,a=1,b=1n=2,a=1,b=1 and n=3,a=1,b=1n=3,a=1,b=1. There is no suitable graph for them. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}990E - Post Lamps Tutorial990E - Post LampsLet's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider 00 to be covered. Function f(i)f(i) — the minimal number of post lamps to cover segment [0;i][0;i] is clearly monotonous, thus you want to update states as early as possible.Okay, now you iterate over all l∈[1;k]l∈[1;k] and update the answer with the results multiplied by cost.Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by k+1k+1 positions or return -1. This can be easily proven by contradiction.Overall complexity: O(n⋅logn)O(n⋅log⁡n), as you do about nlnl steps for each ll and that is a common series sum. Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}990F - Flow Control Tutorial990F - Flow ControlThe answer is \"Impossible\" if and only if the sum of values is not equal to 00. Writing some number on edge does not change the total sum and the goal of the problem is to make 00 in each vertex, thus getting 00 in total.The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and 00 for the rest of edges.Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has 00. This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.Overall complexity: O(n+m)O(n+m). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tdfs(0, -1);\n\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}990G - GCD Counting Tutorial990G - GCD CountingFirstly, for every i∈[1,2⋅105]i∈[1,2⋅105] we can calculate the number of paths such that g(x,y)g(x,y) is divisible by ii. We can do it as follows: generate all divisors of numbers aiai (numbers not exceeding 2⋅1052⋅105 have at most 160160 divisors, so this will be fast enough), and then for every i∈[1,2⋅105]i∈[1,2⋅105] analyze the graph containing the vertices that have ii as its divisor. Each component of this graph gives us k(k+1)2k(k+1)2 paths (if its size is kk), and this is the only formula we need to calculate the number of paths where g(x,y)g(x,y) is divisible by ii (let this be h(i)h(i)).How can we get the answer if we know the values of h(i)h(i)? We can use inclusion-exclusion with Mobius function, for example, to prove that ans(1)=∑i=12⋅105μ(i)h(i)ans(1)=∑i=12⋅105μ(i)h(i); and then if we want to apply the same technique for finding ans(x)ans(x) with any possible xx, we could divide all numbers aiai by xx and do the same thing. But it might be too slow, so it's better to rewrite this formula as ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi)ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi), because we will do exactly the same when dividing all numbers by xx.In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.This problem can also be solved with centroid decomposition. Solution with Möbius (Bleddest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n hd = 0;\n tl = 0;\n q[tl++] = x;\n used[x] = cc;\n while(hd < tl)\n {\n int z = q[hd++];\n for(auto y : g[z])\n {\n if(good[a[y]] == cc && used[y] < cc)\n {\n used[y] = cc;\n q[tl++] = y;\n }\n }\n }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t for(auto x : need_bfs[j])\n\t\t {\n\t\t if(used[x] == cc) continue;\n\t\t\t int z = bfs(x, i);\n\t\t\t ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t }\n\t for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n} Solution with centroid (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\n//\tcerr << \"C = \"<< c << endl;\n\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\n\tT++;\n\taddDiv(a[c], 1);\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\n\tmemset(res, 0, sizeof res);\n\n\tT = 0;\n\tcalc(0);\n\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59962",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 990\\s*C"
          },
          "content_length": 17061
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "what I did in C was ignored all cases of brackets which gave )( this sort of thing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 15",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 17",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 18",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    int totalLength = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[\\\\(\\\\)]+\", \"s_i\");\n        totalLength += s.length();\n        ensuref(totalLength <= 300000, \"Sum of lengths of all bracket sequences must not exceed 300,000\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    int totalLength = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[\\\\(\\\\)]+\", \"s_i\");\n        totalLength += s.length();\n        ensuref(totalLength <= 300000, \"Sum of lengths of all bracket sequences must not exceed 300,000\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n    int totalLength = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[\\\\(\\\\)]+\", \"s_i\");\n        totalLength += s.length();\n        ensuref(totalLength <= 300000, \"Sum of lengths of all bracket sequences must not exceed 300,000\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int sum_len = opt<int>(\"sum_len\", 300000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> sequences(n);\n\n    // Initialize lengths to minimum 1\n    vector<int> lengths(n, 1);\n    int total_length = n; // sum of lengths initialized to n\n\n    int remaining = sum_len - total_length;\n\n    if (remaining < 0) {\n        cerr << \"Invalid parameters: sum_len too small for n sequences.\" << endl;\n        exit(1);\n    }\n\n    // Distribute the remaining length randomly\n    for (int i = 0; i < n && remaining > 0; ++i) {\n        int add = min(remaining, rnd.next(0, min(1000, remaining)));\n        lengths[i] += add;\n        remaining -= add;\n    }\n\n    // If any remaining length, distribute to sequences randomly\n    while (remaining > 0) {\n        int i = rnd.next(0, n - 1);\n        lengths[i]++;\n        remaining--;\n    }\n\n    if (type == \"random\") {\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            string seq = \"\";\n            for (int j = 0; j < lengths[i]; ++j) {\n                seq += rnd.next(0, 1) ? '(' : ')';\n            }\n            sequences[i] = seq;\n        }\n    } else if (type == \"balanced\") {\n        // Generate balanced sequences\n        for (int i = 0; i < n; ++i) {\n            int l = lengths[i];\n            if (l % 2 != 0 && l > 1) {\n                lengths[i]--;\n                l--;\n            }\n            int half = l / 2;\n            string seq = string(half, '(') + string(half, ')');\n            sequences[i] = seq;\n        }\n    } else if (type == \"all_left\") {\n        // Sequences of only '('\n        for (int i = 0; i < n; ++i) {\n            sequences[i] = string(lengths[i], '(');\n        }\n    } else if (type == \"all_right\") {\n        // Sequences of only ')'\n        for (int i = 0; i < n; ++i) {\n            sequences[i] = string(lengths[i], ')');\n        }\n    } else if (type == \"paired\") {\n        // Sequences designed to form balanced pairs\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                sequences[i] = string(lengths[i], '(');\n            } else {\n                sequences[i] = string(lengths[i], ')');\n            }\n        }\n    } else if (type == \"nested\") {\n        // Generate nested balanced sequences like '((...))'\n        for (int i = 0; i < n; ++i) {\n            int l = lengths[i];\n            if (l % 2 != 0 && l > 1) {\n                lengths[i]--;\n                l--;\n            }\n            int half = l / 2;\n            string seq = string(half, '(') + string(half, ')');\n            sequences[i] = seq;\n        }\n    } else if (type == \"unbalanced\") {\n        // Generate unbalanced sequences\n        for (int i = 0; i < n; ++i) {\n            if (i % 3 == 0) {\n                sequences[i] = string(lengths[i], '(');\n            } else if (i % 3 == 1) {\n                sequences[i] = string(lengths[i], ')');\n            } else {\n                string seq = \"\";\n                for (int j = 0; j < lengths[i]; ++j) {\n                    seq += rnd.next(0, 1) ? '(' : ')';\n                }\n                sequences[i] = seq;\n            }\n        }\n    } else {\n        cerr << \"Unknown type specified.\" << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequences\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", sequences[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int sum_len = opt<int>(\"sum_len\", 300000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> sequences(n);\n\n    // Initialize lengths to minimum 1\n    vector<int> lengths(n, 1);\n    int total_length = n; // sum of lengths initialized to n\n\n    int remaining = sum_len - total_length;\n\n    if (remaining < 0) {\n        cerr << \"Invalid parameters: sum_len too small for n sequences.\" << endl;\n        exit(1);\n    }\n\n    // Distribute the remaining length randomly\n    for (int i = 0; i < n && remaining > 0; ++i) {\n        int add = min(remaining, rnd.next(0, min(1000, remaining)));\n        lengths[i] += add;\n        remaining -= add;\n    }\n\n    // If any remaining length, distribute to sequences randomly\n    while (remaining > 0) {\n        int i = rnd.next(0, n - 1);\n        lengths[i]++;\n        remaining--;\n    }\n\n    if (type == \"random\") {\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            string seq = \"\";\n            for (int j = 0; j < lengths[i]; ++j) {\n                seq += rnd.next(0, 1) ? '(' : ')';\n            }\n            sequences[i] = seq;\n        }\n    } else if (type == \"balanced\") {\n        // Generate balanced sequences\n        for (int i = 0; i < n; ++i) {\n            int l = lengths[i];\n            if (l % 2 != 0 && l > 1) {\n                lengths[i]--;\n                l--;\n            }\n            int half = l / 2;\n            string seq = string(half, '(') + string(half, ')');\n            sequences[i] = seq;\n        }\n    } else if (type == \"all_left\") {\n        // Sequences of only '('\n        for (int i = 0; i < n; ++i) {\n            sequences[i] = string(lengths[i], '(');\n        }\n    } else if (type == \"all_right\") {\n        // Sequences of only ')'\n        for (int i = 0; i < n; ++i) {\n            sequences[i] = string(lengths[i], ')');\n        }\n    } else if (type == \"paired\") {\n        // Sequences designed to form balanced pairs\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                sequences[i] = string(lengths[i], '(');\n            } else {\n                sequences[i] = string(lengths[i], ')');\n            }\n        }\n    } else if (type == \"nested\") {\n        // Generate nested balanced sequences like '((...))'\n        for (int i = 0; i < n; ++i) {\n            int l = lengths[i];\n            if (l % 2 != 0 && l > 1) {\n                lengths[i]--;\n                l--;\n            }\n            int half = l / 2;\n            string seq = string(half, '(') + string(half, ')');\n            sequences[i] = seq;\n        }\n    } else if (type == \"unbalanced\") {\n        // Generate unbalanced sequences\n        for (int i = 0; i < n; ++i) {\n            if (i % 3 == 0) {\n                sequences[i] = string(lengths[i], '(');\n            } else if (i % 3 == 1) {\n                sequences[i] = string(lengths[i], ')');\n            } else {\n                string seq = \"\";\n                for (int j = 0; j < lengths[i]; ++j) {\n                    seq += rnd.next(0, 1) ? '(' : ')';\n                }\n                sequences[i] = seq;\n            }\n        }\n    } else {\n        cerr << \"Unknown type specified.\" << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequences\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", sequences[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 300000 -type random\n\n./gen -n 1 -type balanced\n./gen -n 10 -type balanced\n./gen -n 100 -type balanced\n./gen -n 1000 -type balanced\n./gen -n 10000 -type balanced\n./gen -n 100000 -type balanced\n./gen -n 300000 -type balanced\n\n./gen -n 1 -type all_left\n./gen -n 1 -type all_right\n\n./gen -n 2 -type paired\n./gen -n 1000 -type paired\n./gen -n 10000 -type paired\n./gen -n 100000 -type paired\n./gen -n 300000 -type paired\n\n./gen -n 100000 -type unbalanced\n./gen -n 300000 -type unbalanced\n\n./gen -n 50000 -type nested\n./gen -n 100000 -type nested\n./gen -n 200000 -type nested\n./gen -n 300000 -type nested\n\n./gen -n 100000 -type all_left\n./gen -n 100000 -type all_right\n./gen -n 300000 -type all_left\n./gen -n 300000 -type all_right\n\n./gen -n 10 -type random -sum_len 10\n./gen -n 100 -type random -sum_len 1000\n./gen -n 1000 -type random -sum_len 100000\n./gen -n 300000 -type random -sum_len 300000\n\n./gen -n 1 -type all_left\n./gen -n 1 -type all_right\n./gen -n 1 -type balanced\n./gen -n 2 -type unbalanced\n./gen -n 2 -type paired\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:43.204696",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/D",
      "title": "D. Graph And Its Complement",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn a single line, three numbers are given n,a,b(1≤n≤1000,1≤a,b≤n)n,a,b(1≤n≤1000,1≤a,b≤n): is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement.",
      "output_spec": "OutputIf there is no graph that satisfies these constraints on a single line, print \"NO\" (without quotes).Otherwise, on the first line, print \"YES\"(without quotes). In each of the next nn lines, output nn digits such that jj-th digit of ii-th line must be 11 if and only if there is an edge between vertices ii and jj in GG (and 00 otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. If there are several matrices that satisfy the conditions — output any of them.",
      "sample_tests": "ExamplesInputCopy3 1 2OutputCopyYES001001110InputCopy3 3 3OutputCopyNO",
      "description": "D. Graph And Its Complement\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputIn a single line, three numbers are given n,a,b(1≤n≤1000,1≤a,b≤n)n,a,b(1≤n≤1000,1≤a,b≤n): is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement.\n\nOutputIf there is no graph that satisfies these constraints on a single line, print \"NO\" (without quotes).Otherwise, on the first line, print \"YES\"(without quotes). In each of the next nn lines, output nn digits such that jj-th digit of ii-th line must be 11 if and only if there is an edge between vertices ii and jj in GG (and 00 otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. If there are several matrices that satisfy the conditions — output any of them.\n\nInputCopy3 1 2OutputCopyYES001001110InputCopy3 3 3OutputCopyNO\n\nInputCopy3 1 2\n\nOutputCopyYES001001110\n\nInputCopy3 3 3\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces",
          "content": "Hello Codeforces!On Sunday, June 10, 2018 at 18:05UTC+8 Educational Codeforces Round 45 will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Adilbek adedalic Dalabaev, Roman Roms Glazov, Ivan BledDest Androsov, Mike MikeMirzayanov Mirzayanov and me.Good luck to all participants!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 KrK 7 225 2 isaf27 7 231 3 BigBag 7 325 4 Motarack 7 327 5 TangentDay 7 331 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 202:-52 2 2014CAIS01 26:-2 3 djm03178 20 4 bitcoin 19 5 antguz 25:-17 549 successful hacks and 525 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A tzuyu_chou 0:01 B DoomzGay 0:05 C 562225807 0:08 D teja349 0:12 E eddy1021 0:18 F nhho 0:45 G AChen142857 0:14 UPD: Editorial is out",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/59919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1384
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces",
          "content": "990A - Commentary Boxes Tutorial990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to nn and the closest one greater than nn. Distances to them are (nmodm)(nmodm) and (m−(nmodm))(m−(nmodm)) respectively. Now you should multiply the first result by bb, the second result by aa and compare the products.Overall complexity: O(1)O(1). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}990B - Micro-World Tutorial990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria ii you need to check existence of any bacteria jj satisfying condition ai<aj≤ai+Kai<aj≤ai+K.There plenty of ways to check this condition. One of them is to sort array aa and for each ii find minimal aj>aiaj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai≤106ai≤106 and build solution around it.Result complexity is O(nlogn)O(nlog⁡n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}990C - Bracket Sequences Concatenation Problem Tutorial990C - Bracket Sequences Concatenation ProblemLet f(s)f(s) be the mirror reflection of the string ss. For example: ff(\"((\") = \"))\", ff(\"))(\") = \")((\", ff(\"()\") = \"()\".Let string be good if it does not have a prefix, which have more closing brackets than opening ones. For example, \"((\", \"(())(\", \"()()\" are good, and \"())\", \")((\", \"()())\" are not.The balance bal(s)bal(s) of the string ss is the difference between number of opening and closing brackets in ss. For example, balbal(\"(()\") = 1, balbal(\"()\") = 0.Let cnt[x]cnt[x] be the number of good strings with a balance xx.The answer to the problem is ∑s, where f(s) is goodcnt[bal(f(s))]∑s, where f(s) is goodcnt[bal(f(s))]. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}990D - Graph And Its Complement Tutorial990D - Graph And Its ComplementLet's prove that if a>1a>1, then b=1b=1. Let GG be the original graph, and HH — the complement of the graph GG. Let's look at each pair of vertices (u,v)(u,v). If uu and vv belong to different components of the graph GG, then there is an edge between them in the graph HH. Otherwise, uu and vv belong to the same component of the graph GG, but since GG has more than one component, there is vertex xx in other component of GG, and there are edges {u,x}{u,x} and {v,x}{v,x} in HH. That's why, there is a connected path for any pair of vertices (u,v)(u,v), and the graph HH is connected. Similarly, the case b>1b>1 is proved.So, if min(a,b)>1min(a,b)>1, then the answer is \"NO\". Otherwise, min(a,b)=1min(a,b)=1. Consider the case where b=1b=1 (if b>ab>a, we can swap aa and bb, and output complement of the constructed graph). To have aa components in the graph GG, it is enough to connect the vertex 11 with the vertex 22, the vertex 22 with the vertex 33, ⋯⋯, the vertex n−an−a with the vertex n−a+1n−a+1. A particular cases are the tests n=2,a=1,b=1n=2,a=1,b=1 and n=3,a=1,b=1n=3,a=1,b=1. There is no suitable graph for them. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}990E - Post Lamps Tutorial990E - Post LampsLet's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider 00 to be covered. Function f(i)f(i) — the minimal number of post lamps to cover segment [0;i][0;i] is clearly monotonous, thus you want to update states as early as possible.Okay, now you iterate over all l∈[1;k]l∈[1;k] and update the answer with the results multiplied by cost.Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by k+1k+1 positions or return -1. This can be easily proven by contradiction.Overall complexity: O(n⋅logn)O(n⋅log⁡n), as you do about nlnl steps for each ll and that is a common series sum. Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}990F - Flow Control Tutorial990F - Flow ControlThe answer is \"Impossible\" if and only if the sum of values is not equal to 00. Writing some number on edge does not change the total sum and the goal of the problem is to make 00 in each vertex, thus getting 00 in total.The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and 00 for the rest of edges.Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has 00. This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.Overall complexity: O(n+m)O(n+m). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tdfs(0, -1);\n\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}990G - GCD Counting Tutorial990G - GCD CountingFirstly, for every i∈[1,2⋅105]i∈[1,2⋅105] we can calculate the number of paths such that g(x,y)g(x,y) is divisible by ii. We can do it as follows: generate all divisors of numbers aiai (numbers not exceeding 2⋅1052⋅105 have at most 160160 divisors, so this will be fast enough), and then for every i∈[1,2⋅105]i∈[1,2⋅105] analyze the graph containing the vertices that have ii as its divisor. Each component of this graph gives us k(k+1)2k(k+1)2 paths (if its size is kk), and this is the only formula we need to calculate the number of paths where g(x,y)g(x,y) is divisible by ii (let this be h(i)h(i)).How can we get the answer if we know the values of h(i)h(i)? We can use inclusion-exclusion with Mobius function, for example, to prove that ans(1)=∑i=12⋅105μ(i)h(i)ans(1)=∑i=12⋅105μ(i)h(i); and then if we want to apply the same technique for finding ans(x)ans(x) with any possible xx, we could divide all numbers aiai by xx and do the same thing. But it might be too slow, so it's better to rewrite this formula as ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi)ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi), because we will do exactly the same when dividing all numbers by xx.In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.This problem can also be solved with centroid decomposition. Solution with Möbius (Bleddest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n hd = 0;\n tl = 0;\n q[tl++] = x;\n used[x] = cc;\n while(hd < tl)\n {\n int z = q[hd++];\n for(auto y : g[z])\n {\n if(good[a[y]] == cc && used[y] < cc)\n {\n used[y] = cc;\n q[tl++] = y;\n }\n }\n }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t for(auto x : need_bfs[j])\n\t\t {\n\t\t if(used[x] == cc) continue;\n\t\t\t int z = bfs(x, i);\n\t\t\t ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t }\n\t for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n} Solution with centroid (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\n//\tcerr << \"C = \"<< c << endl;\n\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\n\tT++;\n\taddDiv(a[c], 1);\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\n\tmemset(res, 0, sizeof res);\n\n\tT = 0;\n\tcalc(0);\n\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59962",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 990\\s*D"
          },
          "content_length": 17061
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "what I did in C was ignored all cases of brackets which gave )( this sort of thing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 15",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 17",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 18",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int a = inf.readInt();\n    int b = inf.readInt();\n\n    string jury_answer = ans.readToken();\n    if (jury_answer != \"YES\" && jury_answer != \"NO\") {\n        quitf(_fail, \"Jury answer is neither 'YES' nor 'NO'\");\n    }\n    bool jury_has_solution = (jury_answer == \"YES\");\n\n    string participant_answer = ouf.readToken();\n    if (participant_answer != \"YES\" && participant_answer != \"NO\") {\n        quitf(_pe, \"Your answer is neither 'YES' nor 'NO'\");\n    }\n    bool participant_has_solution = (participant_answer == \"YES\");\n\n    if (!jury_has_solution) {\n        if (!participant_has_solution) {\n            quitf(_ok, \"Correct: participant and jury both output 'NO'\");\n        } else {\n            quitf(_wa, \"Participant claimed to find a solution but jury says 'NO'\");\n        }\n    } else {\n        if (!participant_has_solution) {\n            quitf(_wa, \"Participant failed to find a solution but jury says 'YES'\");\n        } else {\n            vector<string> adj_matrix(n);\n            for (int i = 0; i < n; i++) {\n                adj_matrix[i] = ouf.readToken();\n                if ((int)adj_matrix[i].length() != n) {\n                    quitf(_wa, \"Line %d: Expected length %d, got %d\", i+1, n, adj_matrix[i].length());\n                }\n                for (int j = 0; j < n; j++) {\n                    if (adj_matrix[i][j] != '0' && adj_matrix[i][j] != '1') {\n                        quitf(_wa, \"Line %d, Column %d: Expected '0' or '1', got '%c'\", i+1, j+1, adj_matrix[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (adj_matrix[i][i] != '0') {\n                    quitf(_wa, \"Adjacency matrix diagonal element (%d, %d) is not zero\", i+1, i+1);\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = i+1; j < n; j++) {\n                    if (adj_matrix[i][j] != adj_matrix[j][i]) {\n                        quitf(_wa, \"Adjacency matrix is not symmetric at (%d, %d) and (%d, %d)\", i+1, j+1, j+1, i+1);\n                    }\n                }\n            }\n            vector<vector<int>> graph(n);\n            vector<vector<int>> complement_graph(n);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (adj_matrix[i][j] == '1') {\n                        graph[i].push_back(j);\n                    } else if (i != j) {\n                        complement_graph[i].push_back(j);\n                    }\n                }\n            }\n            function<int(vector<vector<int>> &)> compute_connected_components = [&](vector<vector<int>>& g) {\n                vector<bool> visited(n, false);\n                int components = 0;\n                for (int i = 0; i < n; i++) {\n                    if (!visited[i]) {\n                        components++;\n                        stack<int> st;\n                        st.push(i);\n                        visited[i] = true;\n                        while (!st.empty()) {\n                            int u = st.top(); st.pop();\n                            for (int v : g[u]) {\n                                if (!visited[v]) {\n                                    visited[v] = true;\n                                    st.push(v);\n                                }\n                            }\n                        }\n                    }\n                }\n                return components;\n            };\n            int cc_count = compute_connected_components(graph);\n            int cc_count_complement = compute_connected_components(complement_graph);\n            if (cc_count != a) {\n                quitf(_wa, \"Number of connected components in the graph is %d, expected %d\", cc_count, a);\n            }\n            if (cc_count_complement != b) {\n                quitf(_wa, \"Number of connected components in the complement graph is %d, expected %d\", cc_count_complement, b);\n            }\n            quitf(_ok, \"Correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    if(a != -1 && b != -1) {\n        // Both a and b are provided\n        // Ensure they are within valid ranges\n        ensure(1 <= a && a <= n);\n        ensure(1 <= b && b <= n);\n    } else {\n        // Need to generate a and b based on type\n\n        if(type == \"possible\") {\n            // Generate values of a and b such that solution is possible\n\n            if(n == 1) {\n                a = b = 1;\n            } else if(n <= 3) {\n                // For n = 2 or n = 3\n                if(rnd.next(2)) {\n                    a = 1;\n                    b = rnd.next(1,n);\n                } else {\n                    b = 1;\n                    a = rnd.next(1,n);\n                }\n            } else {\n                // For n >= 4\n                if(rnd.next(2)) {\n                    a = 1;\n                    b = rnd.next(1,n);\n                } else {\n                    a = rnd.next(1,n);\n                    b = 1;\n                }\n            }\n        } else if (type == \"impossible\") {\n            // Generate values of a and b such that solution is impossible\n\n            if(n >= 4) {\n                a = rnd.next(2, n);\n                b = rnd.next(2, n);\n            } else if(n == 3) {\n                a = rnd.next(2,3);\n                b = rnd.next(2,3);\n            } else if(n == 2) {\n                a = 2;\n                b = 2;\n            } else {\n                // n == 1, no impossible cases\n                // For the sake of consistency, set a = b = 1\n                a = b = 1;\n            }\n        } else {\n            // Unknown type\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    // Output n a b\n    printf(\"%d %d %d\\n\", n, a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    if(a != -1 && b != -1) {\n        // Both a and b are provided\n        // Ensure they are within valid ranges\n        ensure(1 <= a && a <= n);\n        ensure(1 <= b && b <= n);\n    } else {\n        // Need to generate a and b based on type\n\n        if(type == \"possible\") {\n            // Generate values of a and b such that solution is possible\n\n            if(n == 1) {\n                a = b = 1;\n            } else if(n <= 3) {\n                // For n = 2 or n = 3\n                if(rnd.next(2)) {\n                    a = 1;\n                    b = rnd.next(1,n);\n                } else {\n                    b = 1;\n                    a = rnd.next(1,n);\n                }\n            } else {\n                // For n >= 4\n                if(rnd.next(2)) {\n                    a = 1;\n                    b = rnd.next(1,n);\n                } else {\n                    a = rnd.next(1,n);\n                    b = 1;\n                }\n            }\n        } else if (type == \"impossible\") {\n            // Generate values of a and b such that solution is impossible\n\n            if(n >= 4) {\n                a = rnd.next(2, n);\n                b = rnd.next(2, n);\n            } else if(n == 3) {\n                a = rnd.next(2,3);\n                b = rnd.next(2,3);\n            } else if(n == 2) {\n                a = 2;\n                b = 2;\n            } else {\n                // n == 1, no impossible cases\n                // For the sake of consistency, set a = b = 1\n                a = b = 1;\n            }\n        } else {\n            // Unknown type\n            fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    // Output n a b\n    printf(\"%d %d %d\\n\", n, a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type possible\n./gen -n 1 -a 1 -b 1\n\n./gen -n 2 -type possible\n./gen -n 2 -a 1 -b 1\n\n./gen -n 2 -a 2 -b 2 -type impossible\n\n./gen -n 3 -type possible\n./gen -n 3 -a 1 -b 2\n\n./gen -n 3 -a 2 -b 2 -type impossible\n\n./gen -n 4 -type possible\n./gen -n 4 -a 1 -b 1\n\n./gen -n 4 -a 2 -b 2 -type impossible\n\n./gen -n 5 -type possible\n./gen -n 5 -a 1 -b 2\n\n./gen -n 5 -a 2 -b 2 -type impossible\n\n./gen -n 10 -type possible\n./gen -n 10 -a 1 -b 1\n\n./gen -n 10 -a 5 -b 5 -type impossible\n\n./gen -n 100 -type possible\n./gen -n 100 -a 1 -b 100\n\n./gen -n 100 -a 50 -b 50 -type impossible\n\n./gen -n 500 -type possible\n./gen -n 500 -a 1 -b 1\n\n./gen -n 500 -a 250 -b 250 -type impossible\n\n./gen -n 1000 -type possible\n./gen -n 1000 -a 1 -b 1\n\n./gen -n 1000 -a 500 -b 500 -type impossible\n\n# Random large n\n\n./gen -n 999 -type possible\n./gen -n 999 -a 1 -b 999\n\n./gen -n 998 -a 2 -b 2 -type impossible\n\n# Edge cases\n\n./gen -n 4 -a 1 -b 4 -type possible\n./gen -n 4 -a 2 -b 2 -type impossible\n\n./gen -n 3 -a 1 -b 3 -type possible\n./gen -n 3 -a 3 -b 3 -type impossible\n\n./gen -n 2 -a 1 -b 2 -type possible\n./gen -n 2 -a 2 -b 2 -type impossible\n\n./gen -n 1 -a 1 -b 1 -type possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:45.311492",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/E",
      "title": "E. Post Lamps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integer numbers nn, mm and kk (1≤k≤n≤1061≤k≤n≤106, 0≤m≤n0≤m≤n) — the length of the segment of the street Adilbek wants to illuminate, the number of the blocked positions and the maximum power of the post lamp available.The second line contains mm integer numbers s1,s2,…,sms1,s2,…,sm (0≤s1<s2<…sm<n0≤s1<s2<…sm<n) — the blocked positions.The third line contains kk integer numbers a1,a2,…,aka1,a2,…,ak (1≤ai≤1061≤ai≤106) — the costs of the post lamps.",
      "output_spec": "OutputPrint the minimal total cost of the post lamps of exactly one type Adilbek can buy to illuminate the entire segment [0;n][0;n] of the street.If illumintaing the entire segment [0;n][0;n] is impossible, print -1.",
      "sample_tests": "ExamplesInputCopy6 2 31 31 2 3OutputCopy6InputCopy4 3 41 2 31 10 100 1000OutputCopy1000InputCopy5 1 503 3 3 3 3OutputCopy-1InputCopy7 4 32 4 5 63 14 15OutputCopy-1",
      "description": "E. Post Lamps\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integer numbers nn, mm and kk (1≤k≤n≤1061≤k≤n≤106, 0≤m≤n0≤m≤n) — the length of the segment of the street Adilbek wants to illuminate, the number of the blocked positions and the maximum power of the post lamp available.The second line contains mm integer numbers s1,s2,…,sms1,s2,…,sm (0≤s1<s2<…sm<n0≤s1<s2<…sm<n) — the blocked positions.The third line contains kk integer numbers a1,a2,…,aka1,a2,…,ak (1≤ai≤1061≤ai≤106) — the costs of the post lamps.\n\nOutputPrint the minimal total cost of the post lamps of exactly one type Adilbek can buy to illuminate the entire segment [0;n][0;n] of the street.If illumintaing the entire segment [0;n][0;n] is impossible, print -1.\n\nInputCopy6 2 31 31 2 3OutputCopy6InputCopy4 3 41 2 31 10 100 1000OutputCopy1000InputCopy5 1 503 3 3 3 3OutputCopy-1InputCopy7 4 32 4 5 63 14 15OutputCopy-1\n\nInputCopy6 2 31 31 2 3\n\nOutputCopy6\n\nInputCopy4 3 41 2 31 10 100 1000\n\nOutputCopy1000\n\nInputCopy5 1 503 3 3 3 3\n\nOutputCopy-1\n\nInputCopy7 4 32 4 5 63 14 15\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces",
          "content": "Hello Codeforces!On Sunday, June 10, 2018 at 18:05UTC+8 Educational Codeforces Round 45 will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Adilbek adedalic Dalabaev, Roman Roms Glazov, Ivan BledDest Androsov, Mike MikeMirzayanov Mirzayanov and me.Good luck to all participants!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 KrK 7 225 2 isaf27 7 231 3 BigBag 7 325 4 Motarack 7 327 5 TangentDay 7 331 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 202:-52 2 2014CAIS01 26:-2 3 djm03178 20 4 bitcoin 19 5 antguz 25:-17 549 successful hacks and 525 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A tzuyu_chou 0:01 B DoomzGay 0:05 C 562225807 0:08 D teja349 0:12 E eddy1021 0:18 F nhho 0:45 G AChen142857 0:14 UPD: Editorial is out",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/59919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1384
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces",
          "content": "990A - Commentary Boxes Tutorial990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to nn and the closest one greater than nn. Distances to them are (nmodm)(nmodm) and (m−(nmodm))(m−(nmodm)) respectively. Now you should multiply the first result by bb, the second result by aa and compare the products.Overall complexity: O(1)O(1). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}990B - Micro-World Tutorial990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria ii you need to check existence of any bacteria jj satisfying condition ai<aj≤ai+Kai<aj≤ai+K.There plenty of ways to check this condition. One of them is to sort array aa and for each ii find minimal aj>aiaj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai≤106ai≤106 and build solution around it.Result complexity is O(nlogn)O(nlog⁡n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}990C - Bracket Sequences Concatenation Problem Tutorial990C - Bracket Sequences Concatenation ProblemLet f(s)f(s) be the mirror reflection of the string ss. For example: ff(\"((\") = \"))\", ff(\"))(\") = \")((\", ff(\"()\") = \"()\".Let string be good if it does not have a prefix, which have more closing brackets than opening ones. For example, \"((\", \"(())(\", \"()()\" are good, and \"())\", \")((\", \"()())\" are not.The balance bal(s)bal(s) of the string ss is the difference between number of opening and closing brackets in ss. For example, balbal(\"(()\") = 1, balbal(\"()\") = 0.Let cnt[x]cnt[x] be the number of good strings with a balance xx.The answer to the problem is ∑s, where f(s) is goodcnt[bal(f(s))]∑s, where f(s) is goodcnt[bal(f(s))]. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}990D - Graph And Its Complement Tutorial990D - Graph And Its ComplementLet's prove that if a>1a>1, then b=1b=1. Let GG be the original graph, and HH — the complement of the graph GG. Let's look at each pair of vertices (u,v)(u,v). If uu and vv belong to different components of the graph GG, then there is an edge between them in the graph HH. Otherwise, uu and vv belong to the same component of the graph GG, but since GG has more than one component, there is vertex xx in other component of GG, and there are edges {u,x}{u,x} and {v,x}{v,x} in HH. That's why, there is a connected path for any pair of vertices (u,v)(u,v), and the graph HH is connected. Similarly, the case b>1b>1 is proved.So, if min(a,b)>1min(a,b)>1, then the answer is \"NO\". Otherwise, min(a,b)=1min(a,b)=1. Consider the case where b=1b=1 (if b>ab>a, we can swap aa and bb, and output complement of the constructed graph). To have aa components in the graph GG, it is enough to connect the vertex 11 with the vertex 22, the vertex 22 with the vertex 33, ⋯⋯, the vertex n−an−a with the vertex n−a+1n−a+1. A particular cases are the tests n=2,a=1,b=1n=2,a=1,b=1 and n=3,a=1,b=1n=3,a=1,b=1. There is no suitable graph for them. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}990E - Post Lamps Tutorial990E - Post LampsLet's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider 00 to be covered. Function f(i)f(i) — the minimal number of post lamps to cover segment [0;i][0;i] is clearly monotonous, thus you want to update states as early as possible.Okay, now you iterate over all l∈[1;k]l∈[1;k] and update the answer with the results multiplied by cost.Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by k+1k+1 positions or return -1. This can be easily proven by contradiction.Overall complexity: O(n⋅logn)O(n⋅log⁡n), as you do about nlnl steps for each ll and that is a common series sum. Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}990F - Flow Control Tutorial990F - Flow ControlThe answer is \"Impossible\" if and only if the sum of values is not equal to 00. Writing some number on edge does not change the total sum and the goal of the problem is to make 00 in each vertex, thus getting 00 in total.The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and 00 for the rest of edges.Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has 00. This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.Overall complexity: O(n+m)O(n+m). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tdfs(0, -1);\n\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}990G - GCD Counting Tutorial990G - GCD CountingFirstly, for every i∈[1,2⋅105]i∈[1,2⋅105] we can calculate the number of paths such that g(x,y)g(x,y) is divisible by ii. We can do it as follows: generate all divisors of numbers aiai (numbers not exceeding 2⋅1052⋅105 have at most 160160 divisors, so this will be fast enough), and then for every i∈[1,2⋅105]i∈[1,2⋅105] analyze the graph containing the vertices that have ii as its divisor. Each component of this graph gives us k(k+1)2k(k+1)2 paths (if its size is kk), and this is the only formula we need to calculate the number of paths where g(x,y)g(x,y) is divisible by ii (let this be h(i)h(i)).How can we get the answer if we know the values of h(i)h(i)? We can use inclusion-exclusion with Mobius function, for example, to prove that ans(1)=∑i=12⋅105μ(i)h(i)ans(1)=∑i=12⋅105μ(i)h(i); and then if we want to apply the same technique for finding ans(x)ans(x) with any possible xx, we could divide all numbers aiai by xx and do the same thing. But it might be too slow, so it's better to rewrite this formula as ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi)ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi), because we will do exactly the same when dividing all numbers by xx.In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.This problem can also be solved with centroid decomposition. Solution with Möbius (Bleddest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n hd = 0;\n tl = 0;\n q[tl++] = x;\n used[x] = cc;\n while(hd < tl)\n {\n int z = q[hd++];\n for(auto y : g[z])\n {\n if(good[a[y]] == cc && used[y] < cc)\n {\n used[y] = cc;\n q[tl++] = y;\n }\n }\n }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t for(auto x : need_bfs[j])\n\t\t {\n\t\t if(used[x] == cc) continue;\n\t\t\t int z = bfs(x, i);\n\t\t\t ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t }\n\t for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n} Solution with centroid (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\n//\tcerr << \"C = \"<< c << endl;\n\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\n\tT++;\n\taddDiv(a[c], 1);\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\n\tmemset(res, 0, sizeof res);\n\n\tT = 0;\n\tcalc(0);\n\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59962",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 990\\s*E"
          },
          "content_length": 17061
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "what I did in C was ignored all cases of brackets which gave )( this sort of thing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 15",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 17",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 18",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(m, 0, n - 1, \"s\");\n    inf.readEoln();\n\n    for (int i = 1; i < m; ++i) {\n        ensuref(s[i - 1] < s[i], \"Blocked positions are not strictly increasing: s[%d]=%d >= s[%d]=%d\", i - 1, s[i - 1], i, s[i]);\n    }\n\n    vector<int> a = inf.readInts(k, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(m, 0, n - 1, \"s\");\n    inf.readEoln();\n\n    for (int i = 1; i < m; ++i) {\n        ensuref(s[i - 1] < s[i], \"Blocked positions are not strictly increasing: s[%d]=%d >= s[%d]=%d\", i - 1, s[i - 1], i, s[i]);\n    }\n\n    vector<int> a = inf.readInts(k, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(m, 0, n - 1, \"s\");\n    inf.readEoln();\n\n    for (int i = 1; i < m; ++i) {\n        ensuref(s[i - 1] < s[i], \"Blocked positions are not strictly increasing: s[%d]=%d >= s[%d]=%d\", i - 1, s[i - 1], i, s[i]);\n    }\n\n    vector<int> a = inf.readInts(k, 1, 1000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the \"street illumination\" problem.\n  \n  Usage example:\n    ./gen -n 10 -m 3 -k 5 -type random\n    \n  Command line parameters:\n    n     : length of the segment (1 <= n <= 10^6)\n    m     : number of blocked positions (0 <= m <= n)\n    k     : maximum lamp power (1 <= k <= n)\n    type  : one of \n            \"random\",             // random blocked positions, random costs\n            \"none_blocked\",       // m=0, no blocked positions\n            \"all_blocked\",        // m=n, all positions blocked => immediate -1\n            \"impossible_zero\",    // position 0 is blocked => immediate -1\n            \"sparse_blocked\",     // a small fraction of blocked positions, random\n            \"dense_blocked\",      // a large fraction of blocked positions, random\n            \"cost_increasing\",    // costs strictly increasing\n            \"cost_decreasing\",    // costs strictly decreasing\n            \"cost_same\"           // all costs are the same\n            // (if not specified, defaults to \"random\")\n  \n  The generator will output:\n    1) a single line: n m k\n    2) a second line: m distinct blocked positions in ascending order\n    3) a third line: k costs (between 1 and 1e6)\n  \n  NOTE: This generator does not accept or set a random seed.  \n  NOTE: If you pass contradictory parameters (e.g. -m 10 but type=none_blocked),\n        the generator will override m or other parameters as needed.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments.\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 3);\n    int k = opt<int>(\"k\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Make sure arguments are within the problem constraints.\n    // We will do simple checks.\n    // (Real usage might have more thorough checks or rely on the organizer.)\n    // But we won't artificially clamp well beyond.\n    // Instead, we trust the user not to exceed 1e6, etc.\n    if (n < 1)  n = 1;\n    if (m < 0)  m = 0;\n    if (m > n)  m = n;\n    if (k < 1)  k = 1;\n    if (k > n)  k = n;\n\n    // We will generate:\n    // 1) n, m, k\n    // 2) list of m distinct blocked positions in [0..n-1] sorted\n    // 3) list of k costs (1..1e6)\n\n    // Prepare a vector of possible positions [0..n-1].\n    // We'll mark which are blocked depending on the type.\n    vector<int> blocked;\n    blocked.reserve(n); // to avoid reallocation if needed\n\n    // cost array\n    vector<int> costs(k, 1);\n\n    // We'll handle \"type\" to override or guide m and the blocked positions.\n    if (type == \"none_blocked\") {\n        // no blocked positions at all\n        m = 0;\n    }\n    else if (type == \"all_blocked\") {\n        // block everything => immediate -1\n        m = n;\n    }\n    else if (type == \"impossible_zero\") {\n        // specifically block position 0 => immediate -1 if n>0\n        // just override m to 1 if it doesn't conflict with n=0\n        if (n > 0) {\n            m = 1;\n        }\n        else {\n            // if n=0 is nonsensical, fallback\n            m = 0;\n        }\n    }\n    else if (type == \"sparse_blocked\") {\n        // we want a small fraction blocked, say 5% of n (capped)\n        // override m\n        int proposed = max(1, (int)(0.05 * n)); \n        m = min(proposed, n);\n    }\n    else if (type == \"dense_blocked\") {\n        // we want a large fraction blocked, say 80% of n\n        // override m\n        int proposed = max(1, (int)(0.8 * n));\n        m = min(proposed, n);\n    }\n    // \"random\" or anything else just uses user-provided m (capped earlier).\n    // Now let's build the blocked positions array accordingly.\n\n    if (type == \"all_blocked\") {\n        // block everything from 0..n-1\n        blocked.resize(n);\n        iota(blocked.begin(), blocked.end(), 0);\n    }\n    else if (type == \"impossible_zero\" && n > 0) {\n        // block just position 0\n        blocked.clear();\n        blocked.push_back(0);\n    }\n    else {\n        // general random blocking, including random, sparse_blocked, dense_blocked\n        // or none_blocked if m=0, that is fine\n        // generate m distinct random positions in [0..n-1]\n        // but if we already handled \"impossible_zero\" or \"all_blocked\", skip\n        if (!(type == \"impossible_zero\" && n > 0) && !(type == \"all_blocked\")) {\n            // pick m distinct positions\n            // create a list of [0..n-1], shuffle, take first m, sort them\n            vector<int> allPos(n);\n            iota(allPos.begin(), allPos.end(), 0);\n            shuffle(allPos.begin(), allPos.end());\n            blocked.assign(allPos.begin(), allPos.begin() + m);\n            sort(blocked.begin(), blocked.end());\n        }\n    }\n\n    // At this point, 'blocked' has exactly m distinct positions or is already set.\n\n    // Next, generate costs according to possible cost patterns.\n    // For \"cost_increasing\", \"cost_decreasing\", \"cost_same\".\n    // Otherwise random in [1..1e6].\n    if (type == \"cost_increasing\") {\n        // strictly increasing from 1..k\n        for (int i = 0; i < k; i++) {\n            costs[i] = i + 1; // 1,2,3,...,k\n        }\n    }\n    else if (type == \"cost_decreasing\") {\n        // strictly decreasing from k..1\n        // but ensure each cost is >= 1\n        for (int i = 0; i < k; i++) {\n            costs[i] = k - i; // k, k-1, ..., 1\n        }\n    }\n    else if (type == \"cost_same\") {\n        // all costs are the same random value in [1..1e6]\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < k; i++) {\n            costs[i] = val;\n        }\n    }\n    else {\n        // random cost in [1..1e6]\n        for (int i = 0; i < k; i++) {\n            costs[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Now we can output the test.\n    // 1) n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // 2) m blocked positions\n    // If m>0, print them. If m=0, no output on the second line.\n    // The problem statement says \"m integer numbers\" on the second line\n    // If m=0, it will just be a blank line.\n    for (int i = 0; i < m; i++) {\n        printf(\"%d%c\", blocked[i], (i + 1 < m ? ' ' : '\\n'));\n    }\n    if (m == 0) {\n        printf(\"\\n\");\n    }\n\n    // 3) k costs\n    for (int i = 0; i < k; i++) {\n        printf(\"%d%c\", costs[i], (i + 1 < k ? ' ' : '\\n'));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the \"street illumination\" problem.\n  \n  Usage example:\n    ./gen -n 10 -m 3 -k 5 -type random\n    \n  Command line parameters:\n    n     : length of the segment (1 <= n <= 10^6)\n    m     : number of blocked positions (0 <= m <= n)\n    k     : maximum lamp power (1 <= k <= n)\n    type  : one of \n            \"random\",             // random blocked positions, random costs\n            \"none_blocked\",       // m=0, no blocked positions\n            \"all_blocked\",        // m=n, all positions blocked => immediate -1\n            \"impossible_zero\",    // position 0 is blocked => immediate -1\n            \"sparse_blocked\",     // a small fraction of blocked positions, random\n            \"dense_blocked\",      // a large fraction of blocked positions, random\n            \"cost_increasing\",    // costs strictly increasing\n            \"cost_decreasing\",    // costs strictly decreasing\n            \"cost_same\"           // all costs are the same\n            // (if not specified, defaults to \"random\")\n  \n  The generator will output:\n    1) a single line: n m k\n    2) a second line: m distinct blocked positions in ascending order\n    3) a third line: k costs (between 1 and 1e6)\n  \n  NOTE: This generator does not accept or set a random seed.  \n  NOTE: If you pass contradictory parameters (e.g. -m 10 but type=none_blocked),\n        the generator will override m or other parameters as needed.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments.\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 3);\n    int k = opt<int>(\"k\", 5);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Make sure arguments are within the problem constraints.\n    // We will do simple checks.\n    // (Real usage might have more thorough checks or rely on the organizer.)\n    // But we won't artificially clamp well beyond.\n    // Instead, we trust the user not to exceed 1e6, etc.\n    if (n < 1)  n = 1;\n    if (m < 0)  m = 0;\n    if (m > n)  m = n;\n    if (k < 1)  k = 1;\n    if (k > n)  k = n;\n\n    // We will generate:\n    // 1) n, m, k\n    // 2) list of m distinct blocked positions in [0..n-1] sorted\n    // 3) list of k costs (1..1e6)\n\n    // Prepare a vector of possible positions [0..n-1].\n    // We'll mark which are blocked depending on the type.\n    vector<int> blocked;\n    blocked.reserve(n); // to avoid reallocation if needed\n\n    // cost array\n    vector<int> costs(k, 1);\n\n    // We'll handle \"type\" to override or guide m and the blocked positions.\n    if (type == \"none_blocked\") {\n        // no blocked positions at all\n        m = 0;\n    }\n    else if (type == \"all_blocked\") {\n        // block everything => immediate -1\n        m = n;\n    }\n    else if (type == \"impossible_zero\") {\n        // specifically block position 0 => immediate -1 if n>0\n        // just override m to 1 if it doesn't conflict with n=0\n        if (n > 0) {\n            m = 1;\n        }\n        else {\n            // if n=0 is nonsensical, fallback\n            m = 0;\n        }\n    }\n    else if (type == \"sparse_blocked\") {\n        // we want a small fraction blocked, say 5% of n (capped)\n        // override m\n        int proposed = max(1, (int)(0.05 * n)); \n        m = min(proposed, n);\n    }\n    else if (type == \"dense_blocked\") {\n        // we want a large fraction blocked, say 80% of n\n        // override m\n        int proposed = max(1, (int)(0.8 * n));\n        m = min(proposed, n);\n    }\n    // \"random\" or anything else just uses user-provided m (capped earlier).\n    // Now let's build the blocked positions array accordingly.\n\n    if (type == \"all_blocked\") {\n        // block everything from 0..n-1\n        blocked.resize(n);\n        iota(blocked.begin(), blocked.end(), 0);\n    }\n    else if (type == \"impossible_zero\" && n > 0) {\n        // block just position 0\n        blocked.clear();\n        blocked.push_back(0);\n    }\n    else {\n        // general random blocking, including random, sparse_blocked, dense_blocked\n        // or none_blocked if m=0, that is fine\n        // generate m distinct random positions in [0..n-1]\n        // but if we already handled \"impossible_zero\" or \"all_blocked\", skip\n        if (!(type == \"impossible_zero\" && n > 0) && !(type == \"all_blocked\")) {\n            // pick m distinct positions\n            // create a list of [0..n-1], shuffle, take first m, sort them\n            vector<int> allPos(n);\n            iota(allPos.begin(), allPos.end(), 0);\n            shuffle(allPos.begin(), allPos.end());\n            blocked.assign(allPos.begin(), allPos.begin() + m);\n            sort(blocked.begin(), blocked.end());\n        }\n    }\n\n    // At this point, 'blocked' has exactly m distinct positions or is already set.\n\n    // Next, generate costs according to possible cost patterns.\n    // For \"cost_increasing\", \"cost_decreasing\", \"cost_same\".\n    // Otherwise random in [1..1e6].\n    if (type == \"cost_increasing\") {\n        // strictly increasing from 1..k\n        for (int i = 0; i < k; i++) {\n            costs[i] = i + 1; // 1,2,3,...,k\n        }\n    }\n    else if (type == \"cost_decreasing\") {\n        // strictly decreasing from k..1\n        // but ensure each cost is >= 1\n        for (int i = 0; i < k; i++) {\n            costs[i] = k - i; // k, k-1, ..., 1\n        }\n    }\n    else if (type == \"cost_same\") {\n        // all costs are the same random value in [1..1e6]\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < k; i++) {\n            costs[i] = val;\n        }\n    }\n    else {\n        // random cost in [1..1e6]\n        for (int i = 0; i < k; i++) {\n            costs[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Now we can output the test.\n    // 1) n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // 2) m blocked positions\n    // If m>0, print them. If m=0, no output on the second line.\n    // The problem statement says \"m integer numbers\" on the second line\n    // If m=0, it will just be a blank line.\n    for (int i = 0; i < m; i++) {\n        printf(\"%d%c\", blocked[i], (i + 1 < m ? ' ' : '\\n'));\n    }\n    if (m == 0) {\n        printf(\"\\n\");\n    }\n\n    // 3) k costs\n    for (int i = 0; i < k; i++) {\n        printf(\"%d%c\", costs[i], (i + 1 < k ? ' ' : '\\n'));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands (20+ total) to produce various tests. \n# Each command prints exactly one test case to stdout.\n\n# 1) Very small n, no blocked, single power.\n./gen -n 1 -m 0 -k 1 -type none_blocked\n\n# 2) Very small n=1, with 0 blocked => impossible.\n./gen -n 1 -type impossible_zero\n\n# 3) Small random with user-provided m=1, k=1.\n./gen -n 2 -m 1 -k 1 -type random\n\n# 4) Another small random test: n=5, m=2, k=5.\n./gen -n 5 -m 2 -k 5 -type random\n\n# 5) None blocked, n=5, k=5 => everything is open.\n./gen -n 5 -k 5 -type none_blocked\n\n# 6) All blocked, n=5 => immediate -1.\n./gen -n 5 -type all_blocked\n\n# 7) \"impossible_zero\" but n=5 => position 0 blocked => likely -1.\n./gen -n 5 -type impossible_zero\n\n# 8) Sparse blocked, n=20 => about 1 position in 20 blocked randomly (5%).\n./gen -n 20 -type sparse_blocked\n\n# 9) Dense blocked, n=20 => about 16 positions blocked (80%).\n./gen -n 20 -type dense_blocked\n\n# 10) cost_increasing, small n=10, random m=3, k=10.\n./gen -n 10 -m 3 -k 10 -type cost_increasing\n\n# 11) cost_decreasing, small n=10, random m=3, k=10.\n./gen -n 10 -m 3 -k 10 -type cost_decreasing\n\n# 12) cost_same, n=10, k=10, random m=5.\n./gen -n 10 -m 5 -k 10 -type cost_same\n\n# 13) Larger random test: n=50, m=12, k=7.\n./gen -n 50 -m 12 -k 7 -type random\n\n# 14) Larger none_blocked: n=50, k=10.\n./gen -n 50 -k=10 -type none_blocked\n\n# 15) Larger dense_blocked: n=50\n./gen -n 50 -type dense_blocked\n\n# 16) n=100, random block, k=5 => random costs.\n./gen -n 100 -m=20 -k=5 -type random\n\n# 17) n=100, cost_increasing\n./gen -n 100 -m=10 -k=10 -type cost_increasing\n\n# 18) n=200, cost_decreasing\n./gen -n 200 -m=50 -k=15 -type cost_decreasing\n\n# 19) n=500, cost_same\n./gen -n 500 -m=100 -k=20 -type cost_same\n\n# 20) Medium random, n=1000, m=200, k=30\n./gen -n 1000 -m=200 -k=30 -type random\n\n# 21) Large random, n=100000, k=10\n./gen -n 100000 -m=5000 -k=10 -type random\n\n# 22) Larger none_blocked, n=100000\n./gen -n 100000 -k=100 -type none_blocked\n\n# 23) Large dense_blocked, n=100000\n./gen -n 100000 -type dense_blocked\n\n# 24) Large cost_increasing, n=50000, k=50000\n./gen -n 50000 -m=10000 -k=50000 -type cost_increasing\n\n# 25) Very large random, n=1000000, m=500000, k=10\n# (One million positions, half blocked, random cost.)\n./gen -n 1000000 -m=500000 -k=10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:47.641318",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/F",
      "title": "Problem 990/F",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint find(vector<int>& parent, int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unite(vector<int>& parent, vector<int>& rank, int x, int y) {\n    x = find(parent, x);\n    y = find(parent, y);\n    if (x == y)\n        return;\n    if (rank[x] < rank[y])\n        swap(x, y);\n    parent[y] = x;\n    if (rank[x] == rank[y])\n        rank[x]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, -10000, 10000, \"s_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n    vector<int> parent(n + 1);\n    vector<int> rank(n + 1, 0);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge %d connects a node to itself: node %d\", i + 1, x);\n\n        int u = min(x, y);\n        int v = max(x, y);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Duplicate edge between node %d and node %d at edge %d\", x, y, i + 1);\n        edgeSet.insert(edge);\n\n        unite(parent, rank, x, y);\n    }\n\n    // Check connectivity\n    int root = find(parent, 1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(parent, i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint find(vector<int>& parent, int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unite(vector<int>& parent, vector<int>& rank, int x, int y) {\n    x = find(parent, x);\n    y = find(parent, y);\n    if (x == y)\n        return;\n    if (rank[x] < rank[y])\n        swap(x, y);\n    parent[y] = x;\n    if (rank[x] == rank[y])\n        rank[x]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, -10000, 10000, \"s_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n    vector<int> parent(n + 1);\n    vector<int> rank(n + 1, 0);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge %d connects a node to itself: node %d\", i + 1, x);\n\n        int u = min(x, y);\n        int v = max(x, y);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Duplicate edge between node %d and node %d at edge %d\", x, y, i + 1);\n        edgeSet.insert(edge);\n\n        unite(parent, rank, x, y);\n    }\n\n    // Check connectivity\n    int root = find(parent, 1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(parent, i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint find(vector<int>& parent, int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unite(vector<int>& parent, vector<int>& rank, int x, int y) {\n    x = find(parent, x);\n    y = find(parent, y);\n    if (x == y)\n        return;\n    if (rank[x] < rank[y])\n        swap(x, y);\n    parent[y] = x;\n    if (rank[x] == rank[y])\n        rank[x]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(n, -10000, 10000, \"s_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n    vector<int> parent(n + 1);\n    vector<int> rank(n + 1, 0);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge %d connects a node to itself: node %d\", i + 1, x);\n\n        int u = min(x, y);\n        int v = max(x, y);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Duplicate edge between node %d and node %d at edge %d\", x, y, i + 1);\n        edgeSet.insert(edge);\n\n        unite(parent, rank, x, y);\n    }\n\n    // Check connectivity\n    int root = find(parent, 1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(parent, i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read problem input from inf\n    int n = inf.readInt(1, 200000);\n    vector<int> s(n);\n    for (int i = 0; i < n; ++i) {\n        s[i] = inf.readInt(-10000, 10000);\n    }\n    int m = inf.readInt(0, 200000);\n    vector<int> x(m), y(m);\n    for (int i = 0; i < m; ++i) {\n        x[i] = inf.readInt(1, n);\n        y[i] = inf.readInt(1, n);\n    }\n\n    // Read judge's answer\n    string ans_s = ans.readToken();\n\n    // Read contestant's answer\n    string ouf_s = ouf.readToken();\n\n    // Check if contestant's output is 'Possible' or 'Impossible'\n    if (ouf_s != \"Possible\" && ouf_s != \"Impossible\") {\n        ouf.quitf(_wa, \"Contestant's output should be 'Possible' or 'Impossible', but found '%s'\", ouf_s.c_str());\n    }\n\n    if (ouf_s == \"Impossible\") {\n        if (ans_s == \"Impossible\") {\n            quitf(_ok, \"Correctly output 'Impossible'\");\n        } else {\n            ouf.quitf(_wa, \"Contestant outputs 'Impossible' while a solution exists\");\n        }\n    } else if (ouf_s == \"Possible\") {\n        // Read m integers f_i\n        vector<long long> f(m);\n        for (int i = 0; i < m; ++i) {\n            f[i] = ouf.readLong(-2000000000LL, 2000000000LL, format(\"f[%d]\", i + 1).c_str());\n        }\n\n        // Compute net_flow for each node\n        vector<long long> net_flow(n, 0);\n        for (int i = 0; i < m; ++i) {\n            int u = x[i] - 1;\n            int v = y[i] - 1;\n            long long fi = f[i];\n            net_flow[u] -= fi;\n            net_flow[v] += fi;\n        }\n\n        // Check net_flow against s_i\n        for (int i = 0; i < n; ++i) {\n            if (net_flow[i] != s[i]) {\n                ouf.quitf(_wa, \"At node %d, expected net flow %d, but found %lld\", i + 1, s[i], net_flow[i]);\n            }\n        }\n\n        // If contestant found a valid solution, accept\n        quitf(_ok, \"Found a valid solution\");\n    }\n\n    // Should not reach here\n    quitf(_fail, \"Unreachable code reached\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string sum_s = opt<string>(\"sum_s\", \"zero\"); // \"zero\", \"nonzero\", or \"extreme\"\n    string impossible = opt<string>(\"impossible\", \"no\"); // \"yes\" or \"no\"\n\n    vector<pair<int, int>> edges;\n\n    // Generate the graph based on the specified graph type\n    if (graph_type == \"chain\") {\n        m = n - 1;\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (graph_type == \"star\") {\n        m = n - 1;\n        int center = 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({center, i});\n        }\n    } else if (graph_type == \"tree\") {\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({i, parent});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (graph_type == \"random\") {\n        if (m < n - 1) m = n - 1;\n        // Create a random connected graph\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; i++) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        // Add extra edges\n        set<pair<int, int>> edge_set;\n        for (auto &e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edge_set.insert({u, v});\n        }\n        int extra_edges = m - (n - 1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (edge_set.count({a, b})) continue;\n            edge_set.insert({a, b});\n            edges.push_back({u, v});\n            extra_edges--;\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (graph_type == \"complete\") {\n        m = min(m, n * (n - 1) / 2);\n        for (int i = 1; i <= n && edges.size() < m; i++) {\n            for (int j = i + 1; j <= n && edges.size() < m; j++) {\n                edges.push_back({i, j});\n            }\n        }\n        shuffle(edges.begin(), edges.end());\n        if (edges.size() > m) edges.resize(m);\n    } else {\n        // Default to random connected graph if an unknown graph_type is provided\n        m = max(m, n - 1);\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; i++) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        set<pair<int, int>> edge_set;\n        for (auto &e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edge_set.insert({u, v});\n        }\n        int extra_edges = m - (n - 1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (edge_set.count({a, b})) continue;\n            edge_set.insert({a, b});\n            edges.push_back({u, v});\n            extra_edges--;\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate s_i values based on the specified sum_s and impossible parameters\n    vector<int> s(n + 1);\n    int total_s = 0;\n\n    if (sum_s == \"zero\") {\n        // Ensure that the sum of s_i is zero\n        for (int i = 1; i <= n - 1; i++) {\n            s[i] = rnd.next(-10000, 10000);\n            total_s += s[i];\n        }\n        s[n] = -total_s;\n        total_s += s[n];\n    } else if (sum_s == \"nonzero\") {\n        // Generate s_i such that the sum is not zero\n        for (int i = 1; i <= n - 1; i++) {\n            s[i] = rnd.next(-10000, 10000);\n            total_s += s[i];\n        }\n        s[n] = rnd.next(-10000, 10000);\n        total_s += s[n];\n        if (total_s == 0) {\n            // Adjust to make the sum non-zero\n            s[1] += 1;\n            total_s += 1;\n        }\n    } else if (sum_s == \"extreme\") {\n        // Use extreme values for s_i\n        for (int i = 1; i <= n; i++) {\n            s[i] = rnd.next(0, 1) ? -10000 : 10000;\n            total_s += s[i];\n        }\n        if (impossible == \"yes\" && total_s == 0) {\n            s[1] += 1;\n            total_s += 1;\n        } else if (impossible == \"no\" && total_s != 0) {\n            s[1] -= total_s;\n            total_s = 0;\n        }\n    }\n\n    // Adjust s_i to make the test case possible or impossible as required\n    if (impossible == \"yes\" && total_s == 0) {\n        s[1] += rnd.next(1, 10);\n        total_s += s[1];\n    } else if (impossible == \"no\" && total_s != 0) {\n        s[1] -= total_s;\n        total_s = 0;\n    }\n\n    // Ensure s_i values are within the specified range [-10000, 10000]\n    for (int i = 1; i <= n; i++) {\n        if (s[i] < -10000) s[i] = -10000;\n        if (s[i] > 10000) s[i] = 10000;\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d%c\", s[i], i == n ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", m);\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string sum_s = opt<string>(\"sum_s\", \"zero\"); // \"zero\", \"nonzero\", or \"extreme\"\n    string impossible = opt<string>(\"impossible\", \"no\"); // \"yes\" or \"no\"\n\n    vector<pair<int, int>> edges;\n\n    // Generate the graph based on the specified graph type\n    if (graph_type == \"chain\") {\n        m = n - 1;\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (graph_type == \"star\") {\n        m = n - 1;\n        int center = 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({center, i});\n        }\n    } else if (graph_type == \"tree\") {\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({i, parent});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (graph_type == \"random\") {\n        if (m < n - 1) m = n - 1;\n        // Create a random connected graph\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; i++) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        // Add extra edges\n        set<pair<int, int>> edge_set;\n        for (auto &e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edge_set.insert({u, v});\n        }\n        int extra_edges = m - (n - 1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (edge_set.count({a, b})) continue;\n            edge_set.insert({a, b});\n            edges.push_back({u, v});\n            extra_edges--;\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (graph_type == \"complete\") {\n        m = min(m, n * (n - 1) / 2);\n        for (int i = 1; i <= n && edges.size() < m; i++) {\n            for (int j = i + 1; j <= n && edges.size() < m; j++) {\n                edges.push_back({i, j});\n            }\n        }\n        shuffle(edges.begin(), edges.end());\n        if (edges.size() > m) edges.resize(m);\n    } else {\n        // Default to random connected graph if an unknown graph_type is provided\n        m = max(m, n - 1);\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; i++) {\n            parent[i] = rnd.next(1, i - 1);\n            edges.push_back({i, parent[i]});\n        }\n        set<pair<int, int>> edge_set;\n        for (auto &e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edge_set.insert({u, v});\n        }\n        int extra_edges = m - (n - 1);\n        while (extra_edges > 0) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (edge_set.count({a, b})) continue;\n            edge_set.insert({a, b});\n            edges.push_back({u, v});\n            extra_edges--;\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate s_i values based on the specified sum_s and impossible parameters\n    vector<int> s(n + 1);\n    int total_s = 0;\n\n    if (sum_s == \"zero\") {\n        // Ensure that the sum of s_i is zero\n        for (int i = 1; i <= n - 1; i++) {\n            s[i] = rnd.next(-10000, 10000);\n            total_s += s[i];\n        }\n        s[n] = -total_s;\n        total_s += s[n];\n    } else if (sum_s == \"nonzero\") {\n        // Generate s_i such that the sum is not zero\n        for (int i = 1; i <= n - 1; i++) {\n            s[i] = rnd.next(-10000, 10000);\n            total_s += s[i];\n        }\n        s[n] = rnd.next(-10000, 10000);\n        total_s += s[n];\n        if (total_s == 0) {\n            // Adjust to make the sum non-zero\n            s[1] += 1;\n            total_s += 1;\n        }\n    } else if (sum_s == \"extreme\") {\n        // Use extreme values for s_i\n        for (int i = 1; i <= n; i++) {\n            s[i] = rnd.next(0, 1) ? -10000 : 10000;\n            total_s += s[i];\n        }\n        if (impossible == \"yes\" && total_s == 0) {\n            s[1] += 1;\n            total_s += 1;\n        } else if (impossible == \"no\" && total_s != 0) {\n            s[1] -= total_s;\n            total_s = 0;\n        }\n    }\n\n    // Adjust s_i to make the test case possible or impossible as required\n    if (impossible == \"yes\" && total_s == 0) {\n        s[1] += rnd.next(1, 10);\n        total_s += s[1];\n    } else if (impossible == \"no\" && total_s != 0) {\n        s[1] -= total_s;\n        total_s = 0;\n    }\n\n    // Ensure s_i values are within the specified range [-10000, 10000]\n    for (int i = 1; i <= n; i++) {\n        if (s[i] < -10000) s[i] = -10000;\n        if (s[i] > 10000) s[i] = 10000;\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d%c\", s[i], i == n ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", m);\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -graph_type chain -sum_s zero -impossible no\n./gen -n 2 -m 1 -graph_type chain -sum_s nonzero -impossible yes\n\n./gen -n 5 -m 4 -graph_type chain -sum_s zero -impossible no\n./gen -n 5 -m 4 -graph_type chain -sum_s zero -impossible yes\n./gen -n 5 -m 4 -graph_type chain -sum_s nonzero -impossible yes\n\n./gen -n 10 -m 9 -graph_type chain -sum_s zero -impossible no\n./gen -n 10 -m 9 -graph_type chain -sum_s nonzero -impossible yes\n\n./gen -n 10 -m 9 -graph_type star -sum_s zero -impossible no\n./gen -n 10 -m 9 -graph_type star -sum_s nonzero -impossible yes\n\n./gen -n 50 -m 49 -graph_type tree -sum_s zero -impossible no\n./gen -n 50 -m 49 -graph_type tree -sum_s zero -impossible yes\n\n./gen -n 100 -m 100 -graph_type random -sum_s zero -impossible no\n./gen -n 100 -m 100 -graph_type random -sum_s nonzero -impossible yes\n\n./gen -n 500 -m 1000 -graph_type random -sum_s zero -impossible no\n./gen -n 500 -m 1000 -graph_type random -sum_s zero -impossible yes\n\n./gen -n 1000 -m 2000 -graph_type random -sum_s zero -impossible no\n./gen -n 1000 -m 2000 -graph_type random -sum_s nonzero -impossible yes\n\n./gen -n 5000 -m 10000 -graph_type tree -sum_s zero -impossible no\n./gen -n 5000 -m 10000 -graph_type tree -sum_s zero -impossible yes\n\n./gen -n 10000 -m 20000 -graph_type random -sum_s zero -impossible no\n./gen -n 10000 -m 20000 -graph_type random -sum_s nonzero -impossible yes\n\n./gen -n 20000 -m 40000 -graph_type star -sum_s zero -impossible no\n./gen -n 20000 -m 40000 -graph_type star -sum_s zero -impossible yes\n\n./gen -n 50000 -m 100000 -graph_type random -sum_s zero -impossible no\n./gen -n 50000 -m 100000 -graph_type random -sum_s extreme -impossible no\n\n./gen -n 100000 -m 200000 -graph_type tree -sum_s zero -impossible no\n./gen -n 100000 -m 200000 -graph_type tree -sum_s extreme -impossible yes\n\n./gen -n 200000 -m 200000 -graph_type chain -sum_s zero -impossible no\n./gen -n 200000 -m 200000 -graph_type chain -sum_s nonzero -impossible yes\n\n./gen -n 200000 -m 200000 -graph_type star -sum_s zero -impossible no\n./gen -n 200000 -m 200000 -graph_type star -sum_s extreme -impossible no\n\n./gen -n 200000 -m 200000 -graph_type random -sum_s zero -impossible no\n./gen -n 200000 -m 200000 -graph_type random -sum_s nonzero -impossible yes\n\n./gen -n 1 -m 0 -sum_s zero -impossible no\n./gen -n 1 -m 0 -sum_s nonzero -impossible yes\n\n./gen -n 10 -m 45 -graph_type complete -sum_s zero -impossible no\n./gen -n 10 -m 45 -graph_type complete -sum_s nonzero -impossible yes\n\n./gen -n 1000 -m 2000 -graph_type random -sum_s extreme -impossible no\n./gen -n 1000 -m 2000 -graph_type random -sum_s extreme -impossible yes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:49.234531",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "990/G",
      "title": "G. GCD Counting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer nn — the number of vertices (1≤n≤2⋅105)(1≤n≤2⋅105).The second line contains nn integers a1a1, a2a2, ..., anan (1≤ai≤2⋅105)(1≤ai≤2⋅105) — the numbers written on vertices.Then n−1n−1 lines follow, each containing two integers xx and yy (1≤x,y≤n,x≠y)(1≤x,y≤n,x≠y) denoting an edge connecting vertex xx with vertex yy. It is guaranteed that these edges form a tree.",
      "output_spec": "OutputFor every integer ii from 11 to 2⋅1052⋅105 do the following: if there is no pair (x,y)(x,y) such that x≤yx≤y and g(x,y)=ig(x,y)=i, don't output anything. Otherwise output two integers: ii and the number of aforementioned pairs. You have to consider the values of ii in ascending order.See the examples for better understanding.",
      "sample_tests": "ExamplesInputCopy31 2 31 22 3OutputCopy1 42 13 1InputCopy61 2 4 8 16 321 66 33 44 26 5OutputCopy1 62 54 68 116 232 1InputCopy49 16 144 61 32 34 3OutputCopy1 12 13 16 29 216 2144 1",
      "description": "G. GCD Counting\n\ntime limit per test4.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer nn — the number of vertices (1≤n≤2⋅105)(1≤n≤2⋅105).The second line contains nn integers a1a1, a2a2, ..., anan (1≤ai≤2⋅105)(1≤ai≤2⋅105) — the numbers written on vertices.Then n−1n−1 lines follow, each containing two integers xx and yy (1≤x,y≤n,x≠y)(1≤x,y≤n,x≠y) denoting an edge connecting vertex xx with vertex yy. It is guaranteed that these edges form a tree.\n\nOutputFor every integer ii from 11 to 2⋅1052⋅105 do the following: if there is no pair (x,y)(x,y) such that x≤yx≤y and g(x,y)=ig(x,y)=i, don't output anything. Otherwise output two integers: ii and the number of aforementioned pairs. You have to consider the values of ii in ascending order.See the examples for better understanding.\n\nInputCopy31 2 31 22 3OutputCopy1 42 13 1InputCopy61 2 4 8 16 321 66 33 44 26 5OutputCopy1 62 54 68 116 232 1InputCopy49 16 144 61 32 34 3OutputCopy1 12 13 16 29 216 2144 1\n\nInputCopy31 2 31 22 3\n\nOutputCopy1 42 13 1\n\nInputCopy61 2 4 8 16 321 66 33 44 26 5\n\nOutputCopy1 62 54 68 116 232 1\n\nInputCopy49 16 144 61 32 34 3\n\nOutputCopy1 12 13 16 29 216 2144 1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces",
          "content": "Hello Codeforces!On Sunday, June 10, 2018 at 18:05UTC+8 Educational Codeforces Round 45 will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Adilbek adedalic Dalabaev, Roman Roms Glazov, Ivan BledDest Androsov, Mike MikeMirzayanov Mirzayanov and me.Good luck to all participants!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 KrK 7 225 2 isaf27 7 231 3 BigBag 7 325 4 Motarack 7 327 5 TangentDay 7 331 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 202:-52 2 2014CAIS01 26:-2 3 djm03178 20 4 bitcoin 19 5 antguz 25:-17 549 successful hacks and 525 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A tzuyu_chou 0:01 B DoomzGay 0:05 C 562225807 0:08 D teja349 0:12 E eddy1021 0:18 F nhho 0:45 G AChen142857 0:14 UPD: Editorial is out",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/59919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1384
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces",
          "content": "990A - Commentary Boxes Tutorial990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to nn and the closest one greater than nn. Distances to them are (nmodm)(nmodm) and (m−(nmodm))(m−(nmodm)) respectively. Now you should multiply the first result by bb, the second result by aa and compare the products.Overall complexity: O(1)O(1). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}990B - Micro-World Tutorial990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria ii you need to check existence of any bacteria jj satisfying condition ai<aj≤ai+Kai<aj≤ai+K.There plenty of ways to check this condition. One of them is to sort array aa and for each ii find minimal aj>aiaj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai≤106ai≤106 and build solution around it.Result complexity is O(nlogn)O(nlog⁡n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}990C - Bracket Sequences Concatenation Problem Tutorial990C - Bracket Sequences Concatenation ProblemLet f(s)f(s) be the mirror reflection of the string ss. For example: ff(\"((\") = \"))\", ff(\"))(\") = \")((\", ff(\"()\") = \"()\".Let string be good if it does not have a prefix, which have more closing brackets than opening ones. For example, \"((\", \"(())(\", \"()()\" are good, and \"())\", \")((\", \"()())\" are not.The balance bal(s)bal(s) of the string ss is the difference between number of opening and closing brackets in ss. For example, balbal(\"(()\") = 1, balbal(\"()\") = 0.Let cnt[x]cnt[x] be the number of good strings with a balance xx.The answer to the problem is ∑s, where f(s) is goodcnt[bal(f(s))]∑s, where f(s) is goodcnt[bal(f(s))]. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}990D - Graph And Its Complement Tutorial990D - Graph And Its ComplementLet's prove that if a>1a>1, then b=1b=1. Let GG be the original graph, and HH — the complement of the graph GG. Let's look at each pair of vertices (u,v)(u,v). If uu and vv belong to different components of the graph GG, then there is an edge between them in the graph HH. Otherwise, uu and vv belong to the same component of the graph GG, but since GG has more than one component, there is vertex xx in other component of GG, and there are edges {u,x}{u,x} and {v,x}{v,x} in HH. That's why, there is a connected path for any pair of vertices (u,v)(u,v), and the graph HH is connected. Similarly, the case b>1b>1 is proved.So, if min(a,b)>1min(a,b)>1, then the answer is \"NO\". Otherwise, min(a,b)=1min(a,b)=1. Consider the case where b=1b=1 (if b>ab>a, we can swap aa and bb, and output complement of the constructed graph). To have aa components in the graph GG, it is enough to connect the vertex 11 with the vertex 22, the vertex 22 with the vertex 33, ⋯⋯, the vertex n−an−a with the vertex n−a+1n−a+1. A particular cases are the tests n=2,a=1,b=1n=2,a=1,b=1 and n=3,a=1,b=1n=3,a=1,b=1. There is no suitable graph for them. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}990E - Post Lamps Tutorial990E - Post LampsLet's start with learning how to place lamps of fixed power to cover the segment with the minimal number of them. The following greedy strategy works: find the rightmost non-blocked position that is covered by lamps and place lamp there until either everything is covered or rightmost free position is to the left of the last placed lamp. Initially you only consider 00 to be covered. Function f(i)f(i) — the minimal number of post lamps to cover segment [0;i][0;i] is clearly monotonous, thus you want to update states as early as possible.Okay, now you iterate over all l∈[1;k]l∈[1;k] and update the answer with the results multiplied by cost.Now, why will this work fast? You obviously precalculate the rightmost free position for each prefix segment. If there are any free positions to the right of last placed lamp then the rightmost of them will always be the rightmost for the entire prefix segment. Finally, any two consecutive iterations of the algorithm will either move you by k+1k+1 positions or return -1. This can be easily proven by contradiction.Overall complexity: O(n⋅logn)O(n⋅log⁡n), as you do about nlnl steps for each ll and that is a common series sum. Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}990F - Flow Control Tutorial990F - Flow ControlThe answer is \"Impossible\" if and only if the sum of values is not equal to 00. Writing some number on edge does not change the total sum and the goal of the problem is to make 00 in each vertex, thus getting 00 in total.The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and 00 for the rest of edges.Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has 00. This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.Overall complexity: O(n+m)O(n+m). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tdfs(0, -1);\n\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}990G - GCD Counting Tutorial990G - GCD CountingFirstly, for every i∈[1,2⋅105]i∈[1,2⋅105] we can calculate the number of paths such that g(x,y)g(x,y) is divisible by ii. We can do it as follows: generate all divisors of numbers aiai (numbers not exceeding 2⋅1052⋅105 have at most 160160 divisors, so this will be fast enough), and then for every i∈[1,2⋅105]i∈[1,2⋅105] analyze the graph containing the vertices that have ii as its divisor. Each component of this graph gives us k(k+1)2k(k+1)2 paths (if its size is kk), and this is the only formula we need to calculate the number of paths where g(x,y)g(x,y) is divisible by ii (let this be h(i)h(i)).How can we get the answer if we know the values of h(i)h(i)? We can use inclusion-exclusion with Mobius function, for example, to prove that ans(1)=∑i=12⋅105μ(i)h(i)ans(1)=∑i=12⋅105μ(i)h(i); and then if we want to apply the same technique for finding ans(x)ans(x) with any possible xx, we could divide all numbers aiai by xx and do the same thing. But it might be too slow, so it's better to rewrite this formula as ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi)ans(x)=∑i=1⌊2⋅105x⌋μ(i)h(xi), because we will do exactly the same when dividing all numbers by xx.In fact, most contestants have written a much easier version of this solution, so this might be a bit too complicated.This problem can also be solved with centroid decomposition. Solution with Möbius (Bleddest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n hd = 0;\n tl = 0;\n q[tl++] = x;\n used[x] = cc;\n while(hd < tl)\n {\n int z = q[hd++];\n for(auto y : g[z])\n {\n if(good[a[y]] == cc && used[y] < cc)\n {\n used[y] = cc;\n q[tl++] = y;\n }\n }\n }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t for(auto x : need_bfs[j])\n\t\t {\n\t\t if(used[x] == cc) continue;\n\t\t\t int z = bfs(x, i);\n\t\t\t ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t }\n\t for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n} Solution with centroid (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\n//\tcerr << \"C = \"<< c << endl;\n\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\n\tT++;\n\taddDiv(a[c], 1);\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\n\tmemset(res, 0, sizeof res);\n\n\tT = 0;\n\tcalc(0);\n\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59962",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 990\\s*G"
          },
          "content_length": 17061
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "what I did in C was ignored all cases of brackets which gave )( this sort of thing",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "ar.size() - 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59919",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 7;\n\nint n;\nstring s[N];\nchar buf[N];\nint cnt[N];\n\nint getBalance(string &s){\n\tint bal = 0;\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(s[i] == '(')\n\t\t\t++bal;\n\t\telse\n\t\t\t--bal;\n\t\t\n\t\tif(bal < 0)\n\t\t\treturn -1;\n\t}\n\t\n\treturn bal;\n}\n\nstring rev(string &s){\n\tstring revs = s;\n\treverse(revs.begin(), revs.end());\n\tfor(int i = 0; i < revs.size(); ++i)\n\t\tif(revs[i] == '(')\n\t\t\trevs[i] = ')';\n\t\telse\n\t\t\trevs[i] = '(';\n\t\t\n\treturn revs;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%s\", buf);\n\t\ts[i] = buf;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\t++cnt[bal];\n\t}\n\t\n\tlong long res = 0;\t\n\tfor(int i = 0; i < n; ++i){\n\t\ts[i] = rev(s[i]);\n\t\tint bal = getBalance(s[i]);\n\t\tif(bal != -1)\n\t\t\tres += cnt[bal];\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e3) + 7;\n\nint n, a, b;\nbool mat[N][N];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\n\tif(min(a, b) > 1){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tif(a == 1 && b == 1){\n\t\tif(n == 2 || n == 3){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tbool x = false;\n\tif(a == 1){\n\t\tswap(a, b);\n\t\tx = true;\n\t}\n\tfor(int i = n - a; i > 0; --i)\n\t\tmat[i][i - 1] = mat[i - 1][i] = true;\n\tputs(\"YES\");\n\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%c\", '0' + ((x ^ mat[i][j]) && (i != j)));\n\t\t\tputs(\"\");\n\t\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst long long INF64 = 1e18;\nconst int N = 1000 * 1000 + 13;\n\nint n, m, k;\nbool pos[N];\nint lst[N], s[N], a[N];\n\nint get(int l){\n\tint r = 0, i = -1, res = 0;\n\twhile (r < n){\n\t\tif (lst[r] <= i)\n\t\t\treturn INF;\n\t\ti = lst[r];\n\t\tr = lst[r] + l;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tforn(i, m) scanf(\"%d\", &s[i]);\n\tforn(i, k) scanf(\"%d\", &a[i]);\n\tforn(i, n) pos[i] = true;\n\tforn(i, m) pos[s[i]] = false;\n\tforn(i, n){\n\t\tif (pos[i])\n\t\t\tlst[i] = i;\n\t\telse if (i)\n\t\t\tlst[i] = lst[i - 1];\n\t\telse\n\t\t\tlst[i] = -1;\n\t}\n\tlong long ans = INF64;\n\tforn(i, k){\n\t\tlong long t = get(i + 1);\n\t\tif (t != INF)\n\t\t\tans = min(ans, a[i] * t);\n\t}\n\tprintf(\"%lld\\n\", ans == INF64 ? -1 : ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint d[N];\n\nvoid sieve()\n{\n\tvector<int> pr;\n \tfor(int i = 2; i < N; i++) \n \t{\n\t\tif (d[i] == 0) \n\t\t{\n\t\t\td[i] = i;\n\t\t\tpr.push_back(i);\n\t\t}\n\t\tfor(auto x : pr)\n\t\t{\n\t\t\tif (x > d[i] || x * 1ll * i >= N)\n\t\t\t\tbreak;\n\t\t\td[i * x] = x;\n\t\t}\n\t}\n}\n\nint mobius(int x)\n{\n\tint last = -1;\n\tint res = 1;\n\twhile(x != 1)\n\t{\n\t\tif(last == d[x])\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -res;\n\t\tlast = d[x];\n\t\tx /= d[x];\n\t}\n\treturn res;\n}\n\nint mb[N];\n\nvector<int> need_bfs[N];\nint used[N];\nvector<int> g[N];\nint a[N];\nint cc = 0;\nint q[N];\nint hd, tl;\nint good[N];\n\nint bfs(int x, int gc)\n{\n    hd = 0;\n    tl = 0;\n    q[tl++] = x;\n    used[x] = cc;\n    while(hd < tl)\n    {\n        int z = q[hd++];\n        for(auto y : g[z])\n        {\n            if(good[a[y]] == cc && used[y] < cc)\n            {\n                used[y] = cc;\n                q[tl++] = y;\n            }\n        }\n    }\n\treturn tl;\n}\n\nlong long ans1[N];\nlong long ans2[N];\n\nint main() {\n\tsieve();\n\tfor(int i = 1; i < N; i++)\n\t\tmb[i] = mobius(i);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tneed_bfs[a[i]].push_back(i);\n\t}\n\tfor(int i = 200000; i >= 1; i--)\n\t{\n\t\tcc++;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    good[j] = cc;\n\t\tfor(int j = i; j <= 200000; j += i)\n\t\t    for(auto x : need_bfs[j])\n\t\t    {\n\t\t        if(used[x] == cc) continue;\n\t\t\t    int z = bfs(x, i);\n\t\t\t    ans1[i] += z * 1ll * (z + 1) / 2;\n\t\t    }\n\t    for(int j = i, k = 1; j <= 200000; j += i, k++)\n\t        ans2[i] += mb[k] * ans1[j];\n\t}\n\tfor(int i = 1; i <= 200000; i++)\n\t\tif(ans2[i])\n\t\t\tprintf(\"%d %lld\\n\", i, ans2[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 15",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfor(auto &e : v)\n\t\tout << e << \", \";\n\treturn out << \"]\";\n}\n\nconst int N = 1000 * 1000 + 555;\nconst int LOGN = 21;\nint mind[N];\nint pw[LOGN][N];\n\nint n, a[N];\nvector<int> g[N];\nli res[N];\n\nbool gen() {\n\tmt19937 rnd(42);\n\tn = 200 * 1000;\n\tfore(i, 0, n)\n\t\ta[i] = 831600;\n\tfore(i, 1, n) {\n\t\tint u = rnd() % i, v = i;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\ninline bool read() {\n//\treturn gen();\n\tif(!(cin >> n))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\treturn true;\n}\n\nvector<pt> dv[N];\n\ninline int gcd(int a, int b) {\n\tint ans = 1;\n\tunsigned int u = 0, v = 0;\n\twhile(u < dv[a].size() && v < dv[b].size()) {\n\t\tif(dv[a][u].x < dv[b][v].x)\n\t\t\tu++;\n\t\telse if(dv[a][u].x > dv[b][v].x)\n\t\t\tv++;\n\t\telse {\n\t\t\tans *= pw[min(dv[a][u].y, dv[b][v].y)][dv[a][u].x];\n\t\t\tu++, v++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nbool used[N];\nint sz[N];\n\nvoid calcSz(int v, int p) {\n\tsz[v] = 1;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcSz(to, v);\n\t\tsz[v] += sz[to];\n\t}\n}\n\nint findC(int v, int p, int all) {\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tif(sz[to] > all / 2)\n\t\t\treturn findC(to, v, all);\n\t}\n\treturn v;\n}\n\nint u[N], T = 0;\nint cntD[N];\n\ninline void addDiv(int d, int cnt) {\n\tif(u[d] != T)\n\t\tu[d] = T, cntD[d] = 0;\n\tcntD[d] += cnt;\n}\n\nint cds[N], szcds;\n\nvoid calcDs(int v, int p, int gc) {\n\tgc = gcd(a[v], gc);\n\tcds[szcds++] = gc;\n\tfor(int to : g[v]) {\n\t\tif(to == p || used[to])\n\t\t\tcontinue;\n\t\tcalcDs(to, v, gc);\n\t}\n}\n\nvector<int> cps, cmx, vmx;\n\nvoid check(int curd, int curg, int pos, int add) {\n\tif(pos >= (int)cps.size()) {\n\t\tif(u[curd] == T)\n\t\t\tres[curg] += cntD[curd] * 1ll * add;\n\t\treturn;\n\t}\n\t\n\tfore(st, 0, cmx[pos] + 1) {\n\t\tcheck(curd, curg, pos + 1, add);\n\t\t\n\t\tcurd *= cps[pos];\n\t\tif(st < vmx[pos])\n\t\t\tcurg *= cps[pos];\n\t}\n}\n\npt ops[N]; int szops;\nint cntDiff[N];\n\nvoid calc(int v) {\n\tcalcSz(v, -1);\n\tint c = findC(v, -1, sz[v]);\n\tused[c] = 1;\n\t\n//\tcerr << \"C = \"<< c << endl;\n\t\n\tcps.resize(dv[a[c]].size());\n\tcmx.resize(cps.size());\n\tvmx.resize(cmx.size());\n\t\n\tfore(i, 0, cps.size()) {\n\t\tcps[i] = dv[a[c]][i].x;\n\t\tcmx[i] = dv[a[c]][i].y;\n\t}\n\t\n\tT++;\n\taddDiv(a[c], 1);\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\t\n\t\tszcds = 0;\n\t\tcalcDs(to, c, a[c]);\n\t\tfore(i, 0, szcds)\n\t\t\tcntDiff[cds[i]]++;\n\t\t\t\n\t\tszops = 0;\n\t\tfore(j, 0, szcds) {\n\t\t\tif(cntDiff[cds[j]] == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint p = 0, val = cds[j];\n\t\t\tfore(i, 0, vmx.size()) {\n\t\t\t\tif(p >= (int)dv[val].size() || dv[val][p].x > cps[i])\n\t\t\t\t\tvmx[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tvmx[i] = dv[val][p].y, p++;\n\t\t\t}\n\t\t\t\n\t\t\tcheck(1, 1, 0, cntDiff[cds[j]]);\n\t\t\tops[szops++] = {cds[j], cntDiff[cds[j]]};\n\t\t\tcntDiff[cds[j]] = 0;\n\t\t}\n\t\t\n\t\tfore(j, 0, szops)\n\t\t\taddDiv(ops[j].x, ops[j].y);\n\t}\n\t\n\tfor(int to : g[c]) {\n\t\tif(used[to]) continue;\n\t\tcalc(to);\n\t}\n}\n\ninline void solve() {\n\tiota(mind, mind + N, 0);\n\tfore(i, 2, N) {\n\t\tif(mind[i] != i)\n\t\t\tcontinue;\n\t\t\n\t\tpw[0][i] = 1;\n\t\tfore(st, 1, LOGN)\n\t\t\tpw[st][i] = pw[st - 1][i] * i;\n\t\t\n\t\tfor(li j = i * 1ll * i; j < N; j += i)\n\t\t\tmind[j] = min(mind[j], i);\n\t}\n\tfore(i, 2, N) {\n\t\tint val = i;\n\t\twhile(mind[val] > 1) {\n\t\t\tif(dv[i].empty() || dv[i].back().x != mind[val])\n\t\t\t\tdv[i].emplace_back(mind[val], 0);\n\t\t\tdv[i].back().y++;\n\t\t\tval /= mind[val];\n\t\t}\n\t}\n\t\n\tmemset(res, 0, sizeof res);\n\t\n\tT = 0;\n\tcalc(0);\n\t\n\tfore(i, 0, n)\n\t\tres[a[i]]++;\n\t\n\tfore(i, 1, 1000'000 + 1) {\n\t\tif(res[i])\n\t\t\tprintf(\"%d %lld\\n\", i, res[i]);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 17",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 45 Editorial - Codeforces - Code 18",
          "code": "720720 0 100\n100 199 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 100000 100000 100000 100000 100000 100000 100000...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59962",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) {\n        parent.resize(n+1);\n        rank.resize(n+1, 0);\n        for(int i = 1; i <= n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if(parent[x] == x) return x;\n        return parent[x] = find(parent[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false; // cycle detected\n        if(rank[x] < rank[y]) swap(x,y);\n        parent[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 200000, \"a_i\");\n    inf.readEoln();\n\n    DSU dsu(n);\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop detected at edge %d: vertex %d\", i+1, u);\n        ensuref(dsu.unite(u, v), \"Cycle detected at edge %d: between %d and %d\", i+1, u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) {\n        parent.resize(n+1);\n        rank.resize(n+1, 0);\n        for(int i = 1; i <= n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if(parent[x] == x) return x;\n        return parent[x] = find(parent[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false; // cycle detected\n        if(rank[x] < rank[y]) swap(x,y);\n        parent[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 200000, \"a_i\");\n    inf.readEoln();\n\n    DSU dsu(n);\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop detected at edge %d: vertex %d\", i+1, u);\n        ensuref(dsu.unite(u, v), \"Cycle detected at edge %d: between %d and %d\", i+1, u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) {\n        parent.resize(n+1);\n        rank.resize(n+1, 0);\n        for(int i = 1; i <= n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if(parent[x] == x) return x;\n        return parent[x] = find(parent[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false; // cycle detected\n        if(rank[x] < rank[y]) swap(x,y);\n        parent[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 200000, \"a_i\");\n    inf.readEoln();\n\n    DSU dsu(n);\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loop detected at edge %d: vertex %d\", i+1, u);\n        ensuref(dsu.unite(u, v), \"Cycle detected at edge %d: between %d and %d\", i+1, u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string values_type = opt<string>(\"values_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    // Generate tree based on tree_type\n    if (tree_type == \"chain\") {\n        // Edges from node i to node i+1\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (tree_type == \"star\") {\n        // Edges from node 1 to nodes 2..n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else {\n        // Random tree\n        vector<int> p(n+1);\n        for (int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i-1);\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, p[i]});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Randomly shuffle the node labels to avoid any biases\n    vector<int> perm(n+1);\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin()+1, perm.end());\n\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    // Now generate the values based on values_type\n    vector<int> a(n+1);\n    if (values_type == \"all_one\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = 1;\n    } else if (values_type == \"all_max\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = 200000;\n    } else if (values_type == \"increasing\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = i;\n    } else if (values_type == \"decreasing\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = n - i + 1;\n    } else if (values_type == \"random\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = rnd.next(1, 200000);\n    } else if (values_type == \"primes\") {\n        // Generate primes up to 200000\n        int MAX_N = 200000;\n        vector<int> is_prime(MAX_N + 1, 1);\n        is_prime[0] = is_prime[1] = 0;\n        for (int i = 2; i * i <= MAX_N; ++i) {\n            if (is_prime[i]) {\n                for (int j = i * i; j <= MAX_N; j += i)\n                    is_prime[j] = 0;\n            }\n        }\n        vector<int> primes;\n        for (int i = 2; i <= MAX_N; ++i) {\n            if (is_prime[i]) primes.push_back(i);\n        }\n        // Now assign primes to nodes, possibly with duplicates\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = primes[rnd.next(0, (int)primes.size() - 1)];\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a_i values\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output edges\n    for (auto &edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string values_type = opt<string>(\"values_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    // Generate tree based on tree_type\n    if (tree_type == \"chain\") {\n        // Edges from node i to node i+1\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (tree_type == \"star\") {\n        // Edges from node 1 to nodes 2..n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else {\n        // Random tree\n        vector<int> p(n+1);\n        for (int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i-1);\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, p[i]});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Randomly shuffle the node labels to avoid any biases\n    vector<int> perm(n+1);\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin()+1, perm.end());\n\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    // Now generate the values based on values_type\n    vector<int> a(n+1);\n    if (values_type == \"all_one\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = 1;\n    } else if (values_type == \"all_max\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = 200000;\n    } else if (values_type == \"increasing\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = i;\n    } else if (values_type == \"decreasing\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = n - i + 1;\n    } else if (values_type == \"random\") {\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = rnd.next(1, 200000);\n    } else if (values_type == \"primes\") {\n        // Generate primes up to 200000\n        int MAX_N = 200000;\n        vector<int> is_prime(MAX_N + 1, 1);\n        is_prime[0] = is_prime[1] = 0;\n        for (int i = 2; i * i <= MAX_N; ++i) {\n            if (is_prime[i]) {\n                for (int j = i * i; j <= MAX_N; j += i)\n                    is_prime[j] = 0;\n            }\n        }\n        vector<int> primes;\n        for (int i = 2; i <= MAX_N; ++i) {\n            if (is_prime[i]) primes.push_back(i);\n        }\n        // Now assign primes to nodes, possibly with duplicates\n        for (int i = 1; i <= n; ++i)\n            a[perm[i]] = primes[rnd.next(0, (int)primes.size() - 1)];\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a_i values\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output edges\n    for (auto &edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with chain tree and all ones\n./gen -n 1 -tree_type chain -values_type all_one\n./gen -n 2 -tree_type chain -values_type all_one\n./gen -n 3 -tree_type chain -values_type increasing\n\n# Small n with different tree types\n./gen -n 5 -tree_type star -values_type all_max\n./gen -n 5 -tree_type random -values_type primes\n\n# Medium n with different tree and values types\n./gen -n 50 -tree_type chain -values_type decreasing\n./gen -n 50 -tree_type star -values_type random\n./gen -n 50 -tree_type random -values_type random\n\n# Medium n with special values\n./gen -n 100 -tree_type chain -values_type all_one\n./gen -n 100 -tree_type star -values_type all_max\n./gen -n 100 -tree_type random -values_type primes\n\n# Large n with different tree and values types\n./gen -n 1000 -tree_type chain -values_type increasing\n./gen -n 1000 -tree_type chain -values_type decreasing\n./gen -n 1000 -tree_type random -values_type random\n./gen -n 1000 -tree_type star -values_type random\n\n# Maximum n with different trees and values\n./gen -n 200000 -tree_type chain -values_type all_one\n./gen -n 200000 -tree_type chain -values_type all_max\n./gen -n 200000 -tree_type random -values_type random\n./gen -n 200000 -tree_type random -values_type all_one\n./gen -n 200000 -tree_type random -values_type all_max\n./gen -n 200000 -tree_type star -values_type random\n\n# Special cases with large n and varying values\n./gen -n 200000 -tree_type random -values_type increasing\n./gen -n 200000 -tree_type random -values_type decreasing\n\n# Additional edge cases to test primes\n./gen -n 50 -tree_type random -values_type primes\n./gen -n 10000 -tree_type star -values_type primes\n./gen -n 10000 -tree_type star -values_type random\n./gen -n 10000 -tree_type random -values_type random\n./gen -n 10000 -tree_type chain -values_type random\n\n# Testing overlapping GCD values\n./gen -n 200000 -tree_type random -values_type all_one\n./gen -n 200000 -tree_type random -values_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:51.311449",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "991/A",
      "title": "A. Пересдача",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся четыре целых неотрицательных числа — AA, BB, CC и NN (0≤A,B,C,N≤1000≤A,B,C,N≤100).",
      "output_spec": "Выходные данныеЕсли существует такое распределение, что из NN студентов AA посетили BugDonalds, BB — BeaverKing, CC — оба ресторана, и при этом хотя бы один студент остался дома (известно, что хотя бы Вася не сдал экзамен и не пошел праздновать), то следует вывести единственное число — количество студентов (включая Васю), которые не сдали экзамен. Если же Вася ошибся в определении чисел (AA, BB, CC или даже NN) и описанная ситуация невозможна (см. примеры 2 и 3), то следует вывести −1−1.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 10 5 20Выходные данныеСкопировать5Входные данныеСкопировать2 2 0 4Выходные данныеСкопировать-1Входные данныеСкопировать2 2 2 1Выходные данныеСкопировать-1",
      "description": "A. Пересдача\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержатся четыре целых неотрицательных числа — AA, BB, CC и NN (0≤A,B,C,N≤1000≤A,B,C,N≤100).\n\nВходные данные\n\nВыходные данныеЕсли существует такое распределение, что из NN студентов AA посетили BugDonalds, BB — BeaverKing, CC — оба ресторана, и при этом хотя бы один студент остался дома (известно, что хотя бы Вася не сдал экзамен и не пошел праздновать), то следует вывести единственное число — количество студентов (включая Васю), которые не сдали экзамен. Если же Вася ошибся в определении чисел (AA, BB, CC или даже NN) и описанная ситуация невозможна (см. примеры 2 и 3), то следует вывести −1−1.\n\nВыходные данные\n\nВходные данныеСкопировать10 10 5 20Выходные данныеСкопировать5Входные данныеСкопировать2 2 0 4Выходные данныеСкопировать-1Входные данныеСкопировать2 2 2 1Выходные данныеСкопировать-1\n\nВходные данныеСкопировать10 10 5 20\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 0 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере описана такая ситуация: 55 студентов посетили только BugDonalds, 55 студентов — только BeaverKing, 55 — оба ресторана и 55 студентов (включая Васю) не сдали экзамен.Во втором примере 22 человека посетили BugDonalds, 22 — BeaverKing, тогда получается, что все 44 студента группы экзамен сдали, однако, известно, что Вася экзамен не сдал, значит, такой ситуации быть не может.В третьем примере описана явно противоречивая ситуация: 22 студента посетили BugDonalds, но при этом в группе всего 11 студент. Такого быть не может.",
      "solutions": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces",
          "content": "Привет!В субботу 23 июня в 18:35 (Московское время) начнется Codeforces Round #491 (Div.2). Раунд будет рейтинговым для участников с рейтингом менее 2100, остальные участники могут решать задачи вне конкурса.Раунд во многом пересекается с задачами олимпиады по программированию ННГУ 2018 года. Если вы принимали участие в олимпиаде или дорешивали задачи, просьба не участвовать в раунде.В задачах раунда вам нужно будет помочь студенту Васе справиться с трудностями, вызванными окончанием учебного года. Всего будет предложено 6 задач и 2 часа на их решение. Если же вы решите все задачи за 25 минут, то успеете посмотреть второй тайм матча Южная Корея — Мексика на чемпионате мира FIFA.Разбалловка немного нестандартная: 500-1000-1250-1500-2000-2750Выражаю максимальную благодарность Михаилу MikeMirzayanov Мирзаянову за всем известные платформы; Николаю KAN Калинину — за помощь в подготовке задач и координацию раунда; Михаилу mike_live Кривоносову, Алексею Livace Илюхову, Никите FalseMirror Босову, Андрею GreenGrape Райскому и Алексею Aleks5d Упирвицкому — за тестирование задач; Арсению arsor Сорокину — за перевод условий. А всем участникам желаю удачи на раунде!UPD: Раунд завершен, всем спасибо за участие!UPD: Поздравляем победителей!Div. 1: nuip krijgertje qoo2p5 hohomu neal Div. 2: King — решил все задачи, отличный результат! Daniar Saidjamol shoemakerjo Toki_Time-Tinker UPD: Опубликован разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1416
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces",
          "content": "991A - Пересдача РазборВсего студенты разбились на 4 группы — те кто посетил только первый ресторан, кто только второй, кто посетил оба ресторана и кто не сдал экзамен. Один из наиболее простых вариантов отсечь все некорректные случаи — посчитать, сколько студентов оказалось в каждой группе. Для первой группы это значение равно A - C, для второй: B - C, для третьей: C, для четвертой: N - A - B + C. Теперь достаточно проверить, что в первых трех группах неотрицательное число студентов, а в последней — положительное. Если это так, то количество студентов в последней группе и есть ответ на задачу. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;В общем случае, рекомендуется ознакомиться с методом включений-исключений.Кроме того, ограничения в задаче позволяют перебрать значения количества студентов в каждой группе (кроме третьей) за O(N3) и проверить, соответствует ли такое разбиение условию. Если ни одно разбиение не подошло — вывести  - 1: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Решение1Решение2991B - Отлично! РазборВ этой задаче применим жадный алгоритм. Действительно, Васе выгодно сначала исправлять наиболее низкие оценки. Поэтому можно отсортировать полученные оценки в порядке возрастания и начать заменять их на 5, пока не получим желаемый результат. Для проверки результата можно после каждой операции вычислять среднее арифметическое заново (итого, сложность будет O(N2)) или поддерживать текущую сумму оценок, пересчитывая среднее арифметическое за O(1) с общей сложностью O(N), без учета сортировки, например, так: bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}\nРазумеется, оба подхода легко укладываются в ограничение по времени. Кроме того, рекомендуется избежать вычисление среднего арифметического значения с использованием вещественных чисел.Решение991C - Эклеры РазборНесложно проверить, что для некоторого k условие выполняется (Вася съест не менее половины эклеров), то и для любого большего k это условие выполнится. ДоказательствоДействительно, рассмотрим количество эклеров, которое останется вечером каждого дня при некотором выбранном k1 — пусть в день i останется ai эклеров. Если мы возьмем для Васи другое число k2 > k1, то в первый вечер останется меньше эклеров: b1 < a1. Но тогда Петя вечером съест эклеров не больше, чем в первом случае, однако на следующий день их будет все равно не больше, чем в первом случае (если n1 > n2, то n1 - n1 / 10 ≥ n2 - n2 / 10). Аналогично с учетом k2 > k1 и к вечеру второго дня b2 < a2 и так далее. Таким образом, для любого i получаем bi < ai, а значит и Петя каждый день будет есть не больше эклеров, чем в первом случае. Значит, Петя в сумме съест не больше эклеров, чем в первом случае, а Вася — не меньше.Значит, эту задачу можно решать при помощи бинарного поиска по ответу. Для проверки конкретного выбранного k можно использовать простую симуляцию процесса, описанного в условии. bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}Поскольку Петя съедает 10% от количества оставшихся эклеров, то это количество убывает экспоненциально, значит, пройдет достаточно мало дней прежде чем будут съедены все эклеры. В худшем случае ребятам потребуется 378 дней. Формально же асимптотика этого решения есть O(log(n)2).Как и в предыдущей задаче рекомендуется избежать работы с вещественными числами и все вычисления производить в целых типах.Решение991D - Слонопотамы РазборВ этой задаче применим следующий жадный алгоритм. Будем идти по столбцам слева-направо, если мы сейчас рассматриваем столбец i и мы можем поставить фигуру, занимающую клетки столбцов i и i + 1, то нужно ее поставить. Действительно, если в оптимальном решении столбец i не занят ни одной фигурой, то в столбце i + 1 клетки заняты максимум одним слонопотамом. Значит, его можно убрать и поставить в столбцы i и i + 1, от этого ответ станет не хуже. Немного более сложный вопрос — как именно поставить фигуру, если все 4 клетки столбцов i и i + 1 свободны (в других случаях фигуру можно поставить только одним способом)? Разумеется, в столбце i выгодно занять обе клетки. Оказывается, при этом неважно, какую именно клетку столбца i + 1 займет слонопотам. Действительно, клетки столбца i + 1 могут пригодиться только при размещении фигуры в столбцах i + 1,i + 2. Если в столбце i + 2 свободно не более одной клетки, то разместить фигуру не получится и клетки столбца i + 1 ни на что не влияют. Если же в столбце i + 2 свободны обе клетки, то мы можем разместить слонопотама при любом выборе занятой клетки столбца i + 1.Из этого следует, что нам вообще можно не расставлять фигуры, а лишь пересчитывать количество свободных клеток в столбцах. В соответствии с описанным алгоритмом, получаем такой код: \t... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}Более того, эту реализацию можно заметно упростить, сведя решение всего к двум случаям: \tint ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}Формально данную реализацию можно отнести к динамическому программированию. Разумеется, ее можно написать и не обладая глубокими знаниями этого метода.Кроме того, задачу можно решать более ''явной'' динамикой (например в качестве состояния использовать номер текущего столбца и состояние предыдущего). В этом случае реализация будет чуть более сложной, но не будет необходимости доказывать описанные выше утверждения.Решение1Решение2991E - Номер автобуса РазборИз условия следует, что цифры оригинального номера автобуса представляют собой некоторое подмножество цифр номера, увиденного Васей. Перебрать подмножество цифр можно стандартным алгоритмом за 2k операций (где k — длина числа n). При этом каждое подмножество нужно проверить на корректность (содержит ли оно все нужные цифры) и привести к ''каноническому'' виду (например, отсортировать), чтобы избежать повторений с подмножествами, отличающимися лишь порядком цифр. Среди корректных наборов нужно оставить только уникальные. \tlong long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}Теперь для выбранного набора цифр нужно посчитать количество вариантов номера автобуса. Это можно сделать за O(k), использовав стандартную формулу числа перестановок мультимножества (см. секцию ''Permutations of multisets'' в статье про перестановки и мультиномиальные коэффициенты)C = k! / (c0! * c1! * ... * c9!), где k — общее количество цифр в наборе, а ci — количество цифр i в наборе: long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}Из этого числа нужно вычесть количество номеров, начинающихся на 0, если 0 присутствует в наборе. Сделать это достаточно просто: если мы поставим на первое место 0, то достаточно уменьшить k на 1 и c0 на 1, после чего применить формулу выше — она посчитает количество способов разместить остальные цифры набора. long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}Итого, даже при грубой оценке сложности и простой реализации получаем асимптотику O(2k * k), где k ≤ 19 — количество цифр числа n. Легко проверить, что ответ всегда не превосходит 1018, поэтому для его вычисления достаточно ограничиться стандартным 64-битовым типом.Решение991F - Отобразить число РазборВсе числа в задаче (кроме числа 1010, которое дано в примере) содержат максимум 10 цифр. Значит, если мы хотим найти более короткое представление, оно должно содержать максимум 9 цифр. Заметим, что длина суммы двух чисел не превосходит суммы длин чисел, поэтому в оптимальном представлении максимум одно слагаемое является числом, а остальные слагаемые — выражения содержащие * или ^. Каждое выражение имеет длину хотя бы 3 символа, значит, в представлении может быть максимум 3 слагаемых. Максимальное число, которое можно представить 3 слагаемыми: 9^9+9^9+9, но это число содержит лишь 9 знаков, а выражения с 3 слагаемыми всегда содержит минимум 9 знаков. Значит, всегда существует оптимальное представление, содержащее максимум два слагаемых.Тогда существует 3 варианта, как можно представить исходное число: n = a^b n = x+y n = x*y где x и y — выражения (в первом случае a и b — числа), не содержащие знаков +. Причем, во всех случаях эти выражения содержат максимум 7 символов.Давайте найдем для каждого x, не превосходящего n, эквивалентное выражение m[x], содержащие не более 7 символов (если оно короче, чем само число), а так же для каждой длины d — список чисел s[d], которые можно представить выражением длины d. Для этого удобно использовать, например, стандартные контейнеры map и set в C++: map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}Сначала добавим все возможные выражения вида a^b — их будет порядка sqrt(n). void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}Теперь рассмотрим выражения, состоящие из нескольких множителей. Заметим, что аналогично со сложением, в выражении максимум один множитель является числом. Тогда выражение может иметь только вид: x = a^b*c^d x = a^b*c где a, b, c и d — некоторые числа. Давайте переберем длину i первого множителя и пройдем по всем значениям контейнера s[i]. Тогда второй множитель может иметь длину максимум d = 7 - i - 1 и вариантов выбрать этот множитель будет достаточно мало. Второй множитель можно перебрать, пройдя по контейнерам длины до d в первом случае, либо перебрать числа от 1 до 10d во втором случае. Всего при этом мы добавим в m порядка k = 150000 чисел: void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}Теперь вернемся к представлению исходного числа. Для случая a^b мы уже добавили выражения в m. Для случаев x+y и x*y заметим, что можно считать, что длина выражения x не больше 4. Давайте переберем x среди найденных выражений длины до 4, а так же среди чисел от 1 до 104. Для каждого x и для каждого из двух вариантов мы однозначно определяем значение y, оптимальное представление которого уже записано в m или просто равняется числу. Таким образом, для каждого x мы сможем найти оптимальный ответ за два обращения к m, то есть за log(k) операций. string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}Итого, общая сложность алгоритма есть O((sqrt(n) + k + 104) * log(k)).Решение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 991\\s*A"
          },
          "content_length": 13240
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 1",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 2",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 3",
          "code": "unsigned long long a, b;\n    while (n >= 2)\n    {\n        a += 2;\n        n -= 2;\n        b += n / 10;\n        n -= n / 10;\n\n        cout << a << \":\" << b << \"\\n\";\n    }\n    a += n;\n    \n    cout << a << \":\" << b << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 4",
          "code": "unsigned long long a, b;\n    while (n >= 2)\n    {\n        a += 2;\n        n -= 2;\n        b += n / 10;\n        n -= n / 10;\n\n        cout << a << \":\" << b << \"\\n\";\n    }\n    a += n;\n    \n    cout << a << \":\" << b << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 5",
          "code": "~~~~~\nvar\n    n, vasya, petya: longint;\n\nbegin\n    n :=68;\n    while (n > 1) do\n    begin\n        vasya := vasya + 2;\n        n := n - 2;\n        petya :=petya +  n div 10; \n        n:=n - n div 10;\n    end;\n    \n    vasya := vasya + n;\n    writeln('Vasya ',vasya);\n    writeln('Petya ',petya);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 6",
          "code": "~~~~~\nvar\n    n, vasya, petya: longint;\n\nbegin\n    n :=68;\n    while (n > 1) do\n    begin\n        vasya := vasya + 2;\n        n := n - 2;\n        petya :=petya +  n div 10; \n        n:=n - n div 10;\n    end;\n    \n    vasya := vasya + n;\n    writeln('Vasya ',vasya);\n    writeln('Petya ',petya);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 7",
          "code": "забывает проверить выход за пределы массива или строки",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 8",
          "code": "for Test case #7:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 9",
          "code": "Input: 999999972",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 10",
          "code": "Jury's answer: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 11",
          "code": "Output: 39259426",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 12",
          "code": "Output: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 13",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 14",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 15",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 16",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 1",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 2",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 3",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 4",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 5",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 6",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 7",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 8",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 9",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 10",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 11",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 12",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 13",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 14",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 15",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 16",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 17",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 18",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 19",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 20",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 21",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 22",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 23",
          "code": "x = a^b*c^d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 24",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 25",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 26",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 27",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 28",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 29",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 30",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 31",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read A, B, C, N on a single line, each in [0, 100].\n    int A = inf.readInt(0, 100, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(0, 100, \"B\");\n    inf.readSpace();\n    int C = inf.readInt(0, 100, \"C\");\n    inf.readSpace();\n    int N = inf.readInt(0, 100, \"N\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read A, B, C, N on a single line, each in [0, 100].\n    int A = inf.readInt(0, 100, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(0, 100, \"B\");\n    inf.readSpace();\n    int C = inf.readInt(0, 100, \"C\");\n    inf.readSpace();\n    int N = inf.readInt(0, 100, \"N\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read A, B, C, N on a single line, each in [0, 100].\n    int A = inf.readInt(0, 100, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(0, 100, \"B\");\n    inf.readSpace();\n    int C = inf.readInt(0, 100, \"C\");\n    inf.readSpace();\n    int N = inf.readInt(0, 100, \"N\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Generator for the following problem:\n\n    We have four integers: A, B, C, N (0 ≤ A, B, C, N ≤ 100).\n\n    Interpretation:\n    - A = number of students who visited BugDonalds\n    - B = number of students who visited BeaverKing\n    - C = number of students who visited both restaurants\n    - N = total number of students in the group\n\n    We want to produce test inputs (A, B, C, N) such that they can be:\n    1) valid (the problem solution should output a positive integer != -1),\n    2) invalid (the problem solution should output -1),\n    3) corner / special examples, e.g. from the problem statement.\n\n    Command-line parameters (all optional):\n    - \"type\" in { \"random\", \"valid\", \"invalid\", \"corner\" }\n        default = \"random\"\n        Decides how we generate the single test case.\n    - \"ma\" (maximum possible value for A, B, C, N)\n        default = 100\n        We will generate values in [0..ma].\n    - \"special\" (integer selector for corner cases)\n        default = 0\n        Used only when type == \"corner\" to output specific examples from the statement or any special set.\n\n    NOTE: The generator always prints exactly ONE line containing:\n         A B C N\n    Then you may run the generator multiple times with different command-line parameters\n    to obtain multiple test files.\n\n    We do NOT set any random seed in code, and we do NOT accept any seed parameter.\n    The testlib 'rnd' is automatically seeded each run differently.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line parameters.\n    string type = opt<string>(\"type\", \"random\");  // \"random\", \"valid\", \"invalid\", \"corner\"\n    int ma = opt<int>(\"ma\", 100);                 // maximum range for A,B,C,N\n    int special = opt<int>(\"special\", 0);         // used only for corner cases\n\n    int A, B, C, N;\n    A = B = C = N = 0;\n\n    if (type == \"corner\") {\n        /*\n            Produce specific corner/special test cases. We'll handle a few\n            interesting examples from the problem statement or borderline values.\n\n            special = 1 => 0 0 0 0     (expected invalid, w= - ???)\n            special = 2 => 0 0 0 1     (expected valid, solution => 1)\n            special = 3 => 2 2 0 4     (from the statement sample #2 => -1)\n            special = 4 => 2 2 2 1     (from the statement sample #3 => -1)\n            special = 5 => 10 10 5 20  (from the statement sample #1 => valid => 5)\n            anything else => produce a consistent corner we define ourselves\n        */\n        switch (special) {\n            case 1: A = 0; B = 0; C = 0; N = 0; break; \n            case 2: A = 0; B = 0; C = 0; N = 1; break; \n            case 3: A = 2; B = 2; C = 0; N = 4; break; \n            case 4: A = 2; B = 2; C = 2; N = 1; break; \n            case 5: A = 10; B = 10; C = 5; N = 20; break; \n            default:\n                // Another corner: A=0, B=100, C=0, N=100 \n                // ( means 100 visited only BeaverKing, 0 visited BD, 0 visited both => w= ??? )\n                A = 0; B = 100; C = 0; N = 100; \n                break;\n        }\n    }\n    else if (type == \"valid\") {\n        /*\n           Generate random, guaranteed-valid quadruple (A,B,C,N).\n\n           Condition to be valid:\n             - 0 <= A,B,C,N <= ma\n             - 1 <= N <= ma (since we need at least 1 for a valid scenario)\n             - C <= A and C <= B (implies A>=C, B>=C => S=A-C >=0, V=B-C >=0)\n             - w = N - ( (A-C) + (B-C) + C ) = N - (A + B - C) > 0  => A + B - C < N\n        */\n\n        // We will try to find any random triple A,B,C that satisfies these constraints with random N.\n        // We'll allow up to 1000 attempts to find a valid triple within range.\n        bool done = false;\n        for (int tries = 0; tries < 1000 && !done; tries++) {\n            N = rnd.next(1, ma);        // ensure at least 1\n            C = rnd.next(0, N);         // candidate\n            A = rnd.next(C, N);         // ensure A >= C, but not necessarily up to ma\n            B = rnd.next(C, N);         // ensure B >= C\n            // check if A+B -C < N\n            if (A + B - C < N) {\n                done = true;\n            }\n        }\n        // If we couldn't find one, just fix a known valid set\n        if (!done) {\n            A = 1; B = 1; C = 0; N = 3; \n        }\n    }\n    else if (type == \"invalid\") {\n        /*\n           Generate random quadruple that is guaranteed invalid.\n\n           Among the ways to be invalid:\n             1) S < 0 => i.e. C > A\n             2) V < 0 => i.e. C > B\n             3) w <= 0 => meaning N - (A+B - C) <= 0 => A+B - C >= N\n             4) w > N => meaning N - (A+B - C) > N => A+B - C < 0 => A+B < C\n             5) N < 1 => i.e. N=0 or negative, but negative can't happen by constraint. So N=0 might be invalid since we need at least 1 at home (Vasya).\n        */\n        // We'll select a random reason among them and produce an input that triggers it.\n        int reason = rnd.next(1, 6); // from 1 to 5, possibly 6 for variety\n        switch (reason) {\n            case 1: {\n                // C > A\n                N = rnd.next(1, ma);  // random\n                A = rnd.next(0, ma/2);\n                C = rnd.next(A+1, ma);   // ensure C > A\n                B = rnd.next(0, ma);\n            } break;\n            case 2: {\n                // C > B\n                N = rnd.next(1, ma);\n                B = rnd.next(0, ma/2);\n                C = rnd.next(B+1, ma);\n                A = rnd.next(0, ma);\n            } break;\n            case 3: {\n                // w <= 0 => A + B - C >= N\n                N = rnd.next(1, ma);\n                // We want random A, B, C, but with A+B -C >= N\n                // We'll pick random N, random X in [N..2*N] => X = A+B -C => then build A,B,C from that.\n                int X = rnd.next(N, min(2*ma, 2*N));\n                // We'll pick random C in [0..ma], then pick random A,B that sum to X + C.\n                C = rnd.next(0, ma);\n                int sumAB = X + C; \n                // pick A in [0..sumAB], B = sumAB - A\n                A = rnd.next(0, sumAB);\n                B = sumAB - A;\n                // clamp if it got > ma, but let's not complicate. We'll not fix them => possibly we exceed the bounds.\n                if (A>ma || B>ma) {\n                    // fallback if out-of-bounds\n                    A = N; B = N; C = 0; // => w= N - (2N -0) = -N => invalid\n                }\n            } break;\n            case 4: {\n                // w > N => A + B < C\n                // We'll pick random A, B, C in [0..ma] but ensure A+B < C.\n                // Then pick random N in [1..ma].\n                N = rnd.next(1, ma);\n                A = rnd.next(0, ma/2);\n                B = rnd.next(0, ma/2);\n                C = A + B + rnd.next(1, ma/2 + 1);  // ensure C > A+B\n                if (C > ma) C = ma; // clamp, might still keep A+B < C\n                if (A + B >= C) {\n                    // fallback\n                    A = 1; B = 1; C = 3; N = 1; // w= 1-(1+1-3)= 1-( -1 )=2>1 => invalid\n                }\n            } break;\n            case 5: {\n                // N=0\n                // This is automatically invalid because we can't have at least one at home if N=0\n                A = rnd.next(0, ma);\n                B = rnd.next(0, ma);\n                C = min(A, B); // just pick something\n                N = 0;\n            } break;\n            default: {\n                // fallback\n                A = 2; B = 2; C = 0; N = 4; // from sample #2 => invalid\n            } break;\n        }\n    }\n    else {\n        /*\n            type == \"random\"\n            We simply pick random values for A,B,C,N within [0..ma].\n            They might be valid or invalid. This is a purely random set,\n            to cover a wide range of possibilities.\n        */\n        A = rnd.next(0, ma);\n        B = rnd.next(0, ma);\n        C = rnd.next(0, ma);\n        N = rnd.next(0, ma);\n    }\n\n    // Print the single test line with four integers: A B C N\n    printf(\"%d %d %d %d\\n\", A, B, C, N);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Generator for the following problem:\n\n    We have four integers: A, B, C, N (0 ≤ A, B, C, N ≤ 100).\n\n    Interpretation:\n    - A = number of students who visited BugDonalds\n    - B = number of students who visited BeaverKing\n    - C = number of students who visited both restaurants\n    - N = total number of students in the group\n\n    We want to produce test inputs (A, B, C, N) such that they can be:\n    1) valid (the problem solution should output a positive integer != -1),\n    2) invalid (the problem solution should output -1),\n    3) corner / special examples, e.g. from the problem statement.\n\n    Command-line parameters (all optional):\n    - \"type\" in { \"random\", \"valid\", \"invalid\", \"corner\" }\n        default = \"random\"\n        Decides how we generate the single test case.\n    - \"ma\" (maximum possible value for A, B, C, N)\n        default = 100\n        We will generate values in [0..ma].\n    - \"special\" (integer selector for corner cases)\n        default = 0\n        Used only when type == \"corner\" to output specific examples from the statement or any special set.\n\n    NOTE: The generator always prints exactly ONE line containing:\n         A B C N\n    Then you may run the generator multiple times with different command-line parameters\n    to obtain multiple test files.\n\n    We do NOT set any random seed in code, and we do NOT accept any seed parameter.\n    The testlib 'rnd' is automatically seeded each run differently.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line parameters.\n    string type = opt<string>(\"type\", \"random\");  // \"random\", \"valid\", \"invalid\", \"corner\"\n    int ma = opt<int>(\"ma\", 100);                 // maximum range for A,B,C,N\n    int special = opt<int>(\"special\", 0);         // used only for corner cases\n\n    int A, B, C, N;\n    A = B = C = N = 0;\n\n    if (type == \"corner\") {\n        /*\n            Produce specific corner/special test cases. We'll handle a few\n            interesting examples from the problem statement or borderline values.\n\n            special = 1 => 0 0 0 0     (expected invalid, w= - ???)\n            special = 2 => 0 0 0 1     (expected valid, solution => 1)\n            special = 3 => 2 2 0 4     (from the statement sample #2 => -1)\n            special = 4 => 2 2 2 1     (from the statement sample #3 => -1)\n            special = 5 => 10 10 5 20  (from the statement sample #1 => valid => 5)\n            anything else => produce a consistent corner we define ourselves\n        */\n        switch (special) {\n            case 1: A = 0; B = 0; C = 0; N = 0; break; \n            case 2: A = 0; B = 0; C = 0; N = 1; break; \n            case 3: A = 2; B = 2; C = 0; N = 4; break; \n            case 4: A = 2; B = 2; C = 2; N = 1; break; \n            case 5: A = 10; B = 10; C = 5; N = 20; break; \n            default:\n                // Another corner: A=0, B=100, C=0, N=100 \n                // ( means 100 visited only BeaverKing, 0 visited BD, 0 visited both => w= ??? )\n                A = 0; B = 100; C = 0; N = 100; \n                break;\n        }\n    }\n    else if (type == \"valid\") {\n        /*\n           Generate random, guaranteed-valid quadruple (A,B,C,N).\n\n           Condition to be valid:\n             - 0 <= A,B,C,N <= ma\n             - 1 <= N <= ma (since we need at least 1 for a valid scenario)\n             - C <= A and C <= B (implies A>=C, B>=C => S=A-C >=0, V=B-C >=0)\n             - w = N - ( (A-C) + (B-C) + C ) = N - (A + B - C) > 0  => A + B - C < N\n        */\n\n        // We will try to find any random triple A,B,C that satisfies these constraints with random N.\n        // We'll allow up to 1000 attempts to find a valid triple within range.\n        bool done = false;\n        for (int tries = 0; tries < 1000 && !done; tries++) {\n            N = rnd.next(1, ma);        // ensure at least 1\n            C = rnd.next(0, N);         // candidate\n            A = rnd.next(C, N);         // ensure A >= C, but not necessarily up to ma\n            B = rnd.next(C, N);         // ensure B >= C\n            // check if A+B -C < N\n            if (A + B - C < N) {\n                done = true;\n            }\n        }\n        // If we couldn't find one, just fix a known valid set\n        if (!done) {\n            A = 1; B = 1; C = 0; N = 3; \n        }\n    }\n    else if (type == \"invalid\") {\n        /*\n           Generate random quadruple that is guaranteed invalid.\n\n           Among the ways to be invalid:\n             1) S < 0 => i.e. C > A\n             2) V < 0 => i.e. C > B\n             3) w <= 0 => meaning N - (A+B - C) <= 0 => A+B - C >= N\n             4) w > N => meaning N - (A+B - C) > N => A+B - C < 0 => A+B < C\n             5) N < 1 => i.e. N=0 or negative, but negative can't happen by constraint. So N=0 might be invalid since we need at least 1 at home (Vasya).\n        */\n        // We'll select a random reason among them and produce an input that triggers it.\n        int reason = rnd.next(1, 6); // from 1 to 5, possibly 6 for variety\n        switch (reason) {\n            case 1: {\n                // C > A\n                N = rnd.next(1, ma);  // random\n                A = rnd.next(0, ma/2);\n                C = rnd.next(A+1, ma);   // ensure C > A\n                B = rnd.next(0, ma);\n            } break;\n            case 2: {\n                // C > B\n                N = rnd.next(1, ma);\n                B = rnd.next(0, ma/2);\n                C = rnd.next(B+1, ma);\n                A = rnd.next(0, ma);\n            } break;\n            case 3: {\n                // w <= 0 => A + B - C >= N\n                N = rnd.next(1, ma);\n                // We want random A, B, C, but with A+B -C >= N\n                // We'll pick random N, random X in [N..2*N] => X = A+B -C => then build A,B,C from that.\n                int X = rnd.next(N, min(2*ma, 2*N));\n                // We'll pick random C in [0..ma], then pick random A,B that sum to X + C.\n                C = rnd.next(0, ma);\n                int sumAB = X + C; \n                // pick A in [0..sumAB], B = sumAB - A\n                A = rnd.next(0, sumAB);\n                B = sumAB - A;\n                // clamp if it got > ma, but let's not complicate. We'll not fix them => possibly we exceed the bounds.\n                if (A>ma || B>ma) {\n                    // fallback if out-of-bounds\n                    A = N; B = N; C = 0; // => w= N - (2N -0) = -N => invalid\n                }\n            } break;\n            case 4: {\n                // w > N => A + B < C\n                // We'll pick random A, B, C in [0..ma] but ensure A+B < C.\n                // Then pick random N in [1..ma].\n                N = rnd.next(1, ma);\n                A = rnd.next(0, ma/2);\n                B = rnd.next(0, ma/2);\n                C = A + B + rnd.next(1, ma/2 + 1);  // ensure C > A+B\n                if (C > ma) C = ma; // clamp, might still keep A+B < C\n                if (A + B >= C) {\n                    // fallback\n                    A = 1; B = 1; C = 3; N = 1; // w= 1-(1+1-3)= 1-( -1 )=2>1 => invalid\n                }\n            } break;\n            case 5: {\n                // N=0\n                // This is automatically invalid because we can't have at least one at home if N=0\n                A = rnd.next(0, ma);\n                B = rnd.next(0, ma);\n                C = min(A, B); // just pick something\n                N = 0;\n            } break;\n            default: {\n                // fallback\n                A = 2; B = 2; C = 0; N = 4; // from sample #2 => invalid\n            } break;\n        }\n    }\n    else {\n        /*\n            type == \"random\"\n            We simply pick random values for A,B,C,N within [0..ma].\n            They might be valid or invalid. This is a purely random set,\n            to cover a wide range of possibilities.\n        */\n        A = rnd.next(0, ma);\n        B = rnd.next(0, ma);\n        C = rnd.next(0, ma);\n        N = rnd.next(0, ma);\n    }\n\n    // Print the single test line with four integers: A B C N\n    printf(\"%d %d %d %d\\n\", A, B, C, N);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are twenty distinct commands that each produce ONE test case.\n# You can run them (in any order) to generate a variety of inputs.\n\n# 1) Pure random in default range [0..100]\n./gen\n\n# 2) Another random in default range\n./gen -type random\n\n# 3) Another random in default range\n./gen -type random\n\n# 4) Random but smaller maximum (ma=10)\n./gen -type random -ma 10\n\n# 5) Random but larger maximum (ma=100) - same as default, but explicitly set\n./gen -type random -ma 100\n\n# 6) Guarantee a valid test (small max = 10)\n./gen -type valid -ma 10\n\n# 7) Guarantee a valid test (medium max = 50)\n./gen -type valid -ma 50\n\n# 8) Guarantee a valid test (largest max = 100)\n./gen -type valid -ma 100\n\n# 9) Guarantee invalid test (default max=100)\n./gen -type invalid\n\n# 10) Guarantee invalid test (small max=10)\n./gen -type invalid -ma 10\n\n# 11) Guarantee invalid test (max=100)\n./gen -type invalid -ma 100\n\n# 12) Corner case #1 => 0 0 0 0 => invalid\n./gen -type corner -special 1\n\n# 13) Corner case #2 => 0 0 0 1 => valid => result 1\n./gen -type corner -special 2\n\n# 14) Corner case #3 => 2 2 0 4 => example #2 => -1\n./gen -type corner -special 3\n\n# 15) Corner case #4 => 2 2 2 1 => example #3 => -1\n./gen -type corner -special 4\n\n# 16) Corner case #5 => 10 10 5 20 => example #1 => valid => 5\n./gen -type corner -special 5\n\n# 17) Another corner fallback => 0 100 0 100\n./gen -type corner -special 999\n\n# 18) More random\n./gen -type random\n\n# 19) Another valid (distinct)\n./gen -type valid\n\n# 20) Another invalid (distinct)\n./gen -type invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:53.561789",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "991/B",
      "title": "B. Отлично!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится единственное число nn — количество оценок Васи (1≤n≤1001≤n≤100). Во второй строке заданы nn натуральных чисел от 22 до 55 — оценки Васи за лабораторные работы.",
      "output_spec": "Выходные данныеВыведите единственное число — минимальное количество оценок, которое придется исправить Васе. Можно показать, что всегда можно исправить достаточное количество оценок, чтобы получить 55.",
      "sample_tests": "ПримерыВходные данныеСкопировать34 4 4Выходные данныеСкопировать2Входные данныеСкопировать45 4 5 5Выходные данныеСкопировать0Входные данныеСкопировать45 3 3 5Выходные данныеСкопировать1",
      "description": "B. Отлично!\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится единственное число nn — количество оценок Васи (1≤n≤1001≤n≤100). Во второй строке заданы nn натуральных чисел от 22 до 55 — оценки Васи за лабораторные работы.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — минимальное количество оценок, которое придется исправить Васе. Можно показать, что всегда можно исправить достаточное количество оценок, чтобы получить 55.\n\nВыходные данные\n\nВходные данныеСкопировать34 4 4Выходные данныеСкопировать2Входные данныеСкопировать45 4 5 5Выходные данныеСкопировать0Входные данныеСкопировать45 3 3 5Выходные данныеСкопировать1\n\nВходные данныеСкопировать34 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать45 4 5 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать45 3 3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Васе достаточно исправить две оценки 44 на 55.Во втором примере у Васи уже выходит 55 (среднее арифметическое 4.754.75), исправлять ничего не нужно.В третьем примере Васе нужно исправить одну из оценок 33, тогда среднее арифметическое будет ровно 4.54.5 и за семестр Вася получит 55.",
      "solutions": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces",
          "content": "Привет!В субботу 23 июня в 18:35 (Московское время) начнется Codeforces Round #491 (Div.2). Раунд будет рейтинговым для участников с рейтингом менее 2100, остальные участники могут решать задачи вне конкурса.Раунд во многом пересекается с задачами олимпиады по программированию ННГУ 2018 года. Если вы принимали участие в олимпиаде или дорешивали задачи, просьба не участвовать в раунде.В задачах раунда вам нужно будет помочь студенту Васе справиться с трудностями, вызванными окончанием учебного года. Всего будет предложено 6 задач и 2 часа на их решение. Если же вы решите все задачи за 25 минут, то успеете посмотреть второй тайм матча Южная Корея — Мексика на чемпионате мира FIFA.Разбалловка немного нестандартная: 500-1000-1250-1500-2000-2750Выражаю максимальную благодарность Михаилу MikeMirzayanov Мирзаянову за всем известные платформы; Николаю KAN Калинину — за помощь в подготовке задач и координацию раунда; Михаилу mike_live Кривоносову, Алексею Livace Илюхову, Никите FalseMirror Босову, Андрею GreenGrape Райскому и Алексею Aleks5d Упирвицкому — за тестирование задач; Арсению arsor Сорокину — за перевод условий. А всем участникам желаю удачи на раунде!UPD: Раунд завершен, всем спасибо за участие!UPD: Поздравляем победителей!Div. 1: nuip krijgertje qoo2p5 hohomu neal Div. 2: King — решил все задачи, отличный результат! Daniar Saidjamol shoemakerjo Toki_Time-Tinker UPD: Опубликован разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1416
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces",
          "content": "991A - Пересдача РазборВсего студенты разбились на 4 группы — те кто посетил только первый ресторан, кто только второй, кто посетил оба ресторана и кто не сдал экзамен. Один из наиболее простых вариантов отсечь все некорректные случаи — посчитать, сколько студентов оказалось в каждой группе. Для первой группы это значение равно A - C, для второй: B - C, для третьей: C, для четвертой: N - A - B + C. Теперь достаточно проверить, что в первых трех группах неотрицательное число студентов, а в последней — положительное. Если это так, то количество студентов в последней группе и есть ответ на задачу. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;В общем случае, рекомендуется ознакомиться с методом включений-исключений.Кроме того, ограничения в задаче позволяют перебрать значения количества студентов в каждой группе (кроме третьей) за O(N3) и проверить, соответствует ли такое разбиение условию. Если ни одно разбиение не подошло — вывести  - 1: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Решение1Решение2991B - Отлично! РазборВ этой задаче применим жадный алгоритм. Действительно, Васе выгодно сначала исправлять наиболее низкие оценки. Поэтому можно отсортировать полученные оценки в порядке возрастания и начать заменять их на 5, пока не получим желаемый результат. Для проверки результата можно после каждой операции вычислять среднее арифметическое заново (итого, сложность будет O(N2)) или поддерживать текущую сумму оценок, пересчитывая среднее арифметическое за O(1) с общей сложностью O(N), без учета сортировки, например, так: bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}\nРазумеется, оба подхода легко укладываются в ограничение по времени. Кроме того, рекомендуется избежать вычисление среднего арифметического значения с использованием вещественных чисел.Решение991C - Эклеры РазборНесложно проверить, что для некоторого k условие выполняется (Вася съест не менее половины эклеров), то и для любого большего k это условие выполнится. ДоказательствоДействительно, рассмотрим количество эклеров, которое останется вечером каждого дня при некотором выбранном k1 — пусть в день i останется ai эклеров. Если мы возьмем для Васи другое число k2 > k1, то в первый вечер останется меньше эклеров: b1 < a1. Но тогда Петя вечером съест эклеров не больше, чем в первом случае, однако на следующий день их будет все равно не больше, чем в первом случае (если n1 > n2, то n1 - n1 / 10 ≥ n2 - n2 / 10). Аналогично с учетом k2 > k1 и к вечеру второго дня b2 < a2 и так далее. Таким образом, для любого i получаем bi < ai, а значит и Петя каждый день будет есть не больше эклеров, чем в первом случае. Значит, Петя в сумме съест не больше эклеров, чем в первом случае, а Вася — не меньше.Значит, эту задачу можно решать при помощи бинарного поиска по ответу. Для проверки конкретного выбранного k можно использовать простую симуляцию процесса, описанного в условии. bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}Поскольку Петя съедает 10% от количества оставшихся эклеров, то это количество убывает экспоненциально, значит, пройдет достаточно мало дней прежде чем будут съедены все эклеры. В худшем случае ребятам потребуется 378 дней. Формально же асимптотика этого решения есть O(log(n)2).Как и в предыдущей задаче рекомендуется избежать работы с вещественными числами и все вычисления производить в целых типах.Решение991D - Слонопотамы РазборВ этой задаче применим следующий жадный алгоритм. Будем идти по столбцам слева-направо, если мы сейчас рассматриваем столбец i и мы можем поставить фигуру, занимающую клетки столбцов i и i + 1, то нужно ее поставить. Действительно, если в оптимальном решении столбец i не занят ни одной фигурой, то в столбце i + 1 клетки заняты максимум одним слонопотамом. Значит, его можно убрать и поставить в столбцы i и i + 1, от этого ответ станет не хуже. Немного более сложный вопрос — как именно поставить фигуру, если все 4 клетки столбцов i и i + 1 свободны (в других случаях фигуру можно поставить только одним способом)? Разумеется, в столбце i выгодно занять обе клетки. Оказывается, при этом неважно, какую именно клетку столбца i + 1 займет слонопотам. Действительно, клетки столбца i + 1 могут пригодиться только при размещении фигуры в столбцах i + 1,i + 2. Если в столбце i + 2 свободно не более одной клетки, то разместить фигуру не получится и клетки столбца i + 1 ни на что не влияют. Если же в столбце i + 2 свободны обе клетки, то мы можем разместить слонопотама при любом выборе занятой клетки столбца i + 1.Из этого следует, что нам вообще можно не расставлять фигуры, а лишь пересчитывать количество свободных клеток в столбцах. В соответствии с описанным алгоритмом, получаем такой код: \t... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}Более того, эту реализацию можно заметно упростить, сведя решение всего к двум случаям: \tint ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}Формально данную реализацию можно отнести к динамическому программированию. Разумеется, ее можно написать и не обладая глубокими знаниями этого метода.Кроме того, задачу можно решать более ''явной'' динамикой (например в качестве состояния использовать номер текущего столбца и состояние предыдущего). В этом случае реализация будет чуть более сложной, но не будет необходимости доказывать описанные выше утверждения.Решение1Решение2991E - Номер автобуса РазборИз условия следует, что цифры оригинального номера автобуса представляют собой некоторое подмножество цифр номера, увиденного Васей. Перебрать подмножество цифр можно стандартным алгоритмом за 2k операций (где k — длина числа n). При этом каждое подмножество нужно проверить на корректность (содержит ли оно все нужные цифры) и привести к ''каноническому'' виду (например, отсортировать), чтобы избежать повторений с подмножествами, отличающимися лишь порядком цифр. Среди корректных наборов нужно оставить только уникальные. \tlong long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}Теперь для выбранного набора цифр нужно посчитать количество вариантов номера автобуса. Это можно сделать за O(k), использовав стандартную формулу числа перестановок мультимножества (см. секцию ''Permutations of multisets'' в статье про перестановки и мультиномиальные коэффициенты)C = k! / (c0! * c1! * ... * c9!), где k — общее количество цифр в наборе, а ci — количество цифр i в наборе: long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}Из этого числа нужно вычесть количество номеров, начинающихся на 0, если 0 присутствует в наборе. Сделать это достаточно просто: если мы поставим на первое место 0, то достаточно уменьшить k на 1 и c0 на 1, после чего применить формулу выше — она посчитает количество способов разместить остальные цифры набора. long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}Итого, даже при грубой оценке сложности и простой реализации получаем асимптотику O(2k * k), где k ≤ 19 — количество цифр числа n. Легко проверить, что ответ всегда не превосходит 1018, поэтому для его вычисления достаточно ограничиться стандартным 64-битовым типом.Решение991F - Отобразить число РазборВсе числа в задаче (кроме числа 1010, которое дано в примере) содержат максимум 10 цифр. Значит, если мы хотим найти более короткое представление, оно должно содержать максимум 9 цифр. Заметим, что длина суммы двух чисел не превосходит суммы длин чисел, поэтому в оптимальном представлении максимум одно слагаемое является числом, а остальные слагаемые — выражения содержащие * или ^. Каждое выражение имеет длину хотя бы 3 символа, значит, в представлении может быть максимум 3 слагаемых. Максимальное число, которое можно представить 3 слагаемыми: 9^9+9^9+9, но это число содержит лишь 9 знаков, а выражения с 3 слагаемыми всегда содержит минимум 9 знаков. Значит, всегда существует оптимальное представление, содержащее максимум два слагаемых.Тогда существует 3 варианта, как можно представить исходное число: n = a^b n = x+y n = x*y где x и y — выражения (в первом случае a и b — числа), не содержащие знаков +. Причем, во всех случаях эти выражения содержат максимум 7 символов.Давайте найдем для каждого x, не превосходящего n, эквивалентное выражение m[x], содержащие не более 7 символов (если оно короче, чем само число), а так же для каждой длины d — список чисел s[d], которые можно представить выражением длины d. Для этого удобно использовать, например, стандартные контейнеры map и set в C++: map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}Сначала добавим все возможные выражения вида a^b — их будет порядка sqrt(n). void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}Теперь рассмотрим выражения, состоящие из нескольких множителей. Заметим, что аналогично со сложением, в выражении максимум один множитель является числом. Тогда выражение может иметь только вид: x = a^b*c^d x = a^b*c где a, b, c и d — некоторые числа. Давайте переберем длину i первого множителя и пройдем по всем значениям контейнера s[i]. Тогда второй множитель может иметь длину максимум d = 7 - i - 1 и вариантов выбрать этот множитель будет достаточно мало. Второй множитель можно перебрать, пройдя по контейнерам длины до d в первом случае, либо перебрать числа от 1 до 10d во втором случае. Всего при этом мы добавим в m порядка k = 150000 чисел: void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}Теперь вернемся к представлению исходного числа. Для случая a^b мы уже добавили выражения в m. Для случаев x+y и x*y заметим, что можно считать, что длина выражения x не больше 4. Давайте переберем x среди найденных выражений длины до 4, а так же среди чисел от 1 до 104. Для каждого x и для каждого из двух вариантов мы однозначно определяем значение y, оптимальное представление которого уже записано в m или просто равняется числу. Таким образом, для каждого x мы сможем найти оптимальный ответ за два обращения к m, то есть за log(k) операций. string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}Итого, общая сложность алгоритма есть O((sqrt(n) + k + 104) * log(k)).Решение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 991\\s*B"
          },
          "content_length": 13240
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 1",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 2",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 3",
          "code": "unsigned long long a, b;\n    while (n >= 2)\n    {\n        a += 2;\n        n -= 2;\n        b += n / 10;\n        n -= n / 10;\n\n        cout << a << \":\" << b << \"\\n\";\n    }\n    a += n;\n    \n    cout << a << \":\" << b << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 4",
          "code": "unsigned long long a, b;\n    while (n >= 2)\n    {\n        a += 2;\n        n -= 2;\n        b += n / 10;\n        n -= n / 10;\n\n        cout << a << \":\" << b << \"\\n\";\n    }\n    a += n;\n    \n    cout << a << \":\" << b << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 5",
          "code": "~~~~~\nvar\n    n, vasya, petya: longint;\n\nbegin\n    n :=68;\n    while (n > 1) do\n    begin\n        vasya := vasya + 2;\n        n := n - 2;\n        petya :=petya +  n div 10; \n        n:=n - n div 10;\n    end;\n    \n    vasya := vasya + n;\n    writeln('Vasya ',vasya);\n    writeln('Petya ',petya);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 6",
          "code": "~~~~~\nvar\n    n, vasya, petya: longint;\n\nbegin\n    n :=68;\n    while (n > 1) do\n    begin\n        vasya := vasya + 2;\n        n := n - 2;\n        petya :=petya +  n div 10; \n        n:=n - n div 10;\n    end;\n    \n    vasya := vasya + n;\n    writeln('Vasya ',vasya);\n    writeln('Petya ',petya);\nend.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 7",
          "code": "забывает проверить выход за пределы массива или строки",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 8",
          "code": "for Test case #7:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 9",
          "code": "Input: 999999972",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 10",
          "code": "Jury's answer: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 11",
          "code": "Output: 39259426",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 12",
          "code": "Output: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 13",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 14",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 15",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 16",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 1",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 2",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 3",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 4",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 5",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 6",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 7",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 8",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 9",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 10",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 11",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 12",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 13",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 14",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 15",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 16",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 17",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 18",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 19",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 20",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 21",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 22",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 23",
          "code": "x = a^b*c^d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 24",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 25",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 26",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 27",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 28",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 29",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 30",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), разбор задач - Codeforces - Code 31",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 2, 5, \"grades\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 2, 5, \"grades\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 2, 5, \"grades\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> grades(n);\n\n    if (type == \"max_grades\") {\n        // All grades are 5\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 5;\n        }\n    } else if (type == \"min_grades\") {\n        // All grades are 2\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 2;\n        }\n    } else if (type == \"exact_threshold\") {\n        // The average is exactly 4.5\n        // So the sum of grades is 4.5 * n\n        // Since grades are integers, need to distribute 4s and 5s appropriately\n        int sum_needed = 4 * n + n / 2;\n        int sum = 0;\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 4;\n            sum += 4;\n        }\n        int i = 0;\n        while(sum < sum_needed && i < n) {\n            grades[i] = 5;\n            sum += 1;\n            i++;\n        }\n    } else if (type == \"below_threshold\") {\n        // The average is slightly below 4.5\n        // sum of grades < 4.5 * n\n        int target_sum = int(4.5 * n) - 1;\n        int sum = 5 * n;\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 5;\n        }\n        for(int i = 0; i < n && sum > target_sum; ++i) {\n            grades[i] = 4;\n            sum -= 1;\n        }\n    } else if (type == \"above_threshold\") {\n        // The average is slightly above 4.5\n        // sum of grades > 4.5 * n\n        int target_sum = int(4.5 * n + 0.5) + 1;\n        int sum = 4 * n;\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 4;\n        }\n        for(int i = 0; i < n && sum < target_sum; ++i) {\n            grades[i] = 5;\n            sum += 1;\n        }\n    } else if (type == \"one_low_grade\") {\n        // All grades are 5 except one grade which is 2\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 5;\n        }\n        if(n >= 1) {\n            grades[0] = 2;\n        }\n    } else if (type == \"alternating_grades\") {\n        // Grades alternate between 5 and 2\n        for(int i = 0; i < n; ++i) {\n            grades[i] = (i % 2 == 0) ? 5 : 2;\n        }\n    } else if (type == \"random\") {\n        // Random grades between 2 and 5\n        for(int i = 0; i < n; ++i) {\n            grades[i] = rnd.next(2, 5);\n        }\n    } else if (type == \"worst_case\") {\n        // All grades are 2\n        // Vasya needs to redo all labs\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 2;\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", grades[i]);\n        if(i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> grades(n);\n\n    if (type == \"max_grades\") {\n        // All grades are 5\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 5;\n        }\n    } else if (type == \"min_grades\") {\n        // All grades are 2\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 2;\n        }\n    } else if (type == \"exact_threshold\") {\n        // The average is exactly 4.5\n        // So the sum of grades is 4.5 * n\n        // Since grades are integers, need to distribute 4s and 5s appropriately\n        int sum_needed = 4 * n + n / 2;\n        int sum = 0;\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 4;\n            sum += 4;\n        }\n        int i = 0;\n        while(sum < sum_needed && i < n) {\n            grades[i] = 5;\n            sum += 1;\n            i++;\n        }\n    } else if (type == \"below_threshold\") {\n        // The average is slightly below 4.5\n        // sum of grades < 4.5 * n\n        int target_sum = int(4.5 * n) - 1;\n        int sum = 5 * n;\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 5;\n        }\n        for(int i = 0; i < n && sum > target_sum; ++i) {\n            grades[i] = 4;\n            sum -= 1;\n        }\n    } else if (type == \"above_threshold\") {\n        // The average is slightly above 4.5\n        // sum of grades > 4.5 * n\n        int target_sum = int(4.5 * n + 0.5) + 1;\n        int sum = 4 * n;\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 4;\n        }\n        for(int i = 0; i < n && sum < target_sum; ++i) {\n            grades[i] = 5;\n            sum += 1;\n        }\n    } else if (type == \"one_low_grade\") {\n        // All grades are 5 except one grade which is 2\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 5;\n        }\n        if(n >= 1) {\n            grades[0] = 2;\n        }\n    } else if (type == \"alternating_grades\") {\n        // Grades alternate between 5 and 2\n        for(int i = 0; i < n; ++i) {\n            grades[i] = (i % 2 == 0) ? 5 : 2;\n        }\n    } else if (type == \"random\") {\n        // Random grades between 2 and 5\n        for(int i = 0; i < n; ++i) {\n            grades[i] = rnd.next(2, 5);\n        }\n    } else if (type == \"worst_case\") {\n        // All grades are 2\n        // Vasya needs to redo all labs\n        for(int i = 0; i < n; ++i) {\n            grades[i] = 2;\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", grades[i]);\n        if(i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type max_grades\n./gen -n 1 -type min_grades\n./gen -n 1 -type exact_threshold\n./gen -n 1 -type below_threshold\n./gen -n 1 -type above_threshold\n./gen -n 1 -type one_low_grade\n./gen -n 1 -type alternating_grades\n./gen -n 1 -type random\n./gen -n 1 -type worst_case\n\n./gen -n 10 -type max_grades\n./gen -n 10 -type min_grades\n./gen -n 10 -type exact_threshold\n./gen -n 10 -type below_threshold\n./gen -n 10 -type above_threshold\n./gen -n 10 -type one_low_grade\n./gen -n 10 -type alternating_grades\n./gen -n 10 -type random\n./gen -n 10 -type worst_case\n\n./gen -n 50 -type max_grades\n./gen -n 50 -type min_grades\n./gen -n 50 -type exact_threshold\n./gen -n 50 -type below_threshold\n./gen -n 50 -type above_threshold\n./gen -n 50 -type one_low_grade\n./gen -n 50 -type alternating_grades\n./gen -n 50 -type random\n./gen -n 50 -type worst_case\n\n./gen -n 100 -type max_grades\n./gen -n 100 -type min_grades\n./gen -n 100 -type exact_threshold\n./gen -n 100 -type below_threshold\n./gen -n 100 -type above_threshold\n./gen -n 100 -type one_low_grade\n./gen -n 100 -type alternating_grades\n./gen -n 100 -type random\n./gen -n 100 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:55.550383",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "991/C",
      "title": "C. Candies",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (1≤n≤10181≤n≤1018) — the initial amount of candies in the box.",
      "output_spec": "OutputOutput a single integer — the minimal amount of kk that would allow Vasya to eat at least half of candies he got.",
      "sample_tests": "ExampleInputCopy68OutputCopy3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (1≤n≤10181≤n≤1018) — the initial amount of candies in the box.\n\nOutputOutput a single integer — the minimal amount of kk that would allow Vasya to eat at least half of candies he got.\n\nInputCopy68OutputCopy3\n\nInputCopy68\n\nOutputCopy3\n\nNoteIn the sample, the amount of candies, with k=3k=3, would change in the following way (Vasya eats first):68→65→59→56→51→48→44→41→37→34→31→28→26→23→21→18→17→14→13→10→9→6→6→3→3→068→65→59→56→51→48→44→41→37→34→31→28→26→23→21→18→17→14→13→10→9→6→6→3→3→0.In total, Vasya would eat 3939 candies, while Petya — 2929.",
      "solutions": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces",
          "content": "Hello!Codeforces Round #491 (Div.2) will start this Saturday, June 23, 18:35 (UTC+3). This round will be rated for the participants with rating lower than 2100 and other contestants can join it out of competition.This round problems have a significant intersection with NNSU Programming Contest 2018. Please do not participate in the round if you participated in the NNSU contest or tried to upsolve the problems.During the round you have to help student Vasya to manage the difficulties caused by the end of the academic year. There will be 6 problems and 2 hours to solve them. If you solve all the problems in 25 minutes you will be able to watch the second half of South Korea — Mexico at the FIFA World Cup.The scoring is unusual a bit: 500-1000-1250-1500-2000-2750Great thanks to Mikhail MikeMirzayanov Mirzayanov for the well-known platforms; Nikolay KAN Kalinin — for the help with problems and the round coordination; Mikhail mike_live Krivonosov, Alexey Livace Ilyukhov, Nikita FalseMirror Bosov, Andrew GreenGrape Rayskiy and Alexey Aleks5d Upirvitskiy — for the round testing; Arseniy arsor Sorokin — for the statements translation. And good luck to all contestants!UPD: The round is over, thank you for the participation!UPD: Congratulations to the winners!Div. 1: nuip krijgertje qoo2p5 hohomu neal Div. 2: King — solved all the problems, well done! Daniar Saidjamol shoemakerjo Toki_Time-Tinker UPD: The editorial is published",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1441
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces",
          "content": "991A - If at first you don't succeed... EditorialThere are 4 groups of students — those who visited only the first restaurant, who visited only the second, who visited both places and who stayed at home. One of the easiest ways to detect all the incorrect situations is to calculate number of students in each group. For the first group it is A - C, for the second: B - C, for the third: C and for the fourth: N - A - B + C. Now we must just to check that there are non-negative numbers in the first three groups and the positive number for the last group. If such conditions are met the answer is the number of students in the fourth group. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;In general you are recommended to view inclusion–exclusion principle.Moreover the limitations allow to go over all possible numbers of students for each group (except for the third) in O(N3) and to check whether such numbers produce a correct solution. If no correct numbers found, just print  - 1: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Solution1Solution2991B - Getting an A EditorialIt is necessary to use the greedy approach: of course Vasya should redo the lowest grades firstly. So we have to sort the values in the ascending order and begin to replace the values by 5 until we get the desired result. In order to check whether the current state is suitable we may calculate the mean value after each iteration (O(N2) complexity in total), or just update sum of the grades and calculate the arithmetic mean in O(1) with O(N) total complexity (excluding sorting). For example: bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}\nOf course, both approaches easily fit TL.Finally, it is recommended to avoid floating-point operations while calculating the mean value.Solution991C - Candies EditorialIt is easy to check that if for some value k the necessary condition is met (Vasya eats at least half of the candies), then it is met for each integer greater k. ProofLet's consider the number of candies remaining at the evening of each day for some selected k1 — let ai candies remain at day i. If Vasya will use another number k2 > k1 we will have less candies in the first day: b1 < a1. So Petya will eat no more candies than in the first case (for k1), but in the next day the number of candies will be not greater than in the first case (if n1 > n2 then n1 - n1 / 10 ≥ n2 - n2 / 10). The same way, including that k2 > k1 at the evening of the second day we get b2 < a2 and so on. In general, for each i we have bi < ai, so Petya will eat not more candies than in the first case in total. It means that Vasya will eat not less candies than in the first case.So this problem can be solved using the binary search (answer) approach. In order to check whether selected k is applicable it necessary just to implement the process described in the problem statement. bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}Since Petya eats 10% of candies, its amount decreases exponentially, so there will be only few days before all the candies will be eaten. In the worst case it is necessary 378 days. Formally the complexity of the solution is O(log(n)2).Like in the previous problem it is recommended to avoid floating operations and to use only integer types.Solution991D - Bishwock EditorialIn this problem we may use the greedy approach. Let's go through columns from left to right. If we are currently considering column i and we may place a figure occupying only cells at columns i and i + 1, we have to place this figure. Really if the optimal solution doesn't contain a bishwock at column i then column i + 1 may be occupied by at most one bishwock. So we can remove this figure and place it at columns i and i + 1, the result will be at least the same. A bit harder question is — how exactly we should place the figure if all 4 cells of columns i and i + 1 are empty (in other cases there will be only one way to place a bishwock)? Of course, we should occupy both cells of column i. Moreover it does not matter which cell we will occupy at column i + 1 in this case. The cells of i + 1 may be used only for placing a bishwock in columns i + 1,i + 2. If column i + 2 has at most one empty cell we are unable to place such figure and the remaining empty cells of column i + 1 are useless at all. If both cells of column i + 2 are empty we may place a bishwock regardless of the position of the remaining empty cell at column i + 1.It means that we don't have to place the figures actually — we have to calculate and update number of empty cells in columns. According to the described algorithm we may write such code: \t... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}Moreover this implementation can be simplified to just two cases: \tint ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}Formally such algorithm may be considered as the dynamic programming. Of course it is not necessary to have a deep understanding of DP to write such implementation and solve the problem.This problem also can be solved by more ''obvious'' DP approach (for example we may consider index of current column and state of the cells of the previous column as a state of DP). In this case the implementation will be a bit more complicated but it won't be necessary to prove described solution.Solution1Solution2991E - Bus Number EditorialAccording to the statement, digits of original bus number form a subset of digits of the number seen by Vasya. It is possible to iterate through all the subsets in 2k operations (where k is length of n). For each subset we need to check whether it is correct (contains all necessary digits) and transform it to ''normal'' state (sort the digits for example), in order to avoid conflicts with another subsets which differ only at the digits order. We have to keep only unique subsets. \tlong long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}Now for each subset of digits we have to calculate amount of corresponding correct bus numbers. It can be calculated in O(k) operations using permutations of multisets formula (see ''Permutations of multisets'' at the article about permutations and multinomial coefficients)C = k! / (c0! * c1! * ... * c9!), where k — total number of digits in the subset and ci — number of digits i: long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}Now, we have to subtract amount of bus numbers with leading zeroes from the result for this subset if it contains digit 0. This can be done in the very same way: if we place digit 0 at the first position of the number, we have to decrease k by 1 and decrease c0 by 1; the formula described above will calculate amount of ways to place remaining digits of the subset and this number should be subtract from the answer: long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}In total, even with such rough evaluation of complexity and naive implementation we get O(2k * k) operations, where k ≤ 19 — amount of digits in n. It is easy to check that the answer doesn't exceed 1018 so the standard 64-bit integer type will be enough.Solution991F - Concise and clear EditorialAll the problem numbers (except for 1010, which is given in the samples) contain at most 10 digits. It means that we have to use at most 9 digits if we want to find a shorter representation. Notice that the length of sum of two integers is not greater than sum of the lengths of these integers, so in the optimal representation at most one term is a number while other terms are expressions containing * and/or ^. Each expression (not a number) contains at least 3 symbols, so the optimal representation can contain at most 3 terms. The maximal integer that can be represented in such manner is 9^9+9^9+9, but it contains only 9 digits while expressions with 3 terms always contain at least 9 symbols. So we proved that there always exists an optimal representation which is a sum of at most two terms.So there exist only 3 types of representation of the original number: n = a^b n = x+y n = x*y where x and y — some expressions (in the first case a and b are numbers), which doesn't contain +. Moreover in all the cases such expressions should contain at most 7 digits.Let's find for each x ≤ n a shortest valid representation m[x], containing at most 7 symbols (if it exists and contains less digits than simple number x), and for each length d — set of integers s[d] which can be represented by an expression of length d. The standard containers (std::map and std::set в C++) are suitable for that: map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}Firstly let's add all expressions a^b, there are about sqrt(n) such expressions. void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}Now lets consider the expressions containing several multipliers. The same way (as for addition) in such representation at most one multiplier is a number. Including that the expression can contain at most 7 digits we have only 2 possible ways: x = a^b*c^d x = a^b*c where a, b, c and d are some numbers. Lets iterate through i — the length of the representation of the first multiplier and go over all values stored in s[i]. The second multiplier can have length at most d = 7 - i - 1 and the total number of ways to choose two multipliers will be small enough. The second multiplier should be selected from containers s[j] for length at most d (in the first case), or we should iterate from 1 to 10d (in the second case). After that we will have about k = 150000 numbers in m in total: void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}Now lets go back to the representation of the original number. For the first case — a^b — we have already stored such values in m. For the cases x+y and x*y we may assume that the length of expression of x is not greater than 4. Now lets iterate through x among found representations of length up to 4, and among integers from 1 to 104. For each such x and for each of 2 cases we determine value of y uniquely, and the optimal representation of y is already stored in m or it is just a number. So, for each such x we can find optimal answer for n by at most two addressing to m i.e. in log(k) operations. string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}Finally, the total algorithm complexity is O((sqrt(n) + k + 104) * log(k)).Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 991\\s*C"
          },
          "content_length": 13592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 1",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 2",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 3",
          "code": "for Test case #7:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 4",
          "code": "Input: 999999972",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 5",
          "code": "Jury's answer: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 6",
          "code": "Output: 39259426",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 7",
          "code": "Output: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 8",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 9",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 10",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 11",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 1",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 2",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 3",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 4",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 5",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 6",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 7",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 8",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 9",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 10",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 11",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 12",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 13",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 14",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 15",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 16",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 17",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 18",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 19",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 20",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 21",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 22",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 23",
          "code": "x = a^b*c^d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 24",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 25",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 26",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 27",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 28",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 29",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 30",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 31",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1LL) {\n        // n not specified, generate n according to type\n        if (type == \"min\") {\n            n = 1LL;\n        } else if (type == \"max\") {\n            n = 1000000000000000000LL; // 1e18\n        } else if (type == \"small\") {\n            n = rnd.next(1LL, 10LL);\n        } else if (type == \"medium\") {\n            n = rnd.next(100000LL, 10000000LL);\n        } else if (type == \"large\") {\n            n = rnd.next(100000000000000000LL, 1000000000000000000LL);\n        } else if (type == \"boundary\") {\n            int index = rnd.next(1, 4);\n            if (index == 1) n = 9LL;\n            else if (index == 2) n = 10LL;\n            else if (index == 3) n = 11LL;\n            else if (index == 4) n = 1LL;\n        } else if (type == \"edge\") {\n            // Generate n near powers of 10\n            int power = rnd.next(1, 18);\n            long long base = 1;\n            for (int i = 0; i < power; ++i) base *= 10LL;\n            n = base - rnd.next(0LL, 10LL);\n        } else if (type == \"random\") {\n            n = rnd.next(1LL, 1000000000000000000LL); // 1e18\n        } else {\n            // default random\n            n = rnd.next(1LL, 1000000000000000000LL);\n        }\n    } else {\n        // n specified, just use n\n    }\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", -1LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1LL) {\n        // n not specified, generate n according to type\n        if (type == \"min\") {\n            n = 1LL;\n        } else if (type == \"max\") {\n            n = 1000000000000000000LL; // 1e18\n        } else if (type == \"small\") {\n            n = rnd.next(1LL, 10LL);\n        } else if (type == \"medium\") {\n            n = rnd.next(100000LL, 10000000LL);\n        } else if (type == \"large\") {\n            n = rnd.next(100000000000000000LL, 1000000000000000000LL);\n        } else if (type == \"boundary\") {\n            int index = rnd.next(1, 4);\n            if (index == 1) n = 9LL;\n            else if (index == 2) n = 10LL;\n            else if (index == 3) n = 11LL;\n            else if (index == 4) n = 1LL;\n        } else if (type == \"edge\") {\n            // Generate n near powers of 10\n            int power = rnd.next(1, 18);\n            long long base = 1;\n            for (int i = 0; i < power; ++i) base *= 10LL;\n            n = base - rnd.next(0LL, 10LL);\n        } else if (type == \"random\") {\n            n = rnd.next(1LL, 1000000000000000000LL); // 1e18\n        } else {\n            // default random\n            n = rnd.next(1LL, 1000000000000000000LL);\n        }\n    } else {\n        // n specified, just use n\n    }\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n./gen -type medium\n./gen -type large\n./gen -type large\n./gen -type large\n./gen -type boundary\n./gen -type boundary\n./gen -type boundary\n./gen -type edge\n./gen -type edge\n./gen -type edge\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -n 1\n./gen -n 9\n./gen -n 10\n./gen -n 11\n./gen -n 100\n./gen -n 999999999999999999\n./gen -n 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:57.739057",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "991/D",
      "title": "D. Bishwock",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols \"0\" (zero) that denote the empty squares and symbols \"X\" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed 100100.",
      "output_spec": "OutputOutput a single integer — the maximum amount of bishwocks that can be placed onto the given board.",
      "sample_tests": "ExamplesInputCopy0000OutputCopy1InputCopy00X00X0XXX00XXX0X00X00OutputCopy4InputCopy0X0X00X0X0OutputCopy0InputCopy0XXX000000OutputCopy2",
      "description": "D. Bishwock\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols \"0\" (zero) that denote the empty squares and symbols \"X\" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed 100100.\n\nOutputOutput a single integer — the maximum amount of bishwocks that can be placed onto the given board.\n\nInputCopy0000OutputCopy1InputCopy00X00X0XXX00XXX0X00X00OutputCopy4InputCopy0X0X00X0X0OutputCopy0InputCopy0XXX000000OutputCopy2\n\nInputCopy0000\n\nOutputCopy1\n\nInputCopy00X00X0XXX00XXX0X00X00\n\nOutputCopy4\n\nInputCopy0X0X00X0X0\n\nOutputCopy0\n\nInputCopy0XXX000000\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces",
          "content": "Hello!Codeforces Round #491 (Div.2) will start this Saturday, June 23, 18:35 (UTC+3). This round will be rated for the participants with rating lower than 2100 and other contestants can join it out of competition.This round problems have a significant intersection with NNSU Programming Contest 2018. Please do not participate in the round if you participated in the NNSU contest or tried to upsolve the problems.During the round you have to help student Vasya to manage the difficulties caused by the end of the academic year. There will be 6 problems and 2 hours to solve them. If you solve all the problems in 25 minutes you will be able to watch the second half of South Korea — Mexico at the FIFA World Cup.The scoring is unusual a bit: 500-1000-1250-1500-2000-2750Great thanks to Mikhail MikeMirzayanov Mirzayanov for the well-known platforms; Nikolay KAN Kalinin — for the help with problems and the round coordination; Mikhail mike_live Krivonosov, Alexey Livace Ilyukhov, Nikita FalseMirror Bosov, Andrew GreenGrape Rayskiy and Alexey Aleks5d Upirvitskiy — for the round testing; Arseniy arsor Sorokin — for the statements translation. And good luck to all contestants!UPD: The round is over, thank you for the participation!UPD: Congratulations to the winners!Div. 1: nuip krijgertje qoo2p5 hohomu neal Div. 2: King — solved all the problems, well done! Daniar Saidjamol shoemakerjo Toki_Time-Tinker UPD: The editorial is published",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1441
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces",
          "content": "991A - If at first you don't succeed... EditorialThere are 4 groups of students — those who visited only the first restaurant, who visited only the second, who visited both places and who stayed at home. One of the easiest ways to detect all the incorrect situations is to calculate number of students in each group. For the first group it is A - C, for the second: B - C, for the third: C and for the fourth: N - A - B + C. Now we must just to check that there are non-negative numbers in the first three groups and the positive number for the last group. If such conditions are met the answer is the number of students in the fourth group. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;In general you are recommended to view inclusion–exclusion principle.Moreover the limitations allow to go over all possible numbers of students for each group (except for the third) in O(N3) and to check whether such numbers produce a correct solution. If no correct numbers found, just print  - 1: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Solution1Solution2991B - Getting an A EditorialIt is necessary to use the greedy approach: of course Vasya should redo the lowest grades firstly. So we have to sort the values in the ascending order and begin to replace the values by 5 until we get the desired result. In order to check whether the current state is suitable we may calculate the mean value after each iteration (O(N2) complexity in total), or just update sum of the grades and calculate the arithmetic mean in O(1) with O(N) total complexity (excluding sorting). For example: bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}\nOf course, both approaches easily fit TL.Finally, it is recommended to avoid floating-point operations while calculating the mean value.Solution991C - Candies EditorialIt is easy to check that if for some value k the necessary condition is met (Vasya eats at least half of the candies), then it is met for each integer greater k. ProofLet's consider the number of candies remaining at the evening of each day for some selected k1 — let ai candies remain at day i. If Vasya will use another number k2 > k1 we will have less candies in the first day: b1 < a1. So Petya will eat no more candies than in the first case (for k1), but in the next day the number of candies will be not greater than in the first case (if n1 > n2 then n1 - n1 / 10 ≥ n2 - n2 / 10). The same way, including that k2 > k1 at the evening of the second day we get b2 < a2 and so on. In general, for each i we have bi < ai, so Petya will eat not more candies than in the first case in total. It means that Vasya will eat not less candies than in the first case.So this problem can be solved using the binary search (answer) approach. In order to check whether selected k is applicable it necessary just to implement the process described in the problem statement. bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}Since Petya eats 10% of candies, its amount decreases exponentially, so there will be only few days before all the candies will be eaten. In the worst case it is necessary 378 days. Formally the complexity of the solution is O(log(n)2).Like in the previous problem it is recommended to avoid floating operations and to use only integer types.Solution991D - Bishwock EditorialIn this problem we may use the greedy approach. Let's go through columns from left to right. If we are currently considering column i and we may place a figure occupying only cells at columns i and i + 1, we have to place this figure. Really if the optimal solution doesn't contain a bishwock at column i then column i + 1 may be occupied by at most one bishwock. So we can remove this figure and place it at columns i and i + 1, the result will be at least the same. A bit harder question is — how exactly we should place the figure if all 4 cells of columns i and i + 1 are empty (in other cases there will be only one way to place a bishwock)? Of course, we should occupy both cells of column i. Moreover it does not matter which cell we will occupy at column i + 1 in this case. The cells of i + 1 may be used only for placing a bishwock in columns i + 1,i + 2. If column i + 2 has at most one empty cell we are unable to place such figure and the remaining empty cells of column i + 1 are useless at all. If both cells of column i + 2 are empty we may place a bishwock regardless of the position of the remaining empty cell at column i + 1.It means that we don't have to place the figures actually — we have to calculate and update number of empty cells in columns. According to the described algorithm we may write such code: \t... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}Moreover this implementation can be simplified to just two cases: \tint ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}Formally such algorithm may be considered as the dynamic programming. Of course it is not necessary to have a deep understanding of DP to write such implementation and solve the problem.This problem also can be solved by more ''obvious'' DP approach (for example we may consider index of current column and state of the cells of the previous column as a state of DP). In this case the implementation will be a bit more complicated but it won't be necessary to prove described solution.Solution1Solution2991E - Bus Number EditorialAccording to the statement, digits of original bus number form a subset of digits of the number seen by Vasya. It is possible to iterate through all the subsets in 2k operations (where k is length of n). For each subset we need to check whether it is correct (contains all necessary digits) and transform it to ''normal'' state (sort the digits for example), in order to avoid conflicts with another subsets which differ only at the digits order. We have to keep only unique subsets. \tlong long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}Now for each subset of digits we have to calculate amount of corresponding correct bus numbers. It can be calculated in O(k) operations using permutations of multisets formula (see ''Permutations of multisets'' at the article about permutations and multinomial coefficients)C = k! / (c0! * c1! * ... * c9!), where k — total number of digits in the subset and ci — number of digits i: long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}Now, we have to subtract amount of bus numbers with leading zeroes from the result for this subset if it contains digit 0. This can be done in the very same way: if we place digit 0 at the first position of the number, we have to decrease k by 1 and decrease c0 by 1; the formula described above will calculate amount of ways to place remaining digits of the subset and this number should be subtract from the answer: long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}In total, even with such rough evaluation of complexity and naive implementation we get O(2k * k) operations, where k ≤ 19 — amount of digits in n. It is easy to check that the answer doesn't exceed 1018 so the standard 64-bit integer type will be enough.Solution991F - Concise and clear EditorialAll the problem numbers (except for 1010, which is given in the samples) contain at most 10 digits. It means that we have to use at most 9 digits if we want to find a shorter representation. Notice that the length of sum of two integers is not greater than sum of the lengths of these integers, so in the optimal representation at most one term is a number while other terms are expressions containing * and/or ^. Each expression (not a number) contains at least 3 symbols, so the optimal representation can contain at most 3 terms. The maximal integer that can be represented in such manner is 9^9+9^9+9, but it contains only 9 digits while expressions with 3 terms always contain at least 9 symbols. So we proved that there always exists an optimal representation which is a sum of at most two terms.So there exist only 3 types of representation of the original number: n = a^b n = x+y n = x*y where x and y — some expressions (in the first case a and b are numbers), which doesn't contain +. Moreover in all the cases such expressions should contain at most 7 digits.Let's find for each x ≤ n a shortest valid representation m[x], containing at most 7 symbols (if it exists and contains less digits than simple number x), and for each length d — set of integers s[d] which can be represented by an expression of length d. The standard containers (std::map and std::set в C++) are suitable for that: map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}Firstly let's add all expressions a^b, there are about sqrt(n) such expressions. void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}Now lets consider the expressions containing several multipliers. The same way (as for addition) in such representation at most one multiplier is a number. Including that the expression can contain at most 7 digits we have only 2 possible ways: x = a^b*c^d x = a^b*c where a, b, c and d are some numbers. Lets iterate through i — the length of the representation of the first multiplier and go over all values stored in s[i]. The second multiplier can have length at most d = 7 - i - 1 and the total number of ways to choose two multipliers will be small enough. The second multiplier should be selected from containers s[j] for length at most d (in the first case), or we should iterate from 1 to 10d (in the second case). After that we will have about k = 150000 numbers in m in total: void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}Now lets go back to the representation of the original number. For the first case — a^b — we have already stored such values in m. For the cases x+y and x*y we may assume that the length of expression of x is not greater than 4. Now lets iterate through x among found representations of length up to 4, and among integers from 1 to 104. For each such x and for each of 2 cases we determine value of y uniquely, and the optimal representation of y is already stored in m or it is just a number. So, for each such x we can find optimal answer for n by at most two addressing to m i.e. in log(k) operations. string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}Finally, the total algorithm complexity is O((sqrt(n) + k + 104) * log(k)).Solution",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 991\\s*D"
          },
          "content_length": 13592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 1",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 2",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 3",
          "code": "for Test case #7:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 4",
          "code": "Input: 999999972",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 5",
          "code": "Jury's answer: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 6",
          "code": "Output: 39259426",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 7",
          "code": "Output: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 8",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 9",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 10",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 11",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 1",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 2",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 3",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 4",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 5",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 6",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 7",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 8",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 9",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 10",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 11",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 12",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 13",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 14",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 15",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 16",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 17",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 18",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 19",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 20",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 21",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 22",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 23",
          "code": "x = a^b*c^d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 24",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 25",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 26",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 27",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 28",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 29",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 30",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 31",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[0X]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[0X]{1,100}\", \"s2\");\n\n    ensuref(s1.length() == s2.length(), \"Strings s1 and s2 must be of the same length, but lengths are %d and %d\", (int)s1.length(), (int)s2.length());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[0X]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[0X]{1,100}\", \"s2\");\n\n    ensuref(s1.length() == s2.length(), \"Strings s1 and s2 must be of the same length, but lengths are %d and %d\", (int)s1.length(), (int)s2.length());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[0X]{1,100}\", \"s1\");\n    string s2 = inf.readLine(\"[0X]{1,100}\", \"s2\");\n\n    ensuref(s1.length() == s2.length(), \"Strings s1 and s2 must be of the same length, but lengths are %d and %d\", (int)s1.length(), (int)s2.length());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst string zeros = \"00000000000000000000000000000000000000000000000000\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // length of the strings\n    string type = opt<string>(\"type\", \"random\");\n\n    string s1(n, '0'), s2(n, '0');\n\n    if (type == \"all_zero\") {\n        // s1 and s2 already initialized to '0's\n    } else if (type == \"all_X\") {\n        s1 = string(n, 'X');\n        s2 = string(n, 'X');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s1[i] = (i % 2 == 0) ? '0' : 'X';\n            s2[i] = (i % 2 == 0) ? 'X' : '0';\n        }\n    } else if (type == \"random\") {\n        // Generate random '0' and 'X' for s1 and s2\n        for (int i = 0; i < n; ++i) {\n            s1[i] = rnd.next('0', 'X'); // Randomly pick '0' or 'X'\n            s2[i] = rnd.next('0', 'X'); // Randomly pick '0' or 'X'\n        }\n    } else if (type == \"half_X\") {\n        // First half '0's, second half 'X's\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) {\n                s1[i] = '0';\n                s2[i] = '0';\n            } else {\n                s1[i] = 'X';\n                s2[i] = 'X';\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i) {\n            s1[i] = (i % 2 == 0) ? '0' : 'X';\n            s2[i] = (i % 2 == 0) ? '0' : 'X';\n        }\n    } else if (type == \"edge_case\") {\n        // Length 1, minimal size\n        s1 = \"0\";\n        s2 = \"0\";\n    } else if (type == \"max_bishwocks\") {\n        // Create pattern that allows maximum bishwocks\n        for (int i = 0; i < n; ++i) {\n            s1[i] = '0';\n            s2[i] = '0';\n        }\n    } else if (type == \"min_bishwocks\") {\n        // Place 'X's such that no bishwocks can be placed\n        for (int i = 0; i < n; ++i) {\n            s1[i] = 'X';\n            s2[i] = 'X';\n        }\n    } else if (type == \"edge_pawns\") {\n        // Place pawns at the edges\n        s1[0] = 'X';\n        s2[0] = 'X';\n        s1[n-1] = 'X';\n        s2[n-1] = 'X';\n        for (int i = 1; i < n-1; ++i) {\n            s1[i] = '0';\n            s2[i] = '0';\n        }\n    } else if (type == \"single_pawn\") {\n        // Place a single pawn at random position\n        int pos = rnd.next(0, n-1);\n        s1[pos] = 'X';\n        s2[pos] = 'X';\n        for (int i = 0; i < n; ++i) {\n            if (i != pos) {\n                s1[i] = '0';\n                s2[i] = '0';\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s1[i] = rnd.next('0', 'X');\n            s2[i] = rnd.next('0', 'X');\n        }\n    }\n    // Output s1 and s2\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst string zeros = \"00000000000000000000000000000000000000000000000000\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // length of the strings\n    string type = opt<string>(\"type\", \"random\");\n\n    string s1(n, '0'), s2(n, '0');\n\n    if (type == \"all_zero\") {\n        // s1 and s2 already initialized to '0's\n    } else if (type == \"all_X\") {\n        s1 = string(n, 'X');\n        s2 = string(n, 'X');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            s1[i] = (i % 2 == 0) ? '0' : 'X';\n            s2[i] = (i % 2 == 0) ? 'X' : '0';\n        }\n    } else if (type == \"random\") {\n        // Generate random '0' and 'X' for s1 and s2\n        for (int i = 0; i < n; ++i) {\n            s1[i] = rnd.next('0', 'X'); // Randomly pick '0' or 'X'\n            s2[i] = rnd.next('0', 'X'); // Randomly pick '0' or 'X'\n        }\n    } else if (type == \"half_X\") {\n        // First half '0's, second half 'X's\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) {\n                s1[i] = '0';\n                s2[i] = '0';\n            } else {\n                s1[i] = 'X';\n                s2[i] = 'X';\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i) {\n            s1[i] = (i % 2 == 0) ? '0' : 'X';\n            s2[i] = (i % 2 == 0) ? '0' : 'X';\n        }\n    } else if (type == \"edge_case\") {\n        // Length 1, minimal size\n        s1 = \"0\";\n        s2 = \"0\";\n    } else if (type == \"max_bishwocks\") {\n        // Create pattern that allows maximum bishwocks\n        for (int i = 0; i < n; ++i) {\n            s1[i] = '0';\n            s2[i] = '0';\n        }\n    } else if (type == \"min_bishwocks\") {\n        // Place 'X's such that no bishwocks can be placed\n        for (int i = 0; i < n; ++i) {\n            s1[i] = 'X';\n            s2[i] = 'X';\n        }\n    } else if (type == \"edge_pawns\") {\n        // Place pawns at the edges\n        s1[0] = 'X';\n        s2[0] = 'X';\n        s1[n-1] = 'X';\n        s2[n-1] = 'X';\n        for (int i = 1; i < n-1; ++i) {\n            s1[i] = '0';\n            s2[i] = '0';\n        }\n    } else if (type == \"single_pawn\") {\n        // Place a single pawn at random position\n        int pos = rnd.next(0, n-1);\n        s1[pos] = 'X';\n        s2[pos] = 'X';\n        for (int i = 0; i < n; ++i) {\n            if (i != pos) {\n                s1[i] = '0';\n                s2[i] = '0';\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s1[i] = rnd.next('0', 'X');\n            s2[i] = rnd.next('0', 'X');\n        }\n    }\n    // Output s1 and s2\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type edge_case\n\n./gen -n 1 -type all_zero\n./gen -n 1 -type all_X\n\n./gen -n 5 -type random\n./gen -n 5 -type alternating\n./gen -n 5 -type checkerboard\n./gen -n 5 -type half_X\n./gen -n 5 -type single_pawn\n\n./gen -n 10 -type random\n./gen -n 10 -type alternating\n./gen -n 10 -type checkerboard\n./gen -n 10 -type edge_pawns\n./gen -n 10 -type single_pawn\n\n./gen -n 20 -type random\n./gen -n 20 -type max_bishwocks\n./gen -n 20 -type min_bishwocks\n./gen -n 20 -type edge_pawns\n\n./gen -n 50 -type random\n./gen -n 50 -type alternating\n./gen -n 50 -type checkerboard\n\n./gen -n 100 -type random\n./gen -n 100 -type max_bishwocks\n./gen -n 100 -type min_bishwocks\n./gen -n 100 -type half_X\n./gen -n 100 -type single_pawn\n\n./gen -n 100 -type random\n./gen -n 100 -type edge_pawns\n\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:02:59.408793",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "991/E",
      "title": "E. Bus Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer nn (1≤n≤10181≤n≤1018) — the number of the bus that was seen by Vasya. It is guaranteed that this number does not start with 00.",
      "output_spec": "OutputOutput a single integer — the amount of possible variants of the real bus number.",
      "sample_tests": "ExamplesInputCopy97OutputCopy2InputCopy2028OutputCopy13",
      "description": "E. Bus Number\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer nn (1≤n≤10181≤n≤1018) — the number of the bus that was seen by Vasya. It is guaranteed that this number does not start with 00.\n\nOutputOutput a single integer — the amount of possible variants of the real bus number.\n\nInputCopy97OutputCopy2InputCopy2028OutputCopy13\n\nInputCopy97\n\nOutputCopy2\n\nInputCopy2028\n\nOutputCopy13\n\nNoteIn the first sample, only variants 9797 and 7979 are possible.In the second sample, the variants (in the increasing order) are the following: 208208, 280280, 802802, 820820, 20282028, 20822082, 22082208, 22802280, 28022802, 28202820, 80228022, 82028202, 82208220.",
      "solutions": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces",
          "content": "Hello!Codeforces Round #491 (Div.2) will start this Saturday, June 23, 18:35 (UTC+3). This round will be rated for the participants with rating lower than 2100 and other contestants can join it out of competition.This round problems have a significant intersection with NNSU Programming Contest 2018. Please do not participate in the round if you participated in the NNSU contest or tried to upsolve the problems.During the round you have to help student Vasya to manage the difficulties caused by the end of the academic year. There will be 6 problems and 2 hours to solve them. If you solve all the problems in 25 minutes you will be able to watch the second half of South Korea — Mexico at the FIFA World Cup.The scoring is unusual a bit: 500-1000-1250-1500-2000-2750Great thanks to Mikhail MikeMirzayanov Mirzayanov for the well-known platforms; Nikolay KAN Kalinin — for the help with problems and the round coordination; Mikhail mike_live Krivonosov, Alexey Livace Ilyukhov, Nikita FalseMirror Bosov, Andrew GreenGrape Rayskiy and Alexey Aleks5d Upirvitskiy — for the round testing; Arseniy arsor Sorokin — for the statements translation. And good luck to all contestants!UPD: The round is over, thank you for the participation!UPD: Congratulations to the winners!Div. 1: nuip krijgertje qoo2p5 hohomu neal Div. 2: King — solved all the problems, well done! Daniar Saidjamol shoemakerjo Toki_Time-Tinker UPD: The editorial is published",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1441
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces",
          "content": "991A - If at first you don't succeed... EditorialThere are 4 groups of students — those who visited only the first restaurant, who visited only the second, who visited both places and who stayed at home. One of the easiest ways to detect all the incorrect situations is to calculate number of students in each group. For the first group it is A - C, for the second: B - C, for the third: C and for the fourth: N - A - B + C. Now we must just to check that there are non-negative numbers in the first three groups and the positive number for the last group. If such conditions are met the answer is the number of students in the fourth group. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;In general you are recommended to view inclusion–exclusion principle.Moreover the limitations allow to go over all possible numbers of students for each group (except for the third) in O(N3) and to check whether such numbers produce a correct solution. If no correct numbers found, just print  - 1: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Solution1Solution2991B - Getting an A EditorialIt is necessary to use the greedy approach: of course Vasya should redo the lowest grades firstly. So we have to sort the values in the ascending order and begin to replace the values by 5 until we get the desired result. In order to check whether the current state is suitable we may calculate the mean value after each iteration (O(N2) complexity in total), or just update sum of the grades and calculate the arithmetic mean in O(1) with O(N) total complexity (excluding sorting). For example: bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}\nOf course, both approaches easily fit TL.Finally, it is recommended to avoid floating-point operations while calculating the mean value.Solution991C - Candies EditorialIt is easy to check that if for some value k the necessary condition is met (Vasya eats at least half of the candies), then it is met for each integer greater k. ProofLet's consider the number of candies remaining at the evening of each day for some selected k1 — let ai candies remain at day i. If Vasya will use another number k2 > k1 we will have less candies in the first day: b1 < a1. So Petya will eat no more candies than in the first case (for k1), but in the next day the number of candies will be not greater than in the first case (if n1 > n2 then n1 - n1 / 10 ≥ n2 - n2 / 10). The same way, including that k2 > k1 at the evening of the second day we get b2 < a2 and so on. In general, for each i we have bi < ai, so Petya will eat not more candies than in the first case in total. It means that Vasya will eat not less candies than in the first case.So this problem can be solved using the binary search (answer) approach. In order to check whether selected k is applicable it necessary just to implement the process described in the problem statement. bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}Since Petya eats 10% of candies, its amount decreases exponentially, so there will be only few days before all the candies will be eaten. In the worst case it is necessary 378 days. Formally the complexity of the solution is O(log(n)2).Like in the previous problem it is recommended to avoid floating operations and to use only integer types.Solution991D - Bishwock EditorialIn this problem we may use the greedy approach. Let's go through columns from left to right. If we are currently considering column i and we may place a figure occupying only cells at columns i and i + 1, we have to place this figure. Really if the optimal solution doesn't contain a bishwock at column i then column i + 1 may be occupied by at most one bishwock. So we can remove this figure and place it at columns i and i + 1, the result will be at least the same. A bit harder question is — how exactly we should place the figure if all 4 cells of columns i and i + 1 are empty (in other cases there will be only one way to place a bishwock)? Of course, we should occupy both cells of column i. Moreover it does not matter which cell we will occupy at column i + 1 in this case. The cells of i + 1 may be used only for placing a bishwock in columns i + 1,i + 2. If column i + 2 has at most one empty cell we are unable to place such figure and the remaining empty cells of column i + 1 are useless at all. If both cells of column i + 2 are empty we may place a bishwock regardless of the position of the remaining empty cell at column i + 1.It means that we don't have to place the figures actually — we have to calculate and update number of empty cells in columns. According to the described algorithm we may write such code: \t... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}Moreover this implementation can be simplified to just two cases: \tint ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}Formally such algorithm may be considered as the dynamic programming. Of course it is not necessary to have a deep understanding of DP to write such implementation and solve the problem.This problem also can be solved by more ''obvious'' DP approach (for example we may consider index of current column and state of the cells of the previous column as a state of DP). In this case the implementation will be a bit more complicated but it won't be necessary to prove described solution.Solution1Solution2991E - Bus Number EditorialAccording to the statement, digits of original bus number form a subset of digits of the number seen by Vasya. It is possible to iterate through all the subsets in 2k operations (where k is length of n). For each subset we need to check whether it is correct (contains all necessary digits) and transform it to ''normal'' state (sort the digits for example), in order to avoid conflicts with another subsets which differ only at the digits order. We have to keep only unique subsets. \tlong long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}Now for each subset of digits we have to calculate amount of corresponding correct bus numbers. It can be calculated in O(k) operations using permutations of multisets formula (see ''Permutations of multisets'' at the article about permutations and multinomial coefficients)C = k! / (c0! * c1! * ... * c9!), where k — total number of digits in the subset and ci — number of digits i: long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}Now, we have to subtract amount of bus numbers with leading zeroes from the result for this subset if it contains digit 0. This can be done in the very same way: if we place digit 0 at the first position of the number, we have to decrease k by 1 and decrease c0 by 1; the formula described above will calculate amount of ways to place remaining digits of the subset and this number should be subtract from the answer: long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}In total, even with such rough evaluation of complexity and naive implementation we get O(2k * k) operations, where k ≤ 19 — amount of digits in n. It is easy to check that the answer doesn't exceed 1018 so the standard 64-bit integer type will be enough.Solution991F - Concise and clear EditorialAll the problem numbers (except for 1010, which is given in the samples) contain at most 10 digits. It means that we have to use at most 9 digits if we want to find a shorter representation. Notice that the length of sum of two integers is not greater than sum of the lengths of these integers, so in the optimal representation at most one term is a number while other terms are expressions containing * and/or ^. Each expression (not a number) contains at least 3 symbols, so the optimal representation can contain at most 3 terms. The maximal integer that can be represented in such manner is 9^9+9^9+9, but it contains only 9 digits while expressions with 3 terms always contain at least 9 symbols. So we proved that there always exists an optimal representation which is a sum of at most two terms.So there exist only 3 types of representation of the original number: n = a^b n = x+y n = x*y where x and y — some expressions (in the first case a and b are numbers), which doesn't contain +. Moreover in all the cases such expressions should contain at most 7 digits.Let's find for each x ≤ n a shortest valid representation m[x], containing at most 7 symbols (if it exists and contains less digits than simple number x), and for each length d — set of integers s[d] which can be represented by an expression of length d. The standard containers (std::map and std::set в C++) are suitable for that: map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}Firstly let's add all expressions a^b, there are about sqrt(n) such expressions. void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}Now lets consider the expressions containing several multipliers. The same way (as for addition) in such representation at most one multiplier is a number. Including that the expression can contain at most 7 digits we have only 2 possible ways: x = a^b*c^d x = a^b*c where a, b, c and d are some numbers. Lets iterate through i — the length of the representation of the first multiplier and go over all values stored in s[i]. The second multiplier can have length at most d = 7 - i - 1 and the total number of ways to choose two multipliers will be small enough. The second multiplier should be selected from containers s[j] for length at most d (in the first case), or we should iterate from 1 to 10d (in the second case). After that we will have about k = 150000 numbers in m in total: void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}Now lets go back to the representation of the original number. For the first case — a^b — we have already stored such values in m. For the cases x+y and x*y we may assume that the length of expression of x is not greater than 4. Now lets iterate through x among found representations of length up to 4, and among integers from 1 to 104. For each such x and for each of 2 cases we determine value of y uniquely, and the optimal representation of y is already stored in m or it is just a number. So, for each such x we can find optimal answer for n by at most two addressing to m i.e. in log(k) operations. string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}Finally, the total algorithm complexity is O((sqrt(n) + k + 104) * log(k)).Solution",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 991\\s*E"
          },
          "content_length": 13592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 1",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 2",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 3",
          "code": "for Test case #7:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 4",
          "code": "Input: 999999972",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 5",
          "code": "Jury's answer: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 6",
          "code": "Output: 39259426",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 7",
          "code": "Output: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 8",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 9",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 10",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 11",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 1",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 2",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 3",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 4",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 5",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 6",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 7",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 8",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 9",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 10",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 11",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 12",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 13",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 14",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 15",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 16",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 17",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 18",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 19",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 20",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 21",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 22",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 23",
          "code": "x = a^b*c^d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 24",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 25",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 26",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 27",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 28",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 29",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 30",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 31",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"n\");\n    inf.readEoln();\n\n    unsigned long long n = 0;\n    for (int i = 0; i < (int)s.size(); ++i) {\n        char c = s[i];\n        int digit = c - '0';\n\n        n = n * 10 + digit;\n\n        if (n > 1000000000000000000ULL) {\n            ensuref(false, \"n must be less than or equal to 1e18, but n=%s\", s.c_str());\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"n\");\n    inf.readEoln();\n\n    unsigned long long n = 0;\n    for (int i = 0; i < (int)s.size(); ++i) {\n        char c = s[i];\n        int digit = c - '0';\n\n        n = n * 10 + digit;\n\n        if (n > 1000000000000000000ULL) {\n            ensuref(false, \"n must be less than or equal to 1e18, but n=%s\", s.c_str());\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[1-9][0-9]*\", \"n\");\n    inf.readEoln();\n\n    unsigned long long n = 0;\n    for (int i = 0; i < (int)s.size(); ++i) {\n        char c = s[i];\n        int digit = c - '0';\n\n        n = n * 10 + digit;\n\n        if (n > 1000000000000000000ULL) {\n            ensuref(false, \"n must be less than or equal to 1e18, but n=%s\", s.c_str());\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 18);\n    string type = opt<string>(\"type\", \"random\");\n\n    string n_str;\n\n    if (type == \"max\") {\n        n_str = string(len, '9');\n        if (n_str.length() > 18)\n            n_str = string(18, '9');\n    } else if (type == \"min\") {\n        n_str = \"1\";\n    } else if (type == \"random\") {\n        if (len > 18) len = 18;\n        n_str += (char)(rnd.next(1, 9) + '0'); // First digit cannot be zero\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n    } else if (type == \"same_digit\") {\n        if (len > 18) len = 18;\n        char digit = (char)(rnd.next(1, 9) + '0');\n        n_str = string(len, digit);\n    } else if (type == \"palindrome\") {\n        if (len > 18) len = 18;\n        string half;\n        int half_len = (len + 1) / 2;\n        half += (char)(rnd.next(1, 9) + '0'); // First digit\n        for (int i = 1; i < half_len; ++i) {\n            half += (char)(rnd.next(0, 9) + '0');\n        }\n        n_str = half;\n        string rev_half = half;\n        reverse(rev_half.begin(), rev_half.end());\n        if (len % 2 == 1) {\n            rev_half = rev_half.substr(1); // Remove middle character\n        }\n        n_str += rev_half;\n    } else if (type == \"ascending\") {\n        if (len > 9) len = 9; // digits from 1 to 9\n        n_str = \"\";\n        int d = rnd.next(1, 10 - len);\n        for (int i = 0; i < len; ++i) {\n            n_str += (char)(d + '0');\n            d++;\n        }\n    } else if (type == \"descending\") {\n        if (len > 9) len = 9; // digits from 9 to 1\n        n_str = \"\";\n        int d = rnd.next(len, 9);\n        for (int i = 0; i < len; ++i) {\n            n_str += (char)(d + '0');\n            d--;\n        }\n    } else if (type == \"all_digits\") {\n        if (len > 9) len = 9;\n        string digits = \"123456789\";\n        shuffle(digits.begin(), digits.end());\n        n_str = digits.substr(0, len);\n    } else if (type == \"alternating\") {\n        if (len > 18) len = 18;\n        char d1 = (char)(rnd.next(1, 9) + '0');\n        char d2 = (char)(rnd.next(0, 9) + '0');\n        while (d2 == d1) {\n            d2 = (char)(rnd.next(0, 9) + '0');\n        }\n        n_str = \"\";\n        for (int i = 0; i < len; ++i) {\n            n_str += (i % 2 == 0) ? d1 : d2;\n        }\n    } else if (type == \"leading_big_digit\") {\n        if (len > 18) len = 18;\n        char d1 = '9';\n        n_str = \"\";\n        n_str += d1;\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n    } else if (type == \"trailing_zeros\") {\n        if (len > 18) len = 18;\n        int non_zero_len = rnd.next(1, len - 1);\n        n_str = \"\";\n        n_str += (char)(rnd.next(1, 9) + '0');\n        for (int i = 1; i < non_zero_len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n        int zeros = len - non_zero_len;\n        n_str += string(zeros, '0');\n    } else if (type == \"single_digit\") {\n        n_str = (char)(rnd.next(1, 9) + '0');\n    } else if (type == \"repeats\") {\n        if (len > 18) len = 18;\n        n_str = \"\";\n        n_str += (char)(rnd.next(1, 9) + '0');\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n        // Ensure some digits repeat\n        int pos1 = rnd.next(0, len - 1);\n        int pos2 = rnd.next(0, len - 1);\n        while (pos2 == pos1) pos2 = rnd.next(0, len - 1);\n        n_str[pos2] = n_str[pos1];\n    } else {\n        // Default to random\n        if (len > 18) len = 18;\n        n_str += (char)(rnd.next(1, 9) + '0'); // First digit cannot be zero\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n    }\n\n    // Now, ensure n_str represents a valid number within the range [1, 10^18]\n    if (n_str.length() > 18) {\n        n_str = n_str.substr(0, 18);\n    }\n    // Convert n_str to unsigned long long to ensure it's within range\n    unsigned long long n = 0;\n    for (char c : n_str) {\n        n = n * 10 + (c - '0');\n        if (n > 1000000000000000000ULL) {\n            n = 1000000000000000000ULL;\n            break;\n        }\n    }\n    if (n < 1) n = 1;\n    else if (n > 1000000000000000000ULL) n = 1000000000000000000ULL;\n    printf(\"%llu\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 18);\n    string type = opt<string>(\"type\", \"random\");\n\n    string n_str;\n\n    if (type == \"max\") {\n        n_str = string(len, '9');\n        if (n_str.length() > 18)\n            n_str = string(18, '9');\n    } else if (type == \"min\") {\n        n_str = \"1\";\n    } else if (type == \"random\") {\n        if (len > 18) len = 18;\n        n_str += (char)(rnd.next(1, 9) + '0'); // First digit cannot be zero\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n    } else if (type == \"same_digit\") {\n        if (len > 18) len = 18;\n        char digit = (char)(rnd.next(1, 9) + '0');\n        n_str = string(len, digit);\n    } else if (type == \"palindrome\") {\n        if (len > 18) len = 18;\n        string half;\n        int half_len = (len + 1) / 2;\n        half += (char)(rnd.next(1, 9) + '0'); // First digit\n        for (int i = 1; i < half_len; ++i) {\n            half += (char)(rnd.next(0, 9) + '0');\n        }\n        n_str = half;\n        string rev_half = half;\n        reverse(rev_half.begin(), rev_half.end());\n        if (len % 2 == 1) {\n            rev_half = rev_half.substr(1); // Remove middle character\n        }\n        n_str += rev_half;\n    } else if (type == \"ascending\") {\n        if (len > 9) len = 9; // digits from 1 to 9\n        n_str = \"\";\n        int d = rnd.next(1, 10 - len);\n        for (int i = 0; i < len; ++i) {\n            n_str += (char)(d + '0');\n            d++;\n        }\n    } else if (type == \"descending\") {\n        if (len > 9) len = 9; // digits from 9 to 1\n        n_str = \"\";\n        int d = rnd.next(len, 9);\n        for (int i = 0; i < len; ++i) {\n            n_str += (char)(d + '0');\n            d--;\n        }\n    } else if (type == \"all_digits\") {\n        if (len > 9) len = 9;\n        string digits = \"123456789\";\n        shuffle(digits.begin(), digits.end());\n        n_str = digits.substr(0, len);\n    } else if (type == \"alternating\") {\n        if (len > 18) len = 18;\n        char d1 = (char)(rnd.next(1, 9) + '0');\n        char d2 = (char)(rnd.next(0, 9) + '0');\n        while (d2 == d1) {\n            d2 = (char)(rnd.next(0, 9) + '0');\n        }\n        n_str = \"\";\n        for (int i = 0; i < len; ++i) {\n            n_str += (i % 2 == 0) ? d1 : d2;\n        }\n    } else if (type == \"leading_big_digit\") {\n        if (len > 18) len = 18;\n        char d1 = '9';\n        n_str = \"\";\n        n_str += d1;\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n    } else if (type == \"trailing_zeros\") {\n        if (len > 18) len = 18;\n        int non_zero_len = rnd.next(1, len - 1);\n        n_str = \"\";\n        n_str += (char)(rnd.next(1, 9) + '0');\n        for (int i = 1; i < non_zero_len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n        int zeros = len - non_zero_len;\n        n_str += string(zeros, '0');\n    } else if (type == \"single_digit\") {\n        n_str = (char)(rnd.next(1, 9) + '0');\n    } else if (type == \"repeats\") {\n        if (len > 18) len = 18;\n        n_str = \"\";\n        n_str += (char)(rnd.next(1, 9) + '0');\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n        // Ensure some digits repeat\n        int pos1 = rnd.next(0, len - 1);\n        int pos2 = rnd.next(0, len - 1);\n        while (pos2 == pos1) pos2 = rnd.next(0, len - 1);\n        n_str[pos2] = n_str[pos1];\n    } else {\n        // Default to random\n        if (len > 18) len = 18;\n        n_str += (char)(rnd.next(1, 9) + '0'); // First digit cannot be zero\n        for (int i = 1; i < len; ++i) {\n            n_str += (char)(rnd.next(0, 9) + '0');\n        }\n    }\n\n    // Now, ensure n_str represents a valid number within the range [1, 10^18]\n    if (n_str.length() > 18) {\n        n_str = n_str.substr(0, 18);\n    }\n    // Convert n_str to unsigned long long to ensure it's within range\n    unsigned long long n = 0;\n    for (char c : n_str) {\n        n = n * 10 + (c - '0');\n        if (n > 1000000000000000000ULL) {\n            n = 1000000000000000000ULL;\n            break;\n        }\n    }\n    if (n < 1) n = 1;\n    else if (n > 1000000000000000000ULL) n = 1000000000000000000ULL;\n    printf(\"%llu\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Generate random numbers of different lengths\n./gen -len 1 -type random\n./gen -len 2 -type random\n./gen -len 5 -type random\n./gen -len 10 -type random\n./gen -len 18 -type random\n\n# Generate maximum possible number\n./gen -type max\n\n# Generate minimum possible number\n./gen -type min\n\n# Generate numbers with same digit repeated\n./gen -len 1 -type same_digit\n./gen -len 2 -type same_digit\n./gen -len 10 -type same_digit\n./gen -len 18 -type same_digit\n\n# Generate palindromic numbers\n./gen -len 1 -type palindrome\n./gen -len 2 -type palindrome\n./gen -len 10 -type palindrome\n./gen -len 18 -type palindrome\n\n# Generate numbers with ascending digits\n./gen -len 5 -type ascending\n\n# Generate numbers with descending digits\n./gen -len 5 -type descending\n\n# Generate numbers containing all digits\n./gen -len 9 -type all_digits\n\n# Generate numbers with alternating digits\n./gen -len 6 -type alternating\n\n# Generate numbers starting with 9\n./gen -len 18 -type leading_big_digit\n\n# Generate numbers with trailing zeros\n./gen -len 10 -type trailing_zeros\n\n# Generate single-digit number\n./gen -type single_digit\n\n# Generate numbers with digit repeats\n./gen -len 10 -type repeats\n\n# Edge cases\n# Length exceeding maximum allowed (should handle properly)\n./gen -len 20 -type random\n\n# Length of 1 (minimum length)\n./gen -len 1 -type random\n./gen -len 1 -type same_digit\n./gen -len 1 -type palindrome\n\n# Length of maximum allowed (18)\n./gen -len 18 -type random\n./gen -len 18 -type palindrome\n\n# Generate random numbers multiple times to produce different n\n./gen -len 18 -type random\n./gen -len 18 -type random\n./gen -len 18 -type random\n./gen -len 18 -type random\n./gen -len 18 -type random\n\n# Generate numbers with varying lengths and types\n./gen -len 3 -type same_digit\n./gen -len 3 -type palindrome\n./gen -len 3 -type ascending\n./gen -len 3 -type descending\n./gen -len 3 -type repeats\n\n# Generate random numbers for lengths from 1 to 18\nfor len in {1..18}; do ./gen -len $len -type random; done\n\n# Generate same_digit numbers for lengths from 1 to 18\nfor len in {1..18}; do ./gen -len $len -type same_digit; done\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:01.375441",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "991/F",
      "title": "F. Concise and clear",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains a single integer nn (1≤n≤100000000001≤n≤10000000000).",
      "output_spec": "OutputOutput a concise notation of the number nn. If there are several concise notations, output any of them.",
      "sample_tests": "ExamplesInputCopy2018OutputCopy2018InputCopy1000000007OutputCopy10^9+7InputCopy10000000000OutputCopy100^5InputCopy2000000000OutputCopy2*10^9",
      "description": "F. Concise and clear\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains a single integer nn (1≤n≤100000000001≤n≤10000000000).\n\nOutputOutput a concise notation of the number nn. If there are several concise notations, output any of them.\n\nInputCopy2018OutputCopy2018InputCopy1000000007OutputCopy10^9+7InputCopy10000000000OutputCopy100^5InputCopy2000000000OutputCopy2*10^9\n\nInputCopy2018\n\nOutputCopy2018\n\nInputCopy1000000007\n\nOutputCopy10^9+7\n\nInputCopy10000000000\n\nOutputCopy100^5\n\nInputCopy2000000000\n\nOutputCopy2*10^9\n\nNoteThe third sample allows the answer 10^10 also of the length 55.",
      "solutions": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces",
          "content": "Hello!Codeforces Round #491 (Div.2) will start this Saturday, June 23, 18:35 (UTC+3). This round will be rated for the participants with rating lower than 2100 and other contestants can join it out of competition.This round problems have a significant intersection with NNSU Programming Contest 2018. Please do not participate in the round if you participated in the NNSU contest or tried to upsolve the problems.During the round you have to help student Vasya to manage the difficulties caused by the end of the academic year. There will be 6 problems and 2 hours to solve them. If you solve all the problems in 25 minutes you will be able to watch the second half of South Korea — Mexico at the FIFA World Cup.The scoring is unusual a bit: 500-1000-1250-1500-2000-2750Great thanks to Mikhail MikeMirzayanov Mirzayanov for the well-known platforms; Nikolay KAN Kalinin — for the help with problems and the round coordination; Mikhail mike_live Krivonosov, Alexey Livace Ilyukhov, Nikita FalseMirror Bosov, Andrew GreenGrape Rayskiy and Alexey Aleks5d Upirvitskiy — for the round testing; Arseniy arsor Sorokin — for the statements translation. And good luck to all contestants!UPD: The round is over, thank you for the participation!UPD: Congratulations to the winners!Div. 1: nuip krijgertje qoo2p5 hohomu neal Div. 2: King — solved all the problems, well done! Daniar Saidjamol shoemakerjo Toki_Time-Tinker UPD: The editorial is published",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60139",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1441
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces",
          "content": "991A - If at first you don't succeed... EditorialThere are 4 groups of students — those who visited only the first restaurant, who visited only the second, who visited both places and who stayed at home. One of the easiest ways to detect all the incorrect situations is to calculate number of students in each group. For the first group it is A - C, for the second: B - C, for the third: C and for the fourth: N - A - B + C. Now we must just to check that there are non-negative numbers in the first three groups and the positive number for the last group. If such conditions are met the answer is the number of students in the fourth group. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;In general you are recommended to view inclusion–exclusion principle.Moreover the limitations allow to go over all possible numbers of students for each group (except for the third) in O(N3) and to check whether such numbers produce a correct solution. If no correct numbers found, just print  - 1: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Solution1Solution2991B - Getting an A EditorialIt is necessary to use the greedy approach: of course Vasya should redo the lowest grades firstly. So we have to sort the values in the ascending order and begin to replace the values by 5 until we get the desired result. In order to check whether the current state is suitable we may calculate the mean value after each iteration (O(N2) complexity in total), or just update sum of the grades and calculate the arithmetic mean in O(1) with O(N) total complexity (excluding sorting). For example: bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}\nOf course, both approaches easily fit TL.Finally, it is recommended to avoid floating-point operations while calculating the mean value.Solution991C - Candies EditorialIt is easy to check that if for some value k the necessary condition is met (Vasya eats at least half of the candies), then it is met for each integer greater k. ProofLet's consider the number of candies remaining at the evening of each day for some selected k1 — let ai candies remain at day i. If Vasya will use another number k2 > k1 we will have less candies in the first day: b1 < a1. So Petya will eat no more candies than in the first case (for k1), but in the next day the number of candies will be not greater than in the first case (if n1 > n2 then n1 - n1 / 10 ≥ n2 - n2 / 10). The same way, including that k2 > k1 at the evening of the second day we get b2 < a2 and so on. In general, for each i we have bi < ai, so Petya will eat not more candies than in the first case in total. It means that Vasya will eat not less candies than in the first case.So this problem can be solved using the binary search (answer) approach. In order to check whether selected k is applicable it necessary just to implement the process described in the problem statement. bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}Since Petya eats 10% of candies, its amount decreases exponentially, so there will be only few days before all the candies will be eaten. In the worst case it is necessary 378 days. Formally the complexity of the solution is O(log(n)2).Like in the previous problem it is recommended to avoid floating operations and to use only integer types.Solution991D - Bishwock EditorialIn this problem we may use the greedy approach. Let's go through columns from left to right. If we are currently considering column i and we may place a figure occupying only cells at columns i and i + 1, we have to place this figure. Really if the optimal solution doesn't contain a bishwock at column i then column i + 1 may be occupied by at most one bishwock. So we can remove this figure and place it at columns i and i + 1, the result will be at least the same. A bit harder question is — how exactly we should place the figure if all 4 cells of columns i and i + 1 are empty (in other cases there will be only one way to place a bishwock)? Of course, we should occupy both cells of column i. Moreover it does not matter which cell we will occupy at column i + 1 in this case. The cells of i + 1 may be used only for placing a bishwock in columns i + 1,i + 2. If column i + 2 has at most one empty cell we are unable to place such figure and the remaining empty cells of column i + 1 are useless at all. If both cells of column i + 2 are empty we may place a bishwock regardless of the position of the remaining empty cell at column i + 1.It means that we don't have to place the figures actually — we have to calculate and update number of empty cells in columns. According to the described algorithm we may write such code: \t... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}Moreover this implementation can be simplified to just two cases: \tint ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}Formally such algorithm may be considered as the dynamic programming. Of course it is not necessary to have a deep understanding of DP to write such implementation and solve the problem.This problem also can be solved by more ''obvious'' DP approach (for example we may consider index of current column and state of the cells of the previous column as a state of DP). In this case the implementation will be a bit more complicated but it won't be necessary to prove described solution.Solution1Solution2991E - Bus Number EditorialAccording to the statement, digits of original bus number form a subset of digits of the number seen by Vasya. It is possible to iterate through all the subsets in 2k operations (where k is length of n). For each subset we need to check whether it is correct (contains all necessary digits) and transform it to ''normal'' state (sort the digits for example), in order to avoid conflicts with another subsets which differ only at the digits order. We have to keep only unique subsets. \tlong long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}Now for each subset of digits we have to calculate amount of corresponding correct bus numbers. It can be calculated in O(k) operations using permutations of multisets formula (see ''Permutations of multisets'' at the article about permutations and multinomial coefficients)C = k! / (c0! * c1! * ... * c9!), where k — total number of digits in the subset and ci — number of digits i: long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}Now, we have to subtract amount of bus numbers with leading zeroes from the result for this subset if it contains digit 0. This can be done in the very same way: if we place digit 0 at the first position of the number, we have to decrease k by 1 and decrease c0 by 1; the formula described above will calculate amount of ways to place remaining digits of the subset and this number should be subtract from the answer: long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}In total, even with such rough evaluation of complexity and naive implementation we get O(2k * k) operations, where k ≤ 19 — amount of digits in n. It is easy to check that the answer doesn't exceed 1018 so the standard 64-bit integer type will be enough.Solution991F - Concise and clear EditorialAll the problem numbers (except for 1010, which is given in the samples) contain at most 10 digits. It means that we have to use at most 9 digits if we want to find a shorter representation. Notice that the length of sum of two integers is not greater than sum of the lengths of these integers, so in the optimal representation at most one term is a number while other terms are expressions containing * and/or ^. Each expression (not a number) contains at least 3 symbols, so the optimal representation can contain at most 3 terms. The maximal integer that can be represented in such manner is 9^9+9^9+9, but it contains only 9 digits while expressions with 3 terms always contain at least 9 symbols. So we proved that there always exists an optimal representation which is a sum of at most two terms.So there exist only 3 types of representation of the original number: n = a^b n = x+y n = x*y where x and y — some expressions (in the first case a and b are numbers), which doesn't contain +. Moreover in all the cases such expressions should contain at most 7 digits.Let's find for each x ≤ n a shortest valid representation m[x], containing at most 7 symbols (if it exists and contains less digits than simple number x), and for each length d — set of integers s[d] which can be represented by an expression of length d. The standard containers (std::map and std::set в C++) are suitable for that: map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}Firstly let's add all expressions a^b, there are about sqrt(n) such expressions. void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}Now lets consider the expressions containing several multipliers. The same way (as for addition) in such representation at most one multiplier is a number. Including that the expression can contain at most 7 digits we have only 2 possible ways: x = a^b*c^d x = a^b*c where a, b, c and d are some numbers. Lets iterate through i — the length of the representation of the first multiplier and go over all values stored in s[i]. The second multiplier can have length at most d = 7 - i - 1 and the total number of ways to choose two multipliers will be small enough. The second multiplier should be selected from containers s[j] for length at most d (in the first case), or we should iterate from 1 to 10d (in the second case). After that we will have about k = 150000 numbers in m in total: void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}Now lets go back to the representation of the original number. For the first case — a^b — we have already stored such values in m. For the cases x+y and x*y we may assume that the length of expression of x is not greater than 4. Now lets iterate through x among found representations of length up to 4, and among integers from 1 to 104. For each such x and for each of 2 cases we determine value of y uniquely, and the optimal representation of y is already stored in m or it is just a number. So, for each such x we can find optimal answer for n by at most two addressing to m i.e. in log(k) operations. string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}Finally, the total algorithm complexity is O((sqrt(n) + k + 104) * log(k)).Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60181",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 991\\s*F"
          },
          "content_length": 13592
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 1",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 2",
          "code": "wonderful @_@",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 3",
          "code": "for Test case #7:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 4",
          "code": "Input: 999999972",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 5",
          "code": "Jury's answer: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 6",
          "code": "Output: 39259426",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 7",
          "code": "Output: 39259423",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 8",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 9",
          "code": "if (k * days + m >= ceil((float)n / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 10",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2) - Codeforces - Code 11",
          "code": "if (k * days + m >= (n + 1) / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60139",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 1",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 2",
          "code": "int n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 3",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 4",
          "code": "int n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 5",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 6",
          "code": "bool check(int sum, int n) {\n\t// integer representation of sum / n >= 4.5\n\treturn sum * 10 >= n * 45;\n}\n\nint main() {\n\t... // read integers to vector v and calculate sum\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\twhile (!check(sum, n)) {\n\t\tsum += 5 - v[ans];\n\t\tans++;\n\t}\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 7",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 8",
          "code": "bool check(long long k, long long n) {\n\tlong long sum = 0;\n\tlong long cur = n;\n\twhile (cur > 0) {\n\t\tlong long o = min(cur, k);\n\t\tsum += o;\n\t\tcur -= o;\n\t\tcur -= cur / 10;\n\t}\n\treturn sum * 2 >= n;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 9",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 10",
          "code": "... // read strings s[0] and s[1]\n\tint ans = 0;\n\tint previous = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tif (current == 0)\n\t\t\tprevious = 0;\n\t\tif (current == 1) {\n\t\t\tif (previous == 2) {\n\t\t\t\tans++;\n\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 1;\n\t\t}\n\t\tif (current == 2) {\n\t\t\tif (previous > 0) {\n\t\t\t\tans++;\n\t\t\t\tif (previous == 2)\n\t\t\t\t\tprevious = 1;\n\t\t\t\telse\n\t\t\t\t\tprevious = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tprevious = 2;\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 11",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 12",
          "code": "int ans = 0;\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint current = (s[0][i] == '0') + (s[1][i] == '0');\n\t\tempty += current;\n\t\tif (empty >= 3) {\n\t\t\tempty -= 3;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tempty = current;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 13",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 14",
          "code": "long long ans = 0;\n\tfor (int i = 1; i <= (1 << k); i++) {\n\t\tstring c;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif (i & (1 << j))\n\t\t\t\tc += n[j];\n\t\tans += getans(c);\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 15",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 16",
          "code": "long long fact[20];\nint c[10];\n\nvoid split(string s, int *c) {\n\tfor (int i = 0; i < 10; i++)\n\t\tc[i] = 0;\n\tfor (char ch : s)\n\t\tc[ch - 48]++;\n}\n\nlong long getCount() {\n\tlong long ans = fact[accumulate(c, c + 10, 0)];\n\tfor (int i = 0; i < 10; i++)\n\t\tans /= fact[c[i]];\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 17",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 18",
          "code": "long long getans(string s) {\n\tsplit(s, c);\n\n\t// check whether the string contains all digits\n\tfor (int i = 0; i < 10; i++)\n\t\tif (c0[i] && !c[i])\n\t\t\treturn 0;\n\n\t// check whether we already processed such string\n\tsort(s.begin(), s.end());\n\tif (was.count(s))\n\t\treturn 0;\n\twas.insert(s);\n\n\tlong long ans = getCount();\n\tif (c[0] > 0) {\n\t\tc[0]--;\n\t\tans -= getCount();\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 19",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 20",
          "code": "map<long long, string> m;\nset<long long> s[10];\n\nstring get(long long x) {\n\tif (m.count(x))\n\t\treturn m[x];\n\treturn toString(x);\n}\n\nvoid relax(long long x, string str) {\n\t// obviously not optimal\n\tif (x > n || str.length() >= getlen(x))\n\t\treturn;\n\n\t// already have better\n\tif (m.count(x) && m[x].length() <= str.length())\n\t\treturn;\n\n\ts[m[x].length()].erase(x);\n\tm[x] = str;\n\ts[str.length()].insert(x);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 21",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 22",
          "code": "void generatePowers() {\n\tfor (long long x = 2; x * x <= n; x++) {\n\t\tlong long c = x * x;\n\t\tint p = 2;\n\t\twhile (c <= n) {\n\t\t\tstring tmp = toString(x) + \"^\" + toString(p);\n\t\t\trelax(c, tmp);\n\t\t\tc *= x;\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 23",
          "code": "x = a^b*c^d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 24",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 25",
          "code": "void generatePowerAndPower(int maxlen) {\n\tfor (int i = 1; i <= maxlen; i++)\n\t\tfor (int j = i; i + j + 1 <= maxlen; j++)\n\t\t\tfor (auto x : s[i])\n\t\t\t\tfor (auto y : s[j])\n\t\t\t\t\trelax(x * y, get(x) + \"*\" + get(y));\n}\n\nvoid generateSimpleAndPower(int maxlen) {\n\tfor (int i = 1; i + 2 <= maxlen; i++)\n\t\tfor (long long x = 1; x < p10[maxlen - 1 - i]; x++)\n\t\t\tfor (long long y : s[i])\n\t\t\t\trelax(x * y, toString(x) + \"*\" + get(y));\n}\n\nvoid precalc() {\n\tgeneratePowers();\n\tgeneratePowerAndPower(7);\n\tgenerateSimpleAndPower(7);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 26",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 27",
          "code": "string ans;\nvoid relaxAns(string s) {\n\tif (ans.length() > s.length())\n\t\tans = s;\n}\n\nvoid check2() {\n\tfor (int i = 1; i * 2 + 1 < ans.length(); i++) {\n\t\tfor (long long x = 1; x <= p10[i]; x++) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t\tfor (auto x : s[i]) {\n\t\t\trelaxAns(get(n - x) + \"+\" + get(x));\n\t\t\tif (n % x == 0)\n\t\t\t\trelaxAns(get(n / x) + \"*\" + get(x));\n\t\t}\n\t}\n}\n\nint main() {\n\t... // read n, calculate powers of 10\n\tprecalc();\n\tans = get(n);\n\tcheck2();\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 28",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 29",
          "code": "find last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 30",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #491 (Div.2), Editorial - Codeforces - Code 31",
          "code": "lr\nfind last 5:  00000001111\narray:        11335556778\nfind first 5: 00001111111\n                 lr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60181",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 10000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 10000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1, 10000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstring expr;\nint pos;\nint expr_length;\nint minimal_length;\nconst ll MAXN = 10000000000LL;\nll n;\n\n// Forward declarations\nll parseExpression();\nll parseTerm();\nll parseFactor();\nll parseAtom();\nint getNumberLength(ll num);\n\n// Function to compute the minimal length of the notation for n\nvoid computeMinimalLength() {\n    minimal_length = to_string(n).length(); // Initialize with the length of the number itself\n\n    // Try exponentiation\n    for (int e = 2; e <= 64; e++) {\n        ll low = 2, high = powl(n, 1.0 / e) + 2;\n        for (ll base = low; base <= high; base++) {\n            // Check if base^e equals n\n            ll val = 1;\n            bool overflow = false;\n            for (int i = 0; i < e; i++) {\n                if (val > n / base) {\n                    overflow = true;\n                    break;\n                }\n                val *= base;\n            }\n            if (overflow)\n                break;\n            if (val == n) {\n                int length = to_string(base).length() + 1 + to_string(e).length(); // base^e\n                if (length < minimal_length) {\n                    minimal_length = length;\n                }\n            } else if (val > n) {\n                break;\n            }\n        }\n    }\n\n    // Try multiplication\n    for (ll a = 2; a * a <= n; a++) {\n        if (n % a == 0) {\n            ll b = n / a;\n            int length = to_string(a).length() + 1 + to_string(b).length(); // a*b\n            if (length < minimal_length) {\n                minimal_length = length;\n            }\n        }\n    }\n\n    // Addition is unlikely to produce shorter expressions than the number itself\n}\n\n// Function to parse and evaluate the participant's expression\nll parseExpression() {\n    ll value = parseTerm();\n    while (pos < expr.length() && expr[pos] == '+') {\n        pos++; expr_length++; // Skip '+'\n        ll term_value = parseTerm();\n        if (value > MAXN - term_value)\n            quitf(_wa, \"Overflow during evaluation\");\n        value += term_value;\n    }\n    return value;\n}\n\nll parseTerm() {\n    ll value = parseFactor();\n    while (pos < expr.length() && expr[pos] == '*') {\n        pos++; expr_length++; // Skip '*'\n        ll factor_value = parseFactor();\n        if (value > MAXN / factor_value)\n            quitf(_wa, \"Overflow during evaluation\");\n        value *= factor_value;\n    }\n    return value;\n}\n\nll parseFactor() {\n    ll value = parseAtom();\n    if (pos < expr.length() && expr[pos] == '^') {\n        pos++; expr_length++; // Skip '^'\n        ll exponent = parseAtom();\n        if (exponent < 0)\n            quitf(_wa, \"Negative exponent is not allowed\");\n        ll base = value;\n        value = 1;\n        for (int i = 0; i < exponent; i++) {\n            if (value > MAXN / base)\n                quitf(_wa, \"Overflow during exponentiation\");\n            value *= base;\n        }\n    }\n    return value;\n}\n\nll parseAtom() {\n    if (pos >= expr.length())\n        quitf(_wa, \"Unexpected end of expression\");\n\n    if (!isdigit(expr[pos]))\n        quitf(_wa, \"Invalid character '%c' at position %d\", expr[pos], pos);\n\n    // Parse number\n    int start_pos = pos;\n    while (pos < expr.length() && isdigit(expr[pos])) {\n        pos++; expr_length++;\n    }\n    string num_str = expr.substr(start_pos, pos - start_pos);\n    if (num_str.length() > 11) // Max length of 10^10 is 11 digits\n        quitf(_wa, \"Number too large\");\n\n    ll num = atoll(num_str.c_str());\n    if (num < 0 || num > MAXN)\n        quitf(_wa, \"Number out of range\");\n\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readLong(1LL, MAXN);\n\n    expr = ouf.readToken(); // Read participant's expression\n    expr_length = 0;\n    pos = 0;\n\n    // Check for invalid characters\n    for (char c : expr) {\n        if (!isdigit(c) && c != '+' && c != '*' && c != '^')\n            quitf(_wa, \"Invalid character '%c' in expression\", c);\n    }\n\n    // Parse and evaluate the expression\n    ll result = parseExpression();\n\n    if (pos != expr.length())\n        quitf(_wa, \"Invalid expression format\");\n\n    if (result != n)\n        quitf(_wa, \"Expression evaluates to %lld instead of %lld\", result, n);\n\n    // Compute the minimal possible length\n    computeMinimalLength();\n\n    if (expr_length > minimal_length)\n        quitf(_wa, \"Expression is not minimal, length %d > minimal length %d\", expr_length, minimal_length);\n\n    // If all checks pass\n    quitf(_ok, \"Correct expression with minimal length %d\", minimal_length);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int test_case = opt<int>(\"testcase\");\n\n    long long n = 0;\n    switch(test_case) {\n        case 1:\n            n = 1;\n            break;\n        case 2:\n            n = 2;\n            break;\n        case 3:\n            n = 2018;\n            break;\n        case 4:\n            n = 1000000007LL;\n            break;\n        case 5:\n            n = 10000000000LL;\n            break;\n        case 6:\n            n = 2000000000LL;\n            break;\n        case 7:\n            n = 10;\n            break;\n        case 8:\n            n = 10000000000LL; // 10^10, can be represented as 100^5 or 10^10\n            break;\n        case 9:\n            n = 9999999999LL;\n            break;\n        case 10:\n            n = 10000000001LL; // exceeds max, adjust\n            n = 10000000000LL;\n            break;\n        case 11:\n            n = 4294967291LL; // A large prime number\n            break;\n        case 12:\n            n = 9876543210LL;\n            break;\n        case 13:\n            n = 1024LL; // 2^10\n            break;\n        case 14:\n            n = 3125LL; // 5^5\n            break;\n        case 15:\n            n = 16807LL; // 7^5\n            break;\n        case 16:\n            n = 1000003LL; // A 7-digit prime\n            break;\n        case 17:\n            n = rnd.next(1LL, 100LL); // Random small n\n            break;\n        case 18:\n            n = rnd.next(100LL, 100000LL); // Random medium n\n            break;\n        case 19:\n            n = rnd.next(100000LL, 100000000LL); // Random large n\n            break;\n        case 20:\n            n = rnd.next(100000000LL, 10000000000LL); // Random very large n\n            break;\n        case 21:\n            n = 999983LL; // Large prime near 1e6\n            break;\n        case 22:\n            n = rnd.next(1LL, 10000000000LL); // Random n\n            break;\n        case 23:\n            n = 123456789LL;\n            break;\n        case 24:\n            n = 1002003004LL; // Random number with zeros\n            break;\n        case 25:\n            n = 1000000009LL; // Another large prime\n            break;\n        case 26:\n            n = 982451653LL; // Large prime number\n            break;\n        case 27:\n            n = 67280421310721LL; // Exceeds max, adjust\n            n = 10000000000LL;\n            break;\n        case 28:\n            n = 2147483647LL; // Max 32-bit signed integer\n            break;\n        case 29:\n            n = 4294967295LL; // Max 32-bit unsigned integer\n            break;\n        case 30:\n            n = 999999937LL; // Large prime\n            break;\n        default:\n            n = rnd.next(1LL, 10000000000LL);\n    }\n    cout << n << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int test_case = opt<int>(\"testcase\");\n\n    long long n = 0;\n    switch(test_case) {\n        case 1:\n            n = 1;\n            break;\n        case 2:\n            n = 2;\n            break;\n        case 3:\n            n = 2018;\n            break;\n        case 4:\n            n = 1000000007LL;\n            break;\n        case 5:\n            n = 10000000000LL;\n            break;\n        case 6:\n            n = 2000000000LL;\n            break;\n        case 7:\n            n = 10;\n            break;\n        case 8:\n            n = 10000000000LL; // 10^10, can be represented as 100^5 or 10^10\n            break;\n        case 9:\n            n = 9999999999LL;\n            break;\n        case 10:\n            n = 10000000001LL; // exceeds max, adjust\n            n = 10000000000LL;\n            break;\n        case 11:\n            n = 4294967291LL; // A large prime number\n            break;\n        case 12:\n            n = 9876543210LL;\n            break;\n        case 13:\n            n = 1024LL; // 2^10\n            break;\n        case 14:\n            n = 3125LL; // 5^5\n            break;\n        case 15:\n            n = 16807LL; // 7^5\n            break;\n        case 16:\n            n = 1000003LL; // A 7-digit prime\n            break;\n        case 17:\n            n = rnd.next(1LL, 100LL); // Random small n\n            break;\n        case 18:\n            n = rnd.next(100LL, 100000LL); // Random medium n\n            break;\n        case 19:\n            n = rnd.next(100000LL, 100000000LL); // Random large n\n            break;\n        case 20:\n            n = rnd.next(100000000LL, 10000000000LL); // Random very large n\n            break;\n        case 21:\n            n = 999983LL; // Large prime near 1e6\n            break;\n        case 22:\n            n = rnd.next(1LL, 10000000000LL); // Random n\n            break;\n        case 23:\n            n = 123456789LL;\n            break;\n        case 24:\n            n = 1002003004LL; // Random number with zeros\n            break;\n        case 25:\n            n = 1000000009LL; // Another large prime\n            break;\n        case 26:\n            n = 982451653LL; // Large prime number\n            break;\n        case 27:\n            n = 67280421310721LL; // Exceeds max, adjust\n            n = 10000000000LL;\n            break;\n        case 28:\n            n = 2147483647LL; // Max 32-bit signed integer\n            break;\n        case 29:\n            n = 4294967295LL; // Max 32-bit unsigned integer\n            break;\n        case 30:\n            n = 999999937LL; // Large prime\n            break;\n        default:\n            n = rnd.next(1LL, 10000000000LL);\n    }\n    cout << n << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -testcase=1\n./gen -testcase=2\n./gen -testcase=3\n./gen -testcase=4\n./gen -testcase=5\n./gen -testcase=6\n./gen -testcase=7\n./gen -testcase=8\n./gen -testcase=9\n./gen -testcase=10\n./gen -testcase=11\n./gen -testcase=12\n./gen -testcase=13\n./gen -testcase=14\n./gen -testcase=15\n./gen -testcase=16\n./gen -testcase=17\n./gen -testcase=18\n./gen -testcase=19\n./gen -testcase=20\n./gen -testcase=21\n./gen -testcase=22\n./gen -testcase=23\n./gen -testcase=24\n./gen -testcase=25\n./gen -testcase=26\n./gen -testcase=27\n./gen -testcase=28\n./gen -testcase=29\n./gen -testcase=30\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:03.019887",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "992/A",
      "title": "A. Nastya and an Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the size of the array.The second line contains n integers a1, a2, ..., an ( - 105 ≤ ai ≤ 105) — the elements of the array.",
      "output_spec": "OutputPrint a single integer — the minimum number of seconds needed to make all elements of the array equal to zero.",
      "sample_tests": "ExamplesInputCopy51 1 1 1 1OutputCopy1InputCopy32 0 -1OutputCopy2InputCopy45 -6 -5 1OutputCopy4",
      "description": "A. Nastya and an Array\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the size of the array.The second line contains n integers a1, a2, ..., an ( - 105 ≤ ai ≤ 105) — the elements of the array.\n\nOutputPrint a single integer — the minimum number of seconds needed to make all elements of the array equal to zero.\n\nInputCopy51 1 1 1 1OutputCopy1InputCopy32 0 -1OutputCopy2InputCopy45 -6 -5 1OutputCopy4\n\nInputCopy51 1 1 1 1\n\nOutputCopy1\n\nInputCopy32 0 -1\n\nOutputCopy2\n\nInputCopy45 -6 -5 1\n\nOutputCopy4\n\nNoteIn the first example you can add  - 1 to all non-zero elements in one second and make them equal to zero.In the second example you can add  - 2 on the first second, then the array becomes equal to [0, 0,  - 3]. On the second second you can add 3 to the third (the only non-zero) element.",
      "solutions": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces",
          "content": "Hi, Codeforces! I'm glad to invite everybody to the #489 Codeforces Round, which will be held as soon as tomorrow, on Monday, June 18, 2018 at 19:35. The round will be rated for all participants from the second division (with rating below than 2100). As usually, we will be glad to see participants from the first division out of competition!Problems for the round have been invented and prepared by us, pupils of Moscow school №2007, Dmitry DmitryGrigorev Grigorev and Fedor ---------- Ushakov. We want to give thanks to Andrew GreenGrape Raiskiy for his aid in preparing and testing of the problems, to Ildar 300iq Gainullin and to AmirReza Arpa PoorAkhavan who have tested our problems too and to the coordinator Nikolay KAN Kalinin, since our sometimes strange and undeveloped ideas have become eventually the Codeforces round. Also, we say thank you to Mike MikeMirzayanov Mirzayanov for his unbelievable Codeforces and Polygon platforms.You will receive 5 problems and 2 hours for solving it. During the round you will be helping for an extraordinary girl Nastya, who has been living in Byteland and sometimes receives very strange gifts for her birthday :). Score distribution will be announced, traditionally, closer to the start of the contest.We're holding our the first and, I hope, not the last round in Codeforces, so I hope a lot you will like our problems. Please, read all the problems. Anyway, I wish luck and high rating for all the participants!I'm looking forward your participation.UPD Score distribution is standart — 500-1000-1500-2000-2500UPD2 Thank you for your participation in the contest! It's very-very pleasant for me if you like the problems, and I'm sorry if you don't :) I hope the next my contest will be even better, than this. Thank you for all!List of the winners of the contest:Div.2 sminem NguoiHocTinLoai2 YaKon4ick HanaElhami pajenegod Div.1 + Div.2 dotorya Benq anta sminem kevinsogo My frank congratulations for all the winners!UPD3Editorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60050",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1992
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces",
          "content": "All the problems have been prepared by us, — DmitryGrigorev and ----------.(Idea of the problem — DmitryGrigorev) 992A - Nastya and an ArrayLet's notice that after one second we aren't able to decrease the number of distinct non-zero elements in the array more than by 1. It means that we can't make all elements equal to zero faster than after seconds, where is the number of distinct elements in the array initially. And let's notice that we are able to make it surely after second, if we will subtract every second some number which is in the array, so all elements equal this number in the array will have become zero, and the number of distinct non-zero elements will be decreased.So the answer is the number of distinct non-zero elements initially. Complexity is Code — 39423470(Idea of the problem — GreenGrape) Tutorial is loading...Code — 39423481(Idea of the problem — ----------) Tutorial is loading...Code — 39423497(Idea of the problem — DmitryGrigorev) 992D - Nastya and a GameLet's call numbers which are more than 1 as good. Notice the following fact:If a subsegment is suitable, it contains not more than 60 good numbers.Indeed, let's assume that a subsegment contains more than 60 good numbers. In this subsegment . At the same time, as , and , there is . Therefore, this subsegment can't be suitable due to .Let's keep all positions of good numbers in a sorted array. We sort out possible left border of a subsegment and then with binary search we find the next good number to the right of this left border. Then let's iterate from this found number to the right by the good numbers(that is we sort out the rightmost good number in a subsegment), until product of all numbers in the subsegment becomes more than (it's flag which shows us, that product is too big for a suitable subsgment and we need to finish to iterate). We have shown above the number of iterations isn't more than 60. Now for sorted out the left border and the rightmost good number we only need to know the number of 1's which needs to be added to the right of the rightmost good number, as we can easily maintain sum and product in the subsegment during iterating. Then we need to check whether found number of 1's exists to the right of the rightmost good number. It can be checked if we look at the next good number's position.Complexity is .In order to check that is more than , you shouldn't calculate multiply by , due to overflow. You must only check that .(Idea of the problem — DmitryGrigorev)Code — 39423501 Tutorial is loading...Code of the solution I — 39423519Code of the solution II — 39418926. Try to optimize :)Thank you tfg for the idea and the code of the solution III. Very good job!Code of the solution III — 39392321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 992\\s*A"
          },
          "content_length": 2727
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 1",
          "code": "in form a*x and second is in b*y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 2",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 3",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 4",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 5",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 6",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 7",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 8",
          "code": "1000000000 1000000000 1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 9",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 10",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 11",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 12",
          "code": "if x==0 or x%1000000007==0:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 13",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 14",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 15",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 17",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 18",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 19",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 20",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 21",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 22",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 23",
          "code": "lcm(a, b) = a * b /  gcd(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 24",
          "code": "lcm(a, b) = a / gcd(a, b) * b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 25",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 26",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 27",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 28",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 29",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 30",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 31",
          "code": "if(l <= Node[u].l && Node[u].r <= r) return Node[u].sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 2",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 3",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 4",
          "code": "We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least p[i]. It can be done using segment tree with maximums, with descent.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 5",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 6",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -100000, 100000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -100000, 100000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -100000, 100000, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"zeros\") {\n        // All elements are zero\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"ones\") {\n        // All elements are one\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"minus_ones\") {\n        // All elements are -1\n        fill(a.begin(), a.end(), -1);\n    } else if (type == \"max\") {\n        // All elements are maximum value\n        fill(a.begin(), a.end(), 100000);\n    } else if (type == \"min\") {\n        // All elements are minimum value\n        fill(a.begin(), a.end(), -100000);\n    } else if (type == \"alternating\") {\n        // Elements alternate between positives and negatives\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 100000);\n            } else {\n                a[i] = -rnd.next(1, 100000);\n            }\n        }\n    } else if (type == \"singleton_zero\") {\n        // All elements non-zero, except one zero\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000, 100000);\n            if (a[i] == 0) a[i] = 1;\n        }\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 0;\n    } else if (type == \"singleton_nonzero\") {\n        // All zeros except for one non-zero element\n        fill(a.begin(), a.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = rnd.next(-100000, 100000);\n        if (a[pos] == 0) a[pos] = 1; // Ensure it's non-zero\n    } else if (type == \"few_nonzero\") {\n        // Few non-zero elements\n        fill(a.begin(), a.end(), 0);\n        int k = opt<int>(\"k\", 1); // Number of non-zero elements\n        ensuref(k <= n, \"k should be less than or equal to n\");\n        for (int i = 0; i < k; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(0, n - 1);\n            } while (a[pos] != 0);\n            a[pos] = rnd.next(-100000, 100000);\n            if (a[pos] == 0) a[pos] = 1;\n        }\n    } else if (type == \"large_positive\") {\n        // All elements are large positive numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(50000, 100000);\n        }\n    } else if (type == \"large_negative\") {\n        // All elements are large negative numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = -rnd.next(50000, 100000);\n        }\n    } else if (type == \"mixed_large\") {\n        // Elements are randomly large positive or negative values\n        for (int i = 0; i < n; ++i) {\n            int sign = rnd.next(0, 1) == 0 ? 1 : -1;\n            a[i] = sign * rnd.next(50000, 100000);\n        }\n    } else if (type == \"small_values\") {\n        // Elements are small integers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10, 10);\n        }\n    } else if (type == \"patterned\") {\n        // Elements follow a specific pattern\n        string pattern = opt<string>(\"pattern\", \"incr\");\n        if (pattern == \"incr\") {\n            for (int i = 0; i < n; ++i) {\n                a[i] = i;\n            }\n        } else if (pattern == \"decr\") {\n            for (int i = 0; i < n; ++i) {\n                a[i] = n - i;\n            }\n        } else {\n            // default to zeros\n            fill(a.begin(), a.end(), 0);\n        }\n    } else if (type == \"random\") {\n        // Random elements within constraints\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000, 100000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000, 100000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"zeros\") {\n        // All elements are zero\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"ones\") {\n        // All elements are one\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"minus_ones\") {\n        // All elements are -1\n        fill(a.begin(), a.end(), -1);\n    } else if (type == \"max\") {\n        // All elements are maximum value\n        fill(a.begin(), a.end(), 100000);\n    } else if (type == \"min\") {\n        // All elements are minimum value\n        fill(a.begin(), a.end(), -100000);\n    } else if (type == \"alternating\") {\n        // Elements alternate between positives and negatives\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 100000);\n            } else {\n                a[i] = -rnd.next(1, 100000);\n            }\n        }\n    } else if (type == \"singleton_zero\") {\n        // All elements non-zero, except one zero\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000, 100000);\n            if (a[i] == 0) a[i] = 1;\n        }\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 0;\n    } else if (type == \"singleton_nonzero\") {\n        // All zeros except for one non-zero element\n        fill(a.begin(), a.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        a[pos] = rnd.next(-100000, 100000);\n        if (a[pos] == 0) a[pos] = 1; // Ensure it's non-zero\n    } else if (type == \"few_nonzero\") {\n        // Few non-zero elements\n        fill(a.begin(), a.end(), 0);\n        int k = opt<int>(\"k\", 1); // Number of non-zero elements\n        ensuref(k <= n, \"k should be less than or equal to n\");\n        for (int i = 0; i < k; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(0, n - 1);\n            } while (a[pos] != 0);\n            a[pos] = rnd.next(-100000, 100000);\n            if (a[pos] == 0) a[pos] = 1;\n        }\n    } else if (type == \"large_positive\") {\n        // All elements are large positive numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(50000, 100000);\n        }\n    } else if (type == \"large_negative\") {\n        // All elements are large negative numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = -rnd.next(50000, 100000);\n        }\n    } else if (type == \"mixed_large\") {\n        // Elements are randomly large positive or negative values\n        for (int i = 0; i < n; ++i) {\n            int sign = rnd.next(0, 1) == 0 ? 1 : -1;\n            a[i] = sign * rnd.next(50000, 100000);\n        }\n    } else if (type == \"small_values\") {\n        // Elements are small integers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10, 10);\n        }\n    } else if (type == \"patterned\") {\n        // Elements follow a specific pattern\n        string pattern = opt<string>(\"pattern\", \"incr\");\n        if (pattern == \"incr\") {\n            for (int i = 0; i < n; ++i) {\n                a[i] = i;\n            }\n        } else if (pattern == \"decr\") {\n            for (int i = 0; i < n; ++i) {\n                a[i] = n - i;\n            }\n        } else {\n            // default to zeros\n            fill(a.begin(), a.end(), 0);\n        }\n    } else if (type == \"random\") {\n        // Random elements within constraints\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000, 100000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100000, 100000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type ones\n./gen -n 1 -type minus_ones\n./gen -n 1 -type max\n./gen -n 1 -type min\n./gen -n 1 -type random\n\n./gen -n 5 -type zeros\n./gen -n 5 -type ones\n./gen -n 5 -type minus_ones\n./gen -n 5 -type alternating\n./gen -n 5 -type singleton_zero\n./gen -n 5 -type singleton_nonzero\n./gen -n 5 -type few_nonzero -k 2\n./gen -n 5 -type random\n\n./gen -n 100 -type zeros\n./gen -n 100 -type ones\n./gen -n 100 -type alternating\n./gen -n 100 -type singleton_zero\n./gen -n 100 -type singleton_nonzero\n./gen -n 100 -type few_nonzero -k 5\n./gen -n 100 -type large_positive\n./gen -n 100 -type large_negative\n./gen -n 100 -type random\n\n./gen -n 100000 -type zeros\n./gen -n 100000 -type ones\n./gen -n 100000 -type minus_ones\n./gen -n 100000 -type alternating\n./gen -n 100000 -type singleton_nonzero\n./gen -n 100000 -type singleton_zero\n./gen -n 100000 -type few_nonzero -k 10\n./gen -n 100000 -type large_positive\n./gen -n 100000 -type large_negative\n./gen -n 100000 -type mixed_large\n./gen -n 100000 -type small_values\n./gen -n 100000 -type random\n./gen -n 100000 -type max\n./gen -n 100000 -type min\n\n./gen -n 100000 -type patterned -pattern incr\n./gen -n 100000 -type patterned -pattern decr\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:05.209957",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "992/B",
      "title": "B. Nastya Studies Informatics",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains four integers l, r, x, y (1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ y ≤ 109).",
      "output_spec": "OutputIn the only line print the only integer — the answer for the problem.",
      "sample_tests": "ExamplesInputCopy1 2 1 2OutputCopy2InputCopy1 12 1 12OutputCopy4InputCopy50 100 3 30OutputCopy0",
      "description": "B. Nastya Studies Informatics\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains four integers l, r, x, y (1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ y ≤ 109).\n\nOutputIn the only line print the only integer — the answer for the problem.\n\nInputCopy1 2 1 2OutputCopy2InputCopy1 12 1 12OutputCopy4InputCopy50 100 3 30OutputCopy0\n\nInputCopy1 2 1 2\n\nOutputCopy2\n\nInputCopy1 12 1 12\n\nOutputCopy4\n\nInputCopy50 100 3 30\n\nOutputCopy0\n\nNoteIn the first example there are two suitable good pairs of integers (a, b): (1, 2) and (2, 1).In the second example there are four suitable good pairs of integers (a, b): (1, 12), (12, 1), (3, 4) and (4, 3).In the third example there are good pairs of integers, for example, (3, 30), but none of them fits the condition l ≤ a, b ≤ r.",
      "solutions": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces",
          "content": "Hi, Codeforces! I'm glad to invite everybody to the #489 Codeforces Round, which will be held as soon as tomorrow, on Monday, June 18, 2018 at 19:35. The round will be rated for all participants from the second division (with rating below than 2100). As usually, we will be glad to see participants from the first division out of competition!Problems for the round have been invented and prepared by us, pupils of Moscow school №2007, Dmitry DmitryGrigorev Grigorev and Fedor ---------- Ushakov. We want to give thanks to Andrew GreenGrape Raiskiy for his aid in preparing and testing of the problems, to Ildar 300iq Gainullin and to AmirReza Arpa PoorAkhavan who have tested our problems too and to the coordinator Nikolay KAN Kalinin, since our sometimes strange and undeveloped ideas have become eventually the Codeforces round. Also, we say thank you to Mike MikeMirzayanov Mirzayanov for his unbelievable Codeforces and Polygon platforms.You will receive 5 problems and 2 hours for solving it. During the round you will be helping for an extraordinary girl Nastya, who has been living in Byteland and sometimes receives very strange gifts for her birthday :). Score distribution will be announced, traditionally, closer to the start of the contest.We're holding our the first and, I hope, not the last round in Codeforces, so I hope a lot you will like our problems. Please, read all the problems. Anyway, I wish luck and high rating for all the participants!I'm looking forward your participation.UPD Score distribution is standart — 500-1000-1500-2000-2500UPD2 Thank you for your participation in the contest! It's very-very pleasant for me if you like the problems, and I'm sorry if you don't :) I hope the next my contest will be even better, than this. Thank you for all!List of the winners of the contest:Div.2 sminem NguoiHocTinLoai2 YaKon4ick HanaElhami pajenegod Div.1 + Div.2 dotorya Benq anta sminem kevinsogo My frank congratulations for all the winners!UPD3Editorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60050",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1992
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces",
          "content": "All the problems have been prepared by us, — DmitryGrigorev and ----------.(Idea of the problem — DmitryGrigorev) 992A - Nastya and an ArrayLet's notice that after one second we aren't able to decrease the number of distinct non-zero elements in the array more than by 1. It means that we can't make all elements equal to zero faster than after seconds, where is the number of distinct elements in the array initially. And let's notice that we are able to make it surely after second, if we will subtract every second some number which is in the array, so all elements equal this number in the array will have become zero, and the number of distinct non-zero elements will be decreased.So the answer is the number of distinct non-zero elements initially. Complexity is Code — 39423470(Idea of the problem — GreenGrape) 992B - Nastya Studies InformaticsLet's consider some suitable pair . As , we can present number as , and number as , where we know that and .Let's consider too that from the restriction from the problem we surely know the restriction for and , that is . Let's remember we know that (because is , is ). Then we can get . Dividing by :..Now if , answer equals 0.Else as is surely less than , we can just sort out all possible pairs of divisors , such that , and then to check that and are in the getting above restrictions. Complexity of this solution is .Code — 39423481(Idea of the problem — ----------) 992C - Nastya and a WardrobeLet's present we have initially dresses.What does occur in the first month? Initially the number of dresses is multiplied by 2, that is becomes . Then with probability the wardrobe eats a dress, that is expected value of the number of dresses becomes . The same way after the second month expected value becomes . It's easy to notice that after -th month(if ) expected value equals . Eventually it will be only doubled(as the wardrobe doesn't eat a dress in the last month), that is will be equal .Thus, answer of the problem is . Expressing it with , we get: = . = .Thus, we need to calculate degree of 2 right up to . Complexity of the soltion is .Let's notice that the case we need to calculate separately, because wardrobe can't eat a dress when it doesn't exist. If it's easy to proof that the number of dresses is never negative, that is the formula works.Code — 39423497(Idea of the problem — DmitryGrigorev) 992D - Nastya and a GameLet's call numbers which are more than 1 as good. Notice the following fact:If a subsegment is suitable, it contains not more than 60 good numbers.Indeed, let's assume that a subsegment contains more than 60 good numbers. In this subsegment . At the same time, as , and , there is . Therefore, this subsegment can't be suitable due to .Let's keep all positions of good numbers in a sorted array. We sort out possible left border of a subsegment and then with binary search we find the next good number to the right of this left border. Then let's iterate from this found number to the right by the good numbers(that is we sort out the rightmost good number in a subsegment), until product of all numbers in the subsegment becomes more than (it's flag which shows us, that product is too big for a suitable subsgment and we need to finish to iterate). We have shown above the number of iterations isn't more than 60. Now for sorted out the left border and the rightmost good number we only need to know the number of 1's which needs to be added to the right of the rightmost good number, as we can easily maintain sum and product in the subsegment during iterating. Then we need to check whether found number of 1's exists to the right of the rightmost good number. It can be checked if we look at the next good number's position.Complexity is .In order to check that is more than , you shouldn't calculate multiply by , due to overflow. You must only check that .(Idea of the problem — DmitryGrigorev)Code — 39423501 992E - Nastya and King-ShamansThis problem was inspired by idea which was offered by my unbelievable girlfriend :)Solution IIn this problem we maintain two segment trees - with maximum and with sum. After every query we recalculate these trees in for a query. Now we only have to understand, how to answer for a query? Let's call a prefix of the array as good in the case if we surely know that it doesn't contain a king-shaman. So either the first shaman is king and we are able to answer for the query, or we call the prefix with length 1 as good. Then let's repeat the following operation: We call as sum in the good prefix now. We find it using the segment tree with sums. We find the leftmost element which may be king-shaman yet. We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least . It can be done using segment tree with maximums, with descent. We check if this found shaman is king. If isn't, we can say that the good prefix finishes in this shaman now, because it was the leftmost shaman who might be king. Every operation works in . Let's notice, that one operation increases sum in the good prefix at least by two times. So, after operations sum in the good prefix will become more than a maximal possible number in the array, so that we will be able to finish, because we will be sure that answer will be -1. Complexity of the solution is .Solution IILet pi be the prefix sums of a. We're gonna introduce fi = pi - 2·ai and reformulate the queries using these new terms. Imagine we wanna change the value at j to val. Let δ = val - aj. Then fj will decrease by δ whereas fi > j will increase by δ. Imagine we wanna find the answer. Then it's sufficient to find any i satisfying fi = 0. Split f into blocks of size M. Each block will be comprised of pairs (fi, i) sorted by f. At the same time we will maintain overhead array responsible for lazy additions to blocks. How does this help? Let b = j / M. The goal is to find the position of j, decrease its value and increase values for all i > j within this block. It can be done in a smart way in O(M) (actually, this can be represented as merging sorted vectors). You should also take care of the tail, i.e add δ to overheadj > b in O(n / M) time. We're asked to find such i that fi + overheadj / M = 0. All blocks are sorted, thus we can simply apply binary search in overall. The optimal assignment is which results into total runtime. The huge advantage of this approach is its independency from constraints on a (i.e non-negativity). Although we didn't succeed in squeezing this into TL :)Solution IIIGroup the numbers according to their highest bits (with groups of the form [2k... 2k + 1] and separately for zeros). Inside each groups (no more than of them) we maintain elements in increasing order of indexes. It's easy to see that each group contains no more than two candidates for answer (since their sum is guaranteed to be greater than any of the remaining ones). This observation leads to an easy solution in  — we iterate over groups and check prefix sums for these candidates.There's actually further space for optimizations. Let's maintain prefix sums for our candidates — this allows us to get rid of the extra log when quering the tree. Almost everything we need at this step is to somehow process additions and deletions — change the order inside two blocks and probably recalculate prefix sums. The only thing left is to stay aware of prefix sum changes for the remaining blocks. Luckily, they can be fixed in O(1) per block (if i > j then the sum increases by val - aj and stays the same otherwise). The resulting comlexity is .Code of the solution I — 39423519Code of the solution II — 39418926. Try to optimize :)Thank you tfg for the idea and the code of the solution III. Very good job!Code of the solution III — 39392321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 992\\s*B"
          },
          "content_length": 7832
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 1",
          "code": "in form a*x and second is in b*y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 2",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 3",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 4",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 5",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 6",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 7",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 8",
          "code": "1000000000 1000000000 1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 9",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 10",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 11",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 12",
          "code": "if x==0 or x%1000000007==0:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 13",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 14",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 15",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 17",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 18",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 19",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 20",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 21",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 22",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 23",
          "code": "lcm(a, b) = a * b /  gcd(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 24",
          "code": "lcm(a, b) = a / gcd(a, b) * b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 25",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 26",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 27",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 28",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 29",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 30",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 31",
          "code": "if(l <= Node[u].l && Node[u].r <= r) return Node[u].sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 2",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 3",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 4",
          "code": "We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least p[i]. It can be done using segment tree with maximums, with descent.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 5",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 6",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(l, 1000000000, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(x, 1000000000, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(l, 1000000000, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(x, 1000000000, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int r = inf.readInt(l, 1000000000, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(x, 1000000000, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    ll n = opt<ll>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ll l, r, x, y;\n\n    if (type == \"min_l_r\") {\n        /* l and r are minimal */\n        l = 1;\n        r = 1;\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x));\n    } else if (type == \"max_l_r\") {\n        /* l and r are maximal */\n        l = n;\n        r = n;\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x));\n    } else if (type == \"zero_answer\") {\n        /* Generate test case where the answer is zero */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x)) + 1; // y not multiple of x\n        if (y > n) y = n;\n    } else if (type == \"large_answer\") {\n        /* Generate test case where the answer is large */\n        l = 1;\n        r = n;\n        ll small_k = rnd.next(2LL, min(n, 1000LL));\n        ll k = small_k * small_k;\n        x = 1;\n        y = x * k;\n        if (y > n) y = n;\n    } else if (type == \"x_equals_y\") {\n        /* Generate test case where x equals y */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(1LL, n);\n        y = x;\n    } else if (type == \"x_not_divide_y\") {\n        /* Generate test case where x does not divide y */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(2LL, n); // x >= 2\n        if (x == n) x = n - 1;\n        y = x * rnd.next(1LL, n / x) + rnd.next(1LL, x - 1);\n        if (y > n) y = n;\n    } else if (type == \"small_values\") {\n        /* Generate test case with small values */\n        l = 1;\n        r = n;\n        x = rnd.next(1LL, min(n, 100LL));\n        y = x * rnd.next(1LL, min(100LL, n / x));\n    } else {\n        /* Random test case */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x));\n    }\n\n    /* Ensure inputs are within the constraints */\n    l = max(1LL, min(l, n));\n    r = max(l, min(r, n));\n    x = max(1LL, min(x, n));\n    y = max(x, min(y, n));\n\n    printf(\"%lld %lld %lld %lld\\n\", l, r, x, y);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    ll n = opt<ll>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ll l, r, x, y;\n\n    if (type == \"min_l_r\") {\n        /* l and r are minimal */\n        l = 1;\n        r = 1;\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x));\n    } else if (type == \"max_l_r\") {\n        /* l and r are maximal */\n        l = n;\n        r = n;\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x));\n    } else if (type == \"zero_answer\") {\n        /* Generate test case where the answer is zero */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x)) + 1; // y not multiple of x\n        if (y > n) y = n;\n    } else if (type == \"large_answer\") {\n        /* Generate test case where the answer is large */\n        l = 1;\n        r = n;\n        ll small_k = rnd.next(2LL, min(n, 1000LL));\n        ll k = small_k * small_k;\n        x = 1;\n        y = x * k;\n        if (y > n) y = n;\n    } else if (type == \"x_equals_y\") {\n        /* Generate test case where x equals y */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(1LL, n);\n        y = x;\n    } else if (type == \"x_not_divide_y\") {\n        /* Generate test case where x does not divide y */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(2LL, n); // x >= 2\n        if (x == n) x = n - 1;\n        y = x * rnd.next(1LL, n / x) + rnd.next(1LL, x - 1);\n        if (y > n) y = n;\n    } else if (type == \"small_values\") {\n        /* Generate test case with small values */\n        l = 1;\n        r = n;\n        x = rnd.next(1LL, min(n, 100LL));\n        y = x * rnd.next(1LL, min(100LL, n / x));\n    } else {\n        /* Random test case */\n        l = rnd.next(1LL, n);\n        r = rnd.next(l, n);\n        x = rnd.next(1LL, n);\n        y = x * rnd.next(1LL, max(1LL, n / x));\n    }\n\n    /* Ensure inputs are within the constraints */\n    l = max(1LL, min(l, n));\n    r = max(l, min(r, n));\n    x = max(1LL, min(x, n));\n    y = max(x, min(y, n));\n\n    printf(\"%lld %lld %lld %lld\\n\", l, r, x, y);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type small_values\n./gen -n 10 -type x_equals_y\n./gen -n 10 -type zero_answer\n\n./gen -n 100 -type small_values\n./gen -n 100 -type x_equals_y\n./gen -n 100 -type zero_answer\n\n./gen -n 1000 -type small_values\n./gen -n 1000 -type x_equals_y\n./gen -n 1000 -type zero_answer\n\n./gen -n 10000 -type small_values\n./gen -n 10000 -type x_equals_y\n./gen -n 10000 -type zero_answer\n\n./gen -n 100000 -type random\n./gen -n 100000 -type x_not_divide_y\n./gen -n 100000 -type large_answer\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type x_not_divide_y\n./gen -n 1000000 -type large_answer\n\n./gen -n 10000000 -type random\n./gen -n 10000000 -type x_not_divide_y\n./gen -n 10000000 -type large_answer\n\n./gen -n 100000000 -type random\n./gen -n 100000000 -type x_not_divide_y\n./gen -n 100000000 -type large_answer\n\n./gen -n 1000000000 -type random\n./gen -n 1000000000 -type min_l_r\n./gen -n 1000000000 -type max_l_r\n./gen -n 1000000000 -type small_values\n./gen -n 1000000000 -type x_equals_y\n./gen -n 1000000000 -type zero_answer\n./gen -n 1000000000 -type x_not_divide_y\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:07.237624",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "992/C",
      "title": "C. Настя и платяной шкаф",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке вводятся два целых числа x и k (0 ≤ x, k ≤ 1018), где x — начальное количество платьев, а k + 1 — количество месяцев в году Байтландии.",
      "output_spec": "Выходные данныеВ единственной строке выведите одно число — математическое ожидание количества платьев у Насти через год по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 0Выходные данныеСкопировать4Входные данныеСкопировать2 1Выходные данныеСкопировать7Входные данныеСкопировать3 2Выходные данныеСкопировать21",
      "description": "C. Настя и платяной шкаф\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке вводятся два целых числа x и k (0 ≤ x, k ≤ 1018), где x — начальное количество платьев, а k + 1 — количество месяцев в году Байтландии.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите одно число — математическое ожидание количества платьев у Насти через год по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать2 0Выходные данныеСкопировать4Входные данныеСкопировать2 1Выходные данныеСкопировать7Входные данныеСкопировать3 2Выходные данныеСкопировать21\n\nВходные данныеСкопировать2 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте год в Байтландии длится один месяц, таким образом, шкаф никогда не ест платья.Во втором тесте после первого месяца с вероятностью 50% в шкафу 3 платья, и с вероятностью 50% 4 платья. Тогда в конце года в шкафу с вероятностью 50% 6 платьев, и с вероятностью 50% 8 платьев. Таким образом, ответ на данный тест равен (6 + 8) / 2 = 7.",
      "solutions": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces",
          "content": "Привет, Codeforces!Я рад пригласить всех на раунд #489 Codeforces, который состоится уже завтра, в понедельник, 18 июня 2018 г. в 19:35. Раунд будет рейтинговым для всех участников из второго дивизиона (то есть для участников с рейтингом меньше, чем 2100). Как обычно, мы будем очень рады видеть всех участников из первого дивизиона на нашем контесте вне конкурса!Задачи на этот раунд придумывали и готовили мы, ученики московской школы №2007, Дмитрий DmitryGrigorev Григорьев и Фёдор ---------- Ушаков. Большое спасибо Андрею GreenGrape Райскому за помощь в подготовке задач и тестировании раунда, Ильдару 300iq Гайнуллину и Амиррезе Arpa Пурахавану за помощь в тестировании раунда, а также координатору Николаю KAN Калинину за то, что наши зачастую странные и непродуманные идеи превратились в раунд Codeforces и, конечно, Михаилу MikeMirzayanov Мирзаянову за потрясающие платформы Codeforces и Polygon.Вам будет предложено 5 задач и 2 часа на их решение. На протяжении раунда вы будете помогать необычной девочке Насте, которая живет в Байтландии и которой на день рождения дарят очень странные подарки :). Разбалловка раунда будет традиционно объявлена ближе к раунду.Для нас обоих это первый и, надеюсь, не последний раунд на Codeforces, и я надеюсь, что вам понравятся наши задачи. Прочитайте условия всех задач. В любом случае, всем удачи и высокого рейтинга!Ждём завтра на контесте!UPD Разбалловка раунда стандартная — 500-1000-1500-2000-2500UPD2 Спасибо всем за участие в раунде! Я очень надеюсь, что наши задачи вам понравились; если нет, то я постараюсь порадовать вас на следующем своем контесте :).Список победителей контеста:Div.2 sminem NguoiHocTinLoai2 YaKon4ick HanaElhami pajenegod Div.1 + Div.2 dotorya Benq anta sminem kevinsogo Поздравляем всех победителей!UPD3Разбор тут",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60050",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1792
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces",
          "content": "Все задачи подготовлены нами — DmitryGrigorev и ----------.(Идея задачи — DmitryGrigorev) 992A - Настя и массивЗаметим, что за одно действие мы можем уменьшить количество различных ненулевых чисел, присутствующих в массиве, не более чем на один. Значит, сделать массив полностью из нулей нельзя за количество ходов меньшее, чем изначальное количество различных ненулевых чисел в массиве. Заметим, что мы можем сделать это ровно за количество различных ненулевых чисел в массиве, на каждом ходу вычитая из всех ненулевых чисел какое-либо присутствующее в массиве ненулевое число - таким образом количество различных ненулевых чисел каждый раз будет уменьшаться на один, так как то число, которое мы вычли, станет нулём.Итак, ответ - количество различных чисел в массиве. Асимптотика - Код — 39423470(Идея задачи — GreenGrape) 992B - Настя учит информатикуРассмотрим подходящую пару . Так как , то мы можем представить число как , а число как , где и .Заметим, что мы из ограничения точно знаем ограничение на и , а именно . Теперь вспомним, что (так как это , а это ). Из этого следует, что . Сокращая на , получим:..Теперь, если , то ответ равен 0.Иначе, так как точно меньше, чем , можно просто перебрать все пары делителей числа , таких что , а затем проверить, что и что лежат в заданных ограничениях. Перебрать все пары делителей числа можно за его корень, следовательно, асимптотика решения Код — 39423481(Идея задачи — ----------) 992C - Настя и платяной шкафПусть мы имеем изначально платьев.Что происходит в первый месяц? Изначально количество платьев удваивается, то есть становится равным . Затем с вероятностью шкаф съедает платье, то есть матожидание их количества становится равным . Аналогично после второго месяца матожидание количества платьев становится . Несложно заметить, что после -го месяца(при ) матожидание количества платьев будет равно . В конце матожидание просто умножится на два(так как шкаф не ест платья на Новый Год), то есть будет равно .Итак, ответ равен . Выразив через X, получим: = . = .Итак, для подсчета ответа нужно уметь возводить 2 в степень до . Асимптотика решения - .Заметим, что случай надо обработать отдельно, так как количество платьев не может стать отрицательным. При несложно доказать, что количество платьев ни в какой момент не уйдет в минус, и формула будет работать корректноКод — 39423497(Идея задачи — DmitryGrigorev) 992D - Настя и играНазовем числа, большие чем 1, хорошими. Тогда заметим следующий факт:Подходящий подотрезок не может содержать более 60 хороших чисел.Действительно, пусть в подотрезке больше 60 хороших чисел. Тогда на этом отрезке . В то же время, раз , и на любом отрезке , то . Следовательно, такой отрезок не будет подходящим, так как .Сохраним все позиции хороших чисел в отсортированном массиве. Переберем возможную левую границу подходящего подотрезка, с помощью бинарного поиска по этому массиву найдем следующее от рассматриваемой левой границы справа хорошее число. Затем будем идти вправо по хорошим числам(то есть, перебирать самое правое хорошее число подотрезка для данной левой границы), пока произведение чисел подотрезка не превзойдет (это будет маркером, что подотрезок с таким или большим произведением уже не может быть хорошим, следовательно, стоит остановиться). Выше показано, что мы сделаем не более 60 итераций. Теперь для перебранных левой границы подотрезка и самого правого хорошего числа легко понять, сколько единиц надо добавить справа от этого самого правого хорошего числа чтобы подотрезок был подходящим (так как, итерируясь по хорошим числам слева направо, легко поддерживать произведение и сумму). Осталось проверить, есть ли справа столько единиц, а для этого можно просто посмотреть на позицию следующего хорошего числа.Асимптотика решения - .Заметьте, что чтобы проверить, что превзойдет , не нужно умножать на , так как произойдет переполнение. Для этого надо просто проверить, что .(Идея задачи — DmitryGrigorev)Код — 39423501 992E - Настя и шаманы-королиЭта задача была вдохновлена идеей, предложенной моей невероятной девушкой :)Решение IВ этой задаче мы будем поддерживать дерево отрезков на сумму и отдельно дерево отрезков на максимум. После каждого запроса мы будем обновлять оба эти дерева за на каждый запрос. Осталось только понять, как затем ответить на запрос.Назовем префикс массива хорошим в том случае, если мы точно знаем, что на нем нет шамана-короля. Тогда либо первый шаман - король, и мы умеем отвечать на запрос, либо скажем, что префикс длины 1 - хороший. Далее будем повторять следующую операцию: Пусть - сумма на хорошем префиксе в данный момент. Найдем ее с помощью дерева отрезков на сумме. Найдем самый левый элемент, который теоретически может быть королём-шаманом. Несложно понять, что это самый левый элемент, не входящий в хороший префикс (так как в хорошем префиксе гарантированно нет шамана-короля), у которого значение не меньше, чем . Это можно сделать с помощью спуска по дереву отрезков на максимуме. Проверим, является ли он шаманом-королём с помощью дерева отрезков на сумму. Теперь, так как это самый левый элемент, который теоретически мог быть королем-шаманом, то если он не король-шаман, то скажем, что хороший префикс заканчивается в нём. Каждая операция работает за . Заметим, что после каждой операции сумма чисел на хорошем префиксе возрастает хотя бы вдвое. Это значит, что после операций сумма на хорошем префиксе станет больше, чем максимально возможное число в массиве, тогда второй пункт нашей операции ничего не найдет, и ответ на запрос -1.Асимптотика решения - .Решение IIПусть pi — префиксные суммы в массиве a. Скажем, что fi = pi - 2·ai и постараемся переформулировать наши запросы в терминах новых обозначений. Пусть мы пытаемся изменить значение в точке j на val. Скажем, что δ = val - aj. Тогда fj уменьшится на δ, а все fi > j, наоборот, увеличатся на δ. Пусть мы пытаемся найти ответ. Тогда нам достаточно найти любой индекс i, для которого fi = 0. Разобьем всю последовательность f на блоки некоторого заранее неизвестного размера M. Каждый блок будет состоять из пар (fi, i), отсортированных по первому значению. Вместе с тем будем поддерживать массив overhead, который будет отвечать за значения, прибавляемые ко всему блоку сразу. Как тогда обрабатывать операции? Пусть b = j / M. Необходимо найти в нем элемент j, уменьшить его, а также увеличить внутри этого блока значения для всех i > j. Это можно сделать за O(M), если использовать слияние сортированных векторов. Вместе с тем нельзя забывать про хвост, т.е требуется прибавить δ к overheadj > b за O(n / M) времени. От нас требуется найти такое i, что fi + overheadj / M = 0. Все блоки отсортированы, поэтому мы можем использовать бинарный поиск внутри блоков, что дает нам . Оптимальный выбор дает нам общую асимптотику в . Плюс заключается в том, что здесь мы никак не используем ограничения на положительные значения ai. Минус - это сложно уложить в 3 секунды :)Решение IIIСгруппируем элементы относительно их старшего бита (группами вида [2k... 2k + 1] и дополнительно для нуля). Внутри каждой группы (их будет ) будем поддерживать элементы в порядке возрастания их индекса. Нетрудно заметить, что внутри каждой группы не более двух кандидатов на ответ (просто в силу того, что префиксная сумма до третьего элемента обязательно будет содержать в себе первые два, что выводит нас за границы группы). Это дает несложное решение с любым суммирующим деревом за  — каждый раз перебираем все группы и проверяем префиксные суммы для двух кандидатов.Это решение ценно тем, что его можно соптимизировать дальше. Давайте поддерживать префиксные суммы для двух кандидатов — это позволит нам не тратить лишний логарифм на запрос к дереву поиска. Практически все, что требуется — аккуратно обрабатывать удаления и добавления: при удалении и добавлении необходимо пересчитать префиксную сумму для обновленных кандидатов в двух блоках. Осталось лишь вспомнить, что изменение элемента в точке может поменять предподсчитанные префиксные суммы в оставшихся блоках, но, в силу того, что мы знаем, на какую величину эти префиксные суммы изменились, мы потратим O(1) операций на каждый блок (если i > j, то сумма меняется на val - aj, иначе остается неизменной). Это дает нам решение за .Код решения I — 39423519Код решения II — 39418926. Попытайтесь оптимизировать :)Спасибо tfg за идею и код решения III. Хорошая работа!Код решения III — 39392321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 992\\s*C"
          },
          "content_length": 8371
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 1",
          "code": "in form a*x and second is in b*y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 2",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 3",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 4",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 5",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 6",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 7",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 8",
          "code": "1000000000 1000000000 1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 9",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 10",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 11",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 12",
          "code": "if x==0 or x%1000000007==0:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 13",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 14",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 15",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 17",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 18",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 19",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 20",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 21",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 22",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 23",
          "code": "lcm(a, b) = a * b /  gcd(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 24",
          "code": "lcm(a, b) = a / gcd(a, b) * b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 25",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 26",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 27",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 28",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 29",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 30",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 31",
          "code": "if(l <= Node[u].l && Node[u].r <= r) return Node[u].sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 2",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 3",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 4",
          "code": "We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least p[i]. It can be done using segment tree with maximums, with descent.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 5",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 6",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long x = inf.readLong(0LL, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long x = inf.readLong(0LL, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long x = inf.readLong(0LL, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    const long long MAX_VALUE = 1000000000000000000LL; // 1e18\n\n    string type = opt<string>(\"type\", \"random\");\n    long long x_max = opt<long long>(\"xmax\", MAX_VALUE);\n    long long k_max = opt<long long>(\"kmax\", MAX_VALUE);\n\n    long long x, k;\n\n    if (type == \"random\") {\n        x = rnd.next(0LL, x_max);\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"x_zero\") {\n        x = 0LL;\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"k_zero\") {\n        x = rnd.next(0LL, x_max);\n        k = 0LL;\n    } else if (type == \"both_zero\") {\n        x = 0LL;\n        k = 0LL;\n    } else if (type == \"x_max\") {\n        x = x_max;\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"k_max\") {\n        x = rnd.next(0LL, x_max);\n        k = k_max;\n    } else if (type == \"both_max\") {\n        x = x_max;\n        k = k_max;\n    } else if (type == \"x_one\") {\n        x = 1LL;\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"k_one\") {\n        x = rnd.next(0LL, x_max);\n        k = 1LL;\n    } else if (type == \"small\") {\n        x = rnd.next(0LL, 1000LL);\n        k = rnd.next(0LL, 1000LL);\n    } else if (type == \"large\") {\n        x = rnd.next(x_max - 1000LL, x_max);\n        k = rnd.next(k_max - 1000LL, k_max);\n    } else if (type == \"x_small_k_large\") {\n        x = rnd.next(0LL, 1000LL);\n        k = rnd.next(k_max - 1000LL, k_max);\n    } else if (type == \"x_large_k_small\") {\n        x = rnd.next(x_max - 1000LL, x_max);\n        k = rnd.next(0LL, 1000LL);\n    } else {\n        // Default to random\n        x = rnd.next(0LL, x_max);\n        k = rnd.next(0LL, k_max);\n    }\n\n    printf(\"%lld %lld\\n\", x, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    const long long MAX_VALUE = 1000000000000000000LL; // 1e18\n\n    string type = opt<string>(\"type\", \"random\");\n    long long x_max = opt<long long>(\"xmax\", MAX_VALUE);\n    long long k_max = opt<long long>(\"kmax\", MAX_VALUE);\n\n    long long x, k;\n\n    if (type == \"random\") {\n        x = rnd.next(0LL, x_max);\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"x_zero\") {\n        x = 0LL;\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"k_zero\") {\n        x = rnd.next(0LL, x_max);\n        k = 0LL;\n    } else if (type == \"both_zero\") {\n        x = 0LL;\n        k = 0LL;\n    } else if (type == \"x_max\") {\n        x = x_max;\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"k_max\") {\n        x = rnd.next(0LL, x_max);\n        k = k_max;\n    } else if (type == \"both_max\") {\n        x = x_max;\n        k = k_max;\n    } else if (type == \"x_one\") {\n        x = 1LL;\n        k = rnd.next(0LL, k_max);\n    } else if (type == \"k_one\") {\n        x = rnd.next(0LL, x_max);\n        k = 1LL;\n    } else if (type == \"small\") {\n        x = rnd.next(0LL, 1000LL);\n        k = rnd.next(0LL, 1000LL);\n    } else if (type == \"large\") {\n        x = rnd.next(x_max - 1000LL, x_max);\n        k = rnd.next(k_max - 1000LL, k_max);\n    } else if (type == \"x_small_k_large\") {\n        x = rnd.next(0LL, 1000LL);\n        k = rnd.next(k_max - 1000LL, k_max);\n    } else if (type == \"x_large_k_small\") {\n        x = rnd.next(x_max - 1000LL, x_max);\n        k = rnd.next(0LL, 1000LL);\n    } else {\n        // Default to random\n        x = rnd.next(0LL, x_max);\n        k = rnd.next(0LL, k_max);\n    }\n\n    printf(\"%lld %lld\\n\", x, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type x_zero\n./gen -type k_zero\n./gen -type both_zero\n\n./gen -type x_max\n./gen -type k_max\n./gen -type both_max\n\n./gen -type x_one\n./gen -type k_one\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type x_small_k_large\n./gen -type x_small_k_large\n./gen -type x_small_k_large\n\n./gen -type x_large_k_small\n./gen -type x_large_k_small\n./gen -type x_large_k_small\n\n./gen -type random -xmax 1000000000 -kmax 1000000000\n./gen -type random -xmax 1000000 -kmax 1000000\n./gen -type random -xmax 1000 -kmax 1000\n./gen -type random -xmax 10 -kmax 10\n\n./gen -type x_max -xmax 0\n./gen -type k_max -kmax 0\n\n./gen -type x_one -kmax 0\n./gen -type k_one -xmax 0\n\n./gen -type random -xmax 1\n./gen -type random -kmax 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:09.542973",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "992/D",
      "title": "D. Nastya and a Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 2·105, 1 ≤ k ≤ 105), where n is the length of the array and k is the constant described above.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 108) — the elements of the array.",
      "output_spec": "OutputIn the only line print the number of subsegments such that the ratio between the product and the sum on them is equal to k.",
      "sample_tests": "ExamplesInputCopy1 11OutputCopy1InputCopy4 26 3 8 1OutputCopy2",
      "description": "D. Nastya and a Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 2·105, 1 ≤ k ≤ 105), where n is the length of the array and k is the constant described above.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 108) — the elements of the array.\n\nOutputIn the only line print the number of subsegments such that the ratio between the product and the sum on them is equal to k.\n\nInputCopy1 11OutputCopy1InputCopy4 26 3 8 1OutputCopy2\n\nInputCopy1 11\n\nOutputCopy1\n\nInputCopy4 26 3 8 1\n\nOutputCopy2\n\nNoteIn the first example the only subsegment is [1]. The sum equals 1, the product equals 1, so it suits us because .There are two suitable subsegments in the second example — [6, 3] and [3, 8, 1]. Subsegment [6, 3] has sum 9 and product 18, so it suits us because . Subsegment [3, 8, 1] has sum 12 and product 24, so it suits us because .",
      "solutions": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces",
          "content": "Hi, Codeforces! I'm glad to invite everybody to the #489 Codeforces Round, which will be held as soon as tomorrow, on Monday, June 18, 2018 at 19:35. The round will be rated for all participants from the second division (with rating below than 2100). As usually, we will be glad to see participants from the first division out of competition!Problems for the round have been invented and prepared by us, pupils of Moscow school №2007, Dmitry DmitryGrigorev Grigorev and Fedor ---------- Ushakov. We want to give thanks to Andrew GreenGrape Raiskiy for his aid in preparing and testing of the problems, to Ildar 300iq Gainullin and to AmirReza Arpa PoorAkhavan who have tested our problems too and to the coordinator Nikolay KAN Kalinin, since our sometimes strange and undeveloped ideas have become eventually the Codeforces round. Also, we say thank you to Mike MikeMirzayanov Mirzayanov for his unbelievable Codeforces and Polygon platforms.You will receive 5 problems and 2 hours for solving it. During the round you will be helping for an extraordinary girl Nastya, who has been living in Byteland and sometimes receives very strange gifts for her birthday :). Score distribution will be announced, traditionally, closer to the start of the contest.We're holding our the first and, I hope, not the last round in Codeforces, so I hope a lot you will like our problems. Please, read all the problems. Anyway, I wish luck and high rating for all the participants!I'm looking forward your participation.UPD Score distribution is standart — 500-1000-1500-2000-2500UPD2 Thank you for your participation in the contest! It's very-very pleasant for me if you like the problems, and I'm sorry if you don't :) I hope the next my contest will be even better, than this. Thank you for all!List of the winners of the contest:Div.2 sminem NguoiHocTinLoai2 YaKon4ick HanaElhami pajenegod Div.1 + Div.2 dotorya Benq anta sminem kevinsogo My frank congratulations for all the winners!UPD3Editorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60050",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1992
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces",
          "content": "All the problems have been prepared by us, — DmitryGrigorev and ----------.(Idea of the problem — DmitryGrigorev) 992A - Nastya and an ArrayLet's notice that after one second we aren't able to decrease the number of distinct non-zero elements in the array more than by 1. It means that we can't make all elements equal to zero faster than after seconds, where is the number of distinct elements in the array initially. And let's notice that we are able to make it surely after second, if we will subtract every second some number which is in the array, so all elements equal this number in the array will have become zero, and the number of distinct non-zero elements will be decreased.So the answer is the number of distinct non-zero elements initially. Complexity is Code — 39423470(Idea of the problem — GreenGrape) Tutorial is loading...Code — 39423481(Idea of the problem — ----------) Tutorial is loading...Code — 39423497(Idea of the problem — DmitryGrigorev) 992D - Nastya and a GameLet's call numbers which are more than 1 as good. Notice the following fact:If a subsegment is suitable, it contains not more than 60 good numbers.Indeed, let's assume that a subsegment contains more than 60 good numbers. In this subsegment . At the same time, as , and , there is . Therefore, this subsegment can't be suitable due to .Let's keep all positions of good numbers in a sorted array. We sort out possible left border of a subsegment and then with binary search we find the next good number to the right of this left border. Then let's iterate from this found number to the right by the good numbers(that is we sort out the rightmost good number in a subsegment), until product of all numbers in the subsegment becomes more than (it's flag which shows us, that product is too big for a suitable subsgment and we need to finish to iterate). We have shown above the number of iterations isn't more than 60. Now for sorted out the left border and the rightmost good number we only need to know the number of 1's which needs to be added to the right of the rightmost good number, as we can easily maintain sum and product in the subsegment during iterating. Then we need to check whether found number of 1's exists to the right of the rightmost good number. It can be checked if we look at the next good number's position.Complexity is .In order to check that is more than , you shouldn't calculate multiply by , due to overflow. You must only check that .(Idea of the problem — DmitryGrigorev)Code — 39423501 Tutorial is loading...Code of the solution I — 39423519Code of the solution II — 39418926. Try to optimize :)Thank you tfg for the idea and the code of the solution III. Very good job!Code of the solution III — 39392321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 992\\s*D"
          },
          "content_length": 2727
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 1",
          "code": "in form a*x and second is in b*y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 2",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 3",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 4",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 5",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 6",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 7",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 8",
          "code": "1000000000 1000000000 1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 9",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 10",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 11",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 12",
          "code": "if x==0 or x%1000000007==0:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 13",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 14",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 15",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 17",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 18",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 19",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 20",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 21",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 22",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 23",
          "code": "lcm(a, b) = a * b /  gcd(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 24",
          "code": "lcm(a, b) = a / gcd(a, b) * b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 25",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 26",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 27",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 28",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 29",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 30",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 31",
          "code": "if(l <= Node[u].l && Node[u].r <= r) return Node[u].sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 2",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 3",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 4",
          "code": "We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least p[i]. It can be done using segment tree with maximums, with descent.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 5",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 6",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        /* All elements are 1 */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } \n    else if (type == \"all_max\") {\n        /* All elements are maximum */\n        for(int i = 0; i < n; ++i)\n            a[i] = 100000000;\n    }\n    else if (type == \"alternating\") {\n        /* Elements alternate between 1 and maximum */\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : 100000000;\n    }\n    else if (type == \"random_small\") {\n        /* Random small numbers */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    }\n    else if (type == \"random_large\") {\n        /* Random large numbers */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000000);\n    }\n    else if (type == \"single_solution\") {\n        /* Only one subsegment satisfies p / s = k */\n        if (n >= 2 && k <= 100000 && k >= 1) {\n            a[0] = k + 1;\n            a[1] = k + 1;\n            for(int i = 2; i < n; ++i)\n                a[i] = 1;\n        } else {\n            /* Default to random small numbers if conditions are not suitable */\n            for(int i = 0; i < n; ++i)\n                a[i] = rnd.next(1, 10);\n        }\n    }\n    else if (type == \"overflow_risk\") {\n        /* Large numbers to test overflow handling */\n        for(int i = 0; i < n; ++i)\n            a[i] = 100000000 - rnd.next(0, 10);\n    }\n    else {\n        /* Default case: random numbers between 1 and 10^8 */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000000);\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output array elements */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        /* All elements are 1 */\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } \n    else if (type == \"all_max\") {\n        /* All elements are maximum */\n        for(int i = 0; i < n; ++i)\n            a[i] = 100000000;\n    }\n    else if (type == \"alternating\") {\n        /* Elements alternate between 1 and maximum */\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : 100000000;\n    }\n    else if (type == \"random_small\") {\n        /* Random small numbers */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    }\n    else if (type == \"random_large\") {\n        /* Random large numbers */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000000);\n    }\n    else if (type == \"single_solution\") {\n        /* Only one subsegment satisfies p / s = k */\n        if (n >= 2 && k <= 100000 && k >= 1) {\n            a[0] = k + 1;\n            a[1] = k + 1;\n            for(int i = 2; i < n; ++i)\n                a[i] = 1;\n        } else {\n            /* Default to random small numbers if conditions are not suitable */\n            for(int i = 0; i < n; ++i)\n                a[i] = rnd.next(1, 10);\n        }\n    }\n    else if (type == \"overflow_risk\") {\n        /* Large numbers to test overflow handling */\n        for(int i = 0; i < n; ++i)\n            a[i] = 100000000 - rnd.next(0, 10);\n    }\n    else {\n        /* Default case: random numbers between 1 and 10^8 */\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000000);\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output array elements */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type all_ones\n./gen -n 1 -k 1 -type all_max\n./gen -n 1 -k 1 -type random_small\n\n./gen -n 2 -k 1 -type single_solution\n./gen -n 2 -k 2 -type single_solution\n./gen -n 2 -k 3 -type single_solution\n\n./gen -n 10 -k 1 -type all_ones\n./gen -n 10 -k 1 -type random_small\n./gen -n 10 -k 100000 -type all_max\n\n./gen -n 100 -k 1 -type alternating\n./gen -n 100 -k 100000 -type alternating\n\n./gen -n 1000 -k 1 -type random_small\n./gen -n 1000 -k 1000 -type random_large\n\n./gen -n 10000 -k 1 -type overflow_risk\n\n./gen -n 100000 -k 1 -type all_ones\n./gen -n 100000 -k 100000 -type all_max\n\n./gen -n 200000 -k 1 -type random_small\n./gen -n 200000 -k 100000 -type random_large\n\n./gen -n 200000 -k 1 -type alternating\n\n./gen -n 200000 -k 1 -type overflow_risk\n\n./gen -n 200000 -k 100000 -type random_large\n\n./gen -n 199999 -k 1 -type random_small\n\n./gen -n 200000 -k 12345 -type random_large\n\n./gen -n 200000 -k 1 -type random_small\n\n./gen -n 200000 -k 100000 -type all_max\n\n./gen -n 200000 -k 1 -type overflow_risk\n\n./gen -n 200000 -k 2 -type random_small\n\n./gen -n 199999 -k 1 -type single_solution\n./gen -n 199999 -k 2 -type single_solution\n\n./gen -n 2 -k 99999 -type single_solution\n\n./gen -n 2 -k 100000 -type single_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:11.864930",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "992/E",
      "title": "E. Nastya and King-Shamans",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and q (1 ≤ n, q ≤ 2·105).The second line contains n integers a1, ..., an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman.After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi.",
      "output_spec": "OutputPrint q lines, the i-th of them should contain  - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change.If there are multiple king-shamans after each change, print the index of any of them.",
      "sample_tests": "ExamplesInputCopy2 11 31 2OutputCopy-1InputCopy3 42 2 31 11 22 43 6OutputCopy32-13InputCopy10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0OutputCopy1-19-14-11",
      "description": "E. Nastya and King-Shamans\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and q (1 ≤ n, q ≤ 2·105).The second line contains n integers a1, ..., an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman.After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi.\n\nOutputPrint q lines, the i-th of them should contain  - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change.If there are multiple king-shamans after each change, print the index of any of them.\n\nInputCopy2 11 31 2OutputCopy-1InputCopy3 42 2 31 11 22 43 6OutputCopy32-13InputCopy10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0OutputCopy1-19-14-11\n\nInputCopy2 11 31 2\n\nOutputCopy-1\n\nInputCopy3 42 2 31 11 22 43 6\n\nOutputCopy32-13\n\nInputCopy10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0\n\nOutputCopy1-19-14-11\n\nNoteIn the first example powers of shamans after the first change are equal to (2, 3). The answer equals  - 1, because the sum of powers of shamans before the first shaman is equal to 0, and before the second is equal to 2.In the second example after the first change the powers are equal to (1, 2, 3). The answer is equal to 3, because the power of the third shaman is equal to 3, and the sum of powers of the first and the second shaman is also 1 + 2 = 3. After the second change the powers become equal to (2, 2, 3), where the answer equals 2. After the third change the powers become equal to (2, 4, 3), where the answer equals  - 1. After the fourth change the powers become equal to (2, 4, 6), where the answer equals 3.",
      "solutions": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces",
          "content": "Hi, Codeforces! I'm glad to invite everybody to the #489 Codeforces Round, which will be held as soon as tomorrow, on Monday, June 18, 2018 at 19:35. The round will be rated for all participants from the second division (with rating below than 2100). As usually, we will be glad to see participants from the first division out of competition!Problems for the round have been invented and prepared by us, pupils of Moscow school №2007, Dmitry DmitryGrigorev Grigorev and Fedor ---------- Ushakov. We want to give thanks to Andrew GreenGrape Raiskiy for his aid in preparing and testing of the problems, to Ildar 300iq Gainullin and to AmirReza Arpa PoorAkhavan who have tested our problems too and to the coordinator Nikolay KAN Kalinin, since our sometimes strange and undeveloped ideas have become eventually the Codeforces round. Also, we say thank you to Mike MikeMirzayanov Mirzayanov for his unbelievable Codeforces and Polygon platforms.You will receive 5 problems and 2 hours for solving it. During the round you will be helping for an extraordinary girl Nastya, who has been living in Byteland and sometimes receives very strange gifts for her birthday :). Score distribution will be announced, traditionally, closer to the start of the contest.We're holding our the first and, I hope, not the last round in Codeforces, so I hope a lot you will like our problems. Please, read all the problems. Anyway, I wish luck and high rating for all the participants!I'm looking forward your participation.UPD Score distribution is standart — 500-1000-1500-2000-2500UPD2 Thank you for your participation in the contest! It's very-very pleasant for me if you like the problems, and I'm sorry if you don't :) I hope the next my contest will be even better, than this. Thank you for all!List of the winners of the contest:Div.2 sminem NguoiHocTinLoai2 YaKon4ick HanaElhami pajenegod Div.1 + Div.2 dotorya Benq anta sminem kevinsogo My frank congratulations for all the winners!UPD3Editorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60050",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1992
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces",
          "content": "All the problems have been prepared by us, — DmitryGrigorev and ----------.(Idea of the problem — DmitryGrigorev) 992A - Nastya and an ArrayLet's notice that after one second we aren't able to decrease the number of distinct non-zero elements in the array more than by 1. It means that we can't make all elements equal to zero faster than after seconds, where is the number of distinct elements in the array initially. And let's notice that we are able to make it surely after second, if we will subtract every second some number which is in the array, so all elements equal this number in the array will have become zero, and the number of distinct non-zero elements will be decreased.So the answer is the number of distinct non-zero elements initially. Complexity is Code — 39423470(Idea of the problem — GreenGrape) 992B - Nastya Studies InformaticsLet's consider some suitable pair . As , we can present number as , and number as , where we know that and .Let's consider too that from the restriction from the problem we surely know the restriction for and , that is . Let's remember we know that (because is , is ). Then we can get . Dividing by :..Now if , answer equals 0.Else as is surely less than , we can just sort out all possible pairs of divisors , such that , and then to check that and are in the getting above restrictions. Complexity of this solution is .Code — 39423481(Idea of the problem — ----------) 992C - Nastya and a WardrobeLet's present we have initially dresses.What does occur in the first month? Initially the number of dresses is multiplied by 2, that is becomes . Then with probability the wardrobe eats a dress, that is expected value of the number of dresses becomes . The same way after the second month expected value becomes . It's easy to notice that after -th month(if ) expected value equals . Eventually it will be only doubled(as the wardrobe doesn't eat a dress in the last month), that is will be equal .Thus, answer of the problem is . Expressing it with , we get: = . = .Thus, we need to calculate degree of 2 right up to . Complexity of the soltion is .Let's notice that the case we need to calculate separately, because wardrobe can't eat a dress when it doesn't exist. If it's easy to proof that the number of dresses is never negative, that is the formula works.Code — 39423497(Idea of the problem — DmitryGrigorev) 992D - Nastya and a GameLet's call numbers which are more than 1 as good. Notice the following fact:If a subsegment is suitable, it contains not more than 60 good numbers.Indeed, let's assume that a subsegment contains more than 60 good numbers. In this subsegment . At the same time, as , and , there is . Therefore, this subsegment can't be suitable due to .Let's keep all positions of good numbers in a sorted array. We sort out possible left border of a subsegment and then with binary search we find the next good number to the right of this left border. Then let's iterate from this found number to the right by the good numbers(that is we sort out the rightmost good number in a subsegment), until product of all numbers in the subsegment becomes more than (it's flag which shows us, that product is too big for a suitable subsgment and we need to finish to iterate). We have shown above the number of iterations isn't more than 60. Now for sorted out the left border and the rightmost good number we only need to know the number of 1's which needs to be added to the right of the rightmost good number, as we can easily maintain sum and product in the subsegment during iterating. Then we need to check whether found number of 1's exists to the right of the rightmost good number. It can be checked if we look at the next good number's position.Complexity is .In order to check that is more than , you shouldn't calculate multiply by , due to overflow. You must only check that .(Idea of the problem — DmitryGrigorev)Code — 39423501 992E - Nastya and King-ShamansThis problem was inspired by idea which was offered by my unbelievable girlfriend :)Solution IIn this problem we maintain two segment trees - with maximum and with sum. After every query we recalculate these trees in for a query. Now we only have to understand, how to answer for a query? Let's call a prefix of the array as good in the case if we surely know that it doesn't contain a king-shaman. So either the first shaman is king and we are able to answer for the query, or we call the prefix with length 1 as good. Then let's repeat the following operation: We call as sum in the good prefix now. We find it using the segment tree with sums. We find the leftmost element which may be king-shaman yet. We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least . It can be done using segment tree with maximums, with descent. We check if this found shaman is king. If isn't, we can say that the good prefix finishes in this shaman now, because it was the leftmost shaman who might be king. Every operation works in . Let's notice, that one operation increases sum in the good prefix at least by two times. So, after operations sum in the good prefix will become more than a maximal possible number in the array, so that we will be able to finish, because we will be sure that answer will be -1. Complexity of the solution is .Solution IILet pi be the prefix sums of a. We're gonna introduce fi = pi - 2·ai and reformulate the queries using these new terms. Imagine we wanna change the value at j to val. Let δ = val - aj. Then fj will decrease by δ whereas fi > j will increase by δ. Imagine we wanna find the answer. Then it's sufficient to find any i satisfying fi = 0. Split f into blocks of size M. Each block will be comprised of pairs (fi, i) sorted by f. At the same time we will maintain overhead array responsible for lazy additions to blocks. How does this help? Let b = j / M. The goal is to find the position of j, decrease its value and increase values for all i > j within this block. It can be done in a smart way in O(M) (actually, this can be represented as merging sorted vectors). You should also take care of the tail, i.e add δ to overheadj > b in O(n / M) time. We're asked to find such i that fi + overheadj / M = 0. All blocks are sorted, thus we can simply apply binary search in overall. The optimal assignment is which results into total runtime. The huge advantage of this approach is its independency from constraints on a (i.e non-negativity). Although we didn't succeed in squeezing this into TL :)Solution IIIGroup the numbers according to their highest bits (with groups of the form [2k... 2k + 1] and separately for zeros). Inside each groups (no more than of them) we maintain elements in increasing order of indexes. It's easy to see that each group contains no more than two candidates for answer (since their sum is guaranteed to be greater than any of the remaining ones). This observation leads to an easy solution in  — we iterate over groups and check prefix sums for these candidates.There's actually further space for optimizations. Let's maintain prefix sums for our candidates — this allows us to get rid of the extra log when quering the tree. Almost everything we need at this step is to somehow process additions and deletions — change the order inside two blocks and probably recalculate prefix sums. The only thing left is to stay aware of prefix sum changes for the remaining blocks. Luckily, they can be fixed in O(1) per block (if i > j then the sum increases by val - aj and stays the same otherwise). The resulting comlexity is .Code of the solution I — 39423519Code of the solution II — 39418926. Try to optimize :)Thank you tfg for the idea and the code of the solution III. Very good job!Code of the solution III — 39392321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 992\\s*E"
          },
          "content_length": 7832
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 1",
          "code": "in form a*x and second is in b*y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 2",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 3",
          "code": "and check if each pair count number of pair satisfy all the condition:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 4",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 5",
          "code": "l<=a<=r and l<=b<=r and gcd(a,b) = x and lcm(a,b) = y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 6",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 7",
          "code": "int lcm(int a, int b)\n{\n    return (a*b)/gcd(a, b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 8",
          "code": "1000000000 1000000000 1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 9",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 10",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 11",
          "code": "signed main()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 12",
          "code": "if x==0 or x%1000000007==0:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 13",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 14",
          "code": "for (int i = 0; i < n-1; i++)\n   for (int j = i + 1; j < n; j++)\n   {\n       do_something();\n   }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 15",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 16",
          "code": "for(int i=0;i<n;i++){\n  ...;\n  for(int j=i+1;j<n;j++){\n    ...;\n  }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 17",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 18",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 19",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 20",
          "code": "cout<<((x*poww(2,k+1))%mod-poww(2,k)+1 + mod)%mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 21",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 22",
          "code": "10 2 \n1 1 1 1 10 3 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 23",
          "code": "lcm(a, b) = a * b /  gcd(a, b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 24",
          "code": "lcm(a, b) = a / gcd(a, b) * b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 25",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 26",
          "code": "LL PP = tempPro*a[j];\nif(PP<0||PP%a[j]!=0||PP/a[j]!=tempPro)break;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 27",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 28",
          "code": "//checks if a * b overflows long long\ninline bool overflows(LL a, LL b) {\n  return a > (LLONG_MAX / b);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 29",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 30",
          "code": "void f(long long b, long long c) {\n    long long a = b * c;\n    if(b && a / b != c) return;\n    assert(b != 0 && c != 0 && a == 0);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #489 (Div.2) - Codeforces - Code 31",
          "code": "if(l <= Node[u].l && Node[u].r <= r) return Node[u].sum;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60050",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 2",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 3",
          "code": "1e5 + abs(a[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 4",
          "code": "We can realise that it's the leftmost element, which doesn't lie in the good prefix (as there isn't king-shaman according the definition), which have a value at least p[i]. It can be done using segment tree with maximums, with descent.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 5",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        },
        {
          "title": "Editorial of Round #489(Div.2) - Codeforces - Code 6",
          "code": "int down(int i, int l, int r, LL S){\n    if (r-l==1) return l;\n    int mid = (l+r)/2;\n    if ((LL) rmq_max[2*i+1] >= S) return down(2*i+1, l, mid, S);\n    return down(2*i+2, mid, r, S);\n}\nint get(int i, int l, int r, int l1, int r1, LL S){\n    if (l1 >= r1) return n;\n    if (l==l1 && r==r1){\n        if ((LL) rmq_max[i] < S) return n;\n        return down(i, l, r, S);\n    }\n    int mid = (l+r)/2;\n    int res = get(2*i+1, l, mid, l1, min(r1, mid), S);\n    if (res != n) return res;\n    return get(2*i+2, mid, r, max(l1, mid), r1, S);\n}\nLL get_sum(int i, int l, int r, int l1, int r1){\n    if (l1 >= r1) return 0;\n    if (l==l1 && r==r1) return rmq_sum[i];\n    int mid = (l+r)/2;\n    return get_sum(2*i+1, l, mid, l1, min(r1, mid)) + get_sum(2*i+2, mid, r, max(l1, mid), r1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readSpace();\n        int xi = inf.readInt(0, 1000000000, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readSpace();\n        int xi = inf.readInt(0, 1000000000, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readSpace();\n        int xi = inf.readInt(0, 1000000000, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Checker logic:\n    For each query:\n      1) We read p, x (the update to the p-th shaman).\n      2) We apply this update to our array of powers.\n      3) We read the contestant's answer j for this query (an integer in range [-1, n]).\n         - If j == -1, we check that no king-shaman exists.\n         - Otherwise, we check that j is indeed a valid king-shaman, i.e. a_j == sum of all a_k for k < j.\n    If any check fails, we report _wa.\n    If all queries pass, we report _ok.\n*/\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n, q\n    long long n = inf.readLong(1, 200000, \"n\");\n    long long q = inf.readLong(1, 200000, \"q\");\n\n    vector<long long> a(n);\n    for(int i = 0; i < n; i++){\n        a[i] = inf.readLong(0, 1000000000LL, (\"a[\" + to_string(i+1) + \"]\").c_str());\n    }\n\n    while(q--){\n        // Read the update\n        long long p = inf.readLong(1, n, \"p\");\n        long long x = inf.readLong(0, 1000000000LL, \"x\");\n        // Apply the update\n        a[p - 1] = x;\n\n        // Read the contestant's claimed index j\n        long long j = ouf.readLong(-1, n, \"king-shaman index or -1\");\n\n        // Compute prefix sums to find if there's any valid king-shaman\n        // (Naive O(n) approach for demonstration purposes)\n        vector<long long> prefix(n + 1, 0);\n        for(int i = 0; i < n; i++){\n            prefix[i + 1] = prefix[i] + a[i];\n        }\n\n        // Find any valid king-shaman index\n        long long foundIndex = -1; // 1-based, or -1 if none\n        for(int i = 0; i < n; i++){\n            // a[i] == sum of all previous => a[i] == prefix[i]\n            if(a[i] == prefix[i]){\n                foundIndex = i + 1; \n                break;\n            }\n        }\n\n        // Now check participant's output\n        if(j == -1){\n            if(foundIndex != -1){\n                // A king-shaman DOES exist, but participant says -1\n                quitf(_wa, \"participant printed -1 but there is a valid king-shaman at index %lld\", foundIndex);\n            }\n        } else {\n            // The participant claims there IS a king-shaman at j\n            // We must verify that j is truly one\n            // j is guaranteed in [1..n], so check condition\n            if(a[j - 1] != prefix[j - 1]) {\n                quitf(_wa, \"the chosen index %lld is not a valid king-shaman (a_j=%lld, sumPrev=%lld)\",\n                      j, a[j - 1], prefix[j - 1]);\n            }\n        }\n    }\n\n    // If everything passed\n    quitf(_ok, \"All answers look consistent\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<pair<int, int>> changes(q);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = 0;\n            changes[i] = {p, x};\n        }\n    } else if (type == \"all_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = 1000000000;\n            changes[i] = {p, x};\n        }\n    } else if (type == \"shaman1_king\") {\n        a[0] = 0;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 1000); // small random values\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"shaman_n_king\") {\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(0, 10000); // small random values to keep sum small\n            sum += a[i];\n        }\n        a[n - 1] = (sum <= 1000000000) ? sum : 1000000000; // ensure within limit\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"repeated_updates\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n        int p = rnd.next(1, n); // same shaman to update\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"overflow_test\") {\n        // ai and xi are near 1e9 to test for overflow\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000 - rnd.next(0, 10);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = 1000000000 - rnd.next(0,10);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"updates_make_king\") {\n        // Initially no king-shaman,\n        // Then updates create a king-shaman\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        vector<long long> prefix_sum(n+1);\n        for (int i = 0; i < n; ++i) {\n            prefix_sum[i+1] = prefix_sum[i] + a[i];\n        }\n        // Now pick a position to make a king-shaman after some update\n        int pos = rnd.next(1, n-1);\n        // During updates, change a[pos] to prefix_sum[pos];\n        for (int i = 0; i < q; ++i) {\n            int p, x;\n            if (i == q/2) {\n                p = pos+1; // 1-based indexing\n                x = (prefix_sum[pos] <= 1000000000) ? prefix_sum[pos] : 1000000000;\n            } else {\n                p = rnd.next(1, n);\n                x = rnd.next(1, 1000000000);\n            }\n            changes[i] = {p, x};\n        }\n    } else if (type == \"no_king\") {\n        // Generate ai such that no shaman is king-shaman\n        long long sum = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if (a[i] == sum) {\n                a[i] = a[i] + 1;\n                if (a[i] > 1000000000) a[i] = a[i] - 2;\n            }\n            sum += a[i];\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(1, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"many_kings\") {\n        // Generate ai such that many shamans are king-shamans\n        a[0] = 0;\n        int k = min(n, 100000); // up to 100,000 king-shamans\n        for (int i = 1; i < k; ++i) {\n            a[i] = 0;\n        }\n        for (int i = k; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", changes[i].first, changes[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<pair<int, int>> changes(q);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = 0;\n            changes[i] = {p, x};\n        }\n    } else if (type == \"all_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = 1000000000;\n            changes[i] = {p, x};\n        }\n    } else if (type == \"shaman1_king\") {\n        a[0] = 0;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 1000); // small random values\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"shaman_n_king\") {\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(0, 10000); // small random values to keep sum small\n            sum += a[i];\n        }\n        a[n - 1] = (sum <= 1000000000) ? sum : 1000000000; // ensure within limit\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"repeated_updates\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n        int p = rnd.next(1, n); // same shaman to update\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"overflow_test\") {\n        // ai and xi are near 1e9 to test for overflow\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000 - rnd.next(0, 10);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = 1000000000 - rnd.next(0,10);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"updates_make_king\") {\n        // Initially no king-shaman,\n        // Then updates create a king-shaman\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        vector<long long> prefix_sum(n+1);\n        for (int i = 0; i < n; ++i) {\n            prefix_sum[i+1] = prefix_sum[i] + a[i];\n        }\n        // Now pick a position to make a king-shaman after some update\n        int pos = rnd.next(1, n-1);\n        // During updates, change a[pos] to prefix_sum[pos];\n        for (int i = 0; i < q; ++i) {\n            int p, x;\n            if (i == q/2) {\n                p = pos+1; // 1-based indexing\n                x = (prefix_sum[pos] <= 1000000000) ? prefix_sum[pos] : 1000000000;\n            } else {\n                p = rnd.next(1, n);\n                x = rnd.next(1, 1000000000);\n            }\n            changes[i] = {p, x};\n        }\n    } else if (type == \"no_king\") {\n        // Generate ai such that no shaman is king-shaman\n        long long sum = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if (a[i] == sum) {\n                a[i] = a[i] + 1;\n                if (a[i] > 1000000000) a[i] = a[i] - 2;\n            }\n            sum += a[i];\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(1, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else if (type == \"many_kings\") {\n        // Generate ai such that many shamans are king-shamans\n        a[0] = 0;\n        int k = min(n, 100000); // up to 100,000 king-shamans\n        for (int i = 1; i < k; ++i) {\n            a[i] = 0;\n        }\n        for (int i = k; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            int x = rnd.next(0, 1000000000);\n            changes[i] = {p, x};\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", changes[i].first, changes[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and q\n./gen -n 1 -q 1 -type random\n./gen -n 2 -q 2 -type random\n./gen -n 10 -q 10 -type random\n./gen -n 100 -q 100 -type random\n./gen -n 1000 -q 1000 -type random\n\n# Maximum n and q\n./gen -n 200000 -q 200000 -type random\n./gen -n 200000 -q 200000 -type all_zero\n./gen -n 200000 -q 200000 -type all_max\n./gen -n 200000 -q 200000 -type shaman1_king\n./gen -n 200000 -q 200000 -type shaman_n_king\n./gen -n 200000 -q 200000 -type repeated_updates\n\n# Testcases for potential overflows\n./gen -n 200000 -q 200000 -type overflow_test\n\n# Testcases where updates create king-shamans\n./gen -n 1000 -q 1000 -type updates_make_king\n./gen -n 200000 -q 200000 -type updates_make_king\n\n# Edge cases with minimal values\n./gen -n 1 -q 1 -type all_zero\n./gen -n 1 -q 1 -type shaman1_king\n\n# Edge cases with q=0\n./gen -n 100000 -q 0 -type random\n\n# Edge cases with n=1\n./gen -n 1 -q 200000 -type random\n\n# Testcase with only one update\n./gen -n 200000 -q 1 -type random\n\n# Testcases with no king-shamans\n./gen -n 200000 -q 200000 -type no_king\n\n# Testcases designed to have many king-shamans\n./gen -n 1000 -q 1000 -type many_kings\n./gen -n 200000 -q 200000 -type many_kings\n\n# Additional random testcases\n./gen -n 200000 -q 200000 -type random\n./gen -n 200000 -q 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:13.754095",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "993/A",
      "title": "A. Два квадрата",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВходные данные состоят из двух строк, по одной на квадрат, в каждой по четыре пары целых чисел. Каждая пара чисел задает координаты одной вершины квадрата. Координаты для каждого квадрата даны в порядке обхода по или против часовой стрелки.Первая строка содержит координаты вершин квадрата, у которого стороны параллельны осям координат, вторая строка — у которого стороны образуют с осями координат угол 45 градусов.Все числа во входных данных целые и лежат в интервале между −100−100 и 100100.",
      "output_spec": "Выходные данныеВыведите «Yes», если квадраты пересекаются, иначе выведите «No».Вы можете выводить каждую из букв в любом регистре (строчную или заглавную).",
      "sample_tests": "ПримерыВходные данныеСкопировать0 0 6 0 6 6 0 61 3 3 5 5 3 3 1Выходные данныеСкопироватьYESВходные данныеСкопировать0 0 6 0 6 6 0 67 3 9 5 11 3 9 1Выходные данныеСкопироватьNOВходные данныеСкопировать6 0 6 6 0 6 0 07 4 4 7 7 10 10 7Выходные данныеСкопироватьYES",
      "description": "A. Два квадрата\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВходные данные состоят из двух строк, по одной на квадрат, в каждой по четыре пары целых чисел. Каждая пара чисел задает координаты одной вершины квадрата. Координаты для каждого квадрата даны в порядке обхода по или против часовой стрелки.Первая строка содержит координаты вершин квадрата, у которого стороны параллельны осям координат, вторая строка — у которого стороны образуют с осями координат угол 45 градусов.Все числа во входных данных целые и лежат в интервале между −100−100 и 100100.\n\nВходные данные\n\nВыходные данныеВыведите «Yes», если квадраты пересекаются, иначе выведите «No».Вы можете выводить каждую из букв в любом регистре (строчную или заглавную).\n\nВыходные данные\n\nВходные данныеСкопировать0 0 6 0 6 6 0 61 3 3 5 5 3 3 1Выходные данныеСкопироватьYESВходные данныеСкопировать0 0 6 0 6 6 0 67 3 9 5 11 3 9 1Выходные данныеСкопироватьNOВходные данныеСкопировать6 0 6 6 0 6 0 07 4 4 7 7 10 10 7Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать0 0 6 0 6 6 0 61 3 3 5 5 3 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 0 6 0 6 6 0 67 3 9 5 11 3 9 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 0 6 6 0 6 0 07 4 4 7 7 10 10 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере второй квадрат лежит целиком внутри первого, что по условию является пересечением.Во втором примере два квадрата не имеют общих точек.Картинки, иллюстрирующие примеры:",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD: обратите внимание, распределение баллов изменилосьUPD2: LHiC нашел ошибку в авторском решении на div1-F. Мы исследуем вопрос.UPD3: мы нашли правильное решение для div1-F и оба решения отправленных на контесте проходят все тесты против правильного решения => раунд по прежнему рейтинговый.Всем привет,Время старта Codeforces Round 488: воскресенье, 17 июня 2018 г. в 00:35UTC+8. Это будет раунд для обоих дивизионов. Раунд будет длиться 2.5 часа (это на пол часа больше чем обычно).Контест подготовлен компанией NEAR и ее друзьями. В NEAR мы учим машины участвовать в соревнованиях по программированию. В этом блог-посте можно прочитать (на английском) о том, где сегодня находятся исследования в этой области, чем занимается непосредственно NEAR, и как вы можете помочь нам в этом нелегком деле.На контесте будет предложено по шесть задач в каждом дивизионе, 4 задачи из которых общие.Почти все задачи взяты с тестовых раундов, которые проводились на JavaBlitz в прошлом году. Если вы участвовали в одном из JavaBlitz раундов, то этот CBR, к сожалению, придется пропустить.Распределение баллов в первом дивизионе -- 500-1000-1000-1500-2250-3000Во втором -- 500-1000-1500-2000-2000-2500Раунд в обоих дивизионах рейтинговый.Все задачи написаны мной, Александром \"AlexSkidanov\" Скидановым, и Никитой \"FalseMirror\" Босовым. David \"pieguy\" Stolp, Александр \"AlexFetisov\" Фетиско, Marcelo \"mnaeraxr\" Fornet, Николай \"KAN\" Калинин и Михаил \"cerealguy\" Кевер оказали неоценимую помощь в подгтовке раунда и тестировании задач.В завершении хочется в очередной раз напомнить, что мы постоянно ищем людей, которые помогут нам с разметкой данных с архивов по спортивному программированию. Больше информации здесь.Поздравляем победителей!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge Разбор опубликован тут. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1888
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - Отпечатки пальцевДля решения задачи достаточно пройти по всем элементам данной последовательности, и для каждого в цикле пройти по кнопкам с отпечатками и проверить есть ли кнопка с отпечатком, соответствующая текущему числу в последовательности. Такое решение работает за O(n×m)O(n×m) 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Два квадратаЕсли два квадрата пересекаются, то хотя бы для одного из них верно что либо один из его углов лежит в другом квадрате, либо его центр лежит в другом квадрате.Для квадрата, который повернут на 45 градусов, проверить лежат ли его углы или центр в квадрате со сторонами, параллельными осям координат, очень просто.Чтобы проверить в обратную сторону, достаточно повернуть оба квадрата на 45 градусов. Чтобы это сделать, достаточно заменить все xx координаты на x+yx+y, а все yy координаты на x−yx−y (это также изменит масштаб, но это не влияет на пересечение) 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 993 和字母"
          },
          "content_length": 10584
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid validate_square(vector<pair<int,int>>& P, bool is_first_square) {\n    // 1) Check that the 4 points are distinct.\n    set<pair<int,int>> points_set(P.begin(), P.end());\n    ensuref(points_set.size() == 4, \"The 4 points should be distinct, but some points are equal.\");\n\n    // 2) Compute sides\n    vector<pair<int,int>> sides(4);\n    for (int i = 0; i < 4; ++i) {\n        int dx = P[(i+1)%4].first - P[i].first;\n        int dy = P[(i+1)%4].second - P[i].second;\n        sides[i] = make_pair(dx, dy);\n    }\n\n    // 3) Compute lengths squared of sides\n    vector<int> lengths_squared(4);\n    for (int i = 0; i < 4; ++i) {\n        int dx = sides[i].first;\n        int dy = sides[i].second;\n        lengths_squared[i] = dx*dx + dy*dy;\n    }\n\n    // Ensure that all side lengths are equal\n    for (int i = 1; i < 4; ++i) {\n        ensuref(lengths_squared[i] == lengths_squared[0], \"All sides must have equal length.\");\n    }\n\n    // 5) Compute dot products between adjacent sides\n    for (int i = 0; i < 4; ++i) {\n        int dx1 = sides[i].first;\n        int dy1 = sides[i].second;\n        int dx2 = sides[(i+1)%4].first;\n        int dy2 = sides[(i+1)%4].second;\n        int dot = dx1 * dx2 + dy1 * dy2;\n        ensuref(dot == 0, \"Adjacent sides must be perpendicular.\");\n    }\n\n    if (is_first_square) {\n        // For each side, check that dx == 0 or dy == 0\n        for (int i = 0; i < 4; ++i) {\n            int dx = sides[i].first;\n            int dy = sides[i].second;\n            ensuref(dx == 0 || dy == 0, \"Sides of the first square must be axis-aligned.\");\n        }\n    } else {\n        // For each side, check that |dx| == |dy|\n        for (int i = 0; i < 4; ++i) {\n            int dx = sides[i].first;\n            int dy = sides[i].second;\n            ensuref(abs(dx) == abs(dy), \"Sides of the second square must be at 45 degrees.\");\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read first line\n    vector<int> square1 = inf.readInts(8, -100, 100, \"square1\");\n    inf.readEoln();\n\n    vector<pair<int,int>> P1(4);\n    for (int i = 0; i < 4; ++i) {\n        P1[i] = make_pair(square1[2*i], square1[2*i+1]);\n    }\n\n    validate_square(P1, true);\n\n    // Read second line\n    vector<int> square2 = inf.readInts(8, -100, 100, \"square2\");\n    inf.readEoln();\n\n    vector<pair<int,int>> P2(4);\n    for (int i = 0; i < 4; ++i) {\n        P2[i] = make_pair(square2[2*i], square2[2*i+1]);\n    }\n\n    validate_square(P2, false);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid validate_square(vector<pair<int,int>>& P, bool is_first_square) {\n    // 1) Check that the 4 points are distinct.\n    set<pair<int,int>> points_set(P.begin(), P.end());\n    ensuref(points_set.size() == 4, \"The 4 points should be distinct, but some points are equal.\");\n\n    // 2) Compute sides\n    vector<pair<int,int>> sides(4);\n    for (int i = 0; i < 4; ++i) {\n        int dx = P[(i+1)%4].first - P[i].first;\n        int dy = P[(i+1)%4].second - P[i].second;\n        sides[i] = make_pair(dx, dy);\n    }\n\n    // 3) Compute lengths squared of sides\n    vector<int> lengths_squared(4);\n    for (int i = 0; i < 4; ++i) {\n        int dx = sides[i].first;\n        int dy = sides[i].second;\n        lengths_squared[i] = dx*dx + dy*dy;\n    }\n\n    // Ensure that all side lengths are equal\n    for (int i = 1; i < 4; ++i) {\n        ensuref(lengths_squared[i] == lengths_squared[0], \"All sides must have equal length.\");\n    }\n\n    // 5) Compute dot products between adjacent sides\n    for (int i = 0; i < 4; ++i) {\n        int dx1 = sides[i].first;\n        int dy1 = sides[i].second;\n        int dx2 = sides[(i+1)%4].first;\n        int dy2 = sides[(i+1)%4].second;\n        int dot = dx1 * dx2 + dy1 * dy2;\n        ensuref(dot == 0, \"Adjacent sides must be perpendicular.\");\n    }\n\n    if (is_first_square) {\n        // For each side, check that dx == 0 or dy == 0\n        for (int i = 0; i < 4; ++i) {\n            int dx = sides[i].first;\n            int dy = sides[i].second;\n            ensuref(dx == 0 || dy == 0, \"Sides of the first square must be axis-aligned.\");\n        }\n    } else {\n        // For each side, check that |dx| == |dy|\n        for (int i = 0; i < 4; ++i) {\n            int dx = sides[i].first;\n            int dy = sides[i].second;\n            ensuref(abs(dx) == abs(dy), \"Sides of the second square must be at 45 degrees.\");\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read first line\n    vector<int> square1 = inf.readInts(8, -100, 100, \"square1\");\n    inf.readEoln();\n\n    vector<pair<int,int>> P1(4);\n    for (int i = 0; i < 4; ++i) {\n        P1[i] = make_pair(square1[2*i], square1[2*i+1]);\n    }\n\n    validate_square(P1, true);\n\n    // Read second line\n    vector<int> square2 = inf.readInts(8, -100, 100, \"square2\");\n    inf.readEoln();\n\n    vector<pair<int,int>> P2(4);\n    for (int i = 0; i < 4; ++i) {\n        P2[i] = make_pair(square2[2*i], square2[2*i+1]);\n    }\n\n    validate_square(P2, false);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid validate_square(vector<pair<int,int>>& P, bool is_first_square) {\n    // 1) Check that the 4 points are distinct.\n    set<pair<int,int>> points_set(P.begin(), P.end());\n    ensuref(points_set.size() == 4, \"The 4 points should be distinct, but some points are equal.\");\n\n    // 2) Compute sides\n    vector<pair<int,int>> sides(4);\n    for (int i = 0; i < 4; ++i) {\n        int dx = P[(i+1)%4].first - P[i].first;\n        int dy = P[(i+1)%4].second - P[i].second;\n        sides[i] = make_pair(dx, dy);\n    }\n\n    // 3) Compute lengths squared of sides\n    vector<int> lengths_squared(4);\n    for (int i = 0; i < 4; ++i) {\n        int dx = sides[i].first;\n        int dy = sides[i].second;\n        lengths_squared[i] = dx*dx + dy*dy;\n    }\n\n    // Ensure that all side lengths are equal\n    for (int i = 1; i < 4; ++i) {\n        ensuref(lengths_squared[i] == lengths_squared[0], \"All sides must have equal length.\");\n    }\n\n    // 5) Compute dot products between adjacent sides\n    for (int i = 0; i < 4; ++i) {\n        int dx1 = sides[i].first;\n        int dy1 = sides[i].second;\n        int dx2 = sides[(i+1)%4].first;\n        int dy2 = sides[(i+1)%4].second;\n        int dot = dx1 * dx2 + dy1 * dy2;\n        ensuref(dot == 0, \"Adjacent sides must be perpendicular.\");\n    }\n\n    if (is_first_square) {\n        // For each side, check that dx == 0 or dy == 0\n        for (int i = 0; i < 4; ++i) {\n            int dx = sides[i].first;\n            int dy = sides[i].second;\n            ensuref(dx == 0 || dy == 0, \"Sides of the first square must be axis-aligned.\");\n        }\n    } else {\n        // For each side, check that |dx| == |dy|\n        for (int i = 0; i < 4; ++i) {\n            int dx = sides[i].first;\n            int dy = sides[i].second;\n            ensuref(abs(dx) == abs(dy), \"Sides of the second square must be at 45 degrees.\");\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read first line\n    vector<int> square1 = inf.readInts(8, -100, 100, \"square1\");\n    inf.readEoln();\n\n    vector<pair<int,int>> P1(4);\n    for (int i = 0; i < 4; ++i) {\n        P1[i] = make_pair(square1[2*i], square1[2*i+1]);\n    }\n\n    validate_square(P1, true);\n\n    // Read second line\n    vector<int> square2 = inf.readInts(8, -100, 100, \"square2\");\n    inf.readEoln();\n\n    vector<pair<int,int>> P2(4);\n    for (int i = 0; i < 4; ++i) {\n        P2[i] = make_pair(square2[2*i], square2[2*i+1]);\n    }\n\n    validate_square(P2, false);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> generate_axis_aligned_square(int min_coord, int max_coord) {\n    int side_max = min(max_coord - min_coord, 99);\n    int side_length = rnd.next(1, side_max);\n    int x1 = rnd.next(min_coord, max_coord - side_length);\n    int y1 = rnd.next(min_coord, max_coord - side_length);\n\n    vector<pair<int, int>> square;\n    square.push_back({x1, y1});\n    square.push_back({x1 + side_length, y1});\n    square.push_back({x1 + side_length, y1 + side_length});\n    square.push_back({x1, y1 + side_length});\n\n    if (rnd.next(0, 1)) {\n        reverse(square.begin(), square.end());\n    }\n    return square;\n}\n\nvector<pair<int, int>> generate_rotated_square(int min_coord, int max_coord) {\n    int s_max = (max_coord - min_coord) / 2;\n    if (s_max < 1) s_max = 1;\n    int s_length = rnd.next(1, s_max);\n\n    int x0 = rnd.next(min_coord, max_coord - 2 * s_length);\n    int y0 = rnd.next(min_coord + s_length, max_coord - s_length);\n\n    vector<pair<int, int>> square;\n    square.push_back({x0, y0});\n    square.push_back({x0 + s_length, y0 + s_length});\n    square.push_back({x0 + 2 * s_length, y0});\n    square.push_back({x0 + s_length, y0 - s_length});\n\n    if (rnd.next(0, 1)) {\n        reverse(square.begin(), square.end());\n    }\n    return square;\n}\n\nvoid generate_touch_corner(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord, max_coord);\n\n    int idx1 = rnd.next(0, 3);\n    pair<int, int> vertex = square1[idx1];\n    int x0 = vertex.first;\n    int y0 = vertex.second;\n\n    int s_max = min({(max_coord - x0) / 2, (x0 - min_coord) / 2, (max_coord - y0) / 2, (y0 - min_coord) / 2, 50});\n    if (s_max < 1) s_max = 1;\n    int s_length = rnd.next(1, s_max);\n\n    vector<pair<int, int>> sq2;\n    sq2.push_back({x0, y0});\n    sq2.push_back({x0 + s_length, y0 + s_length});\n    sq2.push_back({x0 + 2 * s_length, y0});\n    sq2.push_back({x0 + s_length, y0 - s_length});\n\n    if (rnd.next(0, 1)) {\n        reverse(sq2.begin(), sq2.end());\n    }\n    square2 = sq2;\n}\n\nvoid generate_no_intersect(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord, max_coord);\n\n    int left = square1[1].first + 10;\n    int right = max_coord;\n    if (left >= right) {\n        right = square1[0].first - 10;\n        left = min_coord;\n    }\n    if (left >= right) {\n        left = min_coord;\n        right = max_coord;\n    }\n    square2 = generate_rotated_square(left, right);\n}\n\nvoid generate_nested(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord + 50, max_coord - 50);\n\n    int x_center = (square1[0].first + square1[2].first) / 2;\n    int y_center = (square1[0].second + square1[2].second) / 2;\n\n    int s_length = rnd.next(1, 10);\n    vector<pair<int, int>> sq2;\n    sq2.push_back({x_center, y_center + s_length});\n    sq2.push_back({x_center + s_length, y_center});\n    sq2.push_back({x_center, y_center - s_length});\n    sq2.push_back({x_center - s_length, y_center});\n\n    square2 = sq2;\n}\n\nvoid generate_touch_edge(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord, max_coord);\n\n    int idx = rnd.next(0, 3);\n    pair<int, int> p1 = square1[idx];\n    pair<int, int> p2 = square1[(idx + 1) % 4];\n\n    int x0 = (p1.first + p2.first) / 2;\n    int y0 = (p1.second + p2.second) / 2;\n\n    int s_length = rnd.next(1, 10);\n    vector<pair<int, int>> sq2;\n    sq2.push_back({x0 - s_length, y0});\n    sq2.push_back({x0, y0 + s_length});\n    sq2.push_back({x0 + s_length, y0});\n    sq2.push_back({x0, y0 - s_length});\n\n    square2 = sq2;\n}\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n    int max_coord = opt<int>(\"max_coord\", 100);\n    int min_coord = -max_coord;\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> square1(4), square2(4);\n\n    if (type == \"random\") {\n        square1 = generate_axis_aligned_square(min_coord, max_coord);\n        square2 = generate_rotated_square(min_coord, max_coord);\n    } else if (type == \"touch_corner\") {\n        generate_touch_corner(square1, square2, min_coord, max_coord);\n    } else if (type == \"touch_edge\") {\n        generate_touch_edge(square1, square2, min_coord, max_coord);\n    } else if (type == \"nested\") {\n        generate_nested(square1, square2, min_coord, max_coord);\n    } else if (type == \"no_intersect\") {\n        generate_no_intersect(square1, square2, min_coord, max_coord);\n    } else {\n        // Default to random if type is unknown\n        square1 = generate_axis_aligned_square(min_coord, max_coord);\n        square2 = generate_rotated_square(min_coord, max_coord);\n    }\n\n    for (int i = 0; i < 4; ++i) {\n        printf(\"%d %d\", square1[i].first, square1[i].second);\n        if (i < 3)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < 4; ++i) {\n        printf(\"%d %d\", square2[i].first, square2[i].second);\n        if (i < 3)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> generate_axis_aligned_square(int min_coord, int max_coord) {\n    int side_max = min(max_coord - min_coord, 99);\n    int side_length = rnd.next(1, side_max);\n    int x1 = rnd.next(min_coord, max_coord - side_length);\n    int y1 = rnd.next(min_coord, max_coord - side_length);\n\n    vector<pair<int, int>> square;\n    square.push_back({x1, y1});\n    square.push_back({x1 + side_length, y1});\n    square.push_back({x1 + side_length, y1 + side_length});\n    square.push_back({x1, y1 + side_length});\n\n    if (rnd.next(0, 1)) {\n        reverse(square.begin(), square.end());\n    }\n    return square;\n}\n\nvector<pair<int, int>> generate_rotated_square(int min_coord, int max_coord) {\n    int s_max = (max_coord - min_coord) / 2;\n    if (s_max < 1) s_max = 1;\n    int s_length = rnd.next(1, s_max);\n\n    int x0 = rnd.next(min_coord, max_coord - 2 * s_length);\n    int y0 = rnd.next(min_coord + s_length, max_coord - s_length);\n\n    vector<pair<int, int>> square;\n    square.push_back({x0, y0});\n    square.push_back({x0 + s_length, y0 + s_length});\n    square.push_back({x0 + 2 * s_length, y0});\n    square.push_back({x0 + s_length, y0 - s_length});\n\n    if (rnd.next(0, 1)) {\n        reverse(square.begin(), square.end());\n    }\n    return square;\n}\n\nvoid generate_touch_corner(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord, max_coord);\n\n    int idx1 = rnd.next(0, 3);\n    pair<int, int> vertex = square1[idx1];\n    int x0 = vertex.first;\n    int y0 = vertex.second;\n\n    int s_max = min({(max_coord - x0) / 2, (x0 - min_coord) / 2, (max_coord - y0) / 2, (y0 - min_coord) / 2, 50});\n    if (s_max < 1) s_max = 1;\n    int s_length = rnd.next(1, s_max);\n\n    vector<pair<int, int>> sq2;\n    sq2.push_back({x0, y0});\n    sq2.push_back({x0 + s_length, y0 + s_length});\n    sq2.push_back({x0 + 2 * s_length, y0});\n    sq2.push_back({x0 + s_length, y0 - s_length});\n\n    if (rnd.next(0, 1)) {\n        reverse(sq2.begin(), sq2.end());\n    }\n    square2 = sq2;\n}\n\nvoid generate_no_intersect(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord, max_coord);\n\n    int left = square1[1].first + 10;\n    int right = max_coord;\n    if (left >= right) {\n        right = square1[0].first - 10;\n        left = min_coord;\n    }\n    if (left >= right) {\n        left = min_coord;\n        right = max_coord;\n    }\n    square2 = generate_rotated_square(left, right);\n}\n\nvoid generate_nested(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord + 50, max_coord - 50);\n\n    int x_center = (square1[0].first + square1[2].first) / 2;\n    int y_center = (square1[0].second + square1[2].second) / 2;\n\n    int s_length = rnd.next(1, 10);\n    vector<pair<int, int>> sq2;\n    sq2.push_back({x_center, y_center + s_length});\n    sq2.push_back({x_center + s_length, y_center});\n    sq2.push_back({x_center, y_center - s_length});\n    sq2.push_back({x_center - s_length, y_center});\n\n    square2 = sq2;\n}\n\nvoid generate_touch_edge(vector<pair<int, int>> &square1, vector<pair<int, int>> &square2, int min_coord, int max_coord) {\n    square1 = generate_axis_aligned_square(min_coord, max_coord);\n\n    int idx = rnd.next(0, 3);\n    pair<int, int> p1 = square1[idx];\n    pair<int, int> p2 = square1[(idx + 1) % 4];\n\n    int x0 = (p1.first + p2.first) / 2;\n    int y0 = (p1.second + p2.second) / 2;\n\n    int s_length = rnd.next(1, 10);\n    vector<pair<int, int>> sq2;\n    sq2.push_back({x0 - s_length, y0});\n    sq2.push_back({x0, y0 + s_length});\n    sq2.push_back({x0 + s_length, y0});\n    sq2.push_back({x0, y0 - s_length});\n\n    square2 = sq2;\n}\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n    int max_coord = opt<int>(\"max_coord\", 100);\n    int min_coord = -max_coord;\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> square1(4), square2(4);\n\n    if (type == \"random\") {\n        square1 = generate_axis_aligned_square(min_coord, max_coord);\n        square2 = generate_rotated_square(min_coord, max_coord);\n    } else if (type == \"touch_corner\") {\n        generate_touch_corner(square1, square2, min_coord, max_coord);\n    } else if (type == \"touch_edge\") {\n        generate_touch_edge(square1, square2, min_coord, max_coord);\n    } else if (type == \"nested\") {\n        generate_nested(square1, square2, min_coord, max_coord);\n    } else if (type == \"no_intersect\") {\n        generate_no_intersect(square1, square2, min_coord, max_coord);\n    } else {\n        // Default to random if type is unknown\n        square1 = generate_axis_aligned_square(min_coord, max_coord);\n        square2 = generate_rotated_square(min_coord, max_coord);\n    }\n\n    for (int i = 0; i < 4; ++i) {\n        printf(\"%d %d\", square1[i].first, square1[i].second);\n        if (i < 3)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < 4; ++i) {\n        printf(\"%d %d\", square2[i].first, square2[i].second);\n        if (i < 3)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type touch_corner\n./gen -type touch_corner\n./gen -type touch_edge\n./gen -type touch_edge\n./gen -type nested\n./gen -type nested\n./gen -type no_intersect\n./gen -type no_intersect\n./gen -type random -max_coord 50\n./gen -type random -max_coord 50\n./gen -type nested -max_coord 50\n./gen -type touch_corner -max_coord 50\n./gen -type touch_edge -max_coord 50\n./gen -type random -max_coord 10\n./gen -type nested -max_coord 10\n./gen -type no_intersect -max_coord 10\n./gen -type touch_corner -max_coord 10\n./gen -type touch_edge -max_coord 10\n./gen -type random -max_coord 5\n./gen -type nested -max_coord 5\n./gen -type no_intersect -max_coord 5\n./gen -type touch_corner -max_coord 5\n./gen -type touch_edge -max_coord 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:15.648369",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "993/B",
      "title": "B. Open Communication",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (1≤n,m≤121≤n,m≤12) — the number of pairs the first participant communicated to the second and vice versa.The second line contains nn pairs of integers, each between 11 and 99, — pairs of numbers communicated from first participant to the second.The third line contains mm pairs of integers, each between 11 and 99, — pairs of numbers communicated from the second participant to the first.All pairs within each set are distinct (in particular, if there is a pair (1,2)(1,2), there will be no pair (2,1)(2,1) within the same set), and no pair contains the same number twice.It is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.",
      "output_spec": "OutputIf you can deduce the shared number with certainty, print that number.If you can with certainty deduce that both participants know the shared number, but you do not know it, print 00.Otherwise print −1−1.",
      "sample_tests": "ExamplesInputCopy2 21 2 3 41 5 3 4OutputCopy1InputCopy2 21 2 3 41 5 6 4OutputCopy0InputCopy2 31 2 4 51 2 1 3 2 3OutputCopy-1",
      "description": "B. Open Communication\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (1≤n,m≤121≤n,m≤12) — the number of pairs the first participant communicated to the second and vice versa.The second line contains nn pairs of integers, each between 11 and 99, — pairs of numbers communicated from first participant to the second.The third line contains mm pairs of integers, each between 11 and 99, — pairs of numbers communicated from the second participant to the first.All pairs within each set are distinct (in particular, if there is a pair (1,2)(1,2), there will be no pair (2,1)(2,1) within the same set), and no pair contains the same number twice.It is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.\n\nOutputIf you can deduce the shared number with certainty, print that number.If you can with certainty deduce that both participants know the shared number, but you do not know it, print 00.Otherwise print −1−1.\n\nInputCopy2 21 2 3 41 5 3 4OutputCopy1InputCopy2 21 2 3 41 5 6 4OutputCopy0InputCopy2 31 2 4 51 2 1 3 2 3OutputCopy-1\n\nInputCopy2 21 2 3 41 5 3 4\n\nOutputCopy1\n\nInputCopy2 21 2 3 41 5 6 4\n\nOutputCopy0\n\nInputCopy2 31 2 4 51 2 1 3 2 3\n\nOutputCopy-1\n\nNoteIn the first example the first participant communicated pairs (1,2)(1,2) and (3,4)(3,4), and the second communicated (1,5)(1,5), (3,4)(3,4). Since we know that the actual pairs they received share exactly one number, it can't be that they both have (3,4)(3,4). Thus, the first participant has (1,2)(1,2) and the second has (1,5)(1,5), and at this point you already know the shared number is 11.In the second example either the first participant has (1,2)(1,2) and the second has (1,5)(1,5), or the first has (3,4)(3,4) and the second has (6,4)(6,4). In the first case both of them know the shared number is 11, in the second case both of them know the shared number is 44. You don't have enough information to tell 11 and 44 apart.In the third case if the first participant was given (1,2)(1,2), they don't know what the shared number is, since from their perspective the second participant might have been given either (1,3)(1,3), in which case the shared number is 11, or (2,3)(2,3), in which case the shared number is 22. While the second participant does know the number with certainty, neither you nor the first participant do, so the output is −1−1.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 993 和字母"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 12, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 12, \"m\");\n    inf.readEoln();\n\n    vector<int> nums1 = inf.readInts(2 * n, 1, 9, \"numbers in first set\");\n    inf.readEoln();\n\n    vector<int> nums2 = inf.readInts(2 * m, 1, 9, \"numbers in second set\");\n    inf.readEoln();\n\n    set<pair<int, int>> first_pairs;\n    for (int i = 0; i < 2 * n; i += 2) {\n        int a = nums1[i];\n        int b = nums1[i + 1];\n        ensuref(a != b, \"Pair numbers must be different in first set, but found pair (%d,%d)\", a, b);\n        int x = min(a, b);\n        int y = max(a, b);\n        pair<int, int> p = make_pair(x, y);\n        ensuref(first_pairs.count(p) == 0, \"Duplicate pair (%d,%d) in first set\", x, y);\n        first_pairs.insert(p);\n    }\n\n    set<pair<int, int>> second_pairs;\n    for (int i = 0; i < 2 * m; i += 2) {\n        int a = nums2[i];\n        int b = nums2[i + 1];\n        ensuref(a != b, \"Pair numbers must be different in second set, but found pair (%d,%d)\", a, b);\n        int x = min(a, b);\n        int y = max(a, b);\n        pair<int, int> p = make_pair(x, y);\n        ensuref(second_pairs.count(p) == 0, \"Duplicate pair (%d,%d) in second set\", x, y);\n        second_pairs.insert(p);\n    }\n\n    bool found = false;\n    for (auto p1 : first_pairs) {\n        int a1 = p1.first;\n        int b1 = p1.second;\n        for (auto p2 : second_pairs) {\n            int a2 = p2.first;\n            int b2 = p2.second;\n            int common = 0;\n            if (a1 == a2 || a1 == b2) common++;\n            if (b1 == a2 || b1 == b2) common++;\n            if (common == 1) {\n                found = true;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    ensuref(found, \"No pair from first set and second set share exactly one number\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 12, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 12, \"m\");\n    inf.readEoln();\n\n    vector<int> nums1 = inf.readInts(2 * n, 1, 9, \"numbers in first set\");\n    inf.readEoln();\n\n    vector<int> nums2 = inf.readInts(2 * m, 1, 9, \"numbers in second set\");\n    inf.readEoln();\n\n    set<pair<int, int>> first_pairs;\n    for (int i = 0; i < 2 * n; i += 2) {\n        int a = nums1[i];\n        int b = nums1[i + 1];\n        ensuref(a != b, \"Pair numbers must be different in first set, but found pair (%d,%d)\", a, b);\n        int x = min(a, b);\n        int y = max(a, b);\n        pair<int, int> p = make_pair(x, y);\n        ensuref(first_pairs.count(p) == 0, \"Duplicate pair (%d,%d) in first set\", x, y);\n        first_pairs.insert(p);\n    }\n\n    set<pair<int, int>> second_pairs;\n    for (int i = 0; i < 2 * m; i += 2) {\n        int a = nums2[i];\n        int b = nums2[i + 1];\n        ensuref(a != b, \"Pair numbers must be different in second set, but found pair (%d,%d)\", a, b);\n        int x = min(a, b);\n        int y = max(a, b);\n        pair<int, int> p = make_pair(x, y);\n        ensuref(second_pairs.count(p) == 0, \"Duplicate pair (%d,%d) in second set\", x, y);\n        second_pairs.insert(p);\n    }\n\n    bool found = false;\n    for (auto p1 : first_pairs) {\n        int a1 = p1.first;\n        int b1 = p1.second;\n        for (auto p2 : second_pairs) {\n            int a2 = p2.first;\n            int b2 = p2.second;\n            int common = 0;\n            if (a1 == a2 || a1 == b2) common++;\n            if (b1 == a2 || b1 == b2) common++;\n            if (common == 1) {\n                found = true;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    ensuref(found, \"No pair from first set and second set share exactly one number\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 12, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 12, \"m\");\n    inf.readEoln();\n\n    vector<int> nums1 = inf.readInts(2 * n, 1, 9, \"numbers in first set\");\n    inf.readEoln();\n\n    vector<int> nums2 = inf.readInts(2 * m, 1, 9, \"numbers in second set\");\n    inf.readEoln();\n\n    set<pair<int, int>> first_pairs;\n    for (int i = 0; i < 2 * n; i += 2) {\n        int a = nums1[i];\n        int b = nums1[i + 1];\n        ensuref(a != b, \"Pair numbers must be different in first set, but found pair (%d,%d)\", a, b);\n        int x = min(a, b);\n        int y = max(a, b);\n        pair<int, int> p = make_pair(x, y);\n        ensuref(first_pairs.count(p) == 0, \"Duplicate pair (%d,%d) in first set\", x, y);\n        first_pairs.insert(p);\n    }\n\n    set<pair<int, int>> second_pairs;\n    for (int i = 0; i < 2 * m; i += 2) {\n        int a = nums2[i];\n        int b = nums2[i + 1];\n        ensuref(a != b, \"Pair numbers must be different in second set, but found pair (%d,%d)\", a, b);\n        int x = min(a, b);\n        int y = max(a, b);\n        pair<int, int> p = make_pair(x, y);\n        ensuref(second_pairs.count(p) == 0, \"Duplicate pair (%d,%d) in second set\", x, y);\n        second_pairs.insert(p);\n    }\n\n    bool found = false;\n    for (auto p1 : first_pairs) {\n        int a1 = p1.first;\n        int b1 = p1.second;\n        for (auto p2 : second_pairs) {\n            int a2 = p2.first;\n            int b2 = p2.second;\n            int common = 0;\n            if (a1 == a2 || a1 == b2) common++;\n            if (b1 == a2 || b1 == b2) common++;\n            if (common == 1) {\n                found = true;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    ensuref(found, \"No pair from first set and second set share exactly one number\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nbool eq_pair(pii a, pii b) {\n    if (a.first == b.first && a.second == b.second)\n        return true;\n    if (a.first == b.second && a.second == b.first)\n        return true;\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of pairs for participant 1\n    int m = opt<int>(\"m\"); // Number of pairs for participant 2\n    string ans_type = opt<string>(\"ans_type\", \"number\"); // \"number\", \"zero\", or \"-1\"\n\n    if (n < 1 || n > 12 || m < 1 || m > 12) {\n        fprintf(stderr, \"Invalid n or m\\n\");\n        return 1;\n    }\n\n    vector<pii> set1, set2; // Sets of pairs for participants\n    set<pair<int,int>> pairs1, pairs2; // To check for duplicates within sets\n\n    if (ans_type == \"number\") {\n        // Generate a test case where the shared number can be determined\n        int s = rnd.next(1, 9); // Shared number\n        int a1, a2;\n        do {\n            a1 = rnd.next(1, 9);\n        } while (a1 == s);\n        do {\n            a2 = rnd.next(1, 9);\n        } while (a2 == s || a2 == a1);\n\n        // Add their actual pairs\n        set1.emplace_back(s, a1);\n        pairs1.insert({min(s, a1), max(s, a1)});\n        set2.emplace_back(s, a2);\n        pairs2.insert({min(s, a2), max(s, a2)});\n\n        // Collect other numbers\n        vector<int> nums;\n        for (int i = 1; i <= 9; ++i) {\n            if (i != s && i != a1 && i != a2) {\n                nums.push_back(i);\n            }\n        }\n\n        // Generate other pairs\n        vector<pii> other_pairs;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                other_pairs.emplace_back(nums[i], nums[j]);\n            }\n        }\n        shuffle(other_pairs.begin(), other_pairs.end());\n\n        // Fill up the rest of the pairs\n        for (auto& p : other_pairs) {\n            if (set1.size() < n) {\n                set1.push_back(p);\n                pairs1.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n            if (set2.size() < m) {\n                set2.push_back(p);\n                pairs2.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n        }\n    } else if (ans_type == \"zero\") {\n        // Generate a test case where the shared number is known to participants, but not to us\n        int s1, s2;\n        do { s1 = rnd.next(1, 9); s2 = rnd.next(1, 9); } while (s1 == s2);\n        int a1, a2;\n        do { a1 = rnd.next(1, 9); } while (a1 == s1 || a1 == s2);\n        do { a2 = rnd.next(1, 9); } while (a2 == s1 || a2 == s2 || a2 == a1);\n\n        // Add possible actual pairs\n        set1.emplace_back(s1, a1);\n        set1.emplace_back(s2, a1);\n        pairs1.insert({min(s1, a1), max(s1, a1)});\n        pairs1.insert({min(s2, a1), max(s2, a1)});\n        set2.emplace_back(s1, a2);\n        set2.emplace_back(s2, a2);\n        pairs2.insert({min(s1, a2), max(s1, a2)});\n        pairs2.insert({min(s2, a2), max(s2, a2)});\n\n        // Collect other numbers\n        vector<int> nums;\n        for (int i = 1; i <= 9; ++i) {\n            if (i != s1 && i != s2 && i != a1 && i != a2) {\n                nums.push_back(i);\n            }\n        }\n\n        // Generate other pairs\n        vector<pii> other_pairs;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                other_pairs.emplace_back(nums[i], nums[j]);\n            }\n        }\n        shuffle(other_pairs.begin(), other_pairs.end());\n\n        // Fill up the rest of the pairs\n        for (auto& p : other_pairs) {\n            if (set1.size() < n) {\n                set1.push_back(p);\n                pairs1.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n            if (set2.size() < m) {\n                set2.push_back(p);\n                pairs2.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n        }\n    } else if (ans_type == \"-1\") {\n        // Generate a test case where the shared number cannot be determined\n        int a1, b1, c1;\n        do { a1 = rnd.next(1, 9); b1 = rnd.next(1, 9); c1 = rnd.next(1, 9); } while (a1 == b1 || a1 == c1 || b1 == c1);\n\n        // Add actual pairs\n        set1.emplace_back(a1, b1);\n        pairs1.insert({min(a1, b1), max(a1, b1)});\n        set2.emplace_back(a1, c1);\n        set2.emplace_back(b1, c1);\n        pairs2.insert({min(a1, c1), max(a1, c1)});\n        pairs2.insert({min(b1, c1), max(b1, c1)});\n\n        // Collect other numbers\n        vector<int> nums;\n        for (int i = 1; i <= 9; ++i) {\n            if (i != a1 && i != b1 && i != c1) {\n                nums.push_back(i);\n            }\n        }\n\n        // Generate other pairs\n        vector<pii> other_pairs;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                other_pairs.emplace_back(nums[i], nums[j]);\n            }\n        }\n        shuffle(other_pairs.begin(), other_pairs.end());\n\n        // Fill up the rest of the pairs\n        for (auto& p : other_pairs) {\n            if (set1.size() < n) {\n                set1.push_back(p);\n                pairs1.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n            if (set2.size() < m) {\n                set2.push_back(p);\n                pairs2.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Invalid ans_type\\n\");\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output participant 1 pairs\n    for (size_t i = 0; i < set1.size(); ++i) {\n        printf(\"%d %d%c\", set1[i].first, set1[i].second, (i + 1 == set1.size()) ? '\\n' : ' ');\n    }\n\n    // Output participant 2 pairs\n    for (size_t i = 0; i < set2.size(); ++i) {\n        printf(\"%d %d%c\", set2[i].first, set2[i].second, (i + 1 == set2.size()) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nbool eq_pair(pii a, pii b) {\n    if (a.first == b.first && a.second == b.second)\n        return true;\n    if (a.first == b.second && a.second == b.first)\n        return true;\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of pairs for participant 1\n    int m = opt<int>(\"m\"); // Number of pairs for participant 2\n    string ans_type = opt<string>(\"ans_type\", \"number\"); // \"number\", \"zero\", or \"-1\"\n\n    if (n < 1 || n > 12 || m < 1 || m > 12) {\n        fprintf(stderr, \"Invalid n or m\\n\");\n        return 1;\n    }\n\n    vector<pii> set1, set2; // Sets of pairs for participants\n    set<pair<int,int>> pairs1, pairs2; // To check for duplicates within sets\n\n    if (ans_type == \"number\") {\n        // Generate a test case where the shared number can be determined\n        int s = rnd.next(1, 9); // Shared number\n        int a1, a2;\n        do {\n            a1 = rnd.next(1, 9);\n        } while (a1 == s);\n        do {\n            a2 = rnd.next(1, 9);\n        } while (a2 == s || a2 == a1);\n\n        // Add their actual pairs\n        set1.emplace_back(s, a1);\n        pairs1.insert({min(s, a1), max(s, a1)});\n        set2.emplace_back(s, a2);\n        pairs2.insert({min(s, a2), max(s, a2)});\n\n        // Collect other numbers\n        vector<int> nums;\n        for (int i = 1; i <= 9; ++i) {\n            if (i != s && i != a1 && i != a2) {\n                nums.push_back(i);\n            }\n        }\n\n        // Generate other pairs\n        vector<pii> other_pairs;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                other_pairs.emplace_back(nums[i], nums[j]);\n            }\n        }\n        shuffle(other_pairs.begin(), other_pairs.end());\n\n        // Fill up the rest of the pairs\n        for (auto& p : other_pairs) {\n            if (set1.size() < n) {\n                set1.push_back(p);\n                pairs1.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n            if (set2.size() < m) {\n                set2.push_back(p);\n                pairs2.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n        }\n    } else if (ans_type == \"zero\") {\n        // Generate a test case where the shared number is known to participants, but not to us\n        int s1, s2;\n        do { s1 = rnd.next(1, 9); s2 = rnd.next(1, 9); } while (s1 == s2);\n        int a1, a2;\n        do { a1 = rnd.next(1, 9); } while (a1 == s1 || a1 == s2);\n        do { a2 = rnd.next(1, 9); } while (a2 == s1 || a2 == s2 || a2 == a1);\n\n        // Add possible actual pairs\n        set1.emplace_back(s1, a1);\n        set1.emplace_back(s2, a1);\n        pairs1.insert({min(s1, a1), max(s1, a1)});\n        pairs1.insert({min(s2, a1), max(s2, a1)});\n        set2.emplace_back(s1, a2);\n        set2.emplace_back(s2, a2);\n        pairs2.insert({min(s1, a2), max(s1, a2)});\n        pairs2.insert({min(s2, a2), max(s2, a2)});\n\n        // Collect other numbers\n        vector<int> nums;\n        for (int i = 1; i <= 9; ++i) {\n            if (i != s1 && i != s2 && i != a1 && i != a2) {\n                nums.push_back(i);\n            }\n        }\n\n        // Generate other pairs\n        vector<pii> other_pairs;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                other_pairs.emplace_back(nums[i], nums[j]);\n            }\n        }\n        shuffle(other_pairs.begin(), other_pairs.end());\n\n        // Fill up the rest of the pairs\n        for (auto& p : other_pairs) {\n            if (set1.size() < n) {\n                set1.push_back(p);\n                pairs1.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n            if (set2.size() < m) {\n                set2.push_back(p);\n                pairs2.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n        }\n    } else if (ans_type == \"-1\") {\n        // Generate a test case where the shared number cannot be determined\n        int a1, b1, c1;\n        do { a1 = rnd.next(1, 9); b1 = rnd.next(1, 9); c1 = rnd.next(1, 9); } while (a1 == b1 || a1 == c1 || b1 == c1);\n\n        // Add actual pairs\n        set1.emplace_back(a1, b1);\n        pairs1.insert({min(a1, b1), max(a1, b1)});\n        set2.emplace_back(a1, c1);\n        set2.emplace_back(b1, c1);\n        pairs2.insert({min(a1, c1), max(a1, c1)});\n        pairs2.insert({min(b1, c1), max(b1, c1)});\n\n        // Collect other numbers\n        vector<int> nums;\n        for (int i = 1; i <= 9; ++i) {\n            if (i != a1 && i != b1 && i != c1) {\n                nums.push_back(i);\n            }\n        }\n\n        // Generate other pairs\n        vector<pii> other_pairs;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                other_pairs.emplace_back(nums[i], nums[j]);\n            }\n        }\n        shuffle(other_pairs.begin(), other_pairs.end());\n\n        // Fill up the rest of the pairs\n        for (auto& p : other_pairs) {\n            if (set1.size() < n) {\n                set1.push_back(p);\n                pairs1.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n            if (set2.size() < m) {\n                set2.push_back(p);\n                pairs2.insert({min(p.first, p.second), max(p.first, p.second)});\n            }\n        }\n    } else {\n        fprintf(stderr, \"Invalid ans_type\\n\");\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output participant 1 pairs\n    for (size_t i = 0; i < set1.size(); ++i) {\n        printf(\"%d %d%c\", set1[i].first, set1[i].second, (i + 1 == set1.size()) ? '\\n' : ' ');\n    }\n\n    // Output participant 2 pairs\n    for (size_t i = 0; i < set2.size(); ++i) {\n        printf(\"%d %d%c\", set2[i].first, set2[i].second, (i + 1 == set2.size()) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -ans_type number\n./gen -n 1 -m 1 -ans_type zero\n./gen -n 1 -m 1 -ans_type -1\n\n./gen -n 2 -m 2 -ans_type number\n./gen -n 2 -m 2 -ans_type zero\n./gen -n 2 -m 2 -ans_type -1\n\n./gen -n 3 -m 3 -ans_type number\n./gen -n 3 -m 3 -ans_type zero\n./gen -n 3 -m 3 -ans_type -1\n\n./gen -n 5 -m 5 -ans_type number\n./gen -n 5 -m 5 -ans_type zero\n./gen -n 5 -m 5 -ans_type -1\n\n./gen -n 10 -m 10 -ans_type number\n./gen -n 10 -m 10 -ans_type zero\n./gen -n 10 -m 10 -ans_type -1\n\n./gen -n 12 -m 12 -ans_type number\n./gen -n 12 -m 12 -ans_type zero\n./gen -n 12 -m 12 -ans_type -1\n\n./gen -n 12 -m 1 -ans_type number\n./gen -n 12 -m 1 -ans_type zero\n./gen -n 12 -m 1 -ans_type -1\n\n./gen -n 1 -m 12 -ans_type number\n./gen -n 1 -m 12 -ans_type zero\n./gen -n 1 -m 12 -ans_type -1\n\n./gen -n 8 -m 5 -ans_type number\n./gen -n 8 -m 5 -ans_type zero\n./gen -n 8 -m 5 -ans_type -1\n\n./gen -n 5 -m 8 -ans_type number\n./gen -n 5 -m 8 -ans_type zero\n./gen -n 5 -m 8 -ans_type -1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:17.525586",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "993/C",
      "title": "C. Careful Maneuvering",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (1≤n,m≤601≤n,m≤60), the number of enemy spaceships with x=−100x=−100 and the number of enemy spaceships with x=100x=100, respectively.The second line contains nn integers y1,1,y1,2,…,y1,ny1,1,y1,2,…,y1,n (|y1,i|≤10000|y1,i|≤10000) — the yy-coordinates of the spaceships in the first group.The third line contains mm integers y2,1,y2,2,…,y2,my2,1,y2,2,…,y2,m (|y2,i|≤10000|y2,i|≤10000) — the yy-coordinates of the spaceships in the second group.The yy coordinates are not guaranteed to be unique, even within a group.",
      "output_spec": "OutputPrint a single integer – the largest number of enemy spaceships that can be destroyed.",
      "sample_tests": "ExamplesInputCopy3 91 2 31 2 3 7 8 9 11 12 13OutputCopy9InputCopy5 51 2 3 4 51 2 3 4 5OutputCopy10",
      "description": "C. Careful Maneuvering\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (1≤n,m≤601≤n,m≤60), the number of enemy spaceships with x=−100x=−100 and the number of enemy spaceships with x=100x=100, respectively.The second line contains nn integers y1,1,y1,2,…,y1,ny1,1,y1,2,…,y1,n (|y1,i|≤10000|y1,i|≤10000) — the yy-coordinates of the spaceships in the first group.The third line contains mm integers y2,1,y2,2,…,y2,my2,1,y2,2,…,y2,m (|y2,i|≤10000|y2,i|≤10000) — the yy-coordinates of the spaceships in the second group.The yy coordinates are not guaranteed to be unique, even within a group.\n\nOutputPrint a single integer – the largest number of enemy spaceships that can be destroyed.\n\nInputCopy3 91 2 31 2 3 7 8 9 11 12 13OutputCopy9InputCopy5 51 2 3 4 51 2 3 4 5OutputCopy10\n\nInputCopy3 91 2 31 2 3 7 8 9 11 12 13\n\nOutputCopy9\n\nInputCopy5 51 2 3 4 51 2 3 4 5\n\nOutputCopy10\n\nNoteIn the first example the first spaceship can be positioned at (0,2)(0,2), and the second – at (0,7)(0,7). This way all the enemy spaceships in the first group and 66 out of 99 spaceships in the second group will be destroyed.In the second example the first spaceship can be positioned at (0,3)(0,3), and the second can be positioned anywhere, it will be sufficient to destroy all the enemy spaceships.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 993 和字母"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readEoln();\n\n    vector<int> y1 = inf.readInts(n, -10000, 10000, \"y1\");\n    inf.readEoln();\n\n    vector<int> y2 = inf.readInts(m, -10000, 10000, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readEoln();\n\n    vector<int> y1 = inf.readInts(n, -10000, 10000, \"y1\");\n    inf.readEoln();\n\n    vector<int> y2 = inf.readInts(m, -10000, 10000, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readEoln();\n\n    vector<int> y1 = inf.readInts(n, -10000, 10000, \"y1\");\n    inf.readEoln();\n\n    vector<int> y2 = inf.readInts(m, -10000, 10000, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> y1(n), y2(m);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for(int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"same_y\") {\n        int y = rnd.next(-10000, 10000);\n        for(int i = 0; i < n; ++i)\n            y1[i] = y;\n        for(int i = 0; i < m; ++i)\n            y2[i] = y;\n    } else if (type == \"duplicate_y\") {\n        vector<int> ys;\n        int num_duplicates = rnd.next(1, min(10, n));\n        for(int i = 0; i < num_duplicates; ++i)\n            ys.push_back(rnd.next(-10000, 10000));\n        for(int i = 0; i < n; ++i)\n            y1[i] = ys[rnd.next(0, num_duplicates - 1)];\n        ys.clear();\n        num_duplicates = rnd.next(1, min(10, m));\n        for(int i = 0; i < num_duplicates; ++i)\n            ys.push_back(rnd.next(-10000, 10000));\n        for(int i = 0; i < m; ++i)\n            y2[i] = ys[rnd.next(0, num_duplicates - 1)];\n    } else if (type == \"extreme_y\") {\n        for(int i = 0; i < n; ++i)\n            y1[i] = (i % 2 == 0) ? -10000 : 10000;\n        for(int i = 0; i < m; ++i)\n            y2[i] = (i % 2 == 0) ? -10000 : 10000;\n    } else if (type == \"linear\") {\n        int y_start = rnd.next(-10000, 10000 - n);\n        for(int i = 0; i < n; ++i)\n            y1[i] = y_start + i;\n        y_start = rnd.next(-10000, 10000 - m);\n        for(int i = 0; i < m; ++i)\n            y2[i] = y_start + i;\n    } else if (type == \"clusters\") {\n        int num_clusters = rnd.next(1, 5);\n        vector<int> cluster_y;\n        for(int i = 0; i < num_clusters; ++i)\n            cluster_y.push_back(rnd.next(-10000, 10000));\n\n        for(int i = 0; i < n; ++i)\n            y1[i] = cluster_y[rnd.next(0, num_clusters - 1)] + rnd.next(-5, 5);\n        for(int i = 0; i < m; ++i)\n            y2[i] = cluster_y[rnd.next(0, num_clusters - 1)] + rnd.next(-5, 5);\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for(int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else {\n        // default is random\n        for(int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for(int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", y1[i], i == n - 1 ? '\\n' : ' ');\n    for(int i = 0; i < m; ++i)\n        printf(\"%d%c\", y2[i], i == m - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> y1(n), y2(m);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for(int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"same_y\") {\n        int y = rnd.next(-10000, 10000);\n        for(int i = 0; i < n; ++i)\n            y1[i] = y;\n        for(int i = 0; i < m; ++i)\n            y2[i] = y;\n    } else if (type == \"duplicate_y\") {\n        vector<int> ys;\n        int num_duplicates = rnd.next(1, min(10, n));\n        for(int i = 0; i < num_duplicates; ++i)\n            ys.push_back(rnd.next(-10000, 10000));\n        for(int i = 0; i < n; ++i)\n            y1[i] = ys[rnd.next(0, num_duplicates - 1)];\n        ys.clear();\n        num_duplicates = rnd.next(1, min(10, m));\n        for(int i = 0; i < num_duplicates; ++i)\n            ys.push_back(rnd.next(-10000, 10000));\n        for(int i = 0; i < m; ++i)\n            y2[i] = ys[rnd.next(0, num_duplicates - 1)];\n    } else if (type == \"extreme_y\") {\n        for(int i = 0; i < n; ++i)\n            y1[i] = (i % 2 == 0) ? -10000 : 10000;\n        for(int i = 0; i < m; ++i)\n            y2[i] = (i % 2 == 0) ? -10000 : 10000;\n    } else if (type == \"linear\") {\n        int y_start = rnd.next(-10000, 10000 - n);\n        for(int i = 0; i < n; ++i)\n            y1[i] = y_start + i;\n        y_start = rnd.next(-10000, 10000 - m);\n        for(int i = 0; i < m; ++i)\n            y2[i] = y_start + i;\n    } else if (type == \"clusters\") {\n        int num_clusters = rnd.next(1, 5);\n        vector<int> cluster_y;\n        for(int i = 0; i < num_clusters; ++i)\n            cluster_y.push_back(rnd.next(-10000, 10000));\n\n        for(int i = 0; i < n; ++i)\n            y1[i] = cluster_y[rnd.next(0, num_clusters - 1)] + rnd.next(-5, 5);\n        for(int i = 0; i < m; ++i)\n            y2[i] = cluster_y[rnd.next(0, num_clusters - 1)] + rnd.next(-5, 5);\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for(int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else {\n        // default is random\n        for(int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for(int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", y1[i], i == n - 1 ? '\\n' : ' ');\n    for(int i = 0; i < m; ++i)\n        printf(\"%d%c\", y2[i], i == m - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type same_y\n./gen -n 5 -m 5 -type duplicate_y\n./gen -n 10 -m 10 -type extreme_y\n./gen -n 20 -m 20 -type linear\n./gen -n 30 -m 30 -type clusters\n./gen -n 40 -m 40 -type random\n./gen -n 50 -m 10 -type same_y\n./gen -n 60 -m 60 -type duplicate_y\n./gen -n 60 -m 60 -type extreme_y\n\n./gen -n 55 -m 45 -type clusters\n./gen -n 10 -m 60 -type random\n./gen -n 60 -m 10 -type same_y\n./gen -n 60 -m 1 -type linear\n./gen -n 1 -m 60 -type linear\n./gen -n 50 -m 50 -type clusters\n./gen -n 1 -m 1 -type extreme_y\n./gen -n 60 -m 60 -type max\n./gen -n 59 -m 59 -type max\n./gen -n 60 -m 60 -type random\n\n./gen -n 1 -m 50 -type duplicate_y\n./gen -n 50 -m 1 -type duplicate_y\n./gen -n 3 -m 4 -type clusters\n./gen -n 2 -m 58 -type linear\n./gen -n 22 -m 38 -type random\n./gen -n 15 -m 45 -type extreme_y\n./gen -n 60 -m 60 -type clusters\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:19.551446",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "993/D",
      "title": "D. Compute Power",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of tasks.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 108), where ai represents the amount of power required for the i-th task.The third line contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100), where bi is the number of processors that i-th task will utilize.",
      "output_spec": "OutputPrint a single integer value — the lowest threshold for which it is possible to assign all tasks in such a way that the system will not blow up after the first round of computation, multiplied by 1000 and rounded up.",
      "sample_tests": "ExamplesInputCopy68 10 9 9 8 101 1 1 1 1 1OutputCopy9000InputCopy68 10 9 9 8 101 10 5 5 1 10OutputCopy1160",
      "description": "D. Compute Power\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of tasks.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 108), where ai represents the amount of power required for the i-th task.The third line contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100), where bi is the number of processors that i-th task will utilize.\n\nOutputPrint a single integer value — the lowest threshold for which it is possible to assign all tasks in such a way that the system will not blow up after the first round of computation, multiplied by 1000 and rounded up.\n\nInputCopy68 10 9 9 8 101 1 1 1 1 1OutputCopy9000InputCopy68 10 9 9 8 101 10 5 5 1 10OutputCopy1160\n\nInputCopy68 10 9 9 8 101 1 1 1 1 1\n\nOutputCopy9000\n\nInputCopy68 10 9 9 8 101 10 5 5 1 10\n\nOutputCopy1160\n\nNoteIn the first example the best strategy is to run each task on a separate computer, getting average compute per processor during the first round equal to 9.In the second task it is best to run tasks with compute 10 and 9 on one computer, tasks with compute 10 and 8 on another, and tasks with compute 9 and 8 on the last, averaging (10 + 10 + 9) / (10 + 10 + 5) = 1.16 compute power per processor during the first round.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 993 和字母"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    long long min_ai = opt<long long>(\"min_ai\", 1);\n    long long max_ai = opt<long long>(\"max_ai\", 100000000);\n    int min_bi = opt<int>(\"min_bi\", 1);\n    int max_bi = opt<int>(\"max_bi\", 100);\n\n    vector<long long> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"equal\") {\n        long long a_val = opt<long long>(\"a_val\", min_ai);\n        int b_val = opt<int>(\"b_val\", min_bi);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = a_val;\n            bi[i] = b_val;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min_ai + (max_ai - min_ai) * i / max(1, n - 1);\n            bi[i] = min_bi + (max_bi - min_bi) * i / max(1, n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max_ai - (max_ai - min_ai) * i / max(1, n - 1);\n            bi[i] = max_bi - (max_bi - min_bi) * i / max(1, n - 1);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max_ai;\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min_ai;\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"special_case1\") {\n        // All ai's are equal, can't assign two tasks to the same computer\n        long long common_ai = rnd.next(min_ai, max_ai);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = common_ai;\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"special_case2\") {\n        // ai's are shuffled, might have duplicates and challenge assignment\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min_ai + (max_ai - min_ai) * i / max(1, n - 1);\n        }\n        shuffle(ai.begin(), ai.end());\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    long long min_ai = opt<long long>(\"min_ai\", 1);\n    long long max_ai = opt<long long>(\"max_ai\", 100000000);\n    int min_bi = opt<int>(\"min_bi\", 1);\n    int max_bi = opt<int>(\"max_bi\", 100);\n\n    vector<long long> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"equal\") {\n        long long a_val = opt<long long>(\"a_val\", min_ai);\n        int b_val = opt<int>(\"b_val\", min_bi);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = a_val;\n            bi[i] = b_val;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min_ai + (max_ai - min_ai) * i / max(1, n - 1);\n            bi[i] = min_bi + (max_bi - min_bi) * i / max(1, n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max_ai - (max_ai - min_ai) * i / max(1, n - 1);\n            bi[i] = max_bi - (max_bi - min_bi) * i / max(1, n - 1);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max_ai;\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min_ai;\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"special_case1\") {\n        // All ai's are equal, can't assign two tasks to the same computer\n        long long common_ai = rnd.next(min_ai, max_ai);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = common_ai;\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"special_case2\") {\n        // ai's are shuffled, might have duplicates and challenge assignment\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min_ai + (max_ai - min_ai) * i / max(1, n - 1);\n        }\n        shuffle(ai.begin(), ai.end());\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type equal -a_val 1 -b_val 1\n./gen -n 1 -type equal -a_val 100000000 -b_val 100\n\n./gen -n 5 -type random\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type max_ai\n./gen -n 5 -type min_ai\n./gen -n 5 -type special_case1\n./gen -n 5 -type special_case2\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing -min_ai 1 -max_ai 100 -min_bi 1 -max_bi 10\n./gen -n 10 -type decreasing -min_ai 100 -max_ai 100000000 -min_bi 1 -max_bi 100\n\n./gen -n 20 -type equal -a_val 50000000 -b_val 50\n\n./gen -n 30 -type random -min_ai 1 -max_ai 1 -min_bi 100 -max_bi 100\n\n./gen -n 40 -type random -min_ai 100000000 -max_ai 100000000 -min_bi 1 -max_bi 100\n\n./gen -n 50 -type random\n./gen -n 50 -type increasing -min_ai 1 -max_ai 100000000 -min_bi 1 -max_bi 100\n./gen -n 50 -type decreasing -min_ai 1 -max_ai 100000000 -min_bi 1 -max_bi 100\n\n./gen -n 50 -type special_case1\n./gen -n 50 -type special_case2\n\n./gen -n 50 -type random -min_ai 1 -max_ai 100000000 -min_bi 100 -max_bi 100\n./gen -n 50 -type random -min_ai 1 -max_ai 1 -min_bi 1 -max_bi 1\n\n./gen -n 50 -type equal -a_val 100000000 -b_val 1\n./gen -n 50 -type equal -a_val 1 -b_val 100\n./gen -n 50 -type equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:21.679942",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "993/E",
      "title": "E. Nikita and Order Statistics",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and xx (1≤n≤2⋅105,−109≤x≤109)(1≤n≤2⋅105,−109≤x≤109).The second line contains nn integers a1,a2,…,ana1,a2,…,an (−109≤ai≤109)(−109≤ai≤109) — the given array.",
      "output_spec": "OutputPrint n+1n+1 integers, where the ii-th number is the answer for Nikita's question for k=i−1k=i−1.",
      "sample_tests": "ExamplesInputCopy5 31 2 3 4 5OutputCopy6 5 4 0 0 0 InputCopy2 6-5 9OutputCopy1 2 0 InputCopy6 99-1 -1 -1 -1 -1 -1OutputCopy0 6 5 4 3 2 1",
      "description": "E. Nikita and Order Statistics\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and xx (1≤n≤2⋅105,−109≤x≤109)(1≤n≤2⋅105,−109≤x≤109).The second line contains nn integers a1,a2,…,ana1,a2,…,an (−109≤ai≤109)(−109≤ai≤109) — the given array.\n\nOutputPrint n+1n+1 integers, where the ii-th number is the answer for Nikita's question for k=i−1k=i−1.\n\nInputCopy5 31 2 3 4 5OutputCopy6 5 4 0 0 0 InputCopy2 6-5 9OutputCopy1 2 0 InputCopy6 99-1 -1 -1 -1 -1 -1OutputCopy0 6 5 4 3 2 1\n\nInputCopy5 31 2 3 4 5\n\nOutputCopy6 5 4 0 0 0\n\nInputCopy2 6-5 9\n\nOutputCopy1 2 0\n\nInputCopy6 99-1 -1 -1 -1 -1 -1\n\nOutputCopy0 6 5 4 3 2 1",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 993\\s*E"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long MIN_A = -1000000000LL;\n    const long long MAX_A = 1000000000LL;\n\n    vector<long long> a(n);\n\n    if (type == \"all_less_than_x\") {\n        for (int i = 0; i < n; ++i) {\n            if (x > MIN_A) {\n                a[i] = rnd.next(MIN_A, x - 1);\n            } else {\n                // x == MIN_A, cannot have numbers less than x\n                a[i] = x;\n            }\n        }\n    } else if (type == \"all_greater_than_x\") {\n        for (int i = 0; i < n; ++i) {\n            if (x < MAX_A) {\n                a[i] = rnd.next(x + 1, MAX_A);\n            } else {\n                // x == MAX_A, cannot have numbers greater than x\n                a[i] = x;\n            }\n        }\n    } else if (type == \"all_equal_to_x\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"mix\") {\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0) {\n                // Less than x\n                if (x > MIN_A) {\n                    a[i] = rnd.next(MIN_A, x - 1);\n                } else {\n                    a[i] = x;\n                }\n            } else if (t == 1) {\n                // Equal to x\n                a[i] = x;\n            } else {\n                // Greater than x\n                if (x < MAX_A) {\n                    a[i] = rnd.next(x + 1, MAX_A);\n                } else {\n                    a[i] = x;\n                }\n            }\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(MIN_A, MAX_A);\n        }\n    }\n\n    // Output\n    printf(\"%d %lld\\n\", n, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n -1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long MIN_A = -1000000000LL;\n    const long long MAX_A = 1000000000LL;\n\n    vector<long long> a(n);\n\n    if (type == \"all_less_than_x\") {\n        for (int i = 0; i < n; ++i) {\n            if (x > MIN_A) {\n                a[i] = rnd.next(MIN_A, x - 1);\n            } else {\n                // x == MIN_A, cannot have numbers less than x\n                a[i] = x;\n            }\n        }\n    } else if (type == \"all_greater_than_x\") {\n        for (int i = 0; i < n; ++i) {\n            if (x < MAX_A) {\n                a[i] = rnd.next(x + 1, MAX_A);\n            } else {\n                // x == MAX_A, cannot have numbers greater than x\n                a[i] = x;\n            }\n        }\n    } else if (type == \"all_equal_to_x\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"mix\") {\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0) {\n                // Less than x\n                if (x > MIN_A) {\n                    a[i] = rnd.next(MIN_A, x - 1);\n                } else {\n                    a[i] = x;\n                }\n            } else if (t == 1) {\n                // Equal to x\n                a[i] = x;\n            } else {\n                // Greater than x\n                if (x < MAX_A) {\n                    a[i] = rnd.next(x + 1, MAX_A);\n                } else {\n                    a[i] = x;\n                }\n            }\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(MIN_A, MAX_A);\n        }\n    }\n\n    // Output\n    printf(\"%d %lld\\n\", n, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n -1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -x 0 -type all_equal_to_x\n./gen -n 1 -x 0 -type all_less_than_x\n./gen -n 1 -x 0 -type all_greater_than_x\n./gen -n 1 -x 0 -type mix\n./gen -n 1 -x 0 -type random\n\n./gen -n 10 -x 0 -type all_equal_to_x\n./gen -n 10 -x 0 -type all_less_than_x\n./gen -n 10 -x 0 -type all_greater_than_x\n./gen -n 10 -x 0 -type mix\n./gen -n 10 -x 0 -type random\n\n./gen -n 1000 -x -1000000000 -type all_less_than_x\n./gen -n 1000 -x -1000000000 -type all_equal_to_x\n./gen -n 1000 -x -1000000000 -type mix\n\n./gen -n 1000 -x 1000000000 -type all_greater_than_x\n./gen -n 1000 -x 1000000000 -type all_equal_to_x\n./gen -n 1000 -x 1000000000 -type mix\n\n./gen -n 10000 -x 500000000 -type random\n./gen -n 10000 -x -500000000 -type random\n\n./gen -n 200000 -x 0 -type all_equal_to_x\n./gen -n 200000 -x 0 -type random\n./gen -n 200000 -x 0 -type mix\n\n./gen -n 200000 -x 999999999 -type all_less_than_x\n./gen -n 200000 -x -999999999 -type all_greater_than_x\n\n./gen -n 200000 -x -1000000000 -type all_equal_to_x\n./gen -n 200000 -x 1000000000 -type all_equal_to_x\n\n./gen -n 199999 -x 0 -type random\n./gen -n 200000 -x -1 -type random\n\n./gen -n 200000 -x 1000000000 -type random\n\n./gen -n 200000 -x -1000000000 -type random\n\n./gen -n 200000 -x 123456789 -type random\n\n./gen -n 2 -x 10 -type random\n\n./gen -n 2 -x -10 -type random\n\n./gen -n 2 -x 0 -type mix\n\n./gen -n 50 -x 500 -type random\n\n./gen -n 100000 -x -1000000000 -type all_greater_than_x\n\n./gen -n 100000 -x 1000000000 -type all_less_than_x\n\n./gen -n 100000 -x 0 -type mix\n\n./gen -n 1 -x 1000000000 -type all_greater_than_x\n\n./gen -n 1 -x -1000000000 -type all_less_than_x\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:23.410790",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "993/F",
      "title": "F. The Moral Dilemma",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers nn, mm, kk (2≤n,m≤502≤n,m≤50; 1≤k≤501≤k≤50) — the number of input features, the number of gates in the first layer, and the number of gates in the second layer correspondingly.The second line contains mm pairs of strings separated by spaces describing the first layer. The first string in each pair describes the gate (\"and\", \"or\", \"nand\" or \"nor\"), and the second string describes the two input features the gate is connected two as a string consisting of exactly nn characters, with exactly two characters (that correspond to the input features the gate is connected to) equal to 'x' and the remaining characters equal to \".'.The third line contains kk pairs of strings separated by spaces describing the second layer in the same format, where the strings that describe the input parameters have length mm and correspond to the gates of the first layer.",
      "output_spec": "OutputPrint the number of gates that need to be removed from the second layer so that the output of the remaining circuit doesn't depend on whether Hibiki is in love or not.If no matter how many gates are removed the output of the circuit continues to depend on Hibiki's feelings, print −1−1.",
      "sample_tests": "ExamplesInputCopy2 2 2and xx nand xxand xx or xxOutputCopy1InputCopy3 2 2and xx. nor .xxand xx nor xxOutputCopy-1InputCopy4 4 5nor x..x and ..xx and xx.. nand xx..nand ..xx nor ..xx and xx.. nor ..xx or ..xxOutputCopy2",
      "description": "F. The Moral Dilemma\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers nn, mm, kk (2≤n,m≤502≤n,m≤50; 1≤k≤501≤k≤50) — the number of input features, the number of gates in the first layer, and the number of gates in the second layer correspondingly.The second line contains mm pairs of strings separated by spaces describing the first layer. The first string in each pair describes the gate (\"and\", \"or\", \"nand\" or \"nor\"), and the second string describes the two input features the gate is connected two as a string consisting of exactly nn characters, with exactly two characters (that correspond to the input features the gate is connected to) equal to 'x' and the remaining characters equal to \".'.The third line contains kk pairs of strings separated by spaces describing the second layer in the same format, where the strings that describe the input parameters have length mm and correspond to the gates of the first layer.\n\nOutputPrint the number of gates that need to be removed from the second layer so that the output of the remaining circuit doesn't depend on whether Hibiki is in love or not.If no matter how many gates are removed the output of the circuit continues to depend on Hibiki's feelings, print −1−1.\n\nInputCopy2 2 2and xx nand xxand xx or xxOutputCopy1InputCopy3 2 2and xx. nor .xxand xx nor xxOutputCopy-1InputCopy4 4 5nor x..x and ..xx and xx.. nand xx..nand ..xx nor ..xx and xx.. nor ..xx or ..xxOutputCopy2\n\nInputCopy2 2 2and xx nand xxand xx or xx\n\nOutputCopy1\n\nInputCopy3 2 2and xx. nor .xxand xx nor xx\n\nOutputCopy-1\n\nInputCopy4 4 5nor x..x and ..xx and xx.. nand xx..nand ..xx nor ..xx and xx.. nor ..xx or ..xx\n\nOutputCopy2\n\nNoteIn the first example the two gates in the first layer are connected to the same inputs, but first computes \"and\" while second computes \"nand\", and as such their output is always different no matter what the input is and whether Hibiki is in love or not. The second layer has \"or\" and \"and\" gates both connected to the two gates in the first layer. If Hibiki is not in love, the \"and\" gate will produce 0 and the \"or\" gate will produce 1 no matter what input features are equal to, with the final \"or\" gate in the third layer always producing the final answer of 1. If Hibiki is in love, \"and\" gate in the second layer will produce 1 and \"or\" gate will produce 0 no matter what the input is, with the final \"or\" gate in the third layer producing the final answer of 0. Thus, if both gates in the second layer are kept, the output of the circuit does depend on whether Hibiki is in love. If any of the two gates in the second layer is dropped, the output of the circuit will no longer depend on whether Hibiki is in love or not, and hence the answer is 1.In the second example no matter what gates are left in the second layer, the output of the circuit will depend on whether Hibiki is in love or not.In the third example if Hibiki keeps second, third and fourth gates in the second layer, the circuit will not depend on whether Hibiki is in love or not. Alternatively, he can keep the first and the last gates. The former requires removing two gates, the latter requires removing three gates, so the former is better, and the answer is 2.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 993\\s*F"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 50, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readEoln();\n\n    // Read m pairs of strings for the first layer\n    for (int i = 0; i < m; i++) {\n        string gateType = inf.readToken();\n        ensuref(gateType == \"and\" || gateType == \"or\" || gateType == \"nand\" || gateType == \"nor\",\n                \"Invalid gate type: %s\", gateType.c_str());\n        inf.readSpace();\n        string conn = inf.readToken();\n\n        ensuref((int)conn.size() == n, \"Connection string length should be %d, but is %d\", n, (int)conn.size());\n        int x_count = 0;\n        for (char c : conn) {\n            ensuref(c == 'x' || c == '.', \"Connection string should contain only 'x' and '.', but found '%c'\", c);\n            if (c == 'x') x_count++;\n        }\n        ensuref(x_count == 2, \"Connection string should contain exactly two 'x', but found %d\", x_count);\n\n        if (i + 1 < m) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Read k pairs of strings for the second layer\n    for (int i = 0; i < k; i++) {\n        string gateType = inf.readToken();\n        ensuref(gateType == \"and\" || gateType == \"or\" || gateType == \"nand\" || gateType == \"nor\",\n                \"Invalid gate type: %s\", gateType.c_str());\n        inf.readSpace();\n        string conn = inf.readToken();\n\n        ensuref((int)conn.size() == m, \"Connection string length should be %d, but is %d\", m, (int)conn.size());\n        int x_count = 0;\n        for (char c : conn) {\n            ensuref(c == 'x' || c == '.', \"Connection string should contain only 'x' and '.', but found '%c'\", c);\n            if (c == 'x') x_count++;\n        }\n        ensuref(x_count == 2, \"Connection string should contain exactly two 'x', but found %d\", x_count);\n\n        if (i + 1 < k) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 50, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readEoln();\n\n    // Read m pairs of strings for the first layer\n    for (int i = 0; i < m; i++) {\n        string gateType = inf.readToken();\n        ensuref(gateType == \"and\" || gateType == \"or\" || gateType == \"nand\" || gateType == \"nor\",\n                \"Invalid gate type: %s\", gateType.c_str());\n        inf.readSpace();\n        string conn = inf.readToken();\n\n        ensuref((int)conn.size() == n, \"Connection string length should be %d, but is %d\", n, (int)conn.size());\n        int x_count = 0;\n        for (char c : conn) {\n            ensuref(c == 'x' || c == '.', \"Connection string should contain only 'x' and '.', but found '%c'\", c);\n            if (c == 'x') x_count++;\n        }\n        ensuref(x_count == 2, \"Connection string should contain exactly two 'x', but found %d\", x_count);\n\n        if (i + 1 < m) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Read k pairs of strings for the second layer\n    for (int i = 0; i < k; i++) {\n        string gateType = inf.readToken();\n        ensuref(gateType == \"and\" || gateType == \"or\" || gateType == \"nand\" || gateType == \"nor\",\n                \"Invalid gate type: %s\", gateType.c_str());\n        inf.readSpace();\n        string conn = inf.readToken();\n\n        ensuref((int)conn.size() == m, \"Connection string length should be %d, but is %d\", m, (int)conn.size());\n        int x_count = 0;\n        for (char c : conn) {\n            ensuref(c == 'x' || c == '.', \"Connection string should contain only 'x' and '.', but found '%c'\", c);\n            if (c == 'x') x_count++;\n        }\n        ensuref(x_count == 2, \"Connection string should contain exactly two 'x', but found %d\", x_count);\n\n        if (i + 1 < k) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 50, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 50, \"k\");\n    inf.readEoln();\n\n    // Read m pairs of strings for the first layer\n    for (int i = 0; i < m; i++) {\n        string gateType = inf.readToken();\n        ensuref(gateType == \"and\" || gateType == \"or\" || gateType == \"nand\" || gateType == \"nor\",\n                \"Invalid gate type: %s\", gateType.c_str());\n        inf.readSpace();\n        string conn = inf.readToken();\n\n        ensuref((int)conn.size() == n, \"Connection string length should be %d, but is %d\", n, (int)conn.size());\n        int x_count = 0;\n        for (char c : conn) {\n            ensuref(c == 'x' || c == '.', \"Connection string should contain only 'x' and '.', but found '%c'\", c);\n            if (c == 'x') x_count++;\n        }\n        ensuref(x_count == 2, \"Connection string should contain exactly two 'x', but found %d\", x_count);\n\n        if (i + 1 < m) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Read k pairs of strings for the second layer\n    for (int i = 0; i < k; i++) {\n        string gateType = inf.readToken();\n        ensuref(gateType == \"and\" || gateType == \"or\" || gateType == \"nand\" || gateType == \"nor\",\n                \"Invalid gate type: %s\", gateType.c_str());\n        inf.readSpace();\n        string conn = inf.readToken();\n\n        ensuref((int)conn.size() == m, \"Connection string length should be %d, but is %d\", m, (int)conn.size());\n        int x_count = 0;\n        for (char c : conn) {\n            ensuref(c == 'x' || c == '.', \"Connection string should contain only 'x' and '.', but found '%c'\", c);\n            if (c == 'x') x_count++;\n        }\n        ensuref(x_count == 2, \"Connection string should contain exactly two 'x', but found %d\", x_count);\n\n        if (i + 1 < k) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> possible_gates = {\"and\", \"or\", \"nand\", \"nor\"};\n\nstring generate_connections(int len, int num_connections) {\n    string s(len, '.');\n    vector<int> positions(len);\n    for (int i = 0; i < len; ++i) positions[i] = i;\n    shuffle(positions.begin(), positions.end());\n    for (int i = 0; i < num_connections; ++i) s[positions[i]] = 'x';\n    return s;\n}\n\nvoid output_layer(const vector<pair<string, string>> &layer) {\n    for (size_t i = 0; i < layer.size(); ++i) {\n        printf(\"%s %s\", layer[i].first.c_str(), layer[i].second.c_str());\n        if (i + 1 < layer.size()) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 2);\n    int m = opt<int>(\"m\", 2);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<string, string>> layer1_gates;\n    vector<pair<string, string>> layer2_gates;\n\n    if (type == \"random\") {\n        // Generate random gates and connections\n        for (int i = 0; i < m; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    } else if (type == \"impossible\") {\n        // Use the sample input 2 as the impossible test case\n        n = 3; m = 2; k = 2;\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"and xx. nor .xx\\n\");\n        printf(\"and xx nor xx\\n\");\n        return 0;\n    } else if (type == \"sample1\") {\n        // Use sample input 1\n        n = 2; m = 2; k = 2;\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"and xx nand xx\\n\");\n        printf(\"and xx or xx\\n\");\n        return 0;\n    } else if (type == \"sample3\") {\n        // Use sample input 3\n        n = 4; m = 4; k = 5;\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"nor x..x and ..xx and xx.. nand xx..\\n\");\n        printf(\"nand ..xx nor ..xx and xx.. nor ..xx or ..xx\\n\");\n        return 0;\n    } else if (type == \"all_and\") {\n        for (int i = 0; i < m; ++i) {\n            string gate = \"and\";\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = \"and\";\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    } else if (type == \"all_nand\") {\n        for (int i = 0; i < m; ++i) {\n            string gate = \"nand\";\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = \"nand\";\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    } else if (type == \"same_connections\") {\n        string connections1 = generate_connections(n, 2);\n        for (int i = 0; i < m; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            layer1_gates.emplace_back(gate, connections1);\n        }\n        string connections2 = generate_connections(m, 2);\n        for (int i = 0; i < k; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            layer2_gates.emplace_back(gate, connections2);\n        }\n    } else if (type == \"maximal\") {\n        n = 50; m = 50; k = 50;\n        for (int i = 0; i < m; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    }\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    output_layer(layer1_gates);\n    output_layer(layer2_gates);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> possible_gates = {\"and\", \"or\", \"nand\", \"nor\"};\n\nstring generate_connections(int len, int num_connections) {\n    string s(len, '.');\n    vector<int> positions(len);\n    for (int i = 0; i < len; ++i) positions[i] = i;\n    shuffle(positions.begin(), positions.end());\n    for (int i = 0; i < num_connections; ++i) s[positions[i]] = 'x';\n    return s;\n}\n\nvoid output_layer(const vector<pair<string, string>> &layer) {\n    for (size_t i = 0; i < layer.size(); ++i) {\n        printf(\"%s %s\", layer[i].first.c_str(), layer[i].second.c_str());\n        if (i + 1 < layer.size()) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 2);\n    int m = opt<int>(\"m\", 2);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<string, string>> layer1_gates;\n    vector<pair<string, string>> layer2_gates;\n\n    if (type == \"random\") {\n        // Generate random gates and connections\n        for (int i = 0; i < m; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    } else if (type == \"impossible\") {\n        // Use the sample input 2 as the impossible test case\n        n = 3; m = 2; k = 2;\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"and xx. nor .xx\\n\");\n        printf(\"and xx nor xx\\n\");\n        return 0;\n    } else if (type == \"sample1\") {\n        // Use sample input 1\n        n = 2; m = 2; k = 2;\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"and xx nand xx\\n\");\n        printf(\"and xx or xx\\n\");\n        return 0;\n    } else if (type == \"sample3\") {\n        // Use sample input 3\n        n = 4; m = 4; k = 5;\n        printf(\"%d %d %d\\n\", n, m, k);\n        printf(\"nor x..x and ..xx and xx.. nand xx..\\n\");\n        printf(\"nand ..xx nor ..xx and xx.. nor ..xx or ..xx\\n\");\n        return 0;\n    } else if (type == \"all_and\") {\n        for (int i = 0; i < m; ++i) {\n            string gate = \"and\";\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = \"and\";\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    } else if (type == \"all_nand\") {\n        for (int i = 0; i < m; ++i) {\n            string gate = \"nand\";\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = \"nand\";\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    } else if (type == \"same_connections\") {\n        string connections1 = generate_connections(n, 2);\n        for (int i = 0; i < m; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            layer1_gates.emplace_back(gate, connections1);\n        }\n        string connections2 = generate_connections(m, 2);\n        for (int i = 0; i < k; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            layer2_gates.emplace_back(gate, connections2);\n        }\n    } else if (type == \"maximal\") {\n        n = 50; m = 50; k = 50;\n        for (int i = 0; i < m; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(n, 2);\n            layer1_gates.emplace_back(gate, connections);\n        }\n        for (int i = 0; i < k; ++i) {\n            string gate = possible_gates[rnd.next((int)possible_gates.size())];\n            string connections = generate_connections(m, 2);\n            layer2_gates.emplace_back(gate, connections);\n        }\n    }\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    output_layer(layer1_gates);\n    output_layer(layer2_gates);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 3 -m 3 -k 2 -type random\n./gen -n 5 -m 4 -k 3 -type random\n\n# Medium random test cases\n./gen -n 10 -m 10 -k 10 -type random\n./gen -n 15 -m 14 -k 13 -type random\n./gen -n 20 -m 18 -k 15 -type random\n\n# Large random test cases\n./gen -n 50 -m 50 -k 50 -type random\n./gen -n 50 -m 45 -k 40 -type random\n\n# All gates are 'and'\n./gen -n 5 -m 5 -k 5 -type all_and\n./gen -n 10 -m 10 -k 10 -type all_and\n./gen -n 50 -m 50 -k 50 -type all_and\n\n# All gates are 'nand'\n./gen -n 5 -m 5 -k 5 -type all_nand\n./gen -n 10 -m 10 -k 10 -type all_nand\n./gen -n 50 -m 50 -k 50 -type all_nand\n\n# Gates with same connections\n./gen -n 5 -m 5 -k 5 -type same_connections\n./gen -n 10 -m 10 -k 10 -type same_connections\n\n# Maximal size test cases\n./gen -type maximal\n\n# Sample test cases from the problem\n./gen -type sample1\n./gen -type sample3\n\n# Impossible test case\n./gen -type impossible\n\n# Edge cases\n./gen -n 2 -m 2 -k 2 -type random\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 2 -m 2 -k 50 -type random\n\n# Test cases with minimal n, m, k\n./gen -n 2 -m 2 -k 1 -type all_and\n./gen -n 2 -m 2 -k 1 -type all_nand\n\n# Test case with maximum n, m, k\n./gen -n 50 -m 50 -k 50 -type same_connections\n\n# Additional random test cases\n./gen -n 25 -m 20 -k 15 -type random\n./gen -n 30 -m 25 -k 20 -type random\n./gen -n 35 -m 30 -k 25 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:25.701407",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "994/A",
      "title": "A. Отпечатки пальцев",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа nn и mm (1≤n,m≤101≤n,m≤10) — количество цифр в известной вам последовательности, и количество кнопок на замке, на которых есть отпечатки.Следующая строка содержит nn разделенных пробелом различных целых чисел x1,x2,…,xnx1,x2,…,xn (0≤xi≤90≤xi≤9) — известная вам последовательность.Следующая строка содержит mm разделенных пробелом различных целых чисел y1,y2,…,ymy1,y2,…,ym (0≤yi≤90≤yi≤9) – кнопки, на которых есть отпечатки.",
      "output_spec": "Выходные данныеВ единственной строке выведите через пробел цифры кода. Если код пустой, то можно как оставить вывод пустым, так и вывести один перевод строки.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 33 5 7 1 6 2 81 2 7Выходные данныеСкопировать7 1 2Входные данныеСкопировать4 43 4 1 00 1 7 9Выходные данныеСкопировать1 0",
      "description": "A. Отпечатки пальцев\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа nn и mm (1≤n,m≤101≤n,m≤10) — количество цифр в известной вам последовательности, и количество кнопок на замке, на которых есть отпечатки.Следующая строка содержит nn разделенных пробелом различных целых чисел x1,x2,…,xnx1,x2,…,xn (0≤xi≤90≤xi≤9) — известная вам последовательность.Следующая строка содержит mm разделенных пробелом различных целых чисел y1,y2,…,ymy1,y2,…,ym (0≤yi≤90≤yi≤9) – кнопки, на которых есть отпечатки.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите через пробел цифры кода. Если код пустой, то можно как оставить вывод пустым, так и вывести один перевод строки.\n\nВыходные данные\n\nВходные данныеСкопировать7 33 5 7 1 6 2 81 2 7Выходные данныеСкопировать7 1 2Входные данныеСкопировать4 43 4 1 00 1 7 9Выходные данныеСкопировать1 0\n\nВходные данныеСкопировать7 33 5 7 1 6 2 81 2 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7 1 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 43 4 1 00 1 7 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте три кнопки имеют отпечатки: 11, 22 и 77. Все три встречаются в последовательности: сначала 77, затем 11 и затем 22. Таким образом, правильный вывод — 7 1 2. Обратите внимание, что порядок важен, и должен быть таким же, как порядок в данной последовательности.Во втором примере на кнопках с 00, 11, 77 и 99 есть отпечатки, но только 00 и 11 встречаются в данной последовательности. 11 встречается раньше, поэтому правильный вывод — 1 0. Порядок важен.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD: обратите внимание, распределение баллов изменилосьUPD2: LHiC нашел ошибку в авторском решении на div1-F. Мы исследуем вопрос.UPD3: мы нашли правильное решение для div1-F и оба решения отправленных на контесте проходят все тесты против правильного решения => раунд по прежнему рейтинговый.Всем привет,Время старта Codeforces Round 488: воскресенье, 17 июня 2018 г. в 00:35UTC+8. Это будет раунд для обоих дивизионов. Раунд будет длиться 2.5 часа (это на пол часа больше чем обычно).Контест подготовлен компанией NEAR и ее друзьями. В NEAR мы учим машины участвовать в соревнованиях по программированию. В этом блог-посте можно прочитать (на английском) о том, где сегодня находятся исследования в этой области, чем занимается непосредственно NEAR, и как вы можете помочь нам в этом нелегком деле.На контесте будет предложено по шесть задач в каждом дивизионе, 4 задачи из которых общие.Почти все задачи взяты с тестовых раундов, которые проводились на JavaBlitz в прошлом году. Если вы участвовали в одном из JavaBlitz раундов, то этот CBR, к сожалению, придется пропустить.Распределение баллов в первом дивизионе -- 500-1000-1000-1500-2250-3000Во втором -- 500-1000-1500-2000-2000-2500Раунд в обоих дивизионах рейтинговый.Все задачи написаны мной, Александром \"AlexSkidanov\" Скидановым, и Никитой \"FalseMirror\" Босовым. David \"pieguy\" Stolp, Александр \"AlexFetisov\" Фетиско, Marcelo \"mnaeraxr\" Fornet, Николай \"KAN\" Калинин и Михаил \"cerealguy\" Кевер оказали неоценимую помощь в подгтовке раунда и тестировании задач.В завершении хочется в очередной раз напомнить, что мы постоянно ищем людей, которые помогут нам с разметкой данных с архивов по спортивному программированию. Больше информации здесь.Поздравляем победителей!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge Разбор опубликован тут. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1888
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - Отпечатки пальцевДля решения задачи достаточно пройти по всем элементам данной последовательности, и для каждого в цикле пройти по кнопкам с отпечатками и проверить есть ли кнопка с отпечатком, соответствующая текущему числу в последовательности. Такое решение работает за O(n×m)O(n×m) 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Два квадратаЕсли два квадрата пересекаются, то хотя бы для одного из них верно что либо один из его углов лежит в другом квадрате, либо его центр лежит в другом квадрате.Для квадрата, который повернут на 45 градусов, проверить лежат ли его углы или центр в квадрате со сторонами, параллельными осям координат, очень просто.Чтобы проверить в обратную сторону, достаточно повернуть оба квадрата на 45 градусов. Чтобы это сделать, достаточно заменить все xx координаты на x+yx+y, а все yy координаты на x−yx−y (это также изменит масштаб, но это не влияет на пересечение) 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 994\\s*A"
          },
          "content_length": 10584
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 9, \"x_i\");\n    inf.readEoln();\n\n    ensuref((int)set<int>(x.begin(), x.end()).size() == n, \"x_i should be distinct\");\n\n    vector<int> y = inf.readInts(m, 0, 9, \"y_i\");\n    inf.readEoln();\n\n    ensuref((int)set<int>(y.begin(), y.end()).size() == m, \"y_i should be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 9, \"x_i\");\n    inf.readEoln();\n\n    ensuref((int)set<int>(x.begin(), x.end()).size() == n, \"x_i should be distinct\");\n\n    vector<int> y = inf.readInts(m, 0, 9, \"y_i\");\n    inf.readEoln();\n\n    ensuref((int)set<int>(y.begin(), y.end()).size() == m, \"y_i should be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 9, \"x_i\");\n    inf.readEoln();\n\n    ensuref((int)set<int>(x.begin(), x.end()).size() == n, \"x_i should be distinct\");\n\n    vector<int> y = inf.readInts(m, 0, 9, \"y_i\");\n    inf.readEoln();\n\n    ensuref((int)set<int>(y.begin(), y.end()).size() == m, \"y_i should be distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 10);\n    ensure(1 <= m && m <= 10);\n\n    vector<int> a;\n    vector<int> b;\n    vector<int> digits = {0,1,2,3,4,5,6,7,8,9};\n\n    if (type == \"random\") {\n        // Generate random sequences a and b of sizes n and m\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n\n        shuffle(digits.begin(), digits.end());\n        b.assign(digits.begin(), digits.begin() + m);\n    }\n    else if (type == \"nooverlap\") {\n        // Generate a and b with no overlapping digits\n        if (n + m > 10) {\n            fprintf(stderr, \"Cannot generate nooverlap with n + m > 10\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(digits.begin() + n, digits.begin() + n + m);\n    }\n    else if (type == \"fulloverlap\") {\n        // Generate a and b with same digits\n        if (n != m) {\n            fprintf(stderr, \"Cannot generate fulloverlap with n != m\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b = a;\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == \"partialoverlap\") {\n        int overlap = opt<int>(\"overlap\", min(n, m)/2);\n        if (overlap > min(n, m)) overlap = min(n, m);\n        if (n + m - overlap > 10) {\n            fprintf(stderr, \"Cannot generate partialoverlap with given n, m, overlap\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(digits.begin() + n - overlap, digits.begin() + n - overlap + m);\n\n        for (int i = 0; i < overlap; ++i) {\n            b[i] = a[n - overlap + i];\n        }\n        for (int i = overlap; i < m; ++i) {\n            b[i] = digits[n + i - overlap];\n        }\n    }\n    else if (type == \"empty\") {\n        if (n + m > 10) {\n            fprintf(stderr, \"Cannot generate empty with n + m > 10\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(digits.begin() + n, digits.begin() + n + m);\n    }\n    else if (type == \"full\") {\n        if (m < n) {\n            fprintf(stderr, \"Cannot generate full with m < n\\n\");\n            exit(1);\n        }\n        a.clear();\n        b.clear();\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(a.begin(), a.end());\n\n        for (int i = n; i < m; ++i) {\n            for (int d = 0; d <= 9; ++d) {\n                if (find(a.begin(), a.end(), d) == a.end() && find(b.begin(), b.end(), d) == b.end()) {\n                    b.push_back(d);\n                    break;\n                }\n            }\n        }\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == \"ascending\") {\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        sort(a.begin(), a.end());\n        shuffle(digits.begin(), digits.end());\n        b.assign(digits.begin(), digits.begin() + m);\n    }\n    else if (type == \"descending\") {\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        sort(a.begin(), a.end(), greater<int>());\n        shuffle(digits.begin(), digits.end());\n        b.assign(digits.begin(), digits.begin() + m);\n    }\n    else if (type == \"contiguous\") {\n        if (m > n) {\n            fprintf(stderr, \"Cannot generate contiguous with m > n\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        int start_pos = rnd.next(0, n - m);\n        b.assign(a.begin() + start_pos, a.begin() + start_pos + m);\n        shuffle(a.begin(), a.end());\n    }\n    else if (type == \"noncontiguous\") {\n        if (m > n) {\n            fprintf(stderr, \"Cannot generate noncontiguous with m > n\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.clear();\n        for (int i = 0; i < m; ++i) {\n            b.push_back(a[i * n / m]);\n        }\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == \"maxempty\") {\n        n = 10;\n        m = 10;\n        a.clear();\n        b.clear();\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + 5);\n        b.assign(digits.begin() + 5, digits.begin() + 10);\n    }\n    else if (type == \"maxfull\") {\n        n = 10;\n        m = 10;\n        a.clear();\n        b.clear();\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b = a;\n        shuffle(b.begin(), b.end());\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m -1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 10);\n    ensure(1 <= m && m <= 10);\n\n    vector<int> a;\n    vector<int> b;\n    vector<int> digits = {0,1,2,3,4,5,6,7,8,9};\n\n    if (type == \"random\") {\n        // Generate random sequences a and b of sizes n and m\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n\n        shuffle(digits.begin(), digits.end());\n        b.assign(digits.begin(), digits.begin() + m);\n    }\n    else if (type == \"nooverlap\") {\n        // Generate a and b with no overlapping digits\n        if (n + m > 10) {\n            fprintf(stderr, \"Cannot generate nooverlap with n + m > 10\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(digits.begin() + n, digits.begin() + n + m);\n    }\n    else if (type == \"fulloverlap\") {\n        // Generate a and b with same digits\n        if (n != m) {\n            fprintf(stderr, \"Cannot generate fulloverlap with n != m\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b = a;\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == \"partialoverlap\") {\n        int overlap = opt<int>(\"overlap\", min(n, m)/2);\n        if (overlap > min(n, m)) overlap = min(n, m);\n        if (n + m - overlap > 10) {\n            fprintf(stderr, \"Cannot generate partialoverlap with given n, m, overlap\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(digits.begin() + n - overlap, digits.begin() + n - overlap + m);\n\n        for (int i = 0; i < overlap; ++i) {\n            b[i] = a[n - overlap + i];\n        }\n        for (int i = overlap; i < m; ++i) {\n            b[i] = digits[n + i - overlap];\n        }\n    }\n    else if (type == \"empty\") {\n        if (n + m > 10) {\n            fprintf(stderr, \"Cannot generate empty with n + m > 10\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(digits.begin() + n, digits.begin() + n + m);\n    }\n    else if (type == \"full\") {\n        if (m < n) {\n            fprintf(stderr, \"Cannot generate full with m < n\\n\");\n            exit(1);\n        }\n        a.clear();\n        b.clear();\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.assign(a.begin(), a.end());\n\n        for (int i = n; i < m; ++i) {\n            for (int d = 0; d <= 9; ++d) {\n                if (find(a.begin(), a.end(), d) == a.end() && find(b.begin(), b.end(), d) == b.end()) {\n                    b.push_back(d);\n                    break;\n                }\n            }\n        }\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == \"ascending\") {\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        sort(a.begin(), a.end());\n        shuffle(digits.begin(), digits.end());\n        b.assign(digits.begin(), digits.begin() + m);\n    }\n    else if (type == \"descending\") {\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        sort(a.begin(), a.end(), greater<int>());\n        shuffle(digits.begin(), digits.end());\n        b.assign(digits.begin(), digits.begin() + m);\n    }\n    else if (type == \"contiguous\") {\n        if (m > n) {\n            fprintf(stderr, \"Cannot generate contiguous with m > n\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        int start_pos = rnd.next(0, n - m);\n        b.assign(a.begin() + start_pos, a.begin() + start_pos + m);\n        shuffle(a.begin(), a.end());\n    }\n    else if (type == \"noncontiguous\") {\n        if (m > n) {\n            fprintf(stderr, \"Cannot generate noncontiguous with m > n\\n\");\n            exit(1);\n        }\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b.clear();\n        for (int i = 0; i < m; ++i) {\n            b.push_back(a[i * n / m]);\n        }\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == \"maxempty\") {\n        n = 10;\n        m = 10;\n        a.clear();\n        b.clear();\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + 5);\n        b.assign(digits.begin() + 5, digits.begin() + 10);\n    }\n    else if (type == \"maxfull\") {\n        n = 10;\n        m = 10;\n        a.clear();\n        b.clear();\n        shuffle(digits.begin(), digits.end());\n        a.assign(digits.begin(), digits.begin() + n);\n        b = a;\n        shuffle(b.begin(), b.end());\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m -1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 1 -m 1 -type random\n\n./gen -n 5 -m 5 -type nooverlap\n./gen -n 10 -m 10 -type nooverlap\n\n./gen -n 5 -m 5 -type fulloverlap\n./gen -n 10 -m 10 -type fulloverlap\n\n./gen -n 5 -m 5 -type partialoverlap -overlap 2\n./gen -n 5 -m 5 -type partialoverlap -overlap 3\n./gen -n 10 -m 10 -type partialoverlap -overlap 5\n./gen -n 10 -m 10 -type partialoverlap -overlap 0\n\n./gen -n 5 -m 5 -type empty\n./gen -n 10 -m 10 -type empty\n\n./gen -n 5 -m 5 -type full\n./gen -n 7 -m 10 -type full\n\n./gen -n 5 -m 3 -type ascending\n./gen -n 7 -m 4 -type ascending\n\n./gen -n 5 -m 3 -type descending\n./gen -n 7 -m 4 -type descending\n\n./gen -n 5 -m 5 -type contiguous\n./gen -n 5 -m 3 -type contiguous\n\n./gen -n 5 -m 5 -type noncontiguous\n./gen -n 5 -m 3 -type noncontiguous\n\n./gen -n 10 -m 10 -type maxempty\n./gen -n 10 -m 10 -type maxfull\n\n./gen -n 10 -m 5 -type random\n./gen -n 5 -m 10 -type random\n\n./gen -n 7 -m 7 -type random\n./gen -n 7 -m 2 -type empty\n./gen -n 7 -m 7 -type full\n\n./gen -n 7 -m 3 -type partialoverlap -overlap 1\n./gen -n 8 -m 6 -type partialoverlap -overlap 5\n\n./gen -n 10 -m 1 -type empty\n./gen -n 10 -m 1 -type fulloverlap\n./gen -n 10 -m 1 -type partialoverlap -overlap 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:28.170485",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "994/B",
      "title": "B. Knights of a Polygonal Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and kk (1≤n≤105,0≤k≤min(n−1,10))(1≤n≤105,0≤k≤min(n−1,10)) — the number of knights and the number kk from the statement.The second line contains nn integers p1,p2,…,pnp1,p2,…,pn (1≤pi≤109)(1≤pi≤109) — powers of the knights. All pipi are distinct.The third line contains nn integers c1,c2,…,cnc1,c2,…,cn (0≤ci≤109)(0≤ci≤109) — the number of coins each knight has.",
      "output_spec": "OutputPrint nn integers — the maximum number of coins each knight can have it only he kills other knights.",
      "sample_tests": "ExamplesInputCopy4 24 5 9 71 2 11 33OutputCopy1 3 46 36 InputCopy5 11 2 3 4 51 2 3 4 5OutputCopy1 3 5 7 9 InputCopy1 023OutputCopy3",
      "description": "B. Knights of a Polygonal Table\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and kk (1≤n≤105,0≤k≤min(n−1,10))(1≤n≤105,0≤k≤min(n−1,10)) — the number of knights and the number kk from the statement.The second line contains nn integers p1,p2,…,pnp1,p2,…,pn (1≤pi≤109)(1≤pi≤109) — powers of the knights. All pipi are distinct.The third line contains nn integers c1,c2,…,cnc1,c2,…,cn (0≤ci≤109)(0≤ci≤109) — the number of coins each knight has.\n\nOutputPrint nn integers — the maximum number of coins each knight can have it only he kills other knights.\n\nInputCopy4 24 5 9 71 2 11 33OutputCopy1 3 46 36 InputCopy5 11 2 3 4 51 2 3 4 5OutputCopy1 3 5 7 9 InputCopy1 023OutputCopy3\n\nInputCopy4 24 5 9 71 2 11 33\n\nOutputCopy1 3 46 36\n\nInputCopy5 11 2 3 4 51 2 3 4 5\n\nOutputCopy1 3 5 7 9\n\nInputCopy1 023\n\nOutputCopy3\n\nNoteConsider the first example.   The first knight is the weakest, so he can't kill anyone. That leaves him with the only coin he initially has.  The second knight can kill the first knight and add his coin to his own two.  The third knight is the strongest, but he can't kill more than k=2k=2 other knights. It is optimal to kill the second and the fourth knights: 2+11+33=462+11+33=46.  The fourth knight should kill the first and the second knights: 33+1+2=3633+1+2=36. In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.In the third example there is only one knight, so he can't kill anyone.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 994\\s*B"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k_max = min(n - 1, 10);\n    int k = inf.readInt(0, k_max, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p_i\");\n    inf.readEoln();\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All p_i must be distinct\");\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k_max = min(n - 1, 10);\n    int k = inf.readInt(0, k_max, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p_i\");\n    inf.readEoln();\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All p_i must be distinct\");\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k_max = min(n - 1, 10);\n    int k = inf.readInt(0, k_max, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p_i\");\n    inf.readEoln();\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"All p_i must be distinct\");\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int max_c = opt<int>(\"max_c\", 1000000000); // default to max value\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k is valid\n    k = min(k, min(n-1,10));\n\n    vector<int> p(n);\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        // Generate random p_i and c_i\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = rnd.next(0, max_c);\n        }\n    } else if (type == \"max_coins\") {\n        // Generate p_i and c_i = max_c\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = max_c;\n        }\n    } else if (type == \"zero_coins\") {\n        // Generate p_i and c_i = 0\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = 0;\n        }\n    } else if (type == \"asc_power\") {\n        // Generate p_i in ascending order\n        int start = rnd.next(1, 1000000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            p[i] = start + i;\n            c[i] = rnd.next(0, max_c);\n        }\n    } else if (type == \"desc_power\") {\n        // Generate p_i in descending order\n        int start = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            p[i] = start - i;\n            c[i] = rnd.next(0, max_c);\n        }\n    } else if (type == \"equal_coins\") {\n        // Generate p_i randomly, c_i are equal\n        int coin_value = rnd.next(0, max_c);\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = coin_value;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output p_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i+1==n?'\\n':' ');\n    }\n\n    // Output c_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], i+1==n?'\\n':' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int max_c = opt<int>(\"max_c\", 1000000000); // default to max value\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k is valid\n    k = min(k, min(n-1,10));\n\n    vector<int> p(n);\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        // Generate random p_i and c_i\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = rnd.next(0, max_c);\n        }\n    } else if (type == \"max_coins\") {\n        // Generate p_i and c_i = max_c\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = max_c;\n        }\n    } else if (type == \"zero_coins\") {\n        // Generate p_i and c_i = 0\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = 0;\n        }\n    } else if (type == \"asc_power\") {\n        // Generate p_i in ascending order\n        int start = rnd.next(1, 1000000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            p[i] = start + i;\n            c[i] = rnd.next(0, max_c);\n        }\n    } else if (type == \"desc_power\") {\n        // Generate p_i in descending order\n        int start = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            p[i] = start - i;\n            c[i] = rnd.next(0, max_c);\n        }\n    } else if (type == \"equal_coins\") {\n        // Generate p_i randomly, c_i are equal\n        int coin_value = rnd.next(0, max_c);\n        int offset = rnd.next(1, 1000000000 - n + 1);\n        vector<int> idx(n);\n        for (int i = 0; i < n; ++i) idx[i] = i;\n        shuffle(idx.begin(), idx.end());\n        for (int i = 0; i < n; ++i) {\n            p[i] = offset + idx[i];\n            c[i] = coin_value;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output p_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i+1==n?'\\n':' ');\n    }\n\n    // Output c_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], i+1==n?'\\n':' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 0 -type zero_coins\n./gen -n 1 -k 0 -type max_coins\n\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 1 -type asc_power\n./gen -n 2 -k 1 -type desc_power\n\n./gen -n 5 -k 4 -type random\n./gen -n 5 -k 10 -type random\n\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 9 -type random\n./gen -n 10 -k 10 -type random\n\n./gen -n 10 -k 5 -type asc_power\n./gen -n 10 -k 5 -type desc_power\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 10 -type zero_coins\n./gen -n 1000 -k 10 -type max_coins -max_c 1000000000\n\n./gen -n 99999 -k 9 -type equal_coins\n\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 5 -type random\n./gen -n 100000 -k 10 -type random\n\n./gen -n 100000 -k 0 -type asc_power\n./gen -n 100000 -k 10 -type desc_power\n\n./gen -n 100000 -k 10 -type zero_coins\n./gen -n 100000 -k 10 -type max_coins -max_c 1000000000\n\n./gen -n 100000 -k 10 -type random -max_c 1\n./gen -n 100000 -k 10 -type random -max_c 1000000000\n\n./gen -n 100000 -k 10 -type equal_coins\n./gen -n 100000 -k 5 -type equal_coins -max_c 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:30.239237",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "994/C",
      "title": "C. Два квадрата",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВходные данные состоят из двух строк, по одной на квадрат, в каждой по четыре пары целых чисел. Каждая пара чисел задает координаты одной вершины квадрата. Координаты для каждого квадрата даны в порядке обхода по или против часовой стрелки.Первая строка содержит координаты вершин квадрата, у которого стороны параллельны осям координат, вторая строка — у которого стороны образуют с осями координат угол 45 градусов.Все числа во входных данных целые и лежат в интервале между −100−100 и 100100.",
      "output_spec": "Выходные данныеВыведите «Yes», если квадраты пересекаются, иначе выведите «No».Вы можете выводить каждую из букв в любом регистре (строчную или заглавную).",
      "sample_tests": "ПримерыВходные данныеСкопировать0 0 6 0 6 6 0 61 3 3 5 5 3 3 1Выходные данныеСкопироватьYESВходные данныеСкопировать0 0 6 0 6 6 0 67 3 9 5 11 3 9 1Выходные данныеСкопироватьNOВходные данныеСкопировать6 0 6 6 0 6 0 07 4 4 7 7 10 10 7Выходные данныеСкопироватьYES",
      "description": "C. Два квадрата\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВходные данные состоят из двух строк, по одной на квадрат, в каждой по четыре пары целых чисел. Каждая пара чисел задает координаты одной вершины квадрата. Координаты для каждого квадрата даны в порядке обхода по или против часовой стрелки.Первая строка содержит координаты вершин квадрата, у которого стороны параллельны осям координат, вторая строка — у которого стороны образуют с осями координат угол 45 градусов.Все числа во входных данных целые и лежат в интервале между −100−100 и 100100.\n\nВходные данные\n\nВыходные данныеВыведите «Yes», если квадраты пересекаются, иначе выведите «No».Вы можете выводить каждую из букв в любом регистре (строчную или заглавную).\n\nВыходные данные\n\nВходные данныеСкопировать0 0 6 0 6 6 0 61 3 3 5 5 3 3 1Выходные данныеСкопироватьYESВходные данныеСкопировать0 0 6 0 6 6 0 67 3 9 5 11 3 9 1Выходные данныеСкопироватьNOВходные данныеСкопировать6 0 6 6 0 6 0 07 4 4 7 7 10 10 7Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать0 0 6 0 6 6 0 61 3 3 5 5 3 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 0 6 0 6 6 0 67 3 9 5 11 3 9 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 0 6 6 0 6 0 07 4 4 7 7 10 10 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере второй квадрат лежит целиком внутри первого, что по условию является пересечением.Во втором примере два квадрата не имеют общих точек.Картинки, иллюстрирующие примеры:",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD: обратите внимание, распределение баллов изменилосьUPD2: LHiC нашел ошибку в авторском решении на div1-F. Мы исследуем вопрос.UPD3: мы нашли правильное решение для div1-F и оба решения отправленных на контесте проходят все тесты против правильного решения => раунд по прежнему рейтинговый.Всем привет,Время старта Codeforces Round 488: воскресенье, 17 июня 2018 г. в 00:35UTC+8. Это будет раунд для обоих дивизионов. Раунд будет длиться 2.5 часа (это на пол часа больше чем обычно).Контест подготовлен компанией NEAR и ее друзьями. В NEAR мы учим машины участвовать в соревнованиях по программированию. В этом блог-посте можно прочитать (на английском) о том, где сегодня находятся исследования в этой области, чем занимается непосредственно NEAR, и как вы можете помочь нам в этом нелегком деле.На контесте будет предложено по шесть задач в каждом дивизионе, 4 задачи из которых общие.Почти все задачи взяты с тестовых раундов, которые проводились на JavaBlitz в прошлом году. Если вы участвовали в одном из JavaBlitz раундов, то этот CBR, к сожалению, придется пропустить.Распределение баллов в первом дивизионе -- 500-1000-1000-1500-2250-3000Во втором -- 500-1000-1500-2000-2000-2500Раунд в обоих дивизионах рейтинговый.Все задачи написаны мной, Александром \"AlexSkidanov\" Скидановым, и Никитой \"FalseMirror\" Босовым. David \"pieguy\" Stolp, Александр \"AlexFetisov\" Фетиско, Marcelo \"mnaeraxr\" Fornet, Николай \"KAN\" Калинин и Михаил \"cerealguy\" Кевер оказали неоценимую помощь в подгтовке раунда и тестировании задач.В завершении хочется в очередной раз напомнить, что мы постоянно ищем людей, которые помогут нам с разметкой данных с архивов по спортивному программированию. Больше информации здесь.Поздравляем победителей!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge Разбор опубликован тут. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1888
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - Отпечатки пальцевДля решения задачи достаточно пройти по всем элементам данной последовательности, и для каждого в цикле пройти по кнопкам с отпечатками и проверить есть ли кнопка с отпечатком, соответствующая текущему числу в последовательности. Такое решение работает за O(n×m)O(n×m) 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Два квадратаЕсли два квадрата пересекаются, то хотя бы для одного из них верно что либо один из его углов лежит в другом квадрате, либо его центр лежит в другом квадрате.Для квадрата, который повернут на 45 градусов, проверить лежат ли его углы или центр в квадрате со сторонами, параллельными осям координат, очень просто.Чтобы проверить в обратную сторону, достаточно повернуть оба квадрата на 45 градусов. Чтобы это сделать, достаточно заменить все xx координаты на x+yx+y, а все yy координаты на x−yx−y (это также изменит масштаб, но это не влияет на пересечение) 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 994\\s*C"
          },
          "content_length": 10584
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MIN_COORD = -100;\nconst int MAX_COORD = 100;\n\nvoid validate_square(const vector<int> &coords, bool is_axis_aligned) {\n    // Ensure that coords.size() == 8\n    ensuref(coords.size() == 8, \"Expected 8 coordinates, but got %d\", (int)coords.size());\n    // Split into points\n    vector<pair<int, int>> points(4);\n    for (int i = 0; i < 4; ++i) {\n        points[i] = make_pair(coords[2 * i], coords[2 * i + 1]);\n    }\n\n    // Check that all coordinates are within bounds\n    for (int i = 0; i < 4; ++i) {\n        ensuref(MIN_COORD <= points[i].first && points[i].first <= MAX_COORD,\n                \"x-coordinate of point %d is %d, which is out of bounds [%d, %d]\",\n                i + 1, points[i].first, MIN_COORD, MAX_COORD);\n        ensuref(MIN_COORD <= points[i].second && points[i].second <= MAX_COORD,\n                \"y-coordinate of point %d is %d, which is out of bounds [%d, %d]\",\n                i + 1, points[i].second, MIN_COORD, MAX_COORD);\n    }\n\n    // Compute the squared length of each side and check edges\n    vector<long long> side_lengths(4);\n    for (int i = 0; i < 4; ++i) {\n        int x1 = points[i].first;\n        int y1 = points[i].second;\n        int x2 = points[(i + 1) % 4].first;\n        int y2 = points[(i + 1) % 4].second;\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n\n        long long len2 = 1LL * dx * dx + 1LL * dy * dy;\n        side_lengths[i] = len2;\n        ensuref(len2 > 0, \"Edge %d has zero length\", i + 1);\n\n        if (is_axis_aligned) {\n            // Check that either dx == 0 or dy == 0\n            ensuref(dx == 0 || dy == 0,\n                    \"Edge %d of axis-aligned square is not parallel to axes (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n        } else {\n            // Sides at 45 degrees, so |dx| == |dy|\n            ensuref(abs(dx) == abs(dy),\n                    \"Edge %d of rotated square is not at 45 degrees (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n            ensuref(dx != 0 && dy != 0,\n                    \"Edge %d of rotated square has dx or dy equal to zero (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n        }\n    }\n\n    // Check that all sides have equal length\n    for (int i = 1; i < 4; ++i) {\n        ensuref(side_lengths[i] == side_lengths[0],\n                \"Sides are not of equal length: side %d length squared is %lld, side 1 length squared is %lld\",\n                i + 1, side_lengths[i], side_lengths[0]);\n    }\n\n    // Check that diagonals are equal length\n    int x1 = points[0].first, y1 = points[0].second;\n    int x3 = points[2].first, y3 = points[2].second;\n    int dx_diag1 = x3 - x1;\n    int dy_diag1 = y3 - y1;\n    long long diag1_len2 = 1LL * dx_diag1 * dx_diag1 + 1LL * dy_diag1 * dy_diag1;\n\n    x1 = points[1].first; y1 = points[1].second;\n    x3 = points[3].first; y3 = points[3].second;\n    int dx_diag2 = x3 - x1;\n    int dy_diag2 = y3 - y1;\n    long long diag2_len2 = 1LL * dx_diag2 * dx_diag2 + 1LL * dy_diag2 * dy_diag2;\n\n    ensuref(diag1_len2 == diag2_len2,\n            \"Diagonals are not equal length: diag1 length squared is %lld, diag2 length squared is %lld\",\n            diag1_len2, diag2_len2);\n\n    // Check that adjacent edges are perpendicular\n    for (int i = 0; i < 4; ++i) {\n        int x1 = points[i].first;\n        int y1 = points[i].second;\n        int x2 = points[(i + 1) % 4].first;\n        int y2 = points[(i + 1) % 4].second;\n        int x3 = points[(i + 2) % 4].first;\n        int y3 = points[(i + 2) % 4].second;\n\n        int dx1 = x2 - x1;\n        int dy1 = y2 - y1;\n        int dx2 = x3 - x2;\n        int dy2 = y3 - y2;\n\n        int dot = dx1 * dx2 + dy1 * dy2;\n        ensuref(dot == 0,\n                \"Adjacent edges %d and %d are not perpendicular (dot product %d)\",\n                i + 1, ((i + 1) % 4) + 1, dot);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N = 8;\n\n    // First square\n    vector<int> coords1 = inf.readInts(N, MIN_COORD, MAX_COORD, \"coordinates\");\n    inf.readEoln();\n    validate_square(coords1, true);\n\n    // Second square\n    vector<int> coords2 = inf.readInts(N, MIN_COORD, MAX_COORD, \"coordinates\");\n    inf.readEoln();\n    validate_square(coords2, false);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MIN_COORD = -100;\nconst int MAX_COORD = 100;\n\nvoid validate_square(const vector<int> &coords, bool is_axis_aligned) {\n    // Ensure that coords.size() == 8\n    ensuref(coords.size() == 8, \"Expected 8 coordinates, but got %d\", (int)coords.size());\n    // Split into points\n    vector<pair<int, int>> points(4);\n    for (int i = 0; i < 4; ++i) {\n        points[i] = make_pair(coords[2 * i], coords[2 * i + 1]);\n    }\n\n    // Check that all coordinates are within bounds\n    for (int i = 0; i < 4; ++i) {\n        ensuref(MIN_COORD <= points[i].first && points[i].first <= MAX_COORD,\n                \"x-coordinate of point %d is %d, which is out of bounds [%d, %d]\",\n                i + 1, points[i].first, MIN_COORD, MAX_COORD);\n        ensuref(MIN_COORD <= points[i].second && points[i].second <= MAX_COORD,\n                \"y-coordinate of point %d is %d, which is out of bounds [%d, %d]\",\n                i + 1, points[i].second, MIN_COORD, MAX_COORD);\n    }\n\n    // Compute the squared length of each side and check edges\n    vector<long long> side_lengths(4);\n    for (int i = 0; i < 4; ++i) {\n        int x1 = points[i].first;\n        int y1 = points[i].second;\n        int x2 = points[(i + 1) % 4].first;\n        int y2 = points[(i + 1) % 4].second;\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n\n        long long len2 = 1LL * dx * dx + 1LL * dy * dy;\n        side_lengths[i] = len2;\n        ensuref(len2 > 0, \"Edge %d has zero length\", i + 1);\n\n        if (is_axis_aligned) {\n            // Check that either dx == 0 or dy == 0\n            ensuref(dx == 0 || dy == 0,\n                    \"Edge %d of axis-aligned square is not parallel to axes (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n        } else {\n            // Sides at 45 degrees, so |dx| == |dy|\n            ensuref(abs(dx) == abs(dy),\n                    \"Edge %d of rotated square is not at 45 degrees (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n            ensuref(dx != 0 && dy != 0,\n                    \"Edge %d of rotated square has dx or dy equal to zero (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n        }\n    }\n\n    // Check that all sides have equal length\n    for (int i = 1; i < 4; ++i) {\n        ensuref(side_lengths[i] == side_lengths[0],\n                \"Sides are not of equal length: side %d length squared is %lld, side 1 length squared is %lld\",\n                i + 1, side_lengths[i], side_lengths[0]);\n    }\n\n    // Check that diagonals are equal length\n    int x1 = points[0].first, y1 = points[0].second;\n    int x3 = points[2].first, y3 = points[2].second;\n    int dx_diag1 = x3 - x1;\n    int dy_diag1 = y3 - y1;\n    long long diag1_len2 = 1LL * dx_diag1 * dx_diag1 + 1LL * dy_diag1 * dy_diag1;\n\n    x1 = points[1].first; y1 = points[1].second;\n    x3 = points[3].first; y3 = points[3].second;\n    int dx_diag2 = x3 - x1;\n    int dy_diag2 = y3 - y1;\n    long long diag2_len2 = 1LL * dx_diag2 * dx_diag2 + 1LL * dy_diag2 * dy_diag2;\n\n    ensuref(diag1_len2 == diag2_len2,\n            \"Diagonals are not equal length: diag1 length squared is %lld, diag2 length squared is %lld\",\n            diag1_len2, diag2_len2);\n\n    // Check that adjacent edges are perpendicular\n    for (int i = 0; i < 4; ++i) {\n        int x1 = points[i].first;\n        int y1 = points[i].second;\n        int x2 = points[(i + 1) % 4].first;\n        int y2 = points[(i + 1) % 4].second;\n        int x3 = points[(i + 2) % 4].first;\n        int y3 = points[(i + 2) % 4].second;\n\n        int dx1 = x2 - x1;\n        int dy1 = y2 - y1;\n        int dx2 = x3 - x2;\n        int dy2 = y3 - y2;\n\n        int dot = dx1 * dx2 + dy1 * dy2;\n        ensuref(dot == 0,\n                \"Adjacent edges %d and %d are not perpendicular (dot product %d)\",\n                i + 1, ((i + 1) % 4) + 1, dot);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N = 8;\n\n    // First square\n    vector<int> coords1 = inf.readInts(N, MIN_COORD, MAX_COORD, \"coordinates\");\n    inf.readEoln();\n    validate_square(coords1, true);\n\n    // Second square\n    vector<int> coords2 = inf.readInts(N, MIN_COORD, MAX_COORD, \"coordinates\");\n    inf.readEoln();\n    validate_square(coords2, false);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MIN_COORD = -100;\nconst int MAX_COORD = 100;\n\nvoid validate_square(const vector<int> &coords, bool is_axis_aligned) {\n    // Ensure that coords.size() == 8\n    ensuref(coords.size() == 8, \"Expected 8 coordinates, but got %d\", (int)coords.size());\n    // Split into points\n    vector<pair<int, int>> points(4);\n    for (int i = 0; i < 4; ++i) {\n        points[i] = make_pair(coords[2 * i], coords[2 * i + 1]);\n    }\n\n    // Check that all coordinates are within bounds\n    for (int i = 0; i < 4; ++i) {\n        ensuref(MIN_COORD <= points[i].first && points[i].first <= MAX_COORD,\n                \"x-coordinate of point %d is %d, which is out of bounds [%d, %d]\",\n                i + 1, points[i].first, MIN_COORD, MAX_COORD);\n        ensuref(MIN_COORD <= points[i].second && points[i].second <= MAX_COORD,\n                \"y-coordinate of point %d is %d, which is out of bounds [%d, %d]\",\n                i + 1, points[i].second, MIN_COORD, MAX_COORD);\n    }\n\n    // Compute the squared length of each side and check edges\n    vector<long long> side_lengths(4);\n    for (int i = 0; i < 4; ++i) {\n        int x1 = points[i].first;\n        int y1 = points[i].second;\n        int x2 = points[(i + 1) % 4].first;\n        int y2 = points[(i + 1) % 4].second;\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n\n        long long len2 = 1LL * dx * dx + 1LL * dy * dy;\n        side_lengths[i] = len2;\n        ensuref(len2 > 0, \"Edge %d has zero length\", i + 1);\n\n        if (is_axis_aligned) {\n            // Check that either dx == 0 or dy == 0\n            ensuref(dx == 0 || dy == 0,\n                    \"Edge %d of axis-aligned square is not parallel to axes (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n        } else {\n            // Sides at 45 degrees, so |dx| == |dy|\n            ensuref(abs(dx) == abs(dy),\n                    \"Edge %d of rotated square is not at 45 degrees (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n            ensuref(dx != 0 && dy != 0,\n                    \"Edge %d of rotated square has dx or dy equal to zero (dx=%d, dy=%d)\",\n                    i + 1, dx, dy);\n        }\n    }\n\n    // Check that all sides have equal length\n    for (int i = 1; i < 4; ++i) {\n        ensuref(side_lengths[i] == side_lengths[0],\n                \"Sides are not of equal length: side %d length squared is %lld, side 1 length squared is %lld\",\n                i + 1, side_lengths[i], side_lengths[0]);\n    }\n\n    // Check that diagonals are equal length\n    int x1 = points[0].first, y1 = points[0].second;\n    int x3 = points[2].first, y3 = points[2].second;\n    int dx_diag1 = x3 - x1;\n    int dy_diag1 = y3 - y1;\n    long long diag1_len2 = 1LL * dx_diag1 * dx_diag1 + 1LL * dy_diag1 * dy_diag1;\n\n    x1 = points[1].first; y1 = points[1].second;\n    x3 = points[3].first; y3 = points[3].second;\n    int dx_diag2 = x3 - x1;\n    int dy_diag2 = y3 - y1;\n    long long diag2_len2 = 1LL * dx_diag2 * dx_diag2 + 1LL * dy_diag2 * dy_diag2;\n\n    ensuref(diag1_len2 == diag2_len2,\n            \"Diagonals are not equal length: diag1 length squared is %lld, diag2 length squared is %lld\",\n            diag1_len2, diag2_len2);\n\n    // Check that adjacent edges are perpendicular\n    for (int i = 0; i < 4; ++i) {\n        int x1 = points[i].first;\n        int y1 = points[i].second;\n        int x2 = points[(i + 1) % 4].first;\n        int y2 = points[(i + 1) % 4].second;\n        int x3 = points[(i + 2) % 4].first;\n        int y3 = points[(i + 2) % 4].second;\n\n        int dx1 = x2 - x1;\n        int dy1 = y2 - y1;\n        int dx2 = x3 - x2;\n        int dy2 = y3 - y2;\n\n        int dot = dx1 * dx2 + dy1 * dy2;\n        ensuref(dot == 0,\n                \"Adjacent edges %d and %d are not perpendicular (dot product %d)\",\n                i + 1, ((i + 1) % 4) + 1, dot);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int N = 8;\n\n    // First square\n    vector<int> coords1 = inf.readInts(N, MIN_COORD, MAX_COORD, \"coordinates\");\n    inf.readEoln();\n    validate_square(coords1, true);\n\n    // Second square\n    vector<int> coords2 = inf.readInts(N, MIN_COORD, MAX_COORD, \"coordinates\");\n    inf.readEoln();\n    validate_square(coords2, false);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly ONE test case per execution.\n  It generates two squares:\n    1) An axis-aligned square (first line of output).\n    2) A square rotated 45 degrees (second line of output).\n\n  Each square is printed as four pairs of integer coordinates in either\n  clockwise or counterclockwise order. Coordinates are guaranteed to be\n  between -100 and 100.\n  \n  Parameters:\n    -type [string]: one of:\n       * \"random\"    : fully random placement (may or may not intersect).\n       * \"inside\"    : the second (rotated) square is fully inside the first.\n       * \"disjoint\"  : no intersection.\n       * \"corner\"    : the two squares share exactly one corner point.\n       * \"edge\"      : the two squares share a full edge (touching).\n       * \"partial\"   : partially overlapping intersection.\n    -halfSide1 [int, default=10]: half-side for the axis-aligned square.\n    -halfSide2 [int, default=5] : \"radius\" for the 45-degree square,\n                                  i.e. half of its diagonal.\n\n  NOTE:\n    • We do not set or accept a random seed from the command line.\n    • The squares will be kept within [-100, 100].\n    • If a particular scenario cannot be placed in the range easily,\n      the program attempts random placements a few times.\n*/\n\nstatic const int BOUND = 100;\n\n// Returns the corners of an axis-aligned square, in either clockwise or CCW.\nvector<pair<int,int>> makeAxisAlignedSquare(int cx, int cy, int halfSide, bool clockwise) {\n    // Corners in CCW order starting top-left:\n    // top-left, top-right, bottom-right, bottom-left\n    // But we can invert them to get CW if needed.\n\n    // halfSide is > 0\n    // Just ensure the corners are in some valid order.\n    vector<pair<int,int>> ccw = {\n        {cx - halfSide, cy + halfSide},\n        {cx + halfSide, cy + halfSide},\n        {cx + halfSide, cy - halfSide},\n        {cx - halfSide, cy - halfSide}\n    };\n    if (!clockwise) return ccw;\n    else {\n        // reverse ccw to get clockwise\n        reverse(ccw.begin()+1, ccw.end());\n        return ccw;\n    }\n}\n\n// Returns the corners of a 45-degree-rotated square (like a \"diamond\"),\n// in either clockwise or CCW order. \"r\" is half the square's diagonal.\nvector<pair<int,int>> makeRotatedSquare(int cx, int cy, int r, bool clockwise) {\n    // If r>0, the corners (in CCW) can be:\n    // (cx, cy + r), (cx + r, cy), (cx, cy - r), (cx - r, cy)\n    vector<pair<int,int>> ccw = {\n        {cx,     cy + r},\n        {cx + r, cy    },\n        {cx,     cy - r},\n        {cx - r, cy    }\n    };\n    if (!clockwise) return ccw;\n    else {\n        // reverse ccw to get clockwise\n        reverse(ccw.begin()+1, ccw.end());\n        return ccw;\n    }\n}\n\n// Outputs the corners in one line: x1 y1 x2 y2 x3 y3 x4 y4\nvoid printSquare(const vector<pair<int,int>>& sq) {\n    // Just print them in order\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d %d\", sq[i].first, sq[i].second);\n        if (i + 1 < 4) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\n// Checks whether all corners are in [-100,100].\nbool inRange(const vector<pair<int,int>>& corners) {\n    for (auto &c : corners) {\n        if (c.first < -BOUND || c.first > BOUND) return false;\n        if (c.second < -BOUND || c.second > BOUND) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    string type = opt<string>(\"type\", \"random\");\n    int halfSide1 = opt<int>(\"halfSide1\", 10); // half side for axis-aligned\n    int halfSide2 = opt<int>(\"halfSide2\", 5);  // radius for the 45-degree square\n\n    /*\n      We'll generate two squares S1 (axis-aligned) and S2 (rotated).\n      We want to keep them within the coordinate range [-100,100].\n      We'll place S1 at some random center, then place S2 according to \"type\".\n    */\n\n    // For repeated random attempts if one arrangement doesn't fit:\n    const int MAX_TRIES = 1000;\n    \n    // We'll store the final squares after generation\n    vector<pair<int,int>> sq1, sq2;\n\n    // Decide random orientation (CW or CCW)\n    bool cw1 = (rnd.next(2) == 1);\n    bool cw2 = (rnd.next(2) == 1);\n\n    // Helper lambdas:\n    //  1) Attempt to place S1 in range.\n    //  2) Then place S2 depending on \"type\".\n    //  3) Check range, if not good, repeat.\n    auto canPlace = [&](vector<pair<int,int>>& out1,\n                        vector<pair<int,int>>& out2)->bool\n    {\n        // Step 1: place S1 randomly within [-100,100].\n        // center must satisfy:\n        //   -100 + halfSide1 <= cx <= 100 - halfSide1\n        //   -100 + halfSide1 <= cy <= 100 - halfSide1\n        int range1 = 2*(BOUND - halfSide1) + 1; \n        if (range1 <= 0) return false;\n\n        int cx1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n        int cy1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n        out1 = makeAxisAlignedSquare(cx1, cy1, halfSide1, cw1);\n\n        if (!inRange(out1)) return false; // unexpected fallback check\n\n        // Step 2: place S2 depending on type\n        // We define a convenient function to place the second square at center (cx2, cy2).\n        auto buildS2 = [&](int cx2, int cy2){\n            return makeRotatedSquare(cx2, cy2, halfSide2, cw2);\n        };\n\n        // For \"random\", we simply pick any center that keeps corners in range\n        if (type == \"random\") {\n            // random center with constraints\n            int range2 = 2*(BOUND - halfSide2) + 1;\n            if (range2 <= 0) return false;\n\n            int cx2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            int cy2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            out2 = buildS2(cx2, cy2);\n            return inRange(out2);\n        }\n        // For \"inside\", we want S2 inside S1\n        // We'll attempt to place the second square center at the same as the first,\n        // but we must ensure halfSide2 < halfSide1 so there's a good chance it's inside.\n        // Then random shift inside that bounding box of the axis-aligned square.\n        else if (type == \"inside\") {\n            // We want the entire diamond inside the axis-aligned square. \n            // The bounding box of S2 is (cx2 +/- halfSide2, cy2 +/- halfSide2).\n            // The bounding box of S1 is (cx1 +/- halfSide1).\n            // We'll pick a random (cx2, cy2) so that S2 fits inside S1's bounding box.\n            // That means:\n            //   cx1 - halfSide1 <= cx2 - halfSide2, and cx2 + halfSide2 <= cx1 + halfSide1\n            //   => cx1 - halfSide1 + halfSide2 <= cx2 <= cx1 + halfSide1 - halfSide2\n            // Similarly for Y. Then we also ensure global range [-100,100].\n            int minX = max(-BOUND + halfSide2, cx1 - halfSide1 + halfSide2);\n            int maxX = min(BOUND - halfSide2,  cx1 + halfSide1 - halfSide2);\n            int minY = max(-BOUND + halfSide2, cy1 - halfSide1 + halfSide2);\n            int maxY = min(BOUND - halfSide2,  cy1 + halfSide1 - halfSide2);\n\n            if (minX > maxX || minY > maxY) return false;\n            int cx2 = rnd.next(minX, maxX);\n            int cy2 = rnd.next(minY, maxY);\n            out2 = buildS2(cx2, cy2);\n            return inRange(out2);\n        }\n        // For \"disjoint\", we try to place them far apart so they won't intersect\n        else if (type == \"disjoint\") {\n            // We'll attempt to place the second square so that it is definitely\n            // outside the bounding box of the first. We'll just put it far away\n            // from S1 in either left, right, up, or down direction.\n            // Then clamp to range, if not possible => fail\n            // Let's pick a random direction:\n            int dir = rnd.next(4); // 0=left,1=right,2=up,3=down\n            int range2 = BOUND - halfSide2;\n            if (range2 <= 0) return false;\n\n            // bounding box of S1 is from (cx1-halfSide1, cy1-halfSide1) to ...\n            // We'll place S2 so that it does not intersect. For a safe margin,\n            // we can move it 2*(halfSide1+halfSide2) away in some direction.\n            int shift = halfSide1 + halfSide2 + 2;\n            int cx2, cy2;\n            if (dir == 0) {\n                // left\n                cx2 = cx1 - shift - rnd.next(0, 5);\n                cy2 = cy1;\n            } else if (dir == 1) {\n                // right\n                cx2 = cx1 + shift + rnd.next(0, 5);\n                cy2 = cy1;\n            } else if (dir == 2) {\n                // up\n                cx2 = cx1;\n                cy2 = cy1 + shift + rnd.next(0, 5);\n            } else {\n                // down\n                cx2 = cx1;\n                cy2 = cy1 - shift - rnd.next(0, 5);\n            }\n            // Now clamp to ensure corners won't exceed range:\n            // We'll just build and check. If out of range, we fail or try again.\n            out2 = buildS2(cx2, cy2);\n            return inRange(out2);\n        }\n        // For \"corner\", we want them to share exactly one corner\n        else if (type == \"corner\") {\n            // We'll pick a random corner from S1 and a corner from S2, set them equal.\n            // Then ensure the rest can still fit in range.\n            // We'll do a random corner index i in [0..3] for S1, and j in [0..3] for S2.\n            // We'll choose a random center for S2, then shift so corner j matches corner i of S1.\n            int cornerS1Id = rnd.next(4);\n            auto cornerS1 = out1[cornerS1Id];\n\n            // We want out2[j] = cornerS1 => centerS2 + (cornerOfDiamond j) offset\n            // Let's define diamond corners relative to center: \n            //   (0, +r), (+r, 0), (0, -r), (-r, 0)\n            // We'll pick j randomly:\n            int j = rnd.next(4);\n            // The offset from center for corner j:\n            static vector<pair<int,int>> offsets = {\n                {0, +1}, {+1, 0}, {0, -1}, {-1, 0}\n            };\n            auto off = offsets[j];\n            // Then if centerS2 = (cx2, cy2), corner j = (cx2 + offX*r, cy2 + offY*r).\n            // We want that = cornerS1. So cx2 = cornerS1.x - offX*r, etc.\n            // r = halfSide2\n            int cx2 = cornerS1.first  - off.first*halfSide2;\n            int cy2 = cornerS1.second - off.second*halfSide2;\n\n            out2 = makeRotatedSquare(cx2, cy2, halfSide2, cw2);\n\n            // Now check if they share exactly 1 corner is trickier, but we'll assume\n            // it's at least consistent with them sharing that corner. Next we verify range.\n            if (!inRange(out2)) return false;\n\n            // It's possible they share more than one corner if halfSide1 == halfSide2, etc.\n            // But that is still a valid corner-touch scenario from the viewpoint of problem difficulty.\n            return true;\n        }\n        // For \"edge\", we want them to share a full edge. We'll make an edge of S2 coincide with an edge of S1.\n        else if (type == \"edge\") {\n            // For S1, an edge is between corners i and (i+1)%4\n            // We'll pick i randomly, also pick an edge from S2.\n            // For rotated square S2, edges: \n            //   between corners (0->1), (1->2), (2->3), (3->0).\n            // We'll try to place them so that edge is the same line segment. \n            // For S1's edge i, get the two corner points. Let them be (xA,yA),(xB,yB).\n            // For S2's edge j, we want those corners to coincide. We'll see if\n            // that is feasible in the integer grid (we must ensure orientation is consistent).\n            // We won't worry about perfect orientation matching, we'll just place corners the same \n            // in the same order or reversed. Then see if in range. \n            int i = rnd.next(4);\n            int j = rnd.next(4);\n            // corners of S1\n            auto cA1 = out1[i];\n            auto cB1 = out1[(i+1)%4];\n\n            // corners of the *canonical* S2 with center (0,0)\n            // We'll build it first at origin, then shift. \n            // This might produce a mismatch in orientation, but it's okay for test coverage.\n            auto s2orig = makeRotatedSquare(0, 0, halfSide2, cw2);\n            // edge j: s2orig[j] -> s2orig[(j+1)%4]\n            auto cA2 = s2orig[j];\n            auto cB2 = s2orig[(j+1)%4];\n\n            // We want (cx,cy) + cA2 = cA1, (cx,cy) + cB2 = cB1,\n            // which implies the translation is T = cA1 - cA2, and we must check \n            // if cB2 + T = cB1. That is consistent => T = (cA1.x - cA2.x, cA1.y - cA2.y).\n            int tx = cA1.first  - cA2.first;\n            int ty = cA1.second - cA2.second;\n            // Now cB2' = (cB2.x + tx, cB2.y + ty). We want that to be cB1.\n            if ((cB2.first + tx) != cB1.first || (cB2.second + ty) != cB1.second) {\n                // If it doesn't match exactly, we can also try reversing that edge.\n                // That is, match cA2->cB2 with cB1->cA1. We'll do that below. \n                // Let's try reversing the order. For reversing we want cA1->cB1 = cB2->cA2\n                // So T2 = cA1 - cB2, then check if cA2 + T2 = cB1\n                int tx2 = cA1.first  - cB2.first;\n                int ty2 = cA1.second - cB2.second;\n                if ((cA2.first + tx2) != cB1.first || (cA2.second + ty2) != cB1.second) {\n                    // fail\n                    return false;\n                } else {\n                    // use T2\n                    tx = tx2;\n                    ty = ty2;\n                }\n            }\n            // Now apply translation T to all corners of s2orig\n            out2.clear();\n            for (auto &c : s2orig) {\n                out2.push_back({c.first + tx, c.second + ty});\n            }\n            if (!inRange(out2)) return false;\n            return true;\n        }\n        // For \"partial\", we want them to overlap partially but not be fully inside nor just corner/edge.\n        else if (type == \"partial\") {\n            // We'll place the second center near the first square so that corners partially overlap.\n            // Let the first center = (cx1, cy1). We'll choose a random direction\n            // and shift the second center so that half of S2 is inside S1's bounding box.\n            // For more robust approach, we try random offsets. \n            // We'll do up to 50 attempts to find a partial intersection.\n            for (int trial = 0; trial < 50; trial++) {\n                int dx = rnd.next(-2*halfSide1, 2*halfSide1);\n                int dy = rnd.next(-2*halfSide1, 2*halfSide1);\n                int cx2 = cx1 + dx;\n                int cy2 = cy1 + dy;\n                auto candidate = buildS2(cx2, cy2);\n                if (!inRange(candidate)) continue;\n                // This is hopefully partially intersecting. We'll accept it.\n                out2 = candidate;\n                return true;\n            }\n            return false;\n        }\n        // fallback\n        return false;\n    };\n\n    bool success = false;\n    for (int tries = 0; tries < MAX_TRIES; tries++) {\n        if (canPlace(sq1, sq2)) {\n            success = true;\n            break;\n        }\n    }\n\n    // If we ended up not finding a valid scenario, we will just do a random scenario as fallback\n    if (!success) {\n        // fallback: just do random squares\n        // We do a simple loop until success or we give up.\n        for (int tries2 = 0; tries2 < MAX_TRIES; tries2++) {\n            // place S1\n            int range1 = 2*(BOUND - halfSide1) + 1;\n            int cx1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n            int cy1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n            auto candidate1 = makeAxisAlignedSquare(cx1, cy1, halfSide1, cw1);\n            if (!inRange(candidate1)) continue;\n\n            // place S2\n            int range2 = 2*(BOUND - halfSide2) + 1;\n            int cx2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            int cy2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            auto candidate2 = makeRotatedSquare(cx2, cy2, halfSide2, cw2);\n            if (!inRange(candidate2)) continue;\n\n            sq1 = candidate1;\n            sq2 = candidate2;\n            success = true;\n            break;\n        }\n    }\n\n    // Now print the result squares\n    // This must be exactly two lines, each with 8 integers: x1 y1 x2 y2 x3 y3 x4 y4\n    // If still not success, the problem constraints were too tight (which is unlikely).\n    // We'll just forcibly print some trivial squares to avoid an empty output.\n    if (!success) {\n        // e.g. small fallback squares around origin\n        sq1 = makeAxisAlignedSquare(0, 0, 1, false);\n        sq2 = makeRotatedSquare(2, 0, 1, false);\n    }\n\n    printSquare(sq1);\n    printSquare(sq2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly ONE test case per execution.\n  It generates two squares:\n    1) An axis-aligned square (first line of output).\n    2) A square rotated 45 degrees (second line of output).\n\n  Each square is printed as four pairs of integer coordinates in either\n  clockwise or counterclockwise order. Coordinates are guaranteed to be\n  between -100 and 100.\n  \n  Parameters:\n    -type [string]: one of:\n       * \"random\"    : fully random placement (may or may not intersect).\n       * \"inside\"    : the second (rotated) square is fully inside the first.\n       * \"disjoint\"  : no intersection.\n       * \"corner\"    : the two squares share exactly one corner point.\n       * \"edge\"      : the two squares share a full edge (touching).\n       * \"partial\"   : partially overlapping intersection.\n    -halfSide1 [int, default=10]: half-side for the axis-aligned square.\n    -halfSide2 [int, default=5] : \"radius\" for the 45-degree square,\n                                  i.e. half of its diagonal.\n\n  NOTE:\n    • We do not set or accept a random seed from the command line.\n    • The squares will be kept within [-100, 100].\n    • If a particular scenario cannot be placed in the range easily,\n      the program attempts random placements a few times.\n*/\n\nstatic const int BOUND = 100;\n\n// Returns the corners of an axis-aligned square, in either clockwise or CCW.\nvector<pair<int,int>> makeAxisAlignedSquare(int cx, int cy, int halfSide, bool clockwise) {\n    // Corners in CCW order starting top-left:\n    // top-left, top-right, bottom-right, bottom-left\n    // But we can invert them to get CW if needed.\n\n    // halfSide is > 0\n    // Just ensure the corners are in some valid order.\n    vector<pair<int,int>> ccw = {\n        {cx - halfSide, cy + halfSide},\n        {cx + halfSide, cy + halfSide},\n        {cx + halfSide, cy - halfSide},\n        {cx - halfSide, cy - halfSide}\n    };\n    if (!clockwise) return ccw;\n    else {\n        // reverse ccw to get clockwise\n        reverse(ccw.begin()+1, ccw.end());\n        return ccw;\n    }\n}\n\n// Returns the corners of a 45-degree-rotated square (like a \"diamond\"),\n// in either clockwise or CCW order. \"r\" is half the square's diagonal.\nvector<pair<int,int>> makeRotatedSquare(int cx, int cy, int r, bool clockwise) {\n    // If r>0, the corners (in CCW) can be:\n    // (cx, cy + r), (cx + r, cy), (cx, cy - r), (cx - r, cy)\n    vector<pair<int,int>> ccw = {\n        {cx,     cy + r},\n        {cx + r, cy    },\n        {cx,     cy - r},\n        {cx - r, cy    }\n    };\n    if (!clockwise) return ccw;\n    else {\n        // reverse ccw to get clockwise\n        reverse(ccw.begin()+1, ccw.end());\n        return ccw;\n    }\n}\n\n// Outputs the corners in one line: x1 y1 x2 y2 x3 y3 x4 y4\nvoid printSquare(const vector<pair<int,int>>& sq) {\n    // Just print them in order\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d %d\", sq[i].first, sq[i].second);\n        if (i + 1 < 4) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\n// Checks whether all corners are in [-100,100].\nbool inRange(const vector<pair<int,int>>& corners) {\n    for (auto &c : corners) {\n        if (c.first < -BOUND || c.first > BOUND) return false;\n        if (c.second < -BOUND || c.second > BOUND) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    string type = opt<string>(\"type\", \"random\");\n    int halfSide1 = opt<int>(\"halfSide1\", 10); // half side for axis-aligned\n    int halfSide2 = opt<int>(\"halfSide2\", 5);  // radius for the 45-degree square\n\n    /*\n      We'll generate two squares S1 (axis-aligned) and S2 (rotated).\n      We want to keep them within the coordinate range [-100,100].\n      We'll place S1 at some random center, then place S2 according to \"type\".\n    */\n\n    // For repeated random attempts if one arrangement doesn't fit:\n    const int MAX_TRIES = 1000;\n    \n    // We'll store the final squares after generation\n    vector<pair<int,int>> sq1, sq2;\n\n    // Decide random orientation (CW or CCW)\n    bool cw1 = (rnd.next(2) == 1);\n    bool cw2 = (rnd.next(2) == 1);\n\n    // Helper lambdas:\n    //  1) Attempt to place S1 in range.\n    //  2) Then place S2 depending on \"type\".\n    //  3) Check range, if not good, repeat.\n    auto canPlace = [&](vector<pair<int,int>>& out1,\n                        vector<pair<int,int>>& out2)->bool\n    {\n        // Step 1: place S1 randomly within [-100,100].\n        // center must satisfy:\n        //   -100 + halfSide1 <= cx <= 100 - halfSide1\n        //   -100 + halfSide1 <= cy <= 100 - halfSide1\n        int range1 = 2*(BOUND - halfSide1) + 1; \n        if (range1 <= 0) return false;\n\n        int cx1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n        int cy1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n        out1 = makeAxisAlignedSquare(cx1, cy1, halfSide1, cw1);\n\n        if (!inRange(out1)) return false; // unexpected fallback check\n\n        // Step 2: place S2 depending on type\n        // We define a convenient function to place the second square at center (cx2, cy2).\n        auto buildS2 = [&](int cx2, int cy2){\n            return makeRotatedSquare(cx2, cy2, halfSide2, cw2);\n        };\n\n        // For \"random\", we simply pick any center that keeps corners in range\n        if (type == \"random\") {\n            // random center with constraints\n            int range2 = 2*(BOUND - halfSide2) + 1;\n            if (range2 <= 0) return false;\n\n            int cx2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            int cy2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            out2 = buildS2(cx2, cy2);\n            return inRange(out2);\n        }\n        // For \"inside\", we want S2 inside S1\n        // We'll attempt to place the second square center at the same as the first,\n        // but we must ensure halfSide2 < halfSide1 so there's a good chance it's inside.\n        // Then random shift inside that bounding box of the axis-aligned square.\n        else if (type == \"inside\") {\n            // We want the entire diamond inside the axis-aligned square. \n            // The bounding box of S2 is (cx2 +/- halfSide2, cy2 +/- halfSide2).\n            // The bounding box of S1 is (cx1 +/- halfSide1).\n            // We'll pick a random (cx2, cy2) so that S2 fits inside S1's bounding box.\n            // That means:\n            //   cx1 - halfSide1 <= cx2 - halfSide2, and cx2 + halfSide2 <= cx1 + halfSide1\n            //   => cx1 - halfSide1 + halfSide2 <= cx2 <= cx1 + halfSide1 - halfSide2\n            // Similarly for Y. Then we also ensure global range [-100,100].\n            int minX = max(-BOUND + halfSide2, cx1 - halfSide1 + halfSide2);\n            int maxX = min(BOUND - halfSide2,  cx1 + halfSide1 - halfSide2);\n            int minY = max(-BOUND + halfSide2, cy1 - halfSide1 + halfSide2);\n            int maxY = min(BOUND - halfSide2,  cy1 + halfSide1 - halfSide2);\n\n            if (minX > maxX || minY > maxY) return false;\n            int cx2 = rnd.next(minX, maxX);\n            int cy2 = rnd.next(minY, maxY);\n            out2 = buildS2(cx2, cy2);\n            return inRange(out2);\n        }\n        // For \"disjoint\", we try to place them far apart so they won't intersect\n        else if (type == \"disjoint\") {\n            // We'll attempt to place the second square so that it is definitely\n            // outside the bounding box of the first. We'll just put it far away\n            // from S1 in either left, right, up, or down direction.\n            // Then clamp to range, if not possible => fail\n            // Let's pick a random direction:\n            int dir = rnd.next(4); // 0=left,1=right,2=up,3=down\n            int range2 = BOUND - halfSide2;\n            if (range2 <= 0) return false;\n\n            // bounding box of S1 is from (cx1-halfSide1, cy1-halfSide1) to ...\n            // We'll place S2 so that it does not intersect. For a safe margin,\n            // we can move it 2*(halfSide1+halfSide2) away in some direction.\n            int shift = halfSide1 + halfSide2 + 2;\n            int cx2, cy2;\n            if (dir == 0) {\n                // left\n                cx2 = cx1 - shift - rnd.next(0, 5);\n                cy2 = cy1;\n            } else if (dir == 1) {\n                // right\n                cx2 = cx1 + shift + rnd.next(0, 5);\n                cy2 = cy1;\n            } else if (dir == 2) {\n                // up\n                cx2 = cx1;\n                cy2 = cy1 + shift + rnd.next(0, 5);\n            } else {\n                // down\n                cx2 = cx1;\n                cy2 = cy1 - shift - rnd.next(0, 5);\n            }\n            // Now clamp to ensure corners won't exceed range:\n            // We'll just build and check. If out of range, we fail or try again.\n            out2 = buildS2(cx2, cy2);\n            return inRange(out2);\n        }\n        // For \"corner\", we want them to share exactly one corner\n        else if (type == \"corner\") {\n            // We'll pick a random corner from S1 and a corner from S2, set them equal.\n            // Then ensure the rest can still fit in range.\n            // We'll do a random corner index i in [0..3] for S1, and j in [0..3] for S2.\n            // We'll choose a random center for S2, then shift so corner j matches corner i of S1.\n            int cornerS1Id = rnd.next(4);\n            auto cornerS1 = out1[cornerS1Id];\n\n            // We want out2[j] = cornerS1 => centerS2 + (cornerOfDiamond j) offset\n            // Let's define diamond corners relative to center: \n            //   (0, +r), (+r, 0), (0, -r), (-r, 0)\n            // We'll pick j randomly:\n            int j = rnd.next(4);\n            // The offset from center for corner j:\n            static vector<pair<int,int>> offsets = {\n                {0, +1}, {+1, 0}, {0, -1}, {-1, 0}\n            };\n            auto off = offsets[j];\n            // Then if centerS2 = (cx2, cy2), corner j = (cx2 + offX*r, cy2 + offY*r).\n            // We want that = cornerS1. So cx2 = cornerS1.x - offX*r, etc.\n            // r = halfSide2\n            int cx2 = cornerS1.first  - off.first*halfSide2;\n            int cy2 = cornerS1.second - off.second*halfSide2;\n\n            out2 = makeRotatedSquare(cx2, cy2, halfSide2, cw2);\n\n            // Now check if they share exactly 1 corner is trickier, but we'll assume\n            // it's at least consistent with them sharing that corner. Next we verify range.\n            if (!inRange(out2)) return false;\n\n            // It's possible they share more than one corner if halfSide1 == halfSide2, etc.\n            // But that is still a valid corner-touch scenario from the viewpoint of problem difficulty.\n            return true;\n        }\n        // For \"edge\", we want them to share a full edge. We'll make an edge of S2 coincide with an edge of S1.\n        else if (type == \"edge\") {\n            // For S1, an edge is between corners i and (i+1)%4\n            // We'll pick i randomly, also pick an edge from S2.\n            // For rotated square S2, edges: \n            //   between corners (0->1), (1->2), (2->3), (3->0).\n            // We'll try to place them so that edge is the same line segment. \n            // For S1's edge i, get the two corner points. Let them be (xA,yA),(xB,yB).\n            // For S2's edge j, we want those corners to coincide. We'll see if\n            // that is feasible in the integer grid (we must ensure orientation is consistent).\n            // We won't worry about perfect orientation matching, we'll just place corners the same \n            // in the same order or reversed. Then see if in range. \n            int i = rnd.next(4);\n            int j = rnd.next(4);\n            // corners of S1\n            auto cA1 = out1[i];\n            auto cB1 = out1[(i+1)%4];\n\n            // corners of the *canonical* S2 with center (0,0)\n            // We'll build it first at origin, then shift. \n            // This might produce a mismatch in orientation, but it's okay for test coverage.\n            auto s2orig = makeRotatedSquare(0, 0, halfSide2, cw2);\n            // edge j: s2orig[j] -> s2orig[(j+1)%4]\n            auto cA2 = s2orig[j];\n            auto cB2 = s2orig[(j+1)%4];\n\n            // We want (cx,cy) + cA2 = cA1, (cx,cy) + cB2 = cB1,\n            // which implies the translation is T = cA1 - cA2, and we must check \n            // if cB2 + T = cB1. That is consistent => T = (cA1.x - cA2.x, cA1.y - cA2.y).\n            int tx = cA1.first  - cA2.first;\n            int ty = cA1.second - cA2.second;\n            // Now cB2' = (cB2.x + tx, cB2.y + ty). We want that to be cB1.\n            if ((cB2.first + tx) != cB1.first || (cB2.second + ty) != cB1.second) {\n                // If it doesn't match exactly, we can also try reversing that edge.\n                // That is, match cA2->cB2 with cB1->cA1. We'll do that below. \n                // Let's try reversing the order. For reversing we want cA1->cB1 = cB2->cA2\n                // So T2 = cA1 - cB2, then check if cA2 + T2 = cB1\n                int tx2 = cA1.first  - cB2.first;\n                int ty2 = cA1.second - cB2.second;\n                if ((cA2.first + tx2) != cB1.first || (cA2.second + ty2) != cB1.second) {\n                    // fail\n                    return false;\n                } else {\n                    // use T2\n                    tx = tx2;\n                    ty = ty2;\n                }\n            }\n            // Now apply translation T to all corners of s2orig\n            out2.clear();\n            for (auto &c : s2orig) {\n                out2.push_back({c.first + tx, c.second + ty});\n            }\n            if (!inRange(out2)) return false;\n            return true;\n        }\n        // For \"partial\", we want them to overlap partially but not be fully inside nor just corner/edge.\n        else if (type == \"partial\") {\n            // We'll place the second center near the first square so that corners partially overlap.\n            // Let the first center = (cx1, cy1). We'll choose a random direction\n            // and shift the second center so that half of S2 is inside S1's bounding box.\n            // For more robust approach, we try random offsets. \n            // We'll do up to 50 attempts to find a partial intersection.\n            for (int trial = 0; trial < 50; trial++) {\n                int dx = rnd.next(-2*halfSide1, 2*halfSide1);\n                int dy = rnd.next(-2*halfSide1, 2*halfSide1);\n                int cx2 = cx1 + dx;\n                int cy2 = cy1 + dy;\n                auto candidate = buildS2(cx2, cy2);\n                if (!inRange(candidate)) continue;\n                // This is hopefully partially intersecting. We'll accept it.\n                out2 = candidate;\n                return true;\n            }\n            return false;\n        }\n        // fallback\n        return false;\n    };\n\n    bool success = false;\n    for (int tries = 0; tries < MAX_TRIES; tries++) {\n        if (canPlace(sq1, sq2)) {\n            success = true;\n            break;\n        }\n    }\n\n    // If we ended up not finding a valid scenario, we will just do a random scenario as fallback\n    if (!success) {\n        // fallback: just do random squares\n        // We do a simple loop until success or we give up.\n        for (int tries2 = 0; tries2 < MAX_TRIES; tries2++) {\n            // place S1\n            int range1 = 2*(BOUND - halfSide1) + 1;\n            int cx1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n            int cy1 = rnd.next(-BOUND + halfSide1, BOUND - halfSide1);\n            auto candidate1 = makeAxisAlignedSquare(cx1, cy1, halfSide1, cw1);\n            if (!inRange(candidate1)) continue;\n\n            // place S2\n            int range2 = 2*(BOUND - halfSide2) + 1;\n            int cx2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            int cy2 = rnd.next(-BOUND + halfSide2, BOUND - halfSide2);\n            auto candidate2 = makeRotatedSquare(cx2, cy2, halfSide2, cw2);\n            if (!inRange(candidate2)) continue;\n\n            sq1 = candidate1;\n            sq2 = candidate2;\n            success = true;\n            break;\n        }\n    }\n\n    // Now print the result squares\n    // This must be exactly two lines, each with 8 integers: x1 y1 x2 y2 x3 y3 x4 y4\n    // If still not success, the problem constraints were too tight (which is unlikely).\n    // We'll just forcibly print some trivial squares to avoid an empty output.\n    if (!success) {\n        // e.g. small fallback squares around origin\n        sq1 = makeAxisAlignedSquare(0, 0, 1, false);\n        sq2 = makeRotatedSquare(2, 0, 1, false);\n    }\n\n    printSquare(sq1);\n    printSquare(sq2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are ~20-30 sample commands that demonstrate how to use the generator\n# with different parameter sets. Each command will produce exactly ONE test case,\n# printing it to standard output. You do NOT need to redirect the output in this example.\n\n./gen -type random\n./gen -type random -halfSide1 1 -halfSide2 1\n./gen -type random -halfSide1 5 -halfSide2 3\n./gen -type random -halfSide1 50 -halfSide2 50\n./gen -type inside -halfSide1 5 -halfSide2 1\n./gen -type inside -halfSide1 20 -halfSide2 10\n./gen -type disjoint -halfSide1 5 -halfSide2 5\n./gen -type disjoint -halfSide1 10 -halfSide2 10\n./gen -type corner -halfSide1 5 -halfSide2 5\n./gen -type corner -halfSide1 6 -halfSide2 6\n./gen -type edge -halfSide1 2 -halfSide2 2\n./gen -type edge -halfSide1 10 -halfSide2 10\n./gen -type partial -halfSide1 10 -halfSide2 5\n./gen -type partial -halfSide1 15 -halfSide2 10\n./gen -type partial -halfSide1 50 -halfSide2 50\n\n# Some additional random / large combos:\n./gen -type random -halfSide1 50 -halfSide2 1\n./gen -type random -halfSide1 1 -halfSide2 50\n./gen -type random -halfSide1 30 -halfSide2 40\n./gen -type random -halfSide1 40 -halfSide2 30\n\n# Edge cases with relatively large squares:\n./gen -type inside -halfSide1 50 -halfSide2 49\n./gen -type corner -halfSide1 50 -halfSide2 50\n./gen -type disjoint -halfSide1 50 -halfSide2 50\n./gen -type partial -halfSide1 50 -halfSide2 50\n./gen -type random -halfSide1 50 -halfSide2 50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:32.744070",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "994/D",
      "title": "D. Open Communication",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (1≤n,m≤121≤n,m≤12) — the number of pairs the first participant communicated to the second and vice versa.The second line contains nn pairs of integers, each between 11 and 99, — pairs of numbers communicated from first participant to the second.The third line contains mm pairs of integers, each between 11 and 99, — pairs of numbers communicated from the second participant to the first.All pairs within each set are distinct (in particular, if there is a pair (1,2)(1,2), there will be no pair (2,1)(2,1) within the same set), and no pair contains the same number twice.It is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.",
      "output_spec": "OutputIf you can deduce the shared number with certainty, print that number.If you can with certainty deduce that both participants know the shared number, but you do not know it, print 00.Otherwise print −1−1.",
      "sample_tests": "ExamplesInputCopy2 21 2 3 41 5 3 4OutputCopy1InputCopy2 21 2 3 41 5 6 4OutputCopy0InputCopy2 31 2 4 51 2 1 3 2 3OutputCopy-1",
      "description": "D. Open Communication\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (1≤n,m≤121≤n,m≤12) — the number of pairs the first participant communicated to the second and vice versa.The second line contains nn pairs of integers, each between 11 and 99, — pairs of numbers communicated from first participant to the second.The third line contains mm pairs of integers, each between 11 and 99, — pairs of numbers communicated from the second participant to the first.All pairs within each set are distinct (in particular, if there is a pair (1,2)(1,2), there will be no pair (2,1)(2,1) within the same set), and no pair contains the same number twice.It is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.\n\nOutputIf you can deduce the shared number with certainty, print that number.If you can with certainty deduce that both participants know the shared number, but you do not know it, print 00.Otherwise print −1−1.\n\nInputCopy2 21 2 3 41 5 3 4OutputCopy1InputCopy2 21 2 3 41 5 6 4OutputCopy0InputCopy2 31 2 4 51 2 1 3 2 3OutputCopy-1\n\nInputCopy2 21 2 3 41 5 3 4\n\nOutputCopy1\n\nInputCopy2 21 2 3 41 5 6 4\n\nOutputCopy0\n\nInputCopy2 31 2 4 51 2 1 3 2 3\n\nOutputCopy-1\n\nNoteIn the first example the first participant communicated pairs (1,2)(1,2) and (3,4)(3,4), and the second communicated (1,5)(1,5), (3,4)(3,4). Since we know that the actual pairs they received share exactly one number, it can't be that they both have (3,4)(3,4). Thus, the first participant has (1,2)(1,2) and the second has (1,5)(1,5), and at this point you already know the shared number is 11.In the second example either the first participant has (1,2)(1,2) and the second has (1,5)(1,5), or the first has (3,4)(3,4) and the second has (6,4)(6,4). In the first case both of them know the shared number is 11, in the second case both of them know the shared number is 44. You don't have enough information to tell 11 and 44 apart.In the third case if the first participant was given (1,2)(1,2), they don't know what the shared number is, since from their perspective the second participant might have been given either (1,3)(1,3), in which case the shared number is 11, or (2,3)(2,3), in which case the shared number is 22. While the second participant does know the number with certainty, neither you nor the first participant do, so the output is −1−1.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 994\\s*D"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,12,\"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,12,\"m\");\n    inf.readEoln();\n\n    vector<int> nums1 = inf.readInts(2*n,1,9,\"nums1\");\n    inf.readEoln();\n    vector<int> nums2 = inf.readInts(2*m,1,9,\"nums2\");\n    inf.readEoln();\n\n    set<pair<int,int>> pairs1;\n    for(int i=0;i<n;i++) {\n        int a = nums1[2*i];\n        int b = nums1[2*i+1];\n        ensuref(a != b, \"the two numbers in a pair must be different in set1 at position %d\", i+1);\n        pair<int,int> p = make_pair(a,b);\n        pair<int,int> rp = make_pair(b,a);\n        ensuref(pairs1.count(p) == 0, \"Duplicate pair (%d,%d) in set1 at position %d\", a,b,i+1);\n        ensuref(pairs1.count(rp) == 0, \"Reverse pair (%d,%d) already exists in set1 at position %d\", b,a,i+1);\n        pairs1.insert(p);\n    }\n\n    set<pair<int,int>> pairs2;\n    for(int i=0;i<m;i++) {\n        int a = nums2[2*i];\n        int b = nums2[2*i+1];\n        ensuref(a != b, \"the two numbers in a pair must be different in set2 at position %d\", i+1);\n        pair<int,int> p = make_pair(a,b);\n        pair<int,int> rp = make_pair(b,a);\n        ensuref(pairs2.count(p) == 0, \"Duplicate pair (%d,%d) in set2 at position %d\", a,b,i+1);\n        ensuref(pairs2.count(rp) == 0, \"Reverse pair (%d,%d) already exists in set2 at position %d\", b,a,i+1);\n        pairs2.insert(p);\n    }\n\n    bool success = false;\n    for(auto &p1 : pairs1) {\n        for(auto &p2 : pairs2) {\n            int nums_in_common = 0;\n            if(p1.first == p2.first || p1.first == p2.second) nums_in_common++;\n            if(p1.second == p2.first || p1.second == p2.second) nums_in_common++;\n            if(nums_in_common ==1) {\n                success = true;\n                break;\n            }\n        }\n        if(success) break;\n    }\n    ensuref(success, \"No pair from first set and pair from second set share exactly one number\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,12,\"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,12,\"m\");\n    inf.readEoln();\n\n    vector<int> nums1 = inf.readInts(2*n,1,9,\"nums1\");\n    inf.readEoln();\n    vector<int> nums2 = inf.readInts(2*m,1,9,\"nums2\");\n    inf.readEoln();\n\n    set<pair<int,int>> pairs1;\n    for(int i=0;i<n;i++) {\n        int a = nums1[2*i];\n        int b = nums1[2*i+1];\n        ensuref(a != b, \"the two numbers in a pair must be different in set1 at position %d\", i+1);\n        pair<int,int> p = make_pair(a,b);\n        pair<int,int> rp = make_pair(b,a);\n        ensuref(pairs1.count(p) == 0, \"Duplicate pair (%d,%d) in set1 at position %d\", a,b,i+1);\n        ensuref(pairs1.count(rp) == 0, \"Reverse pair (%d,%d) already exists in set1 at position %d\", b,a,i+1);\n        pairs1.insert(p);\n    }\n\n    set<pair<int,int>> pairs2;\n    for(int i=0;i<m;i++) {\n        int a = nums2[2*i];\n        int b = nums2[2*i+1];\n        ensuref(a != b, \"the two numbers in a pair must be different in set2 at position %d\", i+1);\n        pair<int,int> p = make_pair(a,b);\n        pair<int,int> rp = make_pair(b,a);\n        ensuref(pairs2.count(p) == 0, \"Duplicate pair (%d,%d) in set2 at position %d\", a,b,i+1);\n        ensuref(pairs2.count(rp) == 0, \"Reverse pair (%d,%d) already exists in set2 at position %d\", b,a,i+1);\n        pairs2.insert(p);\n    }\n\n    bool success = false;\n    for(auto &p1 : pairs1) {\n        for(auto &p2 : pairs2) {\n            int nums_in_common = 0;\n            if(p1.first == p2.first || p1.first == p2.second) nums_in_common++;\n            if(p1.second == p2.first || p1.second == p2.second) nums_in_common++;\n            if(nums_in_common ==1) {\n                success = true;\n                break;\n            }\n        }\n        if(success) break;\n    }\n    ensuref(success, \"No pair from first set and pair from second set share exactly one number\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,12,\"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,12,\"m\");\n    inf.readEoln();\n\n    vector<int> nums1 = inf.readInts(2*n,1,9,\"nums1\");\n    inf.readEoln();\n    vector<int> nums2 = inf.readInts(2*m,1,9,\"nums2\");\n    inf.readEoln();\n\n    set<pair<int,int>> pairs1;\n    for(int i=0;i<n;i++) {\n        int a = nums1[2*i];\n        int b = nums1[2*i+1];\n        ensuref(a != b, \"the two numbers in a pair must be different in set1 at position %d\", i+1);\n        pair<int,int> p = make_pair(a,b);\n        pair<int,int> rp = make_pair(b,a);\n        ensuref(pairs1.count(p) == 0, \"Duplicate pair (%d,%d) in set1 at position %d\", a,b,i+1);\n        ensuref(pairs1.count(rp) == 0, \"Reverse pair (%d,%d) already exists in set1 at position %d\", b,a,i+1);\n        pairs1.insert(p);\n    }\n\n    set<pair<int,int>> pairs2;\n    for(int i=0;i<m;i++) {\n        int a = nums2[2*i];\n        int b = nums2[2*i+1];\n        ensuref(a != b, \"the two numbers in a pair must be different in set2 at position %d\", i+1);\n        pair<int,int> p = make_pair(a,b);\n        pair<int,int> rp = make_pair(b,a);\n        ensuref(pairs2.count(p) == 0, \"Duplicate pair (%d,%d) in set2 at position %d\", a,b,i+1);\n        ensuref(pairs2.count(rp) == 0, \"Reverse pair (%d,%d) already exists in set2 at position %d\", b,a,i+1);\n        pairs2.insert(p);\n    }\n\n    bool success = false;\n    for(auto &p1 : pairs1) {\n        for(auto &p2 : pairs2) {\n            int nums_in_common = 0;\n            if(p1.first == p2.first || p1.first == p2.second) nums_in_common++;\n            if(p1.second == p2.first || p1.second == p2.second) nums_in_common++;\n            if(nums_in_common ==1) {\n                success = true;\n                break;\n            }\n        }\n        if(success) break;\n    }\n    ensuref(success, \"No pair from first set and pair from second set share exactly one number\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"unique\") {\n        // Generate test case where shared number can be uniquely determined.\n\n        // First, pick x, y1, y2, numbers from 1 to 9\n        int x = rnd.next(1, 9);\n\n        int y1, y2;\n        do {\n            y1 = rnd.next(1, 9);\n        } while(y1 == x);\n        do {\n            y2 = rnd.next(1, 9);\n        } while(y2 == x || y2 == y1);\n\n        // Now get numbers from 1 to 9 excluding x, y1, y2\n        vector<int> nums;\n        for(int i =1; i<=9; ++i) {\n            if(i != x && i != y1 && i != y2) nums.push_back(i);\n        }\n\n        // Shuffle nums\n        shuffle(nums.begin(), nums.end());\n\n        // Divide nums into two sets S1 and S2\n        int half = nums.size() / 2;\n        vector<int> S1(nums.begin(), nums.begin()+half);\n        vector<int> S2(nums.begin()+half, nums.end());\n\n        // Participant A's pairs:\n        vector<pair<int,int>> pairsA;\n        pairsA.push_back({x, y1}); // participant A's actual pair\n\n        // Add pairs (x, ai) for ai in S1\n        for(int ai : S1) {\n            pairsA.push_back({x, ai});\n        }\n\n        // Participant B's pairs:\n        vector<pair<int,int>> pairsB;\n        pairsB.push_back({x, y2}); // participant B's actual pair\n\n        // Add pairs (x, bi) for bi in S2\n        for(int bi : S2) {\n            pairsB.push_back({x, bi});\n        }\n\n        // Add extra pairs if needed\n        int requiredA = n - pairsA.size();\n        if(requiredA > 0) {\n            vector<pair<int,int>> extraA;\n            for(int i =0; i<S1.size(); ++i) {\n                for(int j=i+1; j<S1.size(); ++j) {\n                    extraA.push_back({S1[i], S1[j]});\n                }\n            }\n            shuffle(extraA.begin(), extraA.end());\n            for(auto p : extraA) {\n                if(pairsA.size() >= n) break;\n                pairsA.push_back(p);\n            }\n        }\n\n        int requiredB = m - pairsB.size();\n        if(requiredB > 0) {\n            vector<pair<int,int>> extraB;\n            for(int i =0;i<S2.size(); ++i) {\n                for(int j=i+1; j<S2.size(); ++j) {\n                    extraB.push_back({S2[i], S2[j]});\n                }\n            }\n            shuffle(extraB.begin(), extraB.end());\n            for(auto p : extraB) {\n                if(pairsB.size() >= m) break;\n                pairsB.push_back(p);\n            }\n        }\n\n        shuffle(pairsA.begin(), pairsA.end());\n        shuffle(pairsB.begin(), pairsB.end());\n\n        printf(\"%d %d\\n\", n, m);\n        // Output participant A's pairs\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", pairsA[i].first, pairsA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        // Output participant B's pairs\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", pairsB[i].first, pairsB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n    } else if(type == \"ambiguous\") {\n        // Generate test case where shared number cannot be determined (output -1)\n\n        int x1 = rnd.next(1, 9);\n        int x2;\n        do {\n            x2 = rnd.next(1, 9);\n        } while(x2 == x1);\n\n        int y1;\n        do {\n            y1 = rnd.next(1, 9);\n        } while(y1 == x1 || y1 == x2);\n\n        vector<int> nums;\n        for(int i=1; i<=9; ++i) {\n            if(i != x1 && i != x2 && i != y1)\n                nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n\n        vector<pair<int,int>> pairsA;\n        pairsA.push_back({x1, y1});\n        pairsA.push_back({x2, nums[0]});\n\n        for(int i =1; i<nums.size(); ++i) {\n            if(pairsA.size() >= n) break;\n            pairsA.push_back({nums[i-1], nums[i]});\n        }\n\n        int z1, z2;\n        do {\n            z1 = rnd.next(1, 9);\n        } while(z1 == x1 || z1 == y1 || z1 == x2);\n        do {\n            z2 = rnd.next(1, 9);\n        } while(z2 == x1 || z2 == y1 || z2 == x2 || z2 == z1);\n\n        vector<pair<int,int>> pairsB;\n        pairsB.push_back({x1, z1});\n        pairsB.push_back({x2, z2});\n\n        nums.clear();\n        for(int i=1; i<=9; ++i) {\n            if(i != x1 && i != x2 && i != y1 && i != z1 && i != z2)\n                nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n        for(int i=1; i<nums.size(); ++i) {\n            if(pairsB.size() >= m) break;\n            pairsB.push_back({nums[i-1], nums[i]});\n        }\n\n        shuffle(pairsA.begin(), pairsA.end());\n        shuffle(pairsB.begin(), pairsB.end());\n\n        printf(\"%d %d\\n\", n, m);\n        // Output participant A's pairs\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", pairsA[i].first, pairsA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        // Output participant B's pairs\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", pairsB[i].first, pairsB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    } else if(type == \"unknown\") {\n        // Generate test case where we can deduce that participants know the shared number, but we cannot determine it\n\n        int x1 = rnd.next(1, 9);\n        int x2;\n        do {\n            x2 = rnd.next(1, 9);\n        } while(x2 == x1);\n\n        int y1, y2;\n        do {\n            y1 = rnd.next(1, 9);\n        } while(y1 == x1 || y1 == x2);\n        do {\n            y2 = rnd.next(1,9);\n        } while(y2 == x1 || y2 == x2 || y2 == y1);\n\n        vector<pair<int,int>> pairsA;\n        pairsA.push_back({x1, y1});\n        pairsA.push_back({x2, y2});\n\n        int z1, z2;\n        do {\n            z1 = rnd.next(1, 9);\n        } while(z1 == x1 || z1 == x2 || z1 == y1 || z1 == y2);\n        do {\n            z2 = rnd.next(1,9);\n        } while(z2 == x1 || z2 == x2 || z2 == y1 || z2 == y2 || z2 == z1);\n\n        vector<pair<int,int>> pairsB;\n        pairsB.push_back({x1, z1});\n        pairsB.push_back({x2, z2});\n\n        vector<int> nums;\n        for(int i=1; i<=9; ++i) {\n            if(i != x1 && i != x2 && i != y1 && i != y2 && i != z1 && i != z2)\n                nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n\n        for(int i=1; i<nums.size(); ++i) {\n            if(pairsA.size() >= n) break;\n            pairsA.push_back({nums[i-1], nums[i]});\n        }\n\n        shuffle(nums.begin(), nums.end());\n        for(int i=1; i<nums.size(); ++i) {\n            if(pairsB.size() >= m) break;\n            pairsB.push_back({nums[i-1], nums[i]});\n        }\n\n        shuffle(pairsA.begin(), pairsA.end());\n        shuffle(pairsB.begin(), pairsB.end());\n\n        printf(\"%d %d\\n\", n, m);\n        // Output participant A's pairs\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", pairsA[i].first, pairsA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        // Output participant B's pairs\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", pairsB[i].first, pairsB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n    } else { // type == \"random\" or any other, generate random valid test case\n\n        int x = rnd.next(1, 9);\n\n        int y1, y2;\n        do {\n            y1 = rnd.next(1,9);\n        } while(y1 == x);\n        do {\n            y2 = rnd.next(1,9);\n        } while(y2 == x || y2 == y1);\n\n        pair<int,int> actualPairA = {x, y1};\n        pair<int,int> actualPairB = {x, y2};\n\n        set<pair<int,int>> pairsA, pairsB;\n        pairsA.insert(actualPairA);\n        pairsB.insert(actualPairB);\n\n        while(pairsA.size() < n) {\n            int a = rnd.next(1,9);\n            int b = rnd.next(1,9);\n            if(a == b) continue;\n            pair<int,int> p = {a,b};\n            if(pairsA.count(p) || pairsA.count({b,a})) continue;\n            pairsA.insert(p);\n        }\n\n        while(pairsB.size() < m) {\n            int a = rnd.next(1,9);\n            int b = rnd.next(1,9);\n            if(a == b) continue;\n            pair<int,int> p = {a,b};\n            if(pairsB.count(p) || pairsB.count({b,a})) continue;\n            pairsB.insert(p);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        vector<pair<int,int>> vecA(pairsA.begin(), pairsA.end());\n        shuffle(vecA.begin(), vecA.end());\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", vecA[i].first, vecA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        vector<pair<int,int>> vecB(pairsB.begin(), pairsB.end());\n        shuffle(vecB.begin(), vecB.end());\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", vecB[i].first, vecB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"unique\") {\n        // Generate test case where shared number can be uniquely determined.\n\n        // First, pick x, y1, y2, numbers from 1 to 9\n        int x = rnd.next(1, 9);\n\n        int y1, y2;\n        do {\n            y1 = rnd.next(1, 9);\n        } while(y1 == x);\n        do {\n            y2 = rnd.next(1, 9);\n        } while(y2 == x || y2 == y1);\n\n        // Now get numbers from 1 to 9 excluding x, y1, y2\n        vector<int> nums;\n        for(int i =1; i<=9; ++i) {\n            if(i != x && i != y1 && i != y2) nums.push_back(i);\n        }\n\n        // Shuffle nums\n        shuffle(nums.begin(), nums.end());\n\n        // Divide nums into two sets S1 and S2\n        int half = nums.size() / 2;\n        vector<int> S1(nums.begin(), nums.begin()+half);\n        vector<int> S2(nums.begin()+half, nums.end());\n\n        // Participant A's pairs:\n        vector<pair<int,int>> pairsA;\n        pairsA.push_back({x, y1}); // participant A's actual pair\n\n        // Add pairs (x, ai) for ai in S1\n        for(int ai : S1) {\n            pairsA.push_back({x, ai});\n        }\n\n        // Participant B's pairs:\n        vector<pair<int,int>> pairsB;\n        pairsB.push_back({x, y2}); // participant B's actual pair\n\n        // Add pairs (x, bi) for bi in S2\n        for(int bi : S2) {\n            pairsB.push_back({x, bi});\n        }\n\n        // Add extra pairs if needed\n        int requiredA = n - pairsA.size();\n        if(requiredA > 0) {\n            vector<pair<int,int>> extraA;\n            for(int i =0; i<S1.size(); ++i) {\n                for(int j=i+1; j<S1.size(); ++j) {\n                    extraA.push_back({S1[i], S1[j]});\n                }\n            }\n            shuffle(extraA.begin(), extraA.end());\n            for(auto p : extraA) {\n                if(pairsA.size() >= n) break;\n                pairsA.push_back(p);\n            }\n        }\n\n        int requiredB = m - pairsB.size();\n        if(requiredB > 0) {\n            vector<pair<int,int>> extraB;\n            for(int i =0;i<S2.size(); ++i) {\n                for(int j=i+1; j<S2.size(); ++j) {\n                    extraB.push_back({S2[i], S2[j]});\n                }\n            }\n            shuffle(extraB.begin(), extraB.end());\n            for(auto p : extraB) {\n                if(pairsB.size() >= m) break;\n                pairsB.push_back(p);\n            }\n        }\n\n        shuffle(pairsA.begin(), pairsA.end());\n        shuffle(pairsB.begin(), pairsB.end());\n\n        printf(\"%d %d\\n\", n, m);\n        // Output participant A's pairs\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", pairsA[i].first, pairsA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        // Output participant B's pairs\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", pairsB[i].first, pairsB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n    } else if(type == \"ambiguous\") {\n        // Generate test case where shared number cannot be determined (output -1)\n\n        int x1 = rnd.next(1, 9);\n        int x2;\n        do {\n            x2 = rnd.next(1, 9);\n        } while(x2 == x1);\n\n        int y1;\n        do {\n            y1 = rnd.next(1, 9);\n        } while(y1 == x1 || y1 == x2);\n\n        vector<int> nums;\n        for(int i=1; i<=9; ++i) {\n            if(i != x1 && i != x2 && i != y1)\n                nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n\n        vector<pair<int,int>> pairsA;\n        pairsA.push_back({x1, y1});\n        pairsA.push_back({x2, nums[0]});\n\n        for(int i =1; i<nums.size(); ++i) {\n            if(pairsA.size() >= n) break;\n            pairsA.push_back({nums[i-1], nums[i]});\n        }\n\n        int z1, z2;\n        do {\n            z1 = rnd.next(1, 9);\n        } while(z1 == x1 || z1 == y1 || z1 == x2);\n        do {\n            z2 = rnd.next(1, 9);\n        } while(z2 == x1 || z2 == y1 || z2 == x2 || z2 == z1);\n\n        vector<pair<int,int>> pairsB;\n        pairsB.push_back({x1, z1});\n        pairsB.push_back({x2, z2});\n\n        nums.clear();\n        for(int i=1; i<=9; ++i) {\n            if(i != x1 && i != x2 && i != y1 && i != z1 && i != z2)\n                nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n        for(int i=1; i<nums.size(); ++i) {\n            if(pairsB.size() >= m) break;\n            pairsB.push_back({nums[i-1], nums[i]});\n        }\n\n        shuffle(pairsA.begin(), pairsA.end());\n        shuffle(pairsB.begin(), pairsB.end());\n\n        printf(\"%d %d\\n\", n, m);\n        // Output participant A's pairs\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", pairsA[i].first, pairsA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        // Output participant B's pairs\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", pairsB[i].first, pairsB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    } else if(type == \"unknown\") {\n        // Generate test case where we can deduce that participants know the shared number, but we cannot determine it\n\n        int x1 = rnd.next(1, 9);\n        int x2;\n        do {\n            x2 = rnd.next(1, 9);\n        } while(x2 == x1);\n\n        int y1, y2;\n        do {\n            y1 = rnd.next(1, 9);\n        } while(y1 == x1 || y1 == x2);\n        do {\n            y2 = rnd.next(1,9);\n        } while(y2 == x1 || y2 == x2 || y2 == y1);\n\n        vector<pair<int,int>> pairsA;\n        pairsA.push_back({x1, y1});\n        pairsA.push_back({x2, y2});\n\n        int z1, z2;\n        do {\n            z1 = rnd.next(1, 9);\n        } while(z1 == x1 || z1 == x2 || z1 == y1 || z1 == y2);\n        do {\n            z2 = rnd.next(1,9);\n        } while(z2 == x1 || z2 == x2 || z2 == y1 || z2 == y2 || z2 == z1);\n\n        vector<pair<int,int>> pairsB;\n        pairsB.push_back({x1, z1});\n        pairsB.push_back({x2, z2});\n\n        vector<int> nums;\n        for(int i=1; i<=9; ++i) {\n            if(i != x1 && i != x2 && i != y1 && i != y2 && i != z1 && i != z2)\n                nums.push_back(i);\n        }\n        shuffle(nums.begin(), nums.end());\n\n        for(int i=1; i<nums.size(); ++i) {\n            if(pairsA.size() >= n) break;\n            pairsA.push_back({nums[i-1], nums[i]});\n        }\n\n        shuffle(nums.begin(), nums.end());\n        for(int i=1; i<nums.size(); ++i) {\n            if(pairsB.size() >= m) break;\n            pairsB.push_back({nums[i-1], nums[i]});\n        }\n\n        shuffle(pairsA.begin(), pairsA.end());\n        shuffle(pairsB.begin(), pairsB.end());\n\n        printf(\"%d %d\\n\", n, m);\n        // Output participant A's pairs\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", pairsA[i].first, pairsA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        // Output participant B's pairs\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", pairsB[i].first, pairsB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n    } else { // type == \"random\" or any other, generate random valid test case\n\n        int x = rnd.next(1, 9);\n\n        int y1, y2;\n        do {\n            y1 = rnd.next(1,9);\n        } while(y1 == x);\n        do {\n            y2 = rnd.next(1,9);\n        } while(y2 == x || y2 == y1);\n\n        pair<int,int> actualPairA = {x, y1};\n        pair<int,int> actualPairB = {x, y2};\n\n        set<pair<int,int>> pairsA, pairsB;\n        pairsA.insert(actualPairA);\n        pairsB.insert(actualPairB);\n\n        while(pairsA.size() < n) {\n            int a = rnd.next(1,9);\n            int b = rnd.next(1,9);\n            if(a == b) continue;\n            pair<int,int> p = {a,b};\n            if(pairsA.count(p) || pairsA.count({b,a})) continue;\n            pairsA.insert(p);\n        }\n\n        while(pairsB.size() < m) {\n            int a = rnd.next(1,9);\n            int b = rnd.next(1,9);\n            if(a == b) continue;\n            pair<int,int> p = {a,b};\n            if(pairsB.count(p) || pairsB.count({b,a})) continue;\n            pairsB.insert(p);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n\n        vector<pair<int,int>> vecA(pairsA.begin(), pairsA.end());\n        shuffle(vecA.begin(), vecA.end());\n        for(int i=0; i<n; ++i) {\n            printf(\"%d %d\", vecA[i].first, vecA[i].second);\n            if(i != n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n\n        vector<pair<int,int>> vecB(pairsB.begin(), pairsB.end());\n        shuffle(vecB.begin(), vecB.end());\n        for(int i=0; i<m; ++i) {\n            printf(\"%d %d\", vecB[i].first, vecB[i].second);\n            if(i != m-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type unique\n./gen -n 2 -m 2 -type ambiguous\n./gen -n 2 -m 3 -type unknown\n./gen -n 3 -m 3 -type unique\n./gen -n 4 -m 4 -type ambiguous\n./gen -n 5 -m 5 -type unknown\n./gen -n 12 -m 12 -type unique\n./gen -n 1 -m 1 -type unique\n./gen -n 12 -m 12 -type ambiguous\n./gen -n 12 -m 12 -type unknown\n./gen -n 5 -m 7 -type unique\n./gen -n 7 -m 5 -type ambiguous\n./gen -n 6 -m 6 -type random\n./gen -n 9 -m 8 -type random\n./gen -n 1 -m 2 -type unique\n./gen -n 2 -m 1 -type unique\n./gen -n 1 -m 12 -type ambiguous\n./gen -n 12 -m 1 -type ambiguous\n./gen -n 4 -m 5 -type unknown\n./gen -n 5 -m 4 -type unknown\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 3 -type random\n./gen -n 8 -m 7 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 12 -m 12 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:34.434248",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "994/E",
      "title": "E. Аккуратное маневрирование",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа nn и mm (1≤n,m≤601≤n,m≤60) — количество вражеских кораблей группе с x=−100x=−100 и количество вражеских кораблей в группе c x=100x=100, соответственно.Вторая строка содержит nn целых чисел y1,1,y1,2,…,y1,ny1,1,y1,2,…,y1,n (|y1,i|≤10000|y1,i|≤10000) — yy-координаты кораблей в первой группе.Третья строка содержит mm целых чисел y2,1,y2,2,…,y2,my2,1,y2,2,…,y2,m (|y2,i|≤10000|y2,i|≤10000) — yy-координаты кораблей во второй группе.yy-координаты не обязательно уникальны, даже в пределах одной группы.",
      "output_spec": "Выходные данныеВыведите одно число — максимальное количество вражеских кораблей, которое можно уничтожить.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 91 2 31 2 3 7 8 9 11 12 13Выходные данныеСкопировать9Входные данныеСкопировать5 51 2 3 4 51 2 3 4 5Выходные данныеСкопировать10",
      "description": "E. Аккуратное маневрирование\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся два целых числа nn и mm (1≤n,m≤601≤n,m≤60) — количество вражеских кораблей группе с x=−100x=−100 и количество вражеских кораблей в группе c x=100x=100, соответственно.Вторая строка содержит nn целых чисел y1,1,y1,2,…,y1,ny1,1,y1,2,…,y1,n (|y1,i|≤10000|y1,i|≤10000) — yy-координаты кораблей в первой группе.Третья строка содержит mm целых чисел y2,1,y2,2,…,y2,my2,1,y2,2,…,y2,m (|y2,i|≤10000|y2,i|≤10000) — yy-координаты кораблей во второй группе.yy-координаты не обязательно уникальны, даже в пределах одной группы.\n\nВходные данные\n\nВыходные данныеВыведите одно число — максимальное количество вражеских кораблей, которое можно уничтожить.\n\nВыходные данные\n\nВходные данныеСкопировать3 91 2 31 2 3 7 8 9 11 12 13Выходные данныеСкопировать9Входные данныеСкопировать5 51 2 3 4 51 2 3 4 5Выходные данныеСкопировать10\n\nВходные данныеСкопировать3 91 2 31 2 3 7 8 9 11 12 13\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 51 2 3 4 51 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере один корабль может расположиться в (0,2)(0,2), а второй – в (0,7)(0,7). Так все корабли в первой группе и 66 из 99 кораблей во второй группе будут уничтожены.Во втором примере один корабль может расположиться в (0,3)(0,3), а второй – в любом месте, этого будет достаточно, чтобы уничтожить все вражеские корабли.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD: обратите внимание, распределение баллов изменилосьUPD2: LHiC нашел ошибку в авторском решении на div1-F. Мы исследуем вопрос.UPD3: мы нашли правильное решение для div1-F и оба решения отправленных на контесте проходят все тесты против правильного решения => раунд по прежнему рейтинговый.Всем привет,Время старта Codeforces Round 488: воскресенье, 17 июня 2018 г. в 00:35UTC+8. Это будет раунд для обоих дивизионов. Раунд будет длиться 2.5 часа (это на пол часа больше чем обычно).Контест подготовлен компанией NEAR и ее друзьями. В NEAR мы учим машины участвовать в соревнованиях по программированию. В этом блог-посте можно прочитать (на английском) о том, где сегодня находятся исследования в этой области, чем занимается непосредственно NEAR, и как вы можете помочь нам в этом нелегком деле.На контесте будет предложено по шесть задач в каждом дивизионе, 4 задачи из которых общие.Почти все задачи взяты с тестовых раундов, которые проводились на JavaBlitz в прошлом году. Если вы участвовали в одном из JavaBlitz раундов, то этот CBR, к сожалению, придется пропустить.Распределение баллов в первом дивизионе -- 500-1000-1000-1500-2250-3000Во втором -- 500-1000-1500-2000-2000-2500Раунд в обоих дивизионах рейтинговый.Все задачи написаны мной, Александром \"AlexSkidanov\" Скидановым, и Никитой \"FalseMirror\" Босовым. David \"pieguy\" Stolp, Александр \"AlexFetisov\" Фетиско, Marcelo \"mnaeraxr\" Fornet, Николай \"KAN\" Калинин и Михаил \"cerealguy\" Кевер оказали неоценимую помощь в подгтовке раунда и тестировании задач.В завершении хочется в очередной раз напомнить, что мы постоянно ищем людей, которые помогут нам с разметкой данных с архивов по спортивному программированию. Больше информации здесь.Поздравляем победителей!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge Разбор опубликован тут. Спасибо за участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1888
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - Отпечатки пальцевДля решения задачи достаточно пройти по всем элементам данной последовательности, и для каждого в цикле пройти по кнопкам с отпечатками и проверить есть ли кнопка с отпечатком, соответствующая текущему числу в последовательности. Такое решение работает за O(n×m)O(n×m) 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Два квадратаЕсли два квадрата пересекаются, то хотя бы для одного из них верно что либо один из его углов лежит в другом квадрате, либо его центр лежит в другом квадрате.Для квадрата, который повернут на 45 градусов, проверить лежат ли его углы или центр в квадрате со сторонами, параллельными осям координат, очень просто.Чтобы проверить в обратную сторону, достаточно повернуть оба квадрата на 45 градусов. Чтобы это сделать, достаточно заменить все xx координаты на x+yx+y, а все yy координаты на x−yx−y (это также изменит масштаб, но это не влияет на пересечение) 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 994\\s*E"
          },
          "content_length": 10584
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readEoln();\n\n    vector<int> y1 = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n\n    vector<int> y2 = inf.readInts(m, -10000, 10000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readEoln();\n\n    vector<int> y1 = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n\n    vector<int> y2 = inf.readInts(m, -10000, 10000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readEoln();\n\n    vector<int> y1 = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n\n    vector<int> y2 = inf.readInts(m, -10000, 10000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 60));\n    int m = opt<int>(\"m\", rnd.next(1, 60));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> y1, y2;\n\n    if (type == \"random\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"maxn\") {\n        n = 60;\n        m = 60;\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"duplicateY\") {\n        y1.resize(n);\n        y2.resize(m);\n        int dupNum1 = rnd.next(1, min(10, n / 2));\n        int dupY1 = rnd.next(-10000, 10000);\n        for (int i = 0; i < dupNum1; ++i)\n            y1[i] = dupY1;\n        for (int i = dupNum1; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n\n        int dupNum2 = rnd.next(1, min(10, m / 2));\n        int dupY2 = rnd.next(-10000, 10000);\n        for (int i = 0; i < dupNum2; ++i)\n            y2[i] = dupY2;\n        for (int i = dupNum2; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"sameY\") {\n        y1.resize(n);\n        y2.resize(m);\n        int yValue = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i)\n            y1[i] = yValue;\n        for (int i = 0; i < m; ++i)\n            y2[i] = yValue;\n    } else if (type == \"negativeY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, -1);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, -1);\n    } else if (type == \"positiveY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(1, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(1, 10000);\n    } else if (type == \"allZeroY\") {\n        y1.assign(n, 0);\n        y2.assign(m, 0);\n    } else if (type == \"maxY\") {\n        y1.assign(n, 10000);\n        y2.assign(m, 10000);\n    } else if (type == \"minY\") {\n        y1.assign(n, -10000);\n        y2.assign(m, -10000);\n    } else if (type == \"sortedY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        sort(y1.begin(), y1.end());\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n        sort(y2.begin(), y2.end());\n    } else if (type == \"reverseSortedY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        sort(y1.rbegin(), y1.rend());\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n        sort(y2.rbegin(), y2.rend());\n    } else if (type == \"smalln\") {\n        n = 1;\n        m = 1;\n        y1.resize(n);\n        y2.resize(m);\n        y1[0] = rnd.next(-10000, 10000);\n        y2[0] = rnd.next(-10000, 10000);\n    } else if (type == \"maxYdiff\") {\n        n = m = 60;\n        y1.resize(n);\n        y2.resize(m);\n        y1[0] = -10000;\n        for (int i = 1; i < n; ++i)\n            y1[i] = -10000 + rnd.next(0, 20000);\n        y2[0] = 10000;\n        for (int i = 1; i < m; ++i)\n            y2[i] = -10000 + rnd.next(0, 20000);\n    } else {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", y1[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", y2[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 60));\n    int m = opt<int>(\"m\", rnd.next(1, 60));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> y1, y2;\n\n    if (type == \"random\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"maxn\") {\n        n = 60;\n        m = 60;\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"duplicateY\") {\n        y1.resize(n);\n        y2.resize(m);\n        int dupNum1 = rnd.next(1, min(10, n / 2));\n        int dupY1 = rnd.next(-10000, 10000);\n        for (int i = 0; i < dupNum1; ++i)\n            y1[i] = dupY1;\n        for (int i = dupNum1; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n\n        int dupNum2 = rnd.next(1, min(10, m / 2));\n        int dupY2 = rnd.next(-10000, 10000);\n        for (int i = 0; i < dupNum2; ++i)\n            y2[i] = dupY2;\n        for (int i = dupNum2; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    } else if (type == \"sameY\") {\n        y1.resize(n);\n        y2.resize(m);\n        int yValue = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i)\n            y1[i] = yValue;\n        for (int i = 0; i < m; ++i)\n            y2[i] = yValue;\n    } else if (type == \"negativeY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, -1);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, -1);\n    } else if (type == \"positiveY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(1, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(1, 10000);\n    } else if (type == \"allZeroY\") {\n        y1.assign(n, 0);\n        y2.assign(m, 0);\n    } else if (type == \"maxY\") {\n        y1.assign(n, 10000);\n        y2.assign(m, 10000);\n    } else if (type == \"minY\") {\n        y1.assign(n, -10000);\n        y2.assign(m, -10000);\n    } else if (type == \"sortedY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        sort(y1.begin(), y1.end());\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n        sort(y2.begin(), y2.end());\n    } else if (type == \"reverseSortedY\") {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        sort(y1.rbegin(), y1.rend());\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n        sort(y2.rbegin(), y2.rend());\n    } else if (type == \"smalln\") {\n        n = 1;\n        m = 1;\n        y1.resize(n);\n        y2.resize(m);\n        y1[0] = rnd.next(-10000, 10000);\n        y2[0] = rnd.next(-10000, 10000);\n    } else if (type == \"maxYdiff\") {\n        n = m = 60;\n        y1.resize(n);\n        y2.resize(m);\n        y1[0] = -10000;\n        for (int i = 1; i < n; ++i)\n            y1[i] = -10000 + rnd.next(0, 20000);\n        y2[0] = 10000;\n        for (int i = 1; i < m; ++i)\n            y2[i] = -10000 + rnd.next(0, 20000);\n    } else {\n        y1.resize(n);\n        y2.resize(m);\n        for (int i = 0; i < n; ++i)\n            y1[i] = rnd.next(-10000, 10000);\n        for (int i = 0; i < m; ++i)\n            y2[i] = rnd.next(-10000, 10000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", y1[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", y2[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type smalln\n./gen -n 1 -m 60 -type random\n./gen -n 60 -m 1 -type random\n./gen -n 60 -m 60 -type maxn\n./gen -n 5 -m 5 -type smalln\n./gen -n 30 -m 30 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 60 -m 60 -type random\n./gen -n 60 -m 60 -type duplicateY\n./gen -n 30 -m 30 -type duplicateY\n./gen -n 60 -m 60 -type sameY\n./gen -n 30 -m 30 -type sameY\n./gen -n 60 -m 60 -type negativeY\n./gen -n 30 -m 30 -type negativeY\n./gen -n 60 -m 60 -type positiveY\n./gen -n 30 -m 30 -type positiveY\n./gen -n 60 -m 60 -type allZeroY\n./gen -n 60 -m 60 -type maxY\n./gen -n 60 -m 60 -type minY\n./gen -n 30 -m 30 -type maxY\n./gen -n 30 -m 30 -type minY\n./gen -n 60 -m 60 -type sortedY\n./gen -n 60 -m 60 -type reverseSortedY\n./gen -n 30 -m 30 -type sortedY\n./gen -n 30 -m 30 -type reverseSortedY\n./gen -n 60 -m 60 -type maxYdiff\n./gen -n 60 -m 60 -type random\n./gen -n 60 -m 1 -type random\n./gen -n 1 -m 60 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:36.090198",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "994/F",
      "title": "F. Compute Power",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of tasks.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 108), where ai represents the amount of power required for the i-th task.The third line contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100), where bi is the number of processors that i-th task will utilize.",
      "output_spec": "OutputPrint a single integer value — the lowest threshold for which it is possible to assign all tasks in such a way that the system will not blow up after the first round of computation, multiplied by 1000 and rounded up.",
      "sample_tests": "ExamplesInputCopy68 10 9 9 8 101 1 1 1 1 1OutputCopy9000InputCopy68 10 9 9 8 101 10 5 5 1 10OutputCopy1160",
      "description": "F. Compute Power\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of tasks.The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 108), where ai represents the amount of power required for the i-th task.The third line contains n integers b1, b2, ..., bn (1 ≤ bi ≤ 100), where bi is the number of processors that i-th task will utilize.\n\nOutputPrint a single integer value — the lowest threshold for which it is possible to assign all tasks in such a way that the system will not blow up after the first round of computation, multiplied by 1000 and rounded up.\n\nInputCopy68 10 9 9 8 101 1 1 1 1 1OutputCopy9000InputCopy68 10 9 9 8 101 10 5 5 1 10OutputCopy1160\n\nInputCopy68 10 9 9 8 101 1 1 1 1 1\n\nOutputCopy9000\n\nInputCopy68 10 9 9 8 101 10 5 5 1 10\n\nOutputCopy1160\n\nNoteIn the first example the best strategy is to run each task on a separate computer, getting average compute per processor during the first round equal to 9.In the second task it is best to run tasks with compute 10 and 9 on one computer, tasks with compute 10 and 8 on another, and tasks with compute 9 and 8 on the last, averaging (10 + 10 + 9) / (10 + 10 + 5) = 1.16 compute power per processor during the first round.",
      "solutions": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces",
          "content": "UPD note that the score distribution has changedUPD2: LHiC found a bug in the author solution of div1-F. We are working on the situation.UPD3: we found a correct solution for div1-F and both submissions made during the contest pass all the tests against the correct solution. The round remains rated.Hi, everybody,Codeforces round 488 for both divisions will take place on Sunday, June 17, 2018 at 00:35UTC+8. The round will be 2.5 hours long (which is 30 minutes longer than usual).The contest is created by NEAR and its friends. NEAR is working on teaching machines to compete in programming competitions. Read our blog post to learn more about the state of the art in the program synthesis today, our vision, and how you can help us bring this vision to reality.The contest will feature 6 problems for each division, with 4 problems shared across them.The problems for the contest are from the test rounds hosted on a system JavaBlitz last year. If you participated in any of the JavaBlitz rounds, you shall not participate in this round.The score distribution in the first division is 500-1000-1000-1500-2250-3000In the second -- 500-1000-1500-2000-2000-2500The round is rated for both divisions.All problems are initially created by myself, Alexander \"AlexSkidanov\" Skidanov, and by Nikita \"FalseMirror\" Bosov. David \"pieguy\" Stolp, Alexander \"AlexFetisov\" Fetisko, Marcelo \"mnaeraxr\" Fornet, Nikolay \"KAN\" Kalinin and Mikhail \"cerealguy\" Kever helped tremendously ensuring the high quality of the problems.As a closing note, we are constantly looking for people to help us label competitive programming data for research. Read more here.Congratulations to winners!Div. 1: Um_nik Errichto scott_wu Reyna matthew99 Div. 2: conqueror_of_conqueror Shayan.P gauss148 kessido codejudge The editorial is published here. Thanks for your participation!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/59992",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1849
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces",
          "content": "994A - FingerprintsThe problem can be solved by iterating over every number of the sequence, then iterating over the sequence of fingerprints to check if the number corresponds to a key with a fingerprint, resulting in an O(n×m)O(n×m) solution. 994B - Knights of a Polygonal TableSort the knights by increasing the power. Now we can iterate over an array and greedy store set of kk prevous knights with maximum if coins. After handling knight, if set contains less than kk elements, we add current knight in set. Else if number of coins from current knight greater than from knight with minimum coins in set, we can replace this knight with current knight. You can store the set in vector, multiset or priority_queue. Be careful with overflowing and corner case k=0k=0.Time complexity is O(n⋅k)O(n⋅k) or O(n⋅log(k))O(n⋅log⁡(k)). 994C - Two SquaresIt can be shown that if two squares intersect, then at least for one of the squares it is true that either one of its corners lies within the other square, or its center lies within the other square.It is very easy to check if any corner or the center of the square rotated by 45 degrees lies within the square with sides parallel to the axes.To check in the opposite directions in a similarly simple fashion, it is enough to rotate both squares by 45 degrees. To turn both squares by 45 degrees (with some scaling, which is OK) it is sufficient to replace each xx coordinate with x+yx+y and each yy coordinate with x−yx−y. 994D - Open CommunicationOne way to approach this problem is to1. Iterate over each pair p1p1 communicated by the first participant, and do the following:Iterate over all pairs p2p2 of the second participant that are not equal to p1p1 and count whether the first number of p1p1 appears in any of them and whether the second number of p1p1 appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)(a,b) communicated by one of the participants, there are both pairs (a,c)(a,c) and (b,d)(b,d) among pairs communicated by the other participants, such that c≠bc≠b and d≠ad≠a (but possibly c=dc=d), since in that case if the first participant indeed has the pair (a,b)(a,b), they can't tell whether the actual number is aa or bb. Otherwise the answer is 0. 994E - Careful ManeuveringOne way to solve the problem is to fix one spaceship in the left half and one spaceship in the right half, and assume that they shoot each other by the means of shooting towards one of the small spaceships. This gives us a coordinate of one small spaceship. Once we have it, iterate over all the large spaceships, mark those that are already shot.Now all that is left is to find the best place to position the second spaceship. To do that, create a map from a coordinate to number of unmarked spaceships that would be destroyed if the second small spaceship is at that coordinate. Iterate over each unique spaceship coordinate on the left and each unique spaceship coordinate on the right, and increment the value in the map that corresponds to the position of the second small spaceship that would result in those two large spaceships shooting each other down by the number of large unmarked spaceships at the fixed coordinates.Then update the final answer with the largest value in the map plus the number of marked spaceships and move to the next pair of spaceships in the outer loop.This is a O((n×m)2)O((n×m)2) solution. 994F - Compute PowerFirst observe that if for some threshold there's a way to assign tasks in a way that they will finish computation, it is also possible for all higher thresholds.Because of that, we can use binary search to find the threshold. Now the problem is reduced to figuring out if for a given threshold the tasks can be assigned in a way that the system doesn't blow up too early.For that, observe that if the average power per processor exceeds a given threshold, it also means that the average power exceeds the threshold multiplied by the number of processors, which in turn means that the average power minus threshold multiplied by the number of processors exceeds 0. By regrouping summands, we can associate the value (power - threshold * num_of_processors) to each task, and reduce the problem to finding the mapping of tasks to computers that minimizes the sum of values of all the tasks assigned as the first task, and compare it to zero.To do that, we can use sort the tasks by the power value in decreasing order and use dynamic programming. The dimensions are:i: The current task consideredj: How many tasks that use strictly more power than the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.k: How many tasks that use exactly as much power as the i - 1st task are assigned as the first task to some computer that doesn't have a second task yet.Transitions involve either assigning the task as a first task to some computer that has no tasks yet (increasing k, increasing the value by the value of the i-th task) or assigning the task to some computer that has a first task (decreasing j, not changing the value). Whenever i-th task's power differs from i - 1st task, j increases by k, and k becomes equal to zero.The minimal sum of task values is then equal to the minimum of dp[n][j][k] over all j, k. Update the state of the binary search depending on whether the minimal sum is greater than zero or not.Note that this is O(n3) × log(precision). As an exercise, find a solution that is O(n2) × log(precision) 993E - Nikita and Order StatisticsFirst, we can find amount of numbers that less than xx for each prefix of aa (including empty prefix). We get array ss of this values. You can see that for each i,j,i<ji,j,i<j the truth that s[i]≤s[j]s[i]≤s[j] and if s[i]<s[j]s[i]<s[j] then i<ji<j. Let's count array rr such that r[i]r[i] is number of occurences ii in ss. Then answer for each dd from 11 to kk answer ans[d]ans[d] is ∑i,j,i−j=dr[i]⋅r[j]∑i,j,i−j=dr[i]⋅r[j].Let's create array vv, v[i]=r[n−i]v[i]=r[n−i]. If p=r×vp=r×v then p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d]p[n+d]=∑i,h,i+h=n+dr[i]⋅v[h]=∑i,j,i+n−j=n+dr[i]⋅r[j]=∑i,j,i−j=dr[i]⋅r[j]=ans[d].Multiplication rr and vv can be done by FFT. You should write it accuracy or use extended floating point types because values in pp can reach 10101010. Also you can use NTT by two modules and Chinese Remainder Theorem.Case k=0k=0 should be processed separately because of if s[i]≤s[j]s[i]≤s[j] it's not true that i<ji<j. We can get answer easily by using set or array of labels.Time complexity is O(n⋅log(n))O(n⋅log⁡(n)). 993F - The Moral DilemmaFirst lets observe that for the original and the inverted circuit to return the same value for each input, for each possible input one of the two conditions must be met: either in the original circuit all the gates in the second layer return 0, or in the inverted circuit all the gates in the second layer return 0.This in turn means, that for each input *each* gate in the second layer must return zero in either original or inverted circuit. Since its output only depends on at most two gates in the first layer, and at most four inputs, we can iterate over all possible configurations of gates in the first layer, gate in the second layer, and connections to the inputs to find all configurations that meet this criteria.All these configurations will share an important property: for a gate to return zero for each input in either the original or inverted circuit, it must either return zero in the original circuit for all inputs, or return zero in the inverted circuit for all inputs.Some of these configurations (e.g. and(nand(a,b),and(a,b))and(nand(a,b),and(a,b))) always return 0 in one circuit, and 1 in the opposite circuit. Other configurations (e.g. and(and(a,b),nor(a,c))and(and(a,b),nor(a,c))) return 0 in one circuit, and something depending on the input in another, but critically 0 for the case of all inputs equal to 1.For a circuit to meet the condition in the problem, it needs to have gates such that all of them return zero in either original or inverted circuit, and at least one of them to return one in the other circuit. WLOG let's consider the case of all gates returning zero in the original configuration, and at least one returning zero in the inverted configuration. Such circuit has two properties:1. The circuit only contains the following gates in the second layer: and(nand(a,b),and(a,b))and(nand(a,b),and(a,b)), and(or(a,b),nor(a,b))and(or(a,b),nor(a,b)), nor(nand(a,b),and(a,b))nor(nand(a,b),and(a,b)), nor(or(a,b),nor(a,b))nor(or(a,b),nor(a,b)), and(and(a,b),nor(a,c))and(and(a,b),nor(a,c)), nor(nand(a,b),or(a,b))nor(nand(a,b),or(a,b)). The first four of them in the inverted graph will always return 1, and the last two will return something depending on the input. 2. The circuit contains at least one of the first four gate kinds, and having at least one such gate is sufficient for the circuit to meet the condition from the problem. The latter is easy to show: since each of the first four gate kinds always returns 1 in the inverted mode, having it is sufficient to have at least one gate return 1 in the second layer. To show the former, remember that the last two gates return zero in the inverted mode when all three inputs are ones. It means that no matter how many of last two kinds of gates we have, and no matter how they are wired with the inputs, if all the inputs are equal to 1, all such gates will return 0, and at least one gate of the first four kinds will be necessary to have at least one gate to return 1.From here the solution is trivial: to find the largest subset of the gates in the second layer that would all return 0 in the original circuit, and at least one return 1 in the inverted, we choose the largest set of gates that belong to the abovementioned set, for as long as at least one of them belongs to the first four kinds. If no gate in the second layer belongs to the first four kinds, the desired subset doesn't exist.Solution for the case when the inverted circuit has all gates in the second layer always return zero and original has at least one that returns one is solved similarly.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60047",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 994\\s*F"
          },
          "content_length": 10603
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 1",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 2",
          "code": "9 1\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n\nThe same:\n9 1\n9 8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 3",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 4",
          "code": "if(s.size()>k){\nsum-=(*top);\ns.erase(top);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 5",
          "code": "10 8 4 8 4 5 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 6",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 by NEAR - Codeforces - Code 7",
          "code": "ll mul(ll a,ll b)\n{\n    return ((a * b &mdash; (ll)((long double)a / MOD * b + 1e-6) * MOD) % MOD + MOD) % MOD;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/59992",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 1",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 2",
          "code": "3 6 6\nnor xx. nor x.x nor .xx and xx. and x.x and .xx\nand x...x. and x....x and .x.x.. and .x...x and ..xx.. and ..x.x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 3",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 4",
          "code": "R = lambda: map(int, input().split())\nn, k = R()\nv = []\nt = [0]*n\nfor p, c, i in sorted(zip(R(), R(), range(n))):\n    t[i] = sum(v)+c\n    v += [c]\n    v = sorted(v)[::-1]\n    if len(v) > k:\n        v.pop()\nprint(' '.join(map(str, t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 5",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = ur[i - 1] * ur[1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #488 editorial - Codeforces - Code 6",
          "code": "for(int i = 2; i < (1 << LG); i++)         ur[i] = polar(1.0, i * M_PI * 2 / (1 << LG));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60047",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n, 1, 100, \"b_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"min_ai_bi\") {\n        // ai = 1, bi = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"max_ai_bi\") {\n        // ai = 1e8, bi = 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n            b[i] = 100;\n        }\n    } else if (type == \"random_small_ai_bi\") {\n        // ai and bi random in small ranges\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"random_large_ai_bi\") {\n        // ai random in [1, 1e8], bi random in [1, 100]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n            b[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"increasing_ai_bi\") {\n        // ai and bi increasing\n        int ai = 1;\n        int bi = 1;\n        int ai_step = max(1, (100000000 - 1) / n);\n        int bi_step = max(1, (100 - 1) / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n            ai = min(100000000, ai + ai_step);\n            bi = min(100, bi + bi_step);\n        }\n    } else if (type == \"decreasing_ai_bi\") {\n        // ai and bi decreasing\n        int ai = 100000000;\n        int bi = 100;\n        int ai_step = max(1, (100000000 - 1) / n);\n        int bi_step = max(1, (100 - 1) / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n            ai = max(1, ai - ai_step);\n            bi = max(1, bi - bi_step);\n        }\n    } else if (type == \"same_ai_bi\") {\n        // ai and bi are all the same random value\n        int ai = rnd.next(1, 100000000);\n        int bi = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else if (type == \"varying_ai_bi\") {\n        // ai and bi random with varying ranges\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(1,4);\n            if (choice == 1) {\n                // small ai and bi\n                a[i] = rnd.next(1, 100);\n                b[i] = rnd.next(1, 10);\n            } else if (choice == 2) {\n                // large ai and small bi\n                a[i] = rnd.next(10000000, 100000000);\n                b[i] = rnd.next(1, 10);\n            } else if (choice == 3) {\n                // small ai and large bi\n                a[i] = rnd.next(1, 100);\n                b[i] = rnd.next(50, 100);\n            } else {\n                // large ai and large bi\n                a[i] = rnd.next(10000000, 100000000);\n                b[i] = rnd.next(50, 100);\n            }\n        }\n    } else {\n        // Random ai and bi\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n            b[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1 ? '\\n' : ' '));\n    }\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], (i == n-1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"min_ai_bi\") {\n        // ai = 1, bi = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"max_ai_bi\") {\n        // ai = 1e8, bi = 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n            b[i] = 100;\n        }\n    } else if (type == \"random_small_ai_bi\") {\n        // ai and bi random in small ranges\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"random_large_ai_bi\") {\n        // ai random in [1, 1e8], bi random in [1, 100]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n            b[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"increasing_ai_bi\") {\n        // ai and bi increasing\n        int ai = 1;\n        int bi = 1;\n        int ai_step = max(1, (100000000 - 1) / n);\n        int bi_step = max(1, (100 - 1) / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n            ai = min(100000000, ai + ai_step);\n            bi = min(100, bi + bi_step);\n        }\n    } else if (type == \"decreasing_ai_bi\") {\n        // ai and bi decreasing\n        int ai = 100000000;\n        int bi = 100;\n        int ai_step = max(1, (100000000 - 1) / n);\n        int bi_step = max(1, (100 - 1) / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n            ai = max(1, ai - ai_step);\n            bi = max(1, bi - bi_step);\n        }\n    } else if (type == \"same_ai_bi\") {\n        // ai and bi are all the same random value\n        int ai = rnd.next(1, 100000000);\n        int bi = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else if (type == \"varying_ai_bi\") {\n        // ai and bi random with varying ranges\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(1,4);\n            if (choice == 1) {\n                // small ai and bi\n                a[i] = rnd.next(1, 100);\n                b[i] = rnd.next(1, 10);\n            } else if (choice == 2) {\n                // large ai and small bi\n                a[i] = rnd.next(10000000, 100000000);\n                b[i] = rnd.next(1, 10);\n            } else if (choice == 3) {\n                // small ai and large bi\n                a[i] = rnd.next(1, 100);\n                b[i] = rnd.next(50, 100);\n            } else {\n                // large ai and large bi\n                a[i] = rnd.next(10000000, 100000000);\n                b[i] = rnd.next(50, 100);\n            }\n        }\n    } else {\n        // Random ai and bi\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000000);\n            b[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1 ? '\\n' : ' '));\n    }\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], (i == n-1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_ai_bi\n./gen -n 1 -type max_ai_bi\n./gen -n 1 -type random_small_ai_bi\n./gen -n 1 -type random_large_ai_bi\n./gen -n 1 -type increasing_ai_bi\n./gen -n 1 -type decreasing_ai_bi\n./gen -n 1 -type same_ai_bi\n./gen -n 1 -type varying_ai_bi\n\n./gen -n 5 -type min_ai_bi\n./gen -n 5 -type max_ai_bi\n./gen -n 5 -type random_small_ai_bi\n./gen -n 5 -type random_large_ai_bi\n./gen -n 5 -type increasing_ai_bi\n./gen -n 5 -type decreasing_ai_bi\n./gen -n 5 -type same_ai_bi\n./gen -n 5 -type varying_ai_bi\n\n./gen -n 10 -type random\n./gen -n 15 -type random\n./gen -n 20 -type random\n./gen -n 25 -type random\n\n./gen -n 30 -type min_ai_bi\n./gen -n 30 -type max_ai_bi\n./gen -n 30 -type increasing_ai_bi\n./gen -n 30 -type decreasing_ai_bi\n./gen -n 30 -type same_ai_bi\n./gen -n 30 -type varying_ai_bi\n\n./gen -n 40 -type random_small_ai_bi\n./gen -n 45 -type random_large_ai_bi\n\n./gen -n 50 -type min_ai_bi\n./gen -n 50 -type max_ai_bi\n./gen -n 50 -type random_small_ai_bi\n./gen -n 50 -type random_large_ai_bi\n./gen -n 50 -type increasing_ai_bi\n./gen -n 50 -type decreasing_ai_bi\n./gen -n 50 -type same_ai_bi\n./gen -n 50 -type varying_ai_bi\n./gen -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:38.075056",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "995/A",
      "title": "A. Тесла",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа nn и kk (1≤n≤501≤n≤50, 1≤k≤2n1≤k≤2n), обозначающие число столбцов в таблице и число машин, соответственно.Следующие четыре строки содержат по nn целых чисел, каждов от 00 до kk включительно, они описывают начальное состояние парковки. Строки пронумерованы от 11 до 44 сверху вниз, а столбцы пронумерованы от 11 до nn слева направо.В первой и последней строке целое число 1≤x≤k1≤x≤k обозначает парковочное место машины xx (сюда может заезжать только эта машина), а число 00 означает пустое место (сюда не может заехать ни одна машина).Во второй и третьей строках целое число 1≤x≤k1≤x≤k обозначает начальную позицию машины xx, а число 00 обозначает пустое место (на него могут заезжать все машины).Каждое число xx между 11 и kk встречается ровно один раз во второй и третьей строках, и ровно один раз в первой и четвертой строках.",
      "output_spec": "Выходные данныеЕсли есть последовательность передвижений машин такая, что все машины окажутся на своих местах за не более чем 2000020000 шагов, выведите mm, число шагов, на первой строке. В следующих mm строках выведите шаги по одному в строке в формате ii rr cc, что означает, что Аллен должен подвинуть машину ii на соседнее место в строке rr и столбце cc.Если невозможно передвинуть все машины на правильные места за 2000020000 шагов, выведите −1−1 в единственной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 2 0 41 2 0 45 0 0 30 5 0 3Выходные данныеСкопировать61 1 12 1 24 1 43 4 45 3 25 4 2Входные данныеСкопировать1 21212Выходные данныеСкопировать-1Входные данныеСкопировать1 21122Выходные данныеСкопировать21 1 12 4 1",
      "description": "ограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа nn и kk (1≤n≤501≤n≤50, 1≤k≤2n1≤k≤2n), обозначающие число столбцов в таблице и число машин, соответственно.Следующие четыре строки содержат по nn целых чисел, каждов от 00 до kk включительно, они описывают начальное состояние парковки. Строки пронумерованы от 11 до 44 сверху вниз, а столбцы пронумерованы от 11 до nn слева направо.В первой и последней строке целое число 1≤x≤k1≤x≤k обозначает парковочное место машины xx (сюда может заезжать только эта машина), а число 00 означает пустое место (сюда не может заехать ни одна машина).Во второй и третьей строках целое число 1≤x≤k1≤x≤k обозначает начальную позицию машины xx, а число 00 обозначает пустое место (на него могут заезжать все машины).Каждое число xx между 11 и kk встречается ровно один раз во второй и третьей строках, и ровно один раз в первой и четвертой строках.\n\nВходные данные\n\nВыходные данныеЕсли есть последовательность передвижений машин такая, что все машины окажутся на своих местах за не более чем 2000020000 шагов, выведите mm, число шагов, на первой строке. В следующих mm строках выведите шаги по одному в строке в формате ii rr cc, что означает, что Аллен должен подвинуть машину ii на соседнее место в строке rr и столбце cc.Если невозможно передвинуть все машины на правильные места за 2000020000 шагов, выведите −1−1 в единственной строке.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 2 0 41 2 0 45 0 0 30 5 0 3Выходные данныеСкопировать61 1 12 1 24 1 43 4 45 3 25 4 2Входные данныеСкопировать1 21212Выходные данныеСкопировать-1Входные данныеСкопировать1 21122Выходные данныеСкопировать21 1 12 4 1\n\nВходные данныеСкопировать4 51 2 0 41 2 0 45 0 0 30 5 0 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать61 1 12 1 24 1 43 4 45 3 25 4 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 21212\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 21122\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 1 12 4 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере все машины уже располагаются перед соответствующими парковочными местами, кроме машины 55, которая находится напротив соседнего места. Пример показывает кратчайшее решение, но будет зачтено любое длины не более 2000020000.Во втором примере есть только один столбец, и машины находятся в неправильном порядке, поэтому они не могут двигаться и расставить их правильным образом невозможно.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 995\\s*A"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2 * n, \"k\");\n    inf.readEoln();\n\n    vector<int> parking_spots(k + 1, 0); // Counts for cars in rows 1 and 4\n    vector<int> initial_positions(k + 1, 0); // Counts for cars in rows 2 and 3\n\n    auto read_row = [&](string row_name) -> vector<int> {\n        vector<int> row = inf.readInts(n, 0, k, row_name);\n        inf.readEoln();\n        return row;\n    };\n\n    // Read row 1 and update parking_spots\n    vector<int> row1 = read_row(\"row1\");\n    for (int x : row1) {\n        if (x != 0) {\n            parking_spots[x]++;\n            ensuref(parking_spots[x] <= 1, \"Car %d appears more than once in parking spots\", x);\n        }\n    }\n\n    // Read row 2 and update initial_positions\n    vector<int> row2 = read_row(\"row2\");\n    for (int x : row2) {\n        if (x != 0) {\n            initial_positions[x]++;\n            ensuref(initial_positions[x] <= 1, \"Car %d appears more than once in initial positions\", x);\n        }\n    }\n\n    // Read row 3 and update initial_positions\n    vector<int> row3 = read_row(\"row3\");\n    for (int x : row3) {\n        if (x != 0) {\n            initial_positions[x]++;\n            ensuref(initial_positions[x] <= 1, \"Car %d appears more than once in initial positions\", x);\n        }\n    }\n\n    // Read row 4 and update parking_spots\n    vector<int> row4 = read_row(\"row4\");\n    for (int x : row4) {\n        if (x != 0) {\n            parking_spots[x]++;\n            ensuref(parking_spots[x] <= 1, \"Car %d appears more than once in parking spots\", x);\n        }\n    }\n\n    // Ensure that every car number from 1 to k appears exactly once in initial_positions and parking_spots\n    for (int x = 1; x <= k; x++) {\n        ensuref(initial_positions[x] == 1, \"Car %d does not appear exactly once in initial positions\", x);\n        ensuref(parking_spots[x] == 1, \"Car %d does not appear exactly once in parking spots\", x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2 * n, \"k\");\n    inf.readEoln();\n\n    vector<int> parking_spots(k + 1, 0); // Counts for cars in rows 1 and 4\n    vector<int> initial_positions(k + 1, 0); // Counts for cars in rows 2 and 3\n\n    auto read_row = [&](string row_name) -> vector<int> {\n        vector<int> row = inf.readInts(n, 0, k, row_name);\n        inf.readEoln();\n        return row;\n    };\n\n    // Read row 1 and update parking_spots\n    vector<int> row1 = read_row(\"row1\");\n    for (int x : row1) {\n        if (x != 0) {\n            parking_spots[x]++;\n            ensuref(parking_spots[x] <= 1, \"Car %d appears more than once in parking spots\", x);\n        }\n    }\n\n    // Read row 2 and update initial_positions\n    vector<int> row2 = read_row(\"row2\");\n    for (int x : row2) {\n        if (x != 0) {\n            initial_positions[x]++;\n            ensuref(initial_positions[x] <= 1, \"Car %d appears more than once in initial positions\", x);\n        }\n    }\n\n    // Read row 3 and update initial_positions\n    vector<int> row3 = read_row(\"row3\");\n    for (int x : row3) {\n        if (x != 0) {\n            initial_positions[x]++;\n            ensuref(initial_positions[x] <= 1, \"Car %d appears more than once in initial positions\", x);\n        }\n    }\n\n    // Read row 4 and update parking_spots\n    vector<int> row4 = read_row(\"row4\");\n    for (int x : row4) {\n        if (x != 0) {\n            parking_spots[x]++;\n            ensuref(parking_spots[x] <= 1, \"Car %d appears more than once in parking spots\", x);\n        }\n    }\n\n    // Ensure that every car number from 1 to k appears exactly once in initial_positions and parking_spots\n    for (int x = 1; x <= k; x++) {\n        ensuref(initial_positions[x] == 1, \"Car %d does not appear exactly once in initial positions\", x);\n        ensuref(parking_spots[x] == 1, \"Car %d does not appear exactly once in parking spots\", x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2 * n, \"k\");\n    inf.readEoln();\n\n    vector<int> parking_spots(k + 1, 0); // Counts for cars in rows 1 and 4\n    vector<int> initial_positions(k + 1, 0); // Counts for cars in rows 2 and 3\n\n    auto read_row = [&](string row_name) -> vector<int> {\n        vector<int> row = inf.readInts(n, 0, k, row_name);\n        inf.readEoln();\n        return row;\n    };\n\n    // Read row 1 and update parking_spots\n    vector<int> row1 = read_row(\"row1\");\n    for (int x : row1) {\n        if (x != 0) {\n            parking_spots[x]++;\n            ensuref(parking_spots[x] <= 1, \"Car %d appears more than once in parking spots\", x);\n        }\n    }\n\n    // Read row 2 and update initial_positions\n    vector<int> row2 = read_row(\"row2\");\n    for (int x : row2) {\n        if (x != 0) {\n            initial_positions[x]++;\n            ensuref(initial_positions[x] <= 1, \"Car %d appears more than once in initial positions\", x);\n        }\n    }\n\n    // Read row 3 and update initial_positions\n    vector<int> row3 = read_row(\"row3\");\n    for (int x : row3) {\n        if (x != 0) {\n            initial_positions[x]++;\n            ensuref(initial_positions[x] <= 1, \"Car %d appears more than once in initial positions\", x);\n        }\n    }\n\n    // Read row 4 and update parking_spots\n    vector<int> row4 = read_row(\"row4\");\n    for (int x : row4) {\n        if (x != 0) {\n            parking_spots[x]++;\n            ensuref(parking_spots[x] <= 1, \"Car %d appears more than once in parking spots\", x);\n        }\n    }\n\n    // Ensure that every car number from 1 to k appears exactly once in initial_positions and parking_spots\n    for (int x = 1; x <= k; x++) {\n        ensuref(initial_positions[x] == 1, \"Car %d does not appear exactly once in initial positions\", x);\n        ensuref(parking_spots[x] == 1, \"Car %d does not appear exactly once in parking spots\", x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k;\nint grid[5][51]; // The parking lot grid\nmap<int, pair<int, int>> carPosition; // Current position of each car\nmap<int, pair<int, int>> carParkingSpot; // Designated parking spots for each car\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    n = inf.readInt(1, 50, \"n\");\n    k = inf.readInt(1, 2 * n, \"k\");\n\n    // Initialize the grid and data structures\n    for (int r = 1; r <= 4; ++r) {\n        for (int c = 1; c <= n; ++c) {\n            int x = inf.readInt(0, k, format(\"grid[%d][%d]\", r, c).c_str());\n            grid[r][c] = x;\n\n            if (r == 1 || r == 4) {\n                // Parking spots\n                if (x > 0) {\n                    carParkingSpot[x] = make_pair(r, c);\n                }\n            } else {\n                // Initial positions\n                if (x > 0) {\n                    carPosition[x] = make_pair(r, c);\n                }\n            }\n        }\n    }\n\n    // Read judge's answer\n    int judgeM = ans.readInt(-1, 20000, \"judge m\");\n    bool judgeImpossible = false;\n    if (judgeM == -1) {\n        judgeImpossible = true;\n    }\n\n    // Read contestant's answer\n    int m = ouf.readInt(-1, 20000, \"m\");\n    if (m == -1) {\n        if (judgeImpossible) {\n            quitf(_ok, \"Contestant correctly claims impossible\");\n        } else {\n            quitf(_wa, \"Contestant claims impossible, but a solution exists\");\n        }\n    } else {\n        if (m < 0 || m > 20000) {\n            quitf(_wa, \"Invalid number of moves m: %d\", m);\n        }\n        if (judgeImpossible) {\n            quitf(_fail, \"Contestant provides a solution, but judge says impossible\");\n        }\n\n        // Simulate the moves\n        int gridOcc[5][51]; // Occupancy grid\n        memset(gridOcc, 0, sizeof(gridOcc));\n        for (auto &entry : carPosition) {\n            int car = entry.first;\n            int r = entry.second.first;\n            int c = entry.second.second;\n            gridOcc[r][c] = car;\n        }\n\n        for (int moveNum = 1; moveNum <= m; ++moveNum) {\n            int car = ouf.readInt(1, k, format(\"move %d car\", moveNum).c_str());\n            int r = ouf.readInt(1, 4, format(\"move %d r\", moveNum).c_str());\n            int c = ouf.readInt(1, n, format(\"move %d c\", moveNum).c_str());\n\n            // Validate move\n            if (carPosition.find(car) == carPosition.end()) {\n                quitf(_wa, \"Move %d: Car %d does not exist\", moveNum, car);\n            }\n            int r0 = carPosition[car].first;\n            int c0 = carPosition[car].second;\n\n            // Check adjacency\n            if (abs(r - r0) + abs(c - c0) != 1) {\n                quitf(_wa, \"Move %d: Car %d moves to non-adjacent position (%d,%d)\", moveNum, car, r, c);\n            }\n\n            // Check if destination is empty\n            if (gridOcc[r][c] != 0) {\n                quitf(_wa, \"Move %d: Destination (%d,%d) is not empty\", moveNum, r, c);\n            }\n\n            // Check parking spot constraints\n            if ((r == 1 || r == 4) && carParkingSpot[car] != make_pair(r, c)) {\n                quitf(_wa, \"Move %d: Car %d cannot enter parking spot (%d,%d) which is not its own\", moveNum, car, r, c);\n            }\n\n            // Apply the move\n            gridOcc[r0][c0] = 0;\n            gridOcc[r][c] = car;\n            carPosition[car] = make_pair(r, c);\n        }\n\n        // Check final positions\n        for (int car = 1; car <= k; ++car) {\n            if (carPosition[car] != carParkingSpot[car]) {\n                quitf(_wa, \"After all moves, car %d is at (%d,%d), but its parking spot is at (%d,%d)\",\n                      car, carPosition[car].first, carPosition[car].second,\n                      carParkingSpot[car].first, carParkingSpot[car].second);\n            }\n        }\n\n        quitf(_ok, \"Correct solution with %d moves\", m);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate constraints\n    assert(1 <= n && n <= 50);\n    assert(1 <= k && k <= 2 * n);\n\n    // Initialize the grid with zeros\n    vector<vector<int>> grid(4, vector<int>(n, 0));\n\n    if (type == \"random\") {\n        // Generate random positions for parking spots (rows 0 and 3)\n        vector<pair<int, int>> parking_positions;\n        for (int i = 0; i < n; ++i) {\n            parking_positions.push_back({0, i}); // Row 1 (index 0)\n            parking_positions.push_back({3, i}); // Row 4 (index 3)\n        }\n        // Shuffle parking positions\n        shuffle(parking_positions.begin(), parking_positions.end());\n\n        // Assign cars to parking spots\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n        int idx = 0;\n        for (int car : cars) {\n            int row = parking_positions[idx].first;\n            int col = parking_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n\n        // Generate random positions for initial positions (rows 1 and 2)\n        vector<pair<int, int>> initial_positions;\n        for (int i = 0; i < n; ++i) {\n            initial_positions.push_back({1, i}); // Row 2 (index 1)\n            initial_positions.push_back({2, i}); // Row 3 (index 2)\n        }\n        // Shuffle initial positions\n        shuffle(initial_positions.begin(), initial_positions.end());\n\n        // Assign cars to initial positions\n        idx = 0;\n        for (int car : cars) {\n            int row = initial_positions[idx].first;\n            int col = initial_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n\n    } else if (type == \"pre-solved\") {\n        // Assign cars directly to their parking spots\n        vector<pair<int, int>> parking_positions;\n        for (int i = 0; i < n && k > 0; ++i) {\n            parking_positions.push_back({0, i}); // Row 1\n            k--;\n        }\n        for (int i = 0; i < n && k > 0; ++i) {\n            parking_positions.push_back({3, i}); // Row 4\n            k--;\n        }\n        int car_number = 1;\n        for (auto pos : parking_positions) {\n            grid[pos.first][pos.second] = car_number;\n            car_number++;\n        }\n        // The initial positions (rows 1 and 2) remain empty\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible test case (e.g., N=1, K=2)\n        assert(n == 1);\n        assert(k == 2);\n        grid[0][0] = 1; // Parking spot for car 1\n        grid[1][0] = 2; // Initial position of car 2\n        grid[2][0] = 1; // Initial position of car 1\n        grid[3][0] = 2; // Parking spot for car 2\n        // Cars cannot move because they are blocked\n\n    } else if (type == \"blocked\") {\n        // Create a test case where cars are blocked by other cars\n        assert(n >= 3);\n\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n        shuffle(cars.begin(), cars.end());\n\n        // Assign parking spots\n        int idx = 0;\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[0][i] = cars[idx++]; // Row 1\n        }\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[3][i] = cars[idx++]; // Row 4\n        }\n\n        // Place cars in row 2 to block movement\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[1][i] = cars[idx++]; // Row 2\n        }\n        // Remaining cars in row 3\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[2][i] = cars[idx++]; // Row 3\n        }\n\n    } else if (type == \"minimal\") {\n        // Minimal test case with N=1, K=1\n        assert(n == 1);\n        assert(k == 1);\n        grid[0][0] = 1; // Parking spot for car 1\n        grid[1][0] = 1; // Initial position of car 1\n\n    } else if (type == \"maximal\") {\n        // Maximal test case with N=50, K=100\n        assert(n == 50);\n        assert(k == 100);\n\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n\n        // Assign parking spots in rows 1 and 4\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = cars[i];            // Row 1\n            grid[3][i] = cars[i + n];        // Row 4\n        }\n\n        // Assign initial positions in rows 2 and 3\n        for (int i = 0; i < n; ++i) {\n            grid[1][i] = cars[i];            // Row 2\n            grid[2][i] = cars[i + n];        // Row 3\n        }\n\n    } else {\n        // Default to random case if unknown type\n        // (Same as \"random\" type)\n        // Generate random positions for parking spots (rows 0 and 3)\n        vector<pair<int, int>> parking_positions;\n        for (int i = 0; i < n; ++i) {\n            parking_positions.push_back({0, i}); // Row 1\n            parking_positions.push_back({3, i}); // Row 4\n        }\n        shuffle(parking_positions.begin(), parking_positions.end());\n\n        // Assign cars to parking spots\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n        int idx = 0;\n        for (int car : cars) {\n            int row = parking_positions[idx].first;\n            int col = parking_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n\n        // Generate random positions for initial positions (rows 1 and 2)\n        vector<pair<int, int>> initial_positions;\n        for (int i = 0; i < n; ++i) {\n            initial_positions.push_back({1, i}); // Row 2\n            initial_positions.push_back({2, i}); // Row 3\n        }\n        shuffle(initial_positions.begin(), initial_positions.end());\n\n        // Assign cars to initial positions\n        idx = 0;\n        for (int car : cars) {\n            int row = initial_positions[idx].first;\n            int col = initial_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the grid\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j != n - 1)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate constraints\n    assert(1 <= n && n <= 50);\n    assert(1 <= k && k <= 2 * n);\n\n    // Initialize the grid with zeros\n    vector<vector<int>> grid(4, vector<int>(n, 0));\n\n    if (type == \"random\") {\n        // Generate random positions for parking spots (rows 0 and 3)\n        vector<pair<int, int>> parking_positions;\n        for (int i = 0; i < n; ++i) {\n            parking_positions.push_back({0, i}); // Row 1 (index 0)\n            parking_positions.push_back({3, i}); // Row 4 (index 3)\n        }\n        // Shuffle parking positions\n        shuffle(parking_positions.begin(), parking_positions.end());\n\n        // Assign cars to parking spots\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n        int idx = 0;\n        for (int car : cars) {\n            int row = parking_positions[idx].first;\n            int col = parking_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n\n        // Generate random positions for initial positions (rows 1 and 2)\n        vector<pair<int, int>> initial_positions;\n        for (int i = 0; i < n; ++i) {\n            initial_positions.push_back({1, i}); // Row 2 (index 1)\n            initial_positions.push_back({2, i}); // Row 3 (index 2)\n        }\n        // Shuffle initial positions\n        shuffle(initial_positions.begin(), initial_positions.end());\n\n        // Assign cars to initial positions\n        idx = 0;\n        for (int car : cars) {\n            int row = initial_positions[idx].first;\n            int col = initial_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n\n    } else if (type == \"pre-solved\") {\n        // Assign cars directly to their parking spots\n        vector<pair<int, int>> parking_positions;\n        for (int i = 0; i < n && k > 0; ++i) {\n            parking_positions.push_back({0, i}); // Row 1\n            k--;\n        }\n        for (int i = 0; i < n && k > 0; ++i) {\n            parking_positions.push_back({3, i}); // Row 4\n            k--;\n        }\n        int car_number = 1;\n        for (auto pos : parking_positions) {\n            grid[pos.first][pos.second] = car_number;\n            car_number++;\n        }\n        // The initial positions (rows 1 and 2) remain empty\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible test case (e.g., N=1, K=2)\n        assert(n == 1);\n        assert(k == 2);\n        grid[0][0] = 1; // Parking spot for car 1\n        grid[1][0] = 2; // Initial position of car 2\n        grid[2][0] = 1; // Initial position of car 1\n        grid[3][0] = 2; // Parking spot for car 2\n        // Cars cannot move because they are blocked\n\n    } else if (type == \"blocked\") {\n        // Create a test case where cars are blocked by other cars\n        assert(n >= 3);\n\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n        shuffle(cars.begin(), cars.end());\n\n        // Assign parking spots\n        int idx = 0;\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[0][i] = cars[idx++]; // Row 1\n        }\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[3][i] = cars[idx++]; // Row 4\n        }\n\n        // Place cars in row 2 to block movement\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[1][i] = cars[idx++]; // Row 2\n        }\n        // Remaining cars in row 3\n        for (int i = 0; i < n && idx < k; ++i) {\n            grid[2][i] = cars[idx++]; // Row 3\n        }\n\n    } else if (type == \"minimal\") {\n        // Minimal test case with N=1, K=1\n        assert(n == 1);\n        assert(k == 1);\n        grid[0][0] = 1; // Parking spot for car 1\n        grid[1][0] = 1; // Initial position of car 1\n\n    } else if (type == \"maximal\") {\n        // Maximal test case with N=50, K=100\n        assert(n == 50);\n        assert(k == 100);\n\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n\n        // Assign parking spots in rows 1 and 4\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = cars[i];            // Row 1\n            grid[3][i] = cars[i + n];        // Row 4\n        }\n\n        // Assign initial positions in rows 2 and 3\n        for (int i = 0; i < n; ++i) {\n            grid[1][i] = cars[i];            // Row 2\n            grid[2][i] = cars[i + n];        // Row 3\n        }\n\n    } else {\n        // Default to random case if unknown type\n        // (Same as \"random\" type)\n        // Generate random positions for parking spots (rows 0 and 3)\n        vector<pair<int, int>> parking_positions;\n        for (int i = 0; i < n; ++i) {\n            parking_positions.push_back({0, i}); // Row 1\n            parking_positions.push_back({3, i}); // Row 4\n        }\n        shuffle(parking_positions.begin(), parking_positions.end());\n\n        // Assign cars to parking spots\n        vector<int> cars;\n        for (int i = 1; i <= k; ++i) {\n            cars.push_back(i);\n        }\n        int idx = 0;\n        for (int car : cars) {\n            int row = parking_positions[idx].first;\n            int col = parking_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n\n        // Generate random positions for initial positions (rows 1 and 2)\n        vector<pair<int, int>> initial_positions;\n        for (int i = 0; i < n; ++i) {\n            initial_positions.push_back({1, i}); // Row 2\n            initial_positions.push_back({2, i}); // Row 3\n        }\n        shuffle(initial_positions.begin(), initial_positions.end());\n\n        // Assign cars to initial positions\n        idx = 0;\n        for (int car : cars) {\n            int row = initial_positions[idx].first;\n            int col = initial_positions[idx].second;\n            grid[row][col] = car;\n            idx++;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the grid\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j != n - 1)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type minimal\n./gen -n 1 -k 2 -type impossible\n./gen -n 2 -k 2 -type random\n./gen -n 2 -k 4 -type random\n\n./gen -n 3 -k 3 -type blocked\n./gen -n 3 -k 6 -type blocked\n./gen -n 3 -k 6 -type random\n\n./gen -n 5 -k 5 -type pre-solved\n./gen -n 5 -k 10 -type pre-solved\n./gen -n 5 -k 10 -type random\n\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 20 -type random\n./gen -n 10 -k 20 -type blocked\n\n./gen -n 15 -k 15 -type random\n./gen -n 15 -k 30 -type random\n./gen -n 15 -k 30 -type blocked\n\n./gen -n 20 -k 40 -type random\n./gen -n 25 -k 50 -type random\n./gen -n 25 -k 50 -type blocked\n\n./gen -n 30 -k 60 -type random\n./gen -n 35 -k 70 -type random\n./gen -n 40 -k 80 -type random\n\n./gen -n 45 -k 90 -type random\n./gen -n 50 -k 100 -type maximal\n./gen -n 50 -k 100 -type random\n./gen -n 50 -k 100 -type blocked\n\n# Additional test cases to cover edge conditions\n./gen -n 1 -k 1 -type pre-solved\n./gen -n 1 -k 1 -type random\n\n./gen -n 2 -k 2 -type pre-solved\n./gen -n 2 -k 4 -type pre-solved\n./gen -n 2 -k 4 -type random\n\n# Test cases with N at maximum and K less than maximum\n./gen -n 50 -k 75 -type random\n./gen -n 50 -k 50 -type blocked\n./gen -n 50 -k 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:39.921980",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "995/B",
      "title": "B. Костюм с галстуком",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит одно целое число nn (1≤n≤1001≤n≤100) — количество пар людей.Вторая строка содержит 2n2n целых чисел a1,a2,…,a2na1,a2,…,a2n. Для каждого ii, удовлетворяющего 1≤i≤n1≤i≤n, ii встречается в этом списке ровно два раза. Если aj=ak=iaj=ak=i, то люди на jj-м и на kk-м местах образуют пару.",
      "output_spec": "Выходные данныеВыведите одно целое число — минимальное число обменов местами соседних людей для того, чтобы каждая пара занимала соседние позиции.",
      "sample_tests": "ПримерыВходные данныеСкопировать41 1 2 3 3 2 4 4Выходные данныеСкопировать2Входные данныеСкопировать31 1 2 2 3 3Выходные данныеСкопировать0Входные данныеСкопировать33 1 2 3 1 2Выходные данныеСкопировать3",
      "description": "B. Костюм с галстуком\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит одно целое число nn (1≤n≤1001≤n≤100) — количество пар людей.Вторая строка содержит 2n2n целых чисел a1,a2,…,a2na1,a2,…,a2n. Для каждого ii, удовлетворяющего 1≤i≤n1≤i≤n, ii встречается в этом списке ровно два раза. Если aj=ak=iaj=ak=i, то люди на jj-м и на kk-м местах образуют пару.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — минимальное число обменов местами соседних людей для того, чтобы каждая пара занимала соседние позиции.\n\nВыходные данные\n\nВходные данныеСкопировать41 1 2 3 3 2 4 4Выходные данныеСкопировать2Входные данныеСкопировать31 1 2 2 3 3Выходные данныеСкопировать0Входные данныеСкопировать33 1 2 3 1 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать41 1 2 3 3 2 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 1 2 2 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать33 1 2 3 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере можно добиться результата следующим образом: 11233244→11232344→1122334411233244→11232344→11223344 за два шага. Обратите внимание, что последовательность 11233244→11323244→1133224411233244→11323244→11332244 тоже подходит.Во втором примере все пары уже стоят рядом, поэтому ответ 00.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 995\\s*B"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n    vector<int> a = inf.readInts(2 * n, 1, n);\n    inf.readEoln();\n    inf.readEof();\n\n    vector<int> cnt(n + 1);\n    for (int x : a) {\n        cnt[x]++;\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(cnt[i] == 2, \"Integer %d appears %d times instead of 2\", i, cnt[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n    vector<int> a = inf.readInts(2 * n, 1, n);\n    inf.readEoln();\n    inf.readEof();\n\n    vector<int> cnt(n + 1);\n    for (int x : a) {\n        cnt[x]++;\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(cnt[i] == 2, \"Integer %d appears %d times instead of 2\", i, cnt[i]);\n    }\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n    vector<int> a = inf.readInts(2 * n, 1, n);\n    inf.readEoln();\n    inf.readEof();\n\n    vector<int> cnt(n + 1);\n    for (int x : a) {\n        cnt[x]++;\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(cnt[i] == 2, \"Integer %d appears %d times instead of 2\", i, cnt[i]);\n    }\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt(\"type\", \"random\");\n\n    vector<int> a(2 * n);\n\n    if (type == \"minimal\") {\n        // Pairs are adjacent\n        for (int i = 0; i < n; ++i) {\n            a[2 * i] = i + 1;\n            a[2 * i + 1] = i + 1;\n        }\n    } else if (type == \"maximal\") {\n        // Pairs are maximally separated\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            a[i + n] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        // Pairs are adjacent in reverse order\n        for (int i = 0; i < n; ++i) {\n            a[2 * i] = n - i;\n            a[2 * i + 1] = n - i;\n        }\n    } else if (type == \"random\") {\n        // Randomly shuffled array\n        for (int i = 0; i < n; ++i) {\n            a[2 * i] = i + 1;\n            a[2 * i + 1] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the array\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 != 2 * n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt(\"type\", \"random\");\n\n    vector<int> a(2 * n);\n\n    if (type == \"minimal\") {\n        // Pairs are adjacent\n        for (int i = 0; i < n; ++i) {\n            a[2 * i] = i + 1;\n            a[2 * i + 1] = i + 1;\n        }\n    } else if (type == \"maximal\") {\n        // Pairs are maximally separated\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            a[i + n] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        // Pairs are adjacent in reverse order\n        for (int i = 0; i < n; ++i) {\n            a[2 * i] = n - i;\n            a[2 * i + 1] = n - i;\n        }\n    } else if (type == \"random\") {\n        // Randomly shuffled array\n        for (int i = 0; i < n; ++i) {\n            a[2 * i] = i + 1;\n            a[2 * i + 1] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the array\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 != 2 * n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 1 -type maximal\n./gen -n 1 -type random\n\n./gen -n 2 -type minimal\n./gen -n 2 -type maximal\n./gen -n 2 -type random\n\n./gen -n 3 -type minimal\n./gen -n 3 -type maximal\n./gen -n 3 -type random\n\n./gen -n 4 -type minimal\n./gen -n 4 -type maximal\n./gen -n 4 -type random\n\n./gen -n 5 -type minimal\n./gen -n 5 -type maximal\n./gen -n 5 -type random\n\n./gen -n 10 -type minimal\n./gen -n 10 -type maximal\n./gen -n 10 -type random\n\n./gen -n 20 -type minimal\n./gen -n 20 -type maximal\n./gen -n 20 -type random\n\n./gen -n 50 -type minimal\n./gen -n 50 -type maximal\n./gen -n 50 -type random\n\n./gen -n 75 -type minimal\n./gen -n 75 -type maximal\n./gen -n 75 -type random\n\n./gen -n 99 -type minimal\n./gen -n 99 -type maximal\n./gen -n 99 -type random\n\n./gen -n 100 -type minimal\n./gen -n 100 -type maximal\n./gen -n 100 -type reverse\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:41.955125",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "995/C",
      "title": "C. Из бара домой",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит одно целое число nn (1≤n≤1051≤n≤105) — количество шагов.В каждой из следующих строк содержится два целых числа xixi и yiyi, описывающих вектор vi→=(xi,yi)vi→=(xi,yi). Гарантируется, что |vi|≤106|vi|≤106 выполняется для всех ii.",
      "output_spec": "Выходные данныеВыведите единственною строку, содержащую nn целых чисел c1,c2,⋯,cnc1,c2,⋯,cn, каждое из которых равно либо 11, либо −1−1. Ваше решение будет зачтено, если финальная позиция p=∑ni=1civi→p=∑i=1ncivi→ удовлетворяет |p|≤1.5⋅106|p|≤1.5⋅106.Можно показать, что решение всегда существует при данных ограничениях.",
      "sample_tests": "ПримерыВходные данныеСкопировать3999999 00 999999999999 0Выходные данныеСкопировать1 1 -1 Входные данныеСкопировать1-824590 246031Выходные данныеСкопировать1 Входные данныеСкопировать8-67761 603277640586 -39667146147 -122580569609 -2112400 914208131792 309779-850150 -4862935272 721899Выходные данныеСкопировать1 1 1 1 1 1 1 -1",
      "description": "C. Из бара домой\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит одно целое число nn (1≤n≤1051≤n≤105) — количество шагов.В каждой из следующих строк содержится два целых числа xixi и yiyi, описывающих вектор vi→=(xi,yi)vi→=(xi,yi). Гарантируется, что |vi|≤106|vi|≤106 выполняется для всех ii.\n\nВходные данные\n\nВыходные данныеВыведите единственною строку, содержащую nn целых чисел c1,c2,⋯,cnc1,c2,⋯,cn, каждое из которых равно либо 11, либо −1−1. Ваше решение будет зачтено, если финальная позиция p=∑ni=1civi→p=∑i=1ncivi→ удовлетворяет |p|≤1.5⋅106|p|≤1.5⋅106.Можно показать, что решение всегда существует при данных ограничениях.\n\nВыходные данные\n\nВходные данныеСкопировать3999999 00 999999999999 0Выходные данныеСкопировать1 1 -1 Входные данныеСкопировать1-824590 246031Выходные данныеСкопировать1 Входные данныеСкопировать8-67761 603277640586 -39667146147 -122580569609 -2112400 914208131792 309779-850150 -4862935272 721899Выходные данныеСкопировать1 1 1 1 1 1 1 -1\n\nВходные данныеСкопировать3999999 00 999999999999 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1 -1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1-824590 246031\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8-67761 603277640586 -39667146147 -122580569609 -2112400 914208131792 309779-850150 -4862935272 721899\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1 1 1 1 1 1 -1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 995\\s*C"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    const long long max_sq = 1000000LL * 1000000LL;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n\n        long long xi_ll = xi;\n        long long yi_ll = yi;\n        long long sum_sq = xi_ll * xi_ll + yi_ll * yi_ll;\n\n        ensuref(sum_sq <= max_sq, \"The given vector violates |vi| ≤ 1e6 at index %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    const long long max_sq = 1000000LL * 1000000LL;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n\n        long long xi_ll = xi;\n        long long yi_ll = yi;\n        long long sum_sq = xi_ll * xi_ll + yi_ll * yi_ll;\n\n        ensuref(sum_sq <= max_sq, \"The given vector violates |vi| ≤ 1e6 at index %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    const long long max_sq = 1000000LL * 1000000LL;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000000, 1000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"yi\");\n        inf.readEoln();\n\n        long long xi_ll = xi;\n        long long yi_ll = yi;\n        long long sum_sq = xi_ll * xi_ll + yi_ll * yi_ll;\n\n        ensuref(sum_sq <= max_sq, \"The given vector violates |vi| ≤ 1e6 at index %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    vector<ll> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt();\n        y[i] = inf.readInt();\n    }\n\n    vector<int> c(n);\n    for (int i = 0; i < n; ++i) {\n        int c_i = ouf.readInt(-1, 1, format(\"c[%d]\", i+1).c_str());\n        if (c_i != -1 && c_i != 1) {\n            quitf(_wa, \"c[%d] = %d is not 1 or -1\", i+1, c_i);\n        }\n        c[i] = c_i;\n    }\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"Extra information in output after %d signs\", n);\n    }\n\n    ll p_x = 0, p_y = 0;\n    for (int i = 0; i < n; ++i) {\n        p_x += c[i] * x[i];\n        p_y += c[i] * y[i];\n    }\n\n    double p_norm = sqrt((double)p_x * p_x + (double)p_y * p_y);\n\n    if (p_norm > 1.5e6 + 1e-6) {\n        quitf(_wa, \"|p| = %.10f exceeds 1.5e6\", p_norm);\n    }\n\n    quitf(_ok, \"|p| = %.10f\", p_norm);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> v(n);\n\n    if (type == \"random\") {\n        // Generate random vectors within the constraints\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"maxlen\") {\n        // Generate vectors with maximum length\n        for (int i = 0; i < n; i++) {\n            double angle = rnd.next(0.0, 2.0 * M_PI);\n            int x = (int)(1000000 * cos(angle));\n            int y = (int)(1000000 * sin(angle));\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"minlen\") {\n        // Generate vectors with minimum length (non-zero)\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1, 1);\n                y = rnd.next(-1, 1);\n            } while (x == 0 && y == 0);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"onaxis\") {\n        // Generate vectors along x or y axis\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(0, 1) == 0) {\n                int x = rnd.next(-1000000, 1000000);\n                v[i] = make_pair(x, 0);\n            } else {\n                int y = rnd.next(-1000000, 1000000);\n                v[i] = make_pair(0, y);\n            }\n            if (v[i].first == 0 && v[i].second == 0) {\n                v[i] = make_pair(1, 0); // Adjust zero vector to non-zero\n            }\n        }\n    } else if (type == \"same\") {\n        // All vectors are the same\n        int x, y;\n        do {\n            x = rnd.next(-1000000, 1000000);\n            y = rnd.next(-1000000, 1000000);\n        } while ((long long)x * x + (long long)y * y > 1000000000000LL || (x == 0 && y == 0));\n        for (int i = 0; i < n; i++) {\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"opposite\") {\n        // Alternate vectors in opposite directions\n        int x1, y1, x2, y2;\n        do {\n            x1 = rnd.next(-1000000, 1000000);\n            y1 = rnd.next(-1000000, 1000000);\n        } while ((long long)x1 * x1 + (long long)y1 * y1 > 1000000000000LL || (x1 == 0 && y1 == 0));\n        x2 = -x1;\n        y2 = -y1;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                v[i] = make_pair(x1, y1);\n            } else {\n                v[i] = make_pair(x2, y2);\n            }\n        }\n    } else if (type == \"clustered\") {\n        // Vectors clustered near a point\n        int centerX = rnd.next(-1000000, 1000000);\n        int centerY = rnd.next(-1000000, 1000000);\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = centerX + rnd.next(-10, 10);\n                y = centerY + rnd.next(-10, 10);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            if (x == 0 && y == 0) {\n                x = 1; // Adjust zero vector to non-zero\n            }\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"negative\") {\n        // Generate vectors with negative components only\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, -1);\n                y = rnd.next(-1000000, -1);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"positive\") {\n        // Generate vectors with positive components only\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(1, 1000000);\n                y = rnd.next(1, 1000000);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"zeros\") {\n        // All zero vectors\n        for (int i = 0; i < n; i++) {\n            v[i] = make_pair(0, 0);\n        }\n    } else {\n        // Default to random vectors\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", v[i].first, v[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> v(n);\n\n    if (type == \"random\") {\n        // Generate random vectors within the constraints\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"maxlen\") {\n        // Generate vectors with maximum length\n        for (int i = 0; i < n; i++) {\n            double angle = rnd.next(0.0, 2.0 * M_PI);\n            int x = (int)(1000000 * cos(angle));\n            int y = (int)(1000000 * sin(angle));\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"minlen\") {\n        // Generate vectors with minimum length (non-zero)\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1, 1);\n                y = rnd.next(-1, 1);\n            } while (x == 0 && y == 0);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"onaxis\") {\n        // Generate vectors along x or y axis\n        for (int i = 0; i < n; i++) {\n            if (rnd.next(0, 1) == 0) {\n                int x = rnd.next(-1000000, 1000000);\n                v[i] = make_pair(x, 0);\n            } else {\n                int y = rnd.next(-1000000, 1000000);\n                v[i] = make_pair(0, y);\n            }\n            if (v[i].first == 0 && v[i].second == 0) {\n                v[i] = make_pair(1, 0); // Adjust zero vector to non-zero\n            }\n        }\n    } else if (type == \"same\") {\n        // All vectors are the same\n        int x, y;\n        do {\n            x = rnd.next(-1000000, 1000000);\n            y = rnd.next(-1000000, 1000000);\n        } while ((long long)x * x + (long long)y * y > 1000000000000LL || (x == 0 && y == 0));\n        for (int i = 0; i < n; i++) {\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"opposite\") {\n        // Alternate vectors in opposite directions\n        int x1, y1, x2, y2;\n        do {\n            x1 = rnd.next(-1000000, 1000000);\n            y1 = rnd.next(-1000000, 1000000);\n        } while ((long long)x1 * x1 + (long long)y1 * y1 > 1000000000000LL || (x1 == 0 && y1 == 0));\n        x2 = -x1;\n        y2 = -y1;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                v[i] = make_pair(x1, y1);\n            } else {\n                v[i] = make_pair(x2, y2);\n            }\n        }\n    } else if (type == \"clustered\") {\n        // Vectors clustered near a point\n        int centerX = rnd.next(-1000000, 1000000);\n        int centerY = rnd.next(-1000000, 1000000);\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = centerX + rnd.next(-10, 10);\n                y = centerY + rnd.next(-10, 10);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            if (x == 0 && y == 0) {\n                x = 1; // Adjust zero vector to non-zero\n            }\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"negative\") {\n        // Generate vectors with negative components only\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, -1);\n                y = rnd.next(-1000000, -1);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"positive\") {\n        // Generate vectors with positive components only\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(1, 1000000);\n                y = rnd.next(1, 1000000);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    } else if (type == \"zeros\") {\n        // All zero vectors\n        for (int i = 0; i < n; i++) {\n            v[i] = make_pair(0, 0);\n        }\n    } else {\n        // Default to random vectors\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n            } while ((long long)x * x + (long long)y * y > 1000000000000LL);\n            v[i] = make_pair(x, y);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", v[i].first, v[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Testcase 1: Minimum n\n./gen -n 1 -type random\n\n# Testcase 2: Small n\n./gen -n 5 -type random\n\n# Testcase 3: Small n, maximum length vectors\n./gen -n 5 -type maxlen\n\n# Testcase 4: Small n, minimum length vectors\n./gen -n 5 -type minlen\n\n# Testcase 5: Small n, vectors along axes\n./gen -n 5 -type onaxis\n\n# Testcase 6: Small n, same vectors\n./gen -n 5 -type same\n\n# Testcase 7: Medium n, random vectors\n./gen -n 1000 -type random\n\n# Testcase 8: Medium n, maximum length vectors\n./gen -n 1000 -type maxlen\n\n# Testcase 9: Medium n, minimum length vectors\n./gen -n 1000 -type minlen\n\n# Testcase 10: Medium n, vectors along axes\n./gen -n 1000 -type onaxis\n\n# Testcase 11: Medium n, same vectors\n./gen -n 1000 -type same\n\n# Testcase 12: Medium n, alternating opposite vectors\n./gen -n 1000 -type opposite\n\n# Testcase 13: Medium n, clustered vectors\n./gen -n 1000 -type clustered\n\n# Testcase 14: Large n, random vectors\n./gen -n 100000 -type random\n\n# Testcase 15: Large n, maximum length vectors\n./gen -n 100000 -type maxlen\n\n# Testcase 16: Large n, minimum length vectors\n./gen -n 100000 -type minlen\n\n# Testcase 17: Large n, vectors along axes\n./gen -n 100000 -type onaxis\n\n# Testcase 18: Large n, same vectors\n./gen -n 100000 -type same\n\n# Testcase 19: Large n, alternating opposite vectors\n./gen -n 100000 -type opposite\n\n# Testcase 20: Large n, clustered vectors\n./gen -n 100000 -type clustered\n\n# Testcase 21: Small n, negative vectors\n./gen -n 10 -type negative\n\n# Testcase 22: Medium n, negative vectors\n./gen -n 1000 -type negative\n\n# Testcase 23: Large n, negative vectors\n./gen -n 100000 -type negative\n\n# Testcase 24: Small n, positive vectors\n./gen -n 10 -type positive\n\n# Testcase 25: Medium n, positive vectors\n./gen -n 1000 -type positive\n\n# Testcase 26: Large n, positive vectors\n./gen -n 100000 -type positive\n\n# Testcase 27: Small n, zero vectors\n./gen -n 10 -type zeros\n\n# Testcase 28: Medium n, zero vectors\n./gen -n 1000 -type zeros\n\n# Testcase 29: n near maximum limit, random vectors\n./gen -n 99999 -type random\n\n# Testcase 30: Maximum n, random vectors\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:44.132403",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "995/D",
      "title": "D. Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and rr (1≤n≤181≤n≤18, 0≤r≤2180≤r≤218).The next line contains 2n2n integers c0,c1,…,c2n−1c0,c1,…,c2n−1 (0≤ci≤1090≤ci≤109), denoting the initial values of ff. More specifically, f(x0,x1,…,xn−1)=cxf(x0,x1,…,xn−1)=cx, if x=xn−1…x0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯x=xn−1…x0¯ in binary.Each of the next rr lines contains two integers zz and gg (0≤z≤2n−10≤z≤2n−1, 0≤g≤1090≤g≤109). If z=zn−1…z0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯z=zn−1…z0¯ in binary, then this means to set f(z0,…,zn−1)→gf(z0,…,zn−1)→g.",
      "output_spec": "OutputPrint r+1r+1 lines, the ii-th of which denotes the value of the game ff during the ii-th round. Your answer must have absolute or relative error within 10−610−6.Formally, let your answer be aa, and the jury's answer be bb. Your answer is considered correct if |a−b|max(1,|b|)≤10−6|a−b|max(1,|b|)≤10−6.",
      "sample_tests": "ExamplesInputCopy2 20 1 2 32 50 4OutputCopy1.5000002.2500003.250000InputCopy1 02 3OutputCopy2.500000InputCopy2 01 1 1 1OutputCopy1.000000",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and rr (1≤n≤181≤n≤18, 0≤r≤2180≤r≤218).The next line contains 2n2n integers c0,c1,…,c2n−1c0,c1,…,c2n−1 (0≤ci≤1090≤ci≤109), denoting the initial values of ff. More specifically, f(x0,x1,…,xn−1)=cxf(x0,x1,…,xn−1)=cx, if x=xn−1…x0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯x=xn−1…x0¯ in binary.Each of the next rr lines contains two integers zz and gg (0≤z≤2n−10≤z≤2n−1, 0≤g≤1090≤g≤109). If z=zn−1…z0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯z=zn−1…z0¯ in binary, then this means to set f(z0,…,zn−1)→gf(z0,…,zn−1)→g.\n\nOutputPrint r+1r+1 lines, the ii-th of which denotes the value of the game ff during the ii-th round. Your answer must have absolute or relative error within 10−610−6.Formally, let your answer be aa, and the jury's answer be bb. Your answer is considered correct if |a−b|max(1,|b|)≤10−6|a−b|max(1,|b|)≤10−6.\n\nInputCopy2 20 1 2 32 50 4OutputCopy1.5000002.2500003.250000InputCopy1 02 3OutputCopy2.500000InputCopy2 01 1 1 1OutputCopy1.000000\n\nInputCopy2 20 1 2 32 50 4\n\nOutputCopy1.5000002.2500003.250000\n\nInputCopy1 02 3\n\nOutputCopy2.500000\n\nInputCopy2 01 1 1 1\n\nOutputCopy1.000000\n\nNoteConsider the second test case. If Allen goes first, he will set x1→1x1→1, so the final value will be 33. If Bessie goes first, then she will set x1→0x1→0 so the final value will be 22. Thus the answer is 2.52.5.In the third test case, the game value will always be 11 regardless of Allen and Bessie's play.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 995\\s*D"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(0, 262144, \"r\");\n    inf.readEoln();\n\n    int size = 1 << n;\n\n    vector<int> c = inf.readInts(size, 0, 1000000000);\n    inf.readEoln();\n\n    for (int i = 0; i < r; ++i) {\n        int z = inf.readInt(0, size - 1, \"z\");\n        inf.readSpace();\n        int g = inf.readInt(0, 1000000000, \"g\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(0, 262144, \"r\");\n    inf.readEoln();\n\n    int size = 1 << n;\n\n    vector<int> c = inf.readInts(size, 0, 1000000000);\n    inf.readEoln();\n\n    for (int i = 0; i < r; ++i) {\n        int z = inf.readInt(0, size - 1, \"z\");\n        inf.readSpace();\n        int g = inf.readInt(0, 1000000000, \"g\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(0, 262144, \"r\");\n    inf.readEoln();\n\n    int size = 1 << n;\n\n    vector<int> c = inf.readInts(size, 0, 1000000000);\n    inf.readEoln();\n\n    for (int i = 0; i < r; ++i) {\n        int z = inf.readInt(0, size - 1, \"z\");\n        inf.readSpace();\n        int g = inf.readInt(0, 1000000000, \"g\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\", 0);\n    string ctype = opt<string>(\"ctype\", \"random\"); // Type of initial c_i\n    string rtype = opt<string>(\"rtype\", \"random\"); // Type of updates\n\n    int N = 1 << n;\n    vector<int> c(N);\n\n    // Generate c_i according to ctype\n    if (ctype == \"random\") {\n        for (int i = 0; i < N; ++i) {\n            c[i] = rnd.next(0, 1000000000);\n        }\n    } else if (ctype == \"max\") {\n        for (int i = 0; i < N; ++i) {\n            c[i] = 1000000000;\n        }\n    } else if (ctype == \"min\") {\n        for (int i = 0; i < N; ++i) {\n            c[i] = 0;\n        }\n    } else if (ctype == \"same\") {\n        int val = rnd.next(0, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            c[i] = val;\n        }\n    } else if (ctype == \"inc\") {\n        if (N == 1) {\n            c[0] = 1000000000;\n        } else {\n            for (int i = 0; i < N; ++i) {\n                c[i] = (long long)(1000000000LL * i) / (N - 1);\n            }\n        }\n    } else if (ctype == \"dec\") {\n        if (N == 1) {\n            c[0] = 1000000000;\n        } else {\n            for (int i = 0; i < N; ++i) {\n                c[i] = (long long)(1000000000LL * (N - 1 - i)) / (N - 1);\n            }\n        }\n    } else {\n        // Default to random if unknown\n        for (int i = 0; i < N; ++i) {\n            c[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    vector<pair<int, int> > changes;\n\n    if (r > 0) {\n        if (rtype == \"random\") {\n            for (int i = 0; i < r; ++i) {\n                int z = rnd.next(0, N - 1);\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"first\") {\n            for (int i = 0; i < r; ++i) {\n                int z = 0;\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"last\") {\n            for (int i = 0; i < r; ++i) {\n                int z = N - 1;\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"all_same\") {\n            int z = rnd.next(0, N - 1);\n            for (int i = 0; i < r; ++i) {\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"many_same\") {\n            int k = rnd.next(1, min(10, N));\n            vector<int> zs;\n            set<int> sz;\n            while ((int)sz.size() < k) {\n                int z = rnd.next(0, N - 1);\n                sz.insert(z);\n            }\n            zs.assign(sz.begin(), sz.end());\n            for (int i = 0; i < r; ++i) {\n                int z = zs[rnd.next(0, k - 1)];\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < r; ++i) {\n                int z = rnd.next(0, N - 1);\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, r);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 < N) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < r; ++i) {\n        printf(\"%d %d\\n\", changes[i].first, changes[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\", 0);\n    string ctype = opt<string>(\"ctype\", \"random\"); // Type of initial c_i\n    string rtype = opt<string>(\"rtype\", \"random\"); // Type of updates\n\n    int N = 1 << n;\n    vector<int> c(N);\n\n    // Generate c_i according to ctype\n    if (ctype == \"random\") {\n        for (int i = 0; i < N; ++i) {\n            c[i] = rnd.next(0, 1000000000);\n        }\n    } else if (ctype == \"max\") {\n        for (int i = 0; i < N; ++i) {\n            c[i] = 1000000000;\n        }\n    } else if (ctype == \"min\") {\n        for (int i = 0; i < N; ++i) {\n            c[i] = 0;\n        }\n    } else if (ctype == \"same\") {\n        int val = rnd.next(0, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            c[i] = val;\n        }\n    } else if (ctype == \"inc\") {\n        if (N == 1) {\n            c[0] = 1000000000;\n        } else {\n            for (int i = 0; i < N; ++i) {\n                c[i] = (long long)(1000000000LL * i) / (N - 1);\n            }\n        }\n    } else if (ctype == \"dec\") {\n        if (N == 1) {\n            c[0] = 1000000000;\n        } else {\n            for (int i = 0; i < N; ++i) {\n                c[i] = (long long)(1000000000LL * (N - 1 - i)) / (N - 1);\n            }\n        }\n    } else {\n        // Default to random if unknown\n        for (int i = 0; i < N; ++i) {\n            c[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    vector<pair<int, int> > changes;\n\n    if (r > 0) {\n        if (rtype == \"random\") {\n            for (int i = 0; i < r; ++i) {\n                int z = rnd.next(0, N - 1);\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"first\") {\n            for (int i = 0; i < r; ++i) {\n                int z = 0;\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"last\") {\n            for (int i = 0; i < r; ++i) {\n                int z = N - 1;\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"all_same\") {\n            int z = rnd.next(0, N - 1);\n            for (int i = 0; i < r; ++i) {\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else if (rtype == \"many_same\") {\n            int k = rnd.next(1, min(10, N));\n            vector<int> zs;\n            set<int> sz;\n            while ((int)sz.size() < k) {\n                int z = rnd.next(0, N - 1);\n                sz.insert(z);\n            }\n            zs.assign(sz.begin(), sz.end());\n            for (int i = 0; i < r; ++i) {\n                int z = zs[rnd.next(0, k - 1)];\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < r; ++i) {\n                int z = rnd.next(0, N - 1);\n                int g = rnd.next(0, 1000000000);\n                changes.push_back(make_pair(z, g));\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, r);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 < N) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < r; ++i) {\n        printf(\"%d %d\\n\", changes[i].first, changes[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest n, no changes\n./gen -n 1 -r 0 -ctype min -rtype none\n./gen -n 1 -r 1 -ctype min -rtype random\n./gen -n 1 -r 1 -ctype max -rtype random\n./gen -n 1 -r 1 -ctype random -rtype first\n\n# Small n, some changes\n./gen -n 2 -r 2 -ctype random -rtype random\n./gen -n 2 -r 4 -ctype same -rtype all_same\n./gen -n 2 -r 3 -ctype inc -rtype many_same\n\n# Medium n, no changes\n./gen -n 5 -r 0 -ctype random\n\n# Medium n, small changes\n./gen -n 5 -r 10 -ctype random -rtype random\n./gen -n 5 -r 10 -ctype min -rtype last\n\n# Medium n, large changes\n./gen -n 5 -r 1000 -ctype random -rtype random\n\n# Large n, no changes\n./gen -n 10 -r 0 -ctype random\n\n# Large n, small changes\n./gen -n 10 -r 10 -ctype random -rtype random\n./gen -n 10 -r 100000 -ctype random -rtype random\n\n# Max n, no changes\n./gen -n 18 -r 0 -ctype random\n\n# Max n, small changes\n./gen -n 18 -r 10 -ctype random -rtype random\n\n# Max n, max changes\n./gen -n 18 -r 262144 -ctype random -rtype random\n\n# Test with ctype \"inc\" and \"dec\"\n./gen -n 10 -r 1000 -ctype inc -rtype random\n./gen -n 10 -r 1000 -ctype dec -rtype random\n\n# Test with ctype \"same\"\n./gen -n 15 -r 10000 -ctype same -rtype random\n\n# Test with rtype \"first\" and \"last\"\n./gen -n 15 -r 10000 -ctype random -rtype first\n./gen -n 15 -r 10000 -ctype random -rtype last\n\n# Test with rtype \"all_same\"\n./gen -n 15 -r 10000 -ctype random -rtype all_same\n\n# Test with maximum c_i values\n./gen -n 15 -r 100000 -ctype max -rtype random\n\n# Test with minimum c_i values\n./gen -n 15 -r 100000 -ctype min -rtype random\n\n# Edge case with n=1 and maximum r\n./gen -n 1 -r 262144 -ctype random -rtype random\n\n# Edge case with n=1 and ctype \"inc\" and \"dec\"\n./gen -n 1 -r 0 -ctype inc\n./gen -n 1 -r 0 -ctype dec\n\n# Edge case with n=10 and maximum r\n./gen -n 10 -r 262144 -ctype random -rtype random\n\n# Edge case with n=18 and ctype \"inc\" and \"dec\"\n./gen -n 18 -r 1000 -ctype inc -rtype many_same\n./gen -n 18 -r 1000 -ctype dec -rtype many_same\n\n# Edge case with ctype \"same\" and rtype \"many_same\"\n./gen -n 16 -r 50000 -ctype same -rtype many_same\n\n# Edge case: r=0\n./gen -n 17 -r 0 -ctype random\n\n# Edge case: r=N (maximum allowed r for n=18)\n./gen -n 18 -r 262144 -ctype random -rtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:46.119259",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "995/E",
      "title": "E. Number Clicker",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains 3 positive integers: u,v,pu,v,p (0≤u,v≤p−10≤u,v≤p−1, 3≤p≤109+93≤p≤109+9). pp is guaranteed to be prime.",
      "output_spec": "OutputOn the first line, print a single integer ℓℓ, the number of button presses. On the second line, print integers c1,…,cℓc1,…,cℓ, the button presses. For 1≤i≤ℓ1≤i≤ℓ, 1≤ci≤31≤ci≤3.We can show that the answer always exists.",
      "sample_tests": "ExamplesInputCopy1 3 5OutputCopy21 1InputCopy3 2 5OutputCopy13",
      "description": "E. Number Clicker\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains 3 positive integers: u,v,pu,v,p (0≤u,v≤p−10≤u,v≤p−1, 3≤p≤109+93≤p≤109+9). pp is guaranteed to be prime.\n\nOutputOn the first line, print a single integer ℓℓ, the number of button presses. On the second line, print integers c1,…,cℓc1,…,cℓ, the button presses. For 1≤i≤ℓ1≤i≤ℓ, 1≤ci≤31≤ci≤3.We can show that the answer always exists.\n\nInputCopy1 3 5OutputCopy21 1InputCopy3 2 5OutputCopy13\n\nInputCopy1 3 5\n\nOutputCopy21 1\n\nInputCopy3 2 5\n\nOutputCopy13\n\nNoteIn the first example the integer on the screen changes as 1→2→31→2→3.In the second example the integer on the screen changes as 3→23→2.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 995\\s*E"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long mod) {\n    long long res = 0LL;\n    a %= mod;\n    b %= mod;\n    while (b > 0LL) {\n        if (b & 1LL) {\n            res = (res + a) % mod;\n        }\n        a = (a * 2LL) % mod;\n        b >>= 1LL;\n    }\n    return res % mod;\n}\n\nlong long powmod(long long a, long long n, long long mod) {\n    long long res = 1LL;\n    a = a % mod;\n    while (n > 0LL) {\n        if (n & 1LL)\n            res = mulmod(res, a, mod);\n        a = mulmod(a, a, mod);\n        n >>= 1LL;\n    }\n    return res;\n}\n\nbool isPrime(long long n) {\n    if (n <= 1LL) return false;\n    if (n <= 3LL) return true;\n    if (n % 2LL == 0LL) return false;\n    long long d = n - 1LL;\n    int s = 0;\n    while (d % 2LL == 0LL) {\n        d /= 2LL;\n        s += 1;\n    }\n    int witnesses[] = {2,3,5,7,11};\n    for (int i = 0; i < 5; i++) {\n        int a = witnesses[i];\n        if (a >= n) continue;\n        long long x = powmod(a, d, n);\n        if (x == 1LL || x == n - 1LL)\n            continue;\n        bool composite = true;\n        for (int r = 1; r < s; r++) {\n            x = mulmod(x, x, n);\n            if (x == n - 1LL) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long u = inf.readLong(0LL, 1000000009LL, \"u\");\n    inf.readSpace();\n    long long v = inf.readLong(0LL, 1000000009LL, \"v\");\n    inf.readSpace();\n    long long p = inf.readLong(3LL, 1000000009LL, \"p\");\n    inf.readEoln();\n    ensuref(u >= 0LL && u <= p - 1LL, \"u=%lld must be in [0, p-1=%lld]\", u, p - 1LL);\n    ensuref(v >= 0LL && v <= p - 1LL, \"v=%lld must be in [0, p-1=%lld]\", v, p - 1LL);\n    ensuref(isPrime(p), \"p=%lld must be prime\", p);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long mod) {\n    long long res = 0LL;\n    a %= mod;\n    b %= mod;\n    while (b > 0LL) {\n        if (b & 1LL) {\n            res = (res + a) % mod;\n        }\n        a = (a * 2LL) % mod;\n        b >>= 1LL;\n    }\n    return res % mod;\n}\n\nlong long powmod(long long a, long long n, long long mod) {\n    long long res = 1LL;\n    a = a % mod;\n    while (n > 0LL) {\n        if (n & 1LL)\n            res = mulmod(res, a, mod);\n        a = mulmod(a, a, mod);\n        n >>= 1LL;\n    }\n    return res;\n}\n\nbool isPrime(long long n) {\n    if (n <= 1LL) return false;\n    if (n <= 3LL) return true;\n    if (n % 2LL == 0LL) return false;\n    long long d = n - 1LL;\n    int s = 0;\n    while (d % 2LL == 0LL) {\n        d /= 2LL;\n        s += 1;\n    }\n    int witnesses[] = {2,3,5,7,11};\n    for (int i = 0; i < 5; i++) {\n        int a = witnesses[i];\n        if (a >= n) continue;\n        long long x = powmod(a, d, n);\n        if (x == 1LL || x == n - 1LL)\n            continue;\n        bool composite = true;\n        for (int r = 1; r < s; r++) {\n            x = mulmod(x, x, n);\n            if (x == n - 1LL) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long u = inf.readLong(0LL, 1000000009LL, \"u\");\n    inf.readSpace();\n    long long v = inf.readLong(0LL, 1000000009LL, \"v\");\n    inf.readSpace();\n    long long p = inf.readLong(3LL, 1000000009LL, \"p\");\n    inf.readEoln();\n    ensuref(u >= 0LL && u <= p - 1LL, \"u=%lld must be in [0, p-1=%lld]\", u, p - 1LL);\n    ensuref(v >= 0LL && v <= p - 1LL, \"v=%lld must be in [0, p-1=%lld]\", v, p - 1LL);\n    ensuref(isPrime(p), \"p=%lld must be prime\", p);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long mod) {\n    long long res = 0LL;\n    a %= mod;\n    b %= mod;\n    while (b > 0LL) {\n        if (b & 1LL) {\n            res = (res + a) % mod;\n        }\n        a = (a * 2LL) % mod;\n        b >>= 1LL;\n    }\n    return res % mod;\n}\n\nlong long powmod(long long a, long long n, long long mod) {\n    long long res = 1LL;\n    a = a % mod;\n    while (n > 0LL) {\n        if (n & 1LL)\n            res = mulmod(res, a, mod);\n        a = mulmod(a, a, mod);\n        n >>= 1LL;\n    }\n    return res;\n}\n\nbool isPrime(long long n) {\n    if (n <= 1LL) return false;\n    if (n <= 3LL) return true;\n    if (n % 2LL == 0LL) return false;\n    long long d = n - 1LL;\n    int s = 0;\n    while (d % 2LL == 0LL) {\n        d /= 2LL;\n        s += 1;\n    }\n    int witnesses[] = {2,3,5,7,11};\n    for (int i = 0; i < 5; i++) {\n        int a = witnesses[i];\n        if (a >= n) continue;\n        long long x = powmod(a, d, n);\n        if (x == 1LL || x == n - 1LL)\n            continue;\n        bool composite = true;\n        for (int r = 1; r < s; r++) {\n            x = mulmod(x, x, n);\n            if (x == n - 1LL) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long u = inf.readLong(0LL, 1000000009LL, \"u\");\n    inf.readSpace();\n    long long v = inf.readLong(0LL, 1000000009LL, \"v\");\n    inf.readSpace();\n    long long p = inf.readLong(3LL, 1000000009LL, \"p\");\n    inf.readEoln();\n    ensuref(u >= 0LL && u <= p - 1LL, \"u=%lld must be in [0, p-1=%lld]\", u, p - 1LL);\n    ensuref(v >= 0LL && v <= p - 1LL, \"v=%lld must be in [0, p-1=%lld]\", v, p - 1LL);\n    ensuref(isPrime(p), \"p=%lld must be prime\", p);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute (base^exponent) mod mod\nint modexp(int base, int exponent, int mod) {\n    int result = 1;\n    base %= mod;\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = int((1LL * result * base) % mod);\n        base = int((1LL * base * base) % mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read u, v, p from the input file\n    int u = inf.readInt(0, 1000000009, \"u\");\n    int v = inf.readInt(0, 1000000009, \"v\");\n    int p = inf.readInt(3, 1000000009, \"p\");\n\n    // Ensure that u and v are in [0, p - 1]\n    if (u < 0 || u >= p)\n        quitf(_fail, \"Invalid input: u = %d is not in [0, p - 1]\", u);\n    if (v < 0 || v >= p)\n        quitf(_fail, \"Invalid input: v = %d is not in [0, p - 1]\", v);\n\n    // Read the contestant's output\n    int l = ouf.readInt(0, 200, \"l\");\n\n    vector<int> c(l);\n    for (int i = 0; i < l; ++i) {\n        c[i] = ouf.readInt(1, 3, format(\"c[%d]\", i + 1).c_str());\n    }\n\n    // Simulate the button presses\n    int cur = u;\n    for (int i = 0; i < l; ++i) {\n        int ci = c[i];\n        if (ci == 1) {\n            cur = (cur + 1) % p;\n        } else if (ci == 2) {\n            cur = (cur + p - 1) % p;\n        } else if (ci == 3) {\n            if (cur == 0) {\n                // 0^(p-2) mod p is 0\n                cur = 0;\n            } else {\n                cur = modexp(cur, p - 2, p);\n            }\n        } else {\n            // This case should not happen due to the readInt validation\n            quitf(_fail, \"Invalid button number %d at position %d\", ci, i + 1);\n        }\n    }\n\n    // Check if the final value matches v\n    if (cur == v) {\n        quitf(_ok, \"Answer is correct\");\n    } else {\n        quitf(_wa, \"Final value is %d, expected %d\", cur, v);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mod_pow(long long base, long long exp, long long mod) {\n    long long result = 1 % mod;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1LL)\n            result = result * base % mod;\n        base = base * base % mod;\n        exp >>= 1LL;\n    }\n    return result;\n}\n\nlong long mod_inverse(long long a, long long p) {\n    if (a == 0) return 0; // Inverse of 0 is 0 in this context\n    // Assume p is prime\n    return mod_pow(a, p - 2, p);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long p = opt<long long>(\"p\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (p == 0) {\n        vector<long long> primes = {1000000007LL, 1000000009LL, 999999937LL, 999999929LL, 999999893LL, 1000003LL, 1000033LL, 1000037LL, 100019LL, 17LL, 23LL, 29LL, 31LL, 3LL, 5LL, 7LL, 11LL, 13LL};\n        p = primes[rnd.next(0, (int)primes.size() - 1)];\n    }\n\n    ensure(p >= 3 && p <= 1000000009LL);\n\n    long long u, v;\n\n    if (type == \"random\") {\n        u = rnd.next(0LL, p - 1);\n        v = rnd.next(0LL, p - 1);\n    } else if (type == \"u_zero\") {\n        u = 0;\n        v = rnd.next(0LL, p - 1);\n    } else if (type == \"v_zero\") {\n        u = rnd.next(0LL, p - 1);\n        v = 0;\n    } else if (type == \"u_eq_v\") {\n        u = rnd.next(0LL, p - 1);\n        v = u;\n    } else if (type == \"u_inverse_v\") {\n        v = rnd.next(1LL, p - 1);\n        u = mod_inverse(v, p);\n    } else if (type == \"max\") {\n        u = p - 1;\n        v = p - 1;\n    } else if (type == \"min\") {\n        u = 0;\n        v = 0;\n    } else if (type == \"near\") {\n        u = rnd.next(0LL, p - 1);\n        long long delta = rnd.next(-10LL, 10LL);\n        v = (u + delta + p) % p;\n    } else if (type == \"far\") {\n        u = rnd.next(0LL, p - 1);\n        v = (u + p / 2) % p;\n    } else {\n        // Default to random\n        u = rnd.next(0LL, p - 1);\n        v = rnd.next(0LL, p - 1);\n    }\n\n    ensure(0 <= u && u <= p - 1);\n    ensure(0 <= v && v <= p - 1);\n\n    printf(\"%lld %lld %lld\\n\", u, v, p);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mod_pow(long long base, long long exp, long long mod) {\n    long long result = 1 % mod;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1LL)\n            result = result * base % mod;\n        base = base * base % mod;\n        exp >>= 1LL;\n    }\n    return result;\n}\n\nlong long mod_inverse(long long a, long long p) {\n    if (a == 0) return 0; // Inverse of 0 is 0 in this context\n    // Assume p is prime\n    return mod_pow(a, p - 2, p);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long p = opt<long long>(\"p\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (p == 0) {\n        vector<long long> primes = {1000000007LL, 1000000009LL, 999999937LL, 999999929LL, 999999893LL, 1000003LL, 1000033LL, 1000037LL, 100019LL, 17LL, 23LL, 29LL, 31LL, 3LL, 5LL, 7LL, 11LL, 13LL};\n        p = primes[rnd.next(0, (int)primes.size() - 1)];\n    }\n\n    ensure(p >= 3 && p <= 1000000009LL);\n\n    long long u, v;\n\n    if (type == \"random\") {\n        u = rnd.next(0LL, p - 1);\n        v = rnd.next(0LL, p - 1);\n    } else if (type == \"u_zero\") {\n        u = 0;\n        v = rnd.next(0LL, p - 1);\n    } else if (type == \"v_zero\") {\n        u = rnd.next(0LL, p - 1);\n        v = 0;\n    } else if (type == \"u_eq_v\") {\n        u = rnd.next(0LL, p - 1);\n        v = u;\n    } else if (type == \"u_inverse_v\") {\n        v = rnd.next(1LL, p - 1);\n        u = mod_inverse(v, p);\n    } else if (type == \"max\") {\n        u = p - 1;\n        v = p - 1;\n    } else if (type == \"min\") {\n        u = 0;\n        v = 0;\n    } else if (type == \"near\") {\n        u = rnd.next(0LL, p - 1);\n        long long delta = rnd.next(-10LL, 10LL);\n        v = (u + delta + p) % p;\n    } else if (type == \"far\") {\n        u = rnd.next(0LL, p - 1);\n        v = (u + p / 2) % p;\n    } else {\n        // Default to random\n        u = rnd.next(0LL, p - 1);\n        v = rnd.next(0LL, p - 1);\n    }\n\n    ensure(0 <= u && u <= p - 1);\n    ensure(0 <= v && v <= p - 1);\n\n    printf(\"%lld %lld %lld\\n\", u, v, p);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -p 3 -type min\n./gen -p 3 -type max\n./gen -p 3 -type random\n./gen -p 3 -type u_zero\n./gen -p 3 -type v_zero\n./gen -p 3 -type u_eq_v\n./gen -p 3 -type u_inverse_v\n./gen -p 3 -type near\n./gen -p 3 -type far\n\n./gen -p 1000000007 -type min\n./gen -p 1000000007 -type max\n./gen -p 1000000007 -type random\n./gen -p 1000000007 -type u_zero\n./gen -p 1000000007 -type v_zero\n./gen -p 1000000007 -type u_eq_v\n./gen -p 1000000007 -type u_inverse_v\n./gen -p 1000000007 -type near\n./gen -p 1000000007 -type far\n\n./gen -p 0 -type random\n./gen -p 0 -type u_eq_v\n./gen -p 0 -type u_zero\n./gen -p 0 -type v_zero\n./gen -p 0 -type u_inverse_v\n./gen -p 0 -type near\n./gen -p 0 -type far\n\n./gen -p 999999937 -type random\n./gen -p 999999937 -type u_eq_v\n./gen -p 999999937 -type u_zero\n./gen -p 999999937 -type v_zero\n./gen -p 999999937 -type u_inverse_v\n./gen -p 999999937 -type near\n./gen -p 999999937 -type far\n\n./gen -p 17 -type random\n./gen -p 17 -type u_eq_v\n./gen -p 17 -type u_zero\n./gen -p 17 -type v_zero\n./gen -p 17 -type u_inverse_v\n./gen -p 17 -type near\n./gen -p 17 -type far\n\n./gen -p 5 -type random\n./gen -p 5 -type u_eq_v\n./gen -p 5 -type u_zero\n./gen -p 5 -type v_zero\n./gen -p 5 -type u_inverse_v\n./gen -p 5 -type near\n./gen -p 5 -type far\n\n./gen -p 0 -type max\n./gen -p 0 -type min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:48.342583",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "995/F",
      "title": "F. Зарплаты в комуупании",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа nn и DD (1≤n≤30001≤n≤3000, 1≤D≤1091≤D≤109).Каждая из следующих n−1n−1 строк содержит одно целое число, где ii-я строка содержит целое число pipi (1≤pi≤i1≤pi≤i). pipi обозначает номер непосредственного начальника сотрудника номер i+1i+1.",
      "output_spec": "Выходные данныеВыведите одно целое число: количество способов назначить зарплаты по модулю 109+7109+7.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 211Выходные данныеСкопировать5Входные данныеСкопировать3 312Выходные данныеСкопировать10Входные данныеСкопировать2 51Выходные данныеСкопировать15",
      "description": "F. Зарплаты в комуупании\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа nn и DD (1≤n≤30001≤n≤3000, 1≤D≤1091≤D≤109).Каждая из следующих n−1n−1 строк содержит одно целое число, где ii-я строка содержит целое число pipi (1≤pi≤i1≤pi≤i). pipi обозначает номер непосредственного начальника сотрудника номер i+1i+1.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число: количество способов назначить зарплаты по модулю 109+7109+7.\n\nВыходные данные\n\nВходные данныеСкопировать3 211Выходные данныеСкопировать5Входные данныеСкопировать3 312Выходные данныеСкопировать10Входные данныеСкопировать2 51Выходные данныеСкопировать15\n\nВходные данныеСкопировать3 211\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 312\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 51\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать15\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере сотрудники с номерами 2 и 3 подчиняются непосредственно Аллену. Три зарплаты по порядку могут быть (1,1,1)(1,1,1), (2,1,1)(2,1,1), (2,1,2)(2,1,2), (2,2,1)(2,2,1) или (2,2,2)(2,2,2).Во втором примере сотрудник 2 подчиняется Аллену, а сотрудник 3 подчиняется сотруднику 2. Возможные зарплаты равны (1,1,1)(1,1,1), (2,1,1)(2,1,1), (2,2,1)(2,2,1), (2,2,2)(2,2,2), (3,1,1)(3,1,1), (3,2,1)(3,2,1), (3,2,2)(3,2,2), (3,3,1)(3,3,1), (3,3,2)(3,3,2), (3,3,3)(3,3,3).",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 995\\s*F"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int D = inf.readInt(1, 1000000000, \"D\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        int p_i = inf.readInt(1, i, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int D = inf.readInt(1, 1000000000, \"D\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        int p_i = inf.readInt(1, i, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int D = inf.readInt(1, 1000000000, \"D\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        int p_i = inf.readInt(1, i, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int D = opt<int>(\"D\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n); // p[0..n-1], p_i is the superior of employee i+1\n\n    if (type == \"chain\") {\n        // Chain: employee i+1 reports to employee i\n        for(int i = 1; i < n; ++i)\n            p[i] = i;\n    } else if (type == \"star\") {\n        // Star: all employees report directly to Allen (employee 1)\n        for(int i = 1; i < n; ++i)\n            p[i] = 1;\n    } else if (type == \"binary\") {\n        // Balanced binary tree\n        for(int i = 1; i < n; ++i)\n            p[i] = (i+1)/2; // parent of node i+1\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(1, i);\n    }\n\n    // Output n and D\n    printf(\"%d %d\\n\", n, D);\n    // Output p_i\n    for(int i = 1; i < n; ++i)\n        printf(\"%d\\n\", p[i]);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int D = opt<int>(\"D\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n); // p[0..n-1], p_i is the superior of employee i+1\n\n    if (type == \"chain\") {\n        // Chain: employee i+1 reports to employee i\n        for(int i = 1; i < n; ++i)\n            p[i] = i;\n    } else if (type == \"star\") {\n        // Star: all employees report directly to Allen (employee 1)\n        for(int i = 1; i < n; ++i)\n            p[i] = 1;\n    } else if (type == \"binary\") {\n        // Balanced binary tree\n        for(int i = 1; i < n; ++i)\n            p[i] = (i+1)/2; // parent of node i+1\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(1, i);\n    }\n\n    // Output n and D\n    printf(\"%d %d\\n\", n, D);\n    // Output p_i\n    for(int i = 1; i < n; ++i)\n        printf(\"%d\\n\", p[i]);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -D 1 -type chain\n./gen -n 1 -D 1000000000 -type chain\n\n./gen -n 2 -D 1 -type star\n./gen -n 2 -D 1 -type chain\n\n./gen -n 2 -D 1000000000 -type star\n./gen -n 2 -D 1000000000 -type chain\n\n./gen -n 10 -D 1 -type random\n./gen -n 10 -D 1000000000 -type random\n./gen -n 10 -D 100 -type binary\n./gen -n 10 -D 1000000000 -type binary\n\n./gen -n 1000 -D 1 -type star\n./gen -n 1000 -D 1000000000 -type star\n./gen -n 1000 -D 1 -type chain\n./gen -n 1000 -D 1000000000 -type chain\n./gen -n 1000 -D 1 -type random\n./gen -n 1000 -D 1000000000 -type random\n\n./gen -n 3000 -D 1000000000 -type random\n./gen -n 3000 -D 1 -type random\n./gen -n 3000 -D 1000000000 -type chain\n./gen -n 3000 -D 1000000000 -type star\n./gen -n 3000 -D 1000000000 -type binary\n\n./gen -n 3000 -D 100 -type random\n./gen -n 3000 -D 2 -type chain\n./gen -n 3000 -D 2 -type star\n./gen -n 3000 -D 2 -type random\n./gen -n 3000 -D 10 -type binary\n\n./gen -n 10 -D 5 -type random\n./gen -n 10 -D 1000000000 -type chain\n./gen -n 10 -D 1000000000 -type star\n./gen -n 10 -D 1000000000 -type binary\n\n./gen -n 100 -D 500000000 -type random\n./gen -n 100 -D 1 -type chain\n./gen -n 100 -D 1000000000 -type star\n./gen -n 100 -D 1 -type binary\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:50.132775",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "996/A",
      "title": "A. Выиграть в лотерею",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая и единственная строка содержит одно целое число nn (1≤n≤1091≤n≤109).",
      "output_spec": "Выходные данныеВыведите минимальное число купюр, которые должен получить Аллен.",
      "sample_tests": "ПримерыВходные данныеСкопировать125Выходные данныеСкопировать3Входные данныеСкопировать43Выходные данныеСкопировать5Входные данныеСкопировать1000000000Выходные данныеСкопировать10000000",
      "description": "A. Выиграть в лотерею\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая и единственная строка содержит одно целое число nn (1≤n≤1091≤n≤109).\n\nВходные данные\n\nВыходные данныеВыведите минимальное число купюр, которые должен получить Аллен.\n\nВыходные данные\n\nВходные данныеСкопировать125Выходные данныеСкопировать3Входные данныеСкопировать43Выходные данныеСкопировать5Входные данныеСкопировать1000000000Выходные данныеСкопировать10000000\n\nВходные данныеСкопировать125\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать43\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1000000000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Аллен может получить одну 100100-долларовую купюру, одну купюру в 2020 долларов и одну купюру в 55 долларов. Нельзя получить 125125 долларов с помощью одной или двух купюр.Во втором примере Аллен может получить две 2020-долларовые купюры и три купюры в 11 доллар.В третьем примере Аллен может снять 100000000100000000 (десять миллионов!) 100100-долларовых купюр.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 996\\s*A"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    vector<int> denominations = {1, 5, 10, 20, 100};\n\n    long long n = opt<long long>(\"n\", -1LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    int denom = -1;\n    if (type == \"multiple_of_denom\" || type == \"one_over_denom\" || type == \"one_under_denom\") {\n        denom = opt<int>(\"denom\", -1);\n        if (denom == -1) {\n            fprintf(stderr, \"Error: denom parameter is required for type %s\\n\", type.c_str());\n            exit(1);\n        }\n        ensure(denom > 0);\n        ensure(find(denominations.begin(), denominations.end(), denom) != denominations.end());\n    }\n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1LL;\n        } else if (type == \"max\") {\n            n = 1000000000LL;\n        } else if (type == \"random\") {\n            n = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"multiple_of_denom\") {\n            n = rnd.next(1LL, 1000000000LL / denom) * denom;\n        } else if (type == \"one_over_denom\") {\n            long long max_k = (1000000000LL - 1) / denom;\n            if (max_k <= 0) max_k = 1;\n            long long k = rnd.next(1LL, max_k);\n            n = k * denom + 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n        } else if (type == \"one_under_denom\") {\n            long long max_k = (1000000000LL) / denom;\n            if (max_k <= 1) max_k = 2;\n            long long k = rnd.next(2LL, max_k);\n            n = k * denom - 1;\n            if (n < 1) n = 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n        } else if (type == \"requires_ones\") {\n            n = rnd.next(1LL, 1000000000LL);\n            while (n % 5 == 0) {\n                n = rnd.next(1LL, 1000000000LL);\n            }\n        } else if (type == \"only_hundreds\") {\n            n = rnd.next(1LL, 1000000000LL / 100) * 100;\n        } else if (type == \"only_ones\") {\n            n = rnd.next(1, 4); // n between 1 and 4 inclusive\n        } else {\n            n = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    ensure(1LL <= n && n <= 1000000000LL);\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    vector<int> denominations = {1, 5, 10, 20, 100};\n\n    long long n = opt<long long>(\"n\", -1LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    int denom = -1;\n    if (type == \"multiple_of_denom\" || type == \"one_over_denom\" || type == \"one_under_denom\") {\n        denom = opt<int>(\"denom\", -1);\n        if (denom == -1) {\n            fprintf(stderr, \"Error: denom parameter is required for type %s\\n\", type.c_str());\n            exit(1);\n        }\n        ensure(denom > 0);\n        ensure(find(denominations.begin(), denominations.end(), denom) != denominations.end());\n    }\n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1LL;\n        } else if (type == \"max\") {\n            n = 1000000000LL;\n        } else if (type == \"random\") {\n            n = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"multiple_of_denom\") {\n            n = rnd.next(1LL, 1000000000LL / denom) * denom;\n        } else if (type == \"one_over_denom\") {\n            long long max_k = (1000000000LL - 1) / denom;\n            if (max_k <= 0) max_k = 1;\n            long long k = rnd.next(1LL, max_k);\n            n = k * denom + 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n        } else if (type == \"one_under_denom\") {\n            long long max_k = (1000000000LL) / denom;\n            if (max_k <= 1) max_k = 2;\n            long long k = rnd.next(2LL, max_k);\n            n = k * denom - 1;\n            if (n < 1) n = 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n        } else if (type == \"requires_ones\") {\n            n = rnd.next(1LL, 1000000000LL);\n            while (n % 5 == 0) {\n                n = rnd.next(1LL, 1000000000LL);\n            }\n        } else if (type == \"only_hundreds\") {\n            n = rnd.next(1LL, 1000000000LL / 100) * 100;\n        } else if (type == \"only_ones\") {\n            n = rnd.next(1, 4); // n between 1 and 4 inclusive\n        } else {\n            n = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    ensure(1LL <= n && n <= 1000000000LL);\n\n    printf(\"%lld\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type random\n\n./gen -n 1\n./gen -n 5\n./gen -n 10\n./gen -n 20\n./gen -n 100\n\n./gen -n 125\n./gen -n 43\n./gen -n 1000000000\n\n./gen -type multiple_of_denom -denom 5\n./gen -type multiple_of_denom -denom 10\n./gen -type multiple_of_denom -denom 20\n./gen -type multiple_of_denom -denom 100\n\n./gen -type one_over_denom -denom 5\n./gen -type one_over_denom -denom 10\n./gen -type one_under_denom -denom 20\n./gen -type one_under_denom -denom 100\n\n./gen -type requires_ones\n./gen -type only_hundreds\n./gen -type only_ones\n\n./gen -n 999999999\n./gen -n 555\n./gen -n 22222\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type requires_ones\n./gen -type requires_ones\n\n./gen -type multiple_of_denom -denom 1\n./gen -type multiple_of_denom -denom 5\n./gen -type multiple_of_denom -denom 100\n\n./gen -type one_over_denom -denom 5\n./gen -type one_under_denom -denom 5\n./gen -type one_over_denom -denom 100\n./gen -type one_under_denom -denom 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:51.932944",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "996/B",
      "title": "B. World Cup",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (2≤n≤1052≤n≤105) — the number of entrances.The second line contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤1090≤ai≤109) — the number of people in queues. These numbers do not include Allen.",
      "output_spec": "OutputPrint a single integer — the number of entrance that Allen will use.",
      "sample_tests": "ExamplesInputCopy42 3 2 0OutputCopy3InputCopy210 10OutputCopy1InputCopy65 2 6 5 7 4OutputCopy6",
      "description": "B. World Cup\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (2≤n≤1052≤n≤105) — the number of entrances.The second line contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤1090≤ai≤109) — the number of people in queues. These numbers do not include Allen.\n\nOutputPrint a single integer — the number of entrance that Allen will use.\n\nInputCopy42 3 2 0OutputCopy3InputCopy210 10OutputCopy1InputCopy65 2 6 5 7 4OutputCopy6\n\nInputCopy42 3 2 0\n\nOutputCopy3\n\nInputCopy210 10\n\nOutputCopy1\n\nInputCopy65 2 6 5 7 4\n\nOutputCopy6\n\nNoteIn the first example the number of people (not including Allen) changes as follows: [2,3,2,0]→[1,2,1,0]→[0,1,0,0][2,3,2,0]→[1,2,1,0]→[0,1,0,0]. The number in bold is the queue Alles stands in. We see that he will enter the fan zone through the third entrance.In the second example the number of people (not including Allen) changes as follows: [10,10]→[9,9]→[8,8]→[7,7]→[6,6]→[5,5]→[4,4]→[3,3]→[2,2]→[1,1]→[0,0][10,10]→[9,9]→[8,8]→[7,7]→[6,6]→[5,5]→[4,4]→[3,3]→[2,2]→[1,1]→[0,0].In the third example the number of people (not including Allen) changes as follows: [5,2,6,5,7,4]→[4,1,5,4,6,3]→[3,0,4,3,5,2]→[2,0,3,2,4,1]→[1,0,2,1,3,0]→[0,0,1,0,2,0][5,2,6,5,7,4]→[4,1,5,4,6,3]→[3,0,4,3,5,2]→[2,0,3,2,4,1]→[1,0,2,1,3,0]→[0,0,1,0,2,0].",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 996\\s*B"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\"); // Number of entrances, 2 ≤ n ≤ 1e5\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"allzeros\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"allmax\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = min(1000000000, i * 10000); // Scale up to reach 1e9\n        }\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = min(1000000000, (n - i - 1) * 10000); // Scale up\n        }\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 0;\n            else\n                a[i] = 1000000000;\n        }\n    } else if (type == \"cycletest\") {\n        // Create a test case where Allen cycles around multiple times before entering\n        // To force Allen to make multiple rounds, set a[i] such that Allen needs to circle around multiple times\n        // For simplicity, set a[i] = k - i;\n        int k = opt<int>(\"k\", 100000); // Number of cycles\n        for(int i = 0; i < n; ++i) {\n            a[i] = max(0, k - i - 1);\n            a[i] = min(a[i], 1000000000);\n        }\n    } else if (type == \"big\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000 - 100000, 1000000000);\n        }\n    } else if (type == \"small\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\"); // Number of entrances, 2 ≤ n ≤ 1e5\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"allzeros\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"allmax\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = min(1000000000, i * 10000); // Scale up to reach 1e9\n        }\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = min(1000000000, (n - i - 1) * 10000); // Scale up\n        }\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 0;\n            else\n                a[i] = 1000000000;\n        }\n    } else if (type == \"cycletest\") {\n        // Create a test case where Allen cycles around multiple times before entering\n        // To force Allen to make multiple rounds, set a[i] such that Allen needs to circle around multiple times\n        // For simplicity, set a[i] = k - i;\n        int k = opt<int>(\"k\", 100000); // Number of cycles\n        for(int i = 0; i < n; ++i) {\n            a[i] = max(0, k - i - 1);\n            a[i] = min(a[i], 1000000000);\n        }\n    } else if (type == \"big\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000 - 100000, 1000000000);\n        }\n    } else if (type == \"small\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type allzeros\n./gen -n 2 -type allmax\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n./gen -n 2 -type cycletest -k 1\n\n./gen -n 10 -type random\n./gen -n 10 -type small\n./gen -n 10 -type big\n./gen -n 10 -type cycletest -k 10\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n./gen -n 100 -type cycletest -k 100\n\n./gen -n 1000 -type allzeros\n./gen -n 1000 -type allmax\n./gen -n 1000 -type random\n./gen -n 1000 -type small\n./gen -n 1000 -type big\n\n./gen -n 10000 -type alternating\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n./gen -n 10000 -type cycletest -k 10000\n\n./gen -n 100000 -type random\n./gen -n 100000 -type small\n./gen -n 100000 -type big\n\n./gen -n 100000 -type allzeros\n./gen -n 100000 -type allmax\n\n./gen -n 99999 -type cycletest -k 1000000000\n\n./gen -n 2 -type cycletest -k 1000000000\n\n./gen -n 99999 -type cycletest -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:53.835203",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "996/C",
      "title": "C. Tesla",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers nn and kk (1≤n≤501≤n≤50, 1≤k≤2n1≤k≤2n), representing the number of columns and the number of cars, respectively.The next four lines will contain nn integers each between 00 and kk inclusive, representing the initial state of the parking lot. The rows are numbered 11 to 44 from top to bottom and the columns are numbered 11 to nn from left to right.In the first and last line, an integer 1≤x≤k1≤x≤k represents a parking spot assigned to car xx (you can only move this car to this place), while the integer 00 represents a empty space (you can't move any car to this place).In the second and third line, an integer 1≤x≤k1≤x≤k represents initial position of car xx, while the integer 00 represents an empty space (you can move any car to this place).Each xx between 11 and kk appears exactly once in the second and third line, and exactly once in the first and fourth line.",
      "output_spec": "OutputIf there is a sequence of moves that brings all of the cars to their parking spaces, with at most 2000020000 car moves, then print mm, the number of moves, on the first line. On the following mm lines, print the moves (one move per line) in the format ii rr cc, which corresponds to Allen moving car ii to the neighboring space at row rr and column cc.If it is not possible for Allen to move all the cars to the correct spaces with at most 2000020000 car moves, print a single line with the integer −1−1.",
      "sample_tests": "ExamplesInputCopy4 51 2 0 41 2 0 45 0 0 30 5 0 3OutputCopy61 1 12 1 24 1 43 4 45 3 25 4 2InputCopy1 21212OutputCopy-1InputCopy1 21122OutputCopy21 1 12 4 1",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two space-separated integers nn and kk (1≤n≤501≤n≤50, 1≤k≤2n1≤k≤2n), representing the number of columns and the number of cars, respectively.The next four lines will contain nn integers each between 00 and kk inclusive, representing the initial state of the parking lot. The rows are numbered 11 to 44 from top to bottom and the columns are numbered 11 to nn from left to right.In the first and last line, an integer 1≤x≤k1≤x≤k represents a parking spot assigned to car xx (you can only move this car to this place), while the integer 00 represents a empty space (you can't move any car to this place).In the second and third line, an integer 1≤x≤k1≤x≤k represents initial position of car xx, while the integer 00 represents an empty space (you can move any car to this place).Each xx between 11 and kk appears exactly once in the second and third line, and exactly once in the first and fourth line.\n\nOutputIf there is a sequence of moves that brings all of the cars to their parking spaces, with at most 2000020000 car moves, then print mm, the number of moves, on the first line. On the following mm lines, print the moves (one move per line) in the format ii rr cc, which corresponds to Allen moving car ii to the neighboring space at row rr and column cc.If it is not possible for Allen to move all the cars to the correct spaces with at most 2000020000 car moves, print a single line with the integer −1−1.\n\nInputCopy4 51 2 0 41 2 0 45 0 0 30 5 0 3OutputCopy61 1 12 1 24 1 43 4 45 3 25 4 2InputCopy1 21212OutputCopy-1InputCopy1 21122OutputCopy21 1 12 4 1\n\nInputCopy4 51 2 0 41 2 0 45 0 0 30 5 0 3\n\nOutputCopy61 1 12 1 24 1 43 4 45 3 25 4 2\n\nInputCopy1 21212\n\nOutputCopy-1\n\nInputCopy1 21122\n\nOutputCopy21 1 12 4 1\n\nNoteIn the first sample test case, all cars are in front of their spots except car 55, which is in front of the parking spot adjacent. The example shows the shortest possible sequence of moves, but any sequence of length at most 2000020000 will be accepted.In the second sample test case, there is only one column, and the cars are in the wrong order, so no cars can move and the task is impossible.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 996 和字母"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2 * n, \"k\");\n    inf.readEoln();\n\n    vector<int> initial_counts(k + 1, 0);\n    vector<int> target_counts(k + 1, 0);\n\n    for (int row = 1; row <= 4; ++row) {\n        vector<int> line = inf.readInts(n, 0, k);\n        inf.readEoln();\n\n        for (int i = 0; i < n; ++i) {\n            int x = line[i];\n            if (x != 0) {\n                if (row == 1 || row == 4) {\n                    // Designated parking spots (rows 1 & 4)\n                    target_counts[x]++;\n                } else if (row == 2 || row == 3) {\n                    // Initial positions (rows 2 & 3)\n                    initial_counts[x]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= k; ++x) {\n        ensuref(target_counts[x] == 1, \"Car %d must appear exactly once in designated positions (rows 1 & 4), but appears %d times\", x, target_counts[x]);\n        ensuref(initial_counts[x] == 1, \"Car %d must appear exactly once in initial positions (rows 2 & 3), but appears %d times\", x, initial_counts[x]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2 * n, \"k\");\n    inf.readEoln();\n\n    vector<int> initial_counts(k + 1, 0);\n    vector<int> target_counts(k + 1, 0);\n\n    for (int row = 1; row <= 4; ++row) {\n        vector<int> line = inf.readInts(n, 0, k);\n        inf.readEoln();\n\n        for (int i = 0; i < n; ++i) {\n            int x = line[i];\n            if (x != 0) {\n                if (row == 1 || row == 4) {\n                    // Designated parking spots (rows 1 & 4)\n                    target_counts[x]++;\n                } else if (row == 2 || row == 3) {\n                    // Initial positions (rows 2 & 3)\n                    initial_counts[x]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= k; ++x) {\n        ensuref(target_counts[x] == 1, \"Car %d must appear exactly once in designated positions (rows 1 & 4), but appears %d times\", x, target_counts[x]);\n        ensuref(initial_counts[x] == 1, \"Car %d must appear exactly once in initial positions (rows 2 & 3), but appears %d times\", x, initial_counts[x]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2 * n, \"k\");\n    inf.readEoln();\n\n    vector<int> initial_counts(k + 1, 0);\n    vector<int> target_counts(k + 1, 0);\n\n    for (int row = 1; row <= 4; ++row) {\n        vector<int> line = inf.readInts(n, 0, k);\n        inf.readEoln();\n\n        for (int i = 0; i < n; ++i) {\n            int x = line[i];\n            if (x != 0) {\n                if (row == 1 || row == 4) {\n                    // Designated parking spots (rows 1 & 4)\n                    target_counts[x]++;\n                } else if (row == 2 || row == 3) {\n                    // Initial positions (rows 2 & 3)\n                    initial_counts[x]++;\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= k; ++x) {\n        ensuref(target_counts[x] == 1, \"Car %d must appear exactly once in designated positions (rows 1 & 4), but appears %d times\", x, target_counts[x]);\n        ensuref(initial_counts[x] == 1, \"Car %d must appear exactly once in initial positions (rows 2 & 3), but appears %d times\", x, initial_counts[x]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    int k = inf.readInt(1, 2 * n, \"k\");\n    const int MAX_MOVES = 20000;\n    vector<vector<int>> initial_grid(4, vector<int>(n));\n\n    // Read the initial grid\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < n; j++) {\n            initial_grid[i][j] = inf.readInt(0, k, format(\"initial_grid[%d][%d]\", i+1, j+1).c_str());\n        }\n    }\n\n    // Initialize data structures\n    map<int, pair<int, int>> car_to_initial_position; // car id -> (r, c)\n    map<int, pair<int, int>> car_to_destination; // car id -> (r, c)\n    vector<vector<int>> occupancy(4, vector<int>(n, 0)); // 0 means empty, otherwise car id\n\n    // Process the initial grid\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < n; j++) {\n            int cell = initial_grid[i][j];\n            if (i == 0 || i == 3) {\n                // Row 1 or 4, destination spots\n                if (cell != 0) {\n                    car_to_destination[cell] = make_pair(i, j);\n                    // These cells may be empty or occupied - but occupancy will be updated below\n                }\n            } else {\n                // Rows 2 and 3, initial positions of cars\n                if (cell != 0) {\n                    car_to_initial_position[cell] = make_pair(i, j);\n                    occupancy[i][j] = cell;\n                }\n            }\n        }\n    }\n\n    // Now check that each car id from 1 to k appears exactly once in both initial positions and destinations\n    for (int car_id = 1; car_id <= k; car_id++) {\n        if (car_to_initial_position.find(car_id) == car_to_initial_position.end()) {\n            quitf(_fail, \"Car %d is missing in initial positions\", car_id);\n        }\n        if (car_to_destination.find(car_id) == car_to_destination.end()) {\n            quitf(_fail, \"Car %d is missing in destinations\", car_id);\n        }\n    }\n\n    // Now read the jury's answer\n    string jury_first_token = ans.readToken();\n    bool jury_impossible = (jury_first_token == \"-1\");\n\n    // Now read participant's output\n    string participant_first_token = ouf.readToken();\n    bool participant_impossible = (participant_first_token == \"-1\");\n\n    if (participant_impossible) {\n        // Participant outputs -1\n        if (jury_impossible) {\n            quitf(_ok, \"Correctly reported impossible\");\n        } else {\n            quitf(_wa, \"Participant reports impossible but jury found a solution\");\n        }\n    } else {\n        // Participant outputs possible solution\n        if (jury_impossible) {\n            quitf(_fail, \"Participant found solution but jury reports impossible\");\n        }\n\n        // Read participant's m\n        int m;\n        try {\n            m = stoi(participant_first_token);\n        } catch (...) {\n            quitf(_pe, \"First token is neither -1 nor integer number of moves\");\n        }\n        if (m < 0 || m > MAX_MOVES) {\n            quitf(_wa, \"Number of moves m=%d is out of bounds\", m);\n        }\n\n        // Build the occupancy grid with initial positions\n        occupancy = vector<vector<int>>(4, vector<int>(n, 0));\n        for (int car_id = 1; car_id <= k; car_id++) {\n            pair<int, int> pos = car_to_initial_position[car_id];\n            occupancy[pos.first][pos.second] = car_id;\n        }\n\n        // Map car_id to current position\n        map<int, pair<int, int>> car_positions = car_to_initial_position;\n\n        // Simulate the moves\n        for (int move_num = 1; move_num <= m; move_num++) {\n            int car_id = ouf.readInt(1, k, format(\"move[%d] car_id\", move_num).c_str());\n            int r = ouf.readInt(1, 4, format(\"move[%d] r\", move_num).c_str()) -1; // zero-based index\n            int c = ouf.readInt(1, n, format(\"move[%d] c\", move_num).c_str()) -1; // zero-based index\n\n            // Get car's current position\n            auto it = car_positions.find(car_id);\n            if (it == car_positions.end()) {\n                quitf(_wa, \"Move %d: Car %d is not currently on the grid\", move_num, car_id);\n            }\n            int cur_r = it->second.first;\n            int cur_c = it->second.second;\n\n            // Check that (r, c) is adjacent to (cur_r, cur_c)\n            int dr = abs(r - cur_r);\n            int dc = abs(c - cur_c);\n            if (dr + dc != 1) {\n                quitf(_wa, \"Move %d: Car %d moved from (%d, %d) to non-adjacent cell (%d, %d)\", move_num, car_id, cur_r+1, cur_c+1, r+1, c+1);\n            }\n\n            // Check that destination cell is empty\n            if (occupancy[r][c] != 0) {\n                quitf(_wa, \"Move %d: Destination cell (%d, %d) is not empty\", move_num, r+1, c+1);\n            }\n\n            // Check moving into row 1 or 4\n            if ((r == 0 || r == 3) && (make_pair(r, c) != car_to_destination[car_id])) {\n                quitf(_wa, \"Move %d: Car %d cannot move into row %d, column %d, since it is not its designated parking spot\", move_num, car_id, r+1, c+1);\n            }\n\n            // Update positions\n            occupancy[cur_r][cur_c] = 0; // Empty previous cell\n            occupancy[r][c] = car_id;    // Occupy new cell\n            car_positions[car_id] = make_pair(r, c);\n        }\n\n        // After all moves, check that all cars are at their destinations\n        for (int car_id = 1; car_id <= k; car_id++) {\n            pair<int, int> pos = car_positions[car_id];\n            pair<int, int> dest = car_to_destination[car_id];\n            if (pos != dest) {\n                quitf(_wa, \"After all moves, car %d is at (%d, %d) instead of its destination (%d, %d)\", car_id, pos.first+1, pos.second+1, dest.first+1, dest.second+1);\n            }\n        }\n\n        quitf(_ok, \"Correct solution with %d moves\", m);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    ensure(1 <= n && n <= 50);\n    ensure(1 <= k && k <= 2*n);\n    \n    vector<vector<int>> grid(4, vector<int>(n, 0));\n    vector<int> cars(k);\n    for (int i = 0; i < k; ++i) cars[i] = i+1;\n    \n    if (type == \"edge\") {\n        // Edge cases, use n = 1 and k = 2 if not specified\n        if (n != 1) n = 1;\n        if (k > 2*n) k = 2*n;\n        ensure(k <= 2*n);\n\n        if (k == 2) {\n            // Unsolvable edge case similar to sample input\n            grid[0][0] = 1;\n            grid[1][0] = 2;\n            grid[2][0] = 1;\n            grid[3][0] = 2;\n        } else {\n            // Solvable edge case\n            grid[0][0] = 1;\n            grid[1][0] = 1;\n            grid[2][0] = 0;\n            grid[3][0] = 0;\n        }\n    } else if (type == \"max_moves\") {\n        // Generate a test case that could require many moves\n        n = min(n, 50);\n        k = min(k, 2*n);\n        vector<int> cars_rev = cars;\n        reverse(cars_rev.begin(), cars_rev.end());\n\n        int idx = 0;\n        for (int i = 0; i < n && idx < k; ++i) {\n            if (idx < k) grid[0][i] = cars[idx]; // Parking spots in row 1\n            ++idx;\n            if (idx < k) grid[3][i] = cars[idx]; // Parking spots in row 4\n            ++idx;\n        }\n        idx = 0;\n        for (int i = 0; i < n && idx < k; ++i) {\n            if (idx < k) grid[1][i] = cars_rev[idx]; // Initial positions in row 2\n            ++idx;\n            if (idx < k) grid[2][i] = cars_rev[idx]; // Initial positions in row 3\n            ++idx;\n        }\n    } else {\n        // Random test case\n        vector<int> positions(2*n, 0);\n\n        // Assign cars to initial positions (rows 2 & 3)\n        vector<int> initial_positions(2*n, 0);\n        vector<int> empty_positions;\n        for (int i = 0; i < 2*n; ++i) empty_positions.push_back(i);\n        shuffle(empty_positions.begin(), empty_positions.end());\n        for (int i = 0; i < k; ++i) {\n            int pos = empty_positions[i];\n            initial_positions[pos] = cars[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[1][i] = initial_positions[i];\n            grid[2][i] = initial_positions[i + n];\n        }\n\n        // Assign cars to parking spots (rows 1 & 4)\n        vector<int> parking_positions(2*n, 0);\n        empty_positions.clear();\n        for (int i = 0; i < 2*n; ++i) empty_positions.push_back(i);\n        shuffle(empty_positions.begin(), empty_positions.end());\n        for (int i = 0; i < k; ++i) {\n            int pos = empty_positions[i];\n            parking_positions[pos] = cars[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = parking_positions[i];\n            grid[3][i] = parking_positions[i + n];\n        }\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the grid\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    ensure(1 <= n && n <= 50);\n    ensure(1 <= k && k <= 2*n);\n    \n    vector<vector<int>> grid(4, vector<int>(n, 0));\n    vector<int> cars(k);\n    for (int i = 0; i < k; ++i) cars[i] = i+1;\n    \n    if (type == \"edge\") {\n        // Edge cases, use n = 1 and k = 2 if not specified\n        if (n != 1) n = 1;\n        if (k > 2*n) k = 2*n;\n        ensure(k <= 2*n);\n\n        if (k == 2) {\n            // Unsolvable edge case similar to sample input\n            grid[0][0] = 1;\n            grid[1][0] = 2;\n            grid[2][0] = 1;\n            grid[3][0] = 2;\n        } else {\n            // Solvable edge case\n            grid[0][0] = 1;\n            grid[1][0] = 1;\n            grid[2][0] = 0;\n            grid[3][0] = 0;\n        }\n    } else if (type == \"max_moves\") {\n        // Generate a test case that could require many moves\n        n = min(n, 50);\n        k = min(k, 2*n);\n        vector<int> cars_rev = cars;\n        reverse(cars_rev.begin(), cars_rev.end());\n\n        int idx = 0;\n        for (int i = 0; i < n && idx < k; ++i) {\n            if (idx < k) grid[0][i] = cars[idx]; // Parking spots in row 1\n            ++idx;\n            if (idx < k) grid[3][i] = cars[idx]; // Parking spots in row 4\n            ++idx;\n        }\n        idx = 0;\n        for (int i = 0; i < n && idx < k; ++i) {\n            if (idx < k) grid[1][i] = cars_rev[idx]; // Initial positions in row 2\n            ++idx;\n            if (idx < k) grid[2][i] = cars_rev[idx]; // Initial positions in row 3\n            ++idx;\n        }\n    } else {\n        // Random test case\n        vector<int> positions(2*n, 0);\n\n        // Assign cars to initial positions (rows 2 & 3)\n        vector<int> initial_positions(2*n, 0);\n        vector<int> empty_positions;\n        for (int i = 0; i < 2*n; ++i) empty_positions.push_back(i);\n        shuffle(empty_positions.begin(), empty_positions.end());\n        for (int i = 0; i < k; ++i) {\n            int pos = empty_positions[i];\n            initial_positions[pos] = cars[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[1][i] = initial_positions[i];\n            grid[2][i] = initial_positions[i + n];\n        }\n\n        // Assign cars to parking spots (rows 1 & 4)\n        vector<int> parking_positions(2*n, 0);\n        empty_positions.clear();\n        for (int i = 0; i < 2*n; ++i) empty_positions.push_back(i);\n        shuffle(empty_positions.begin(), empty_positions.end());\n        for (int i = 0; i < k; ++i) {\n            int pos = empty_positions[i];\n            parking_positions[pos] = cars[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = parking_positions[i];\n            grid[3][i] = parking_positions[i + n];\n        }\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the grid\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type edge\n./gen -n 1 -k 2 -type edge\n./gen -n 1 -k 2 -type random\n./gen -n 2 -k 2 -type edge\n./gen -n 2 -k 2 -type random\n./gen -n 2 -k 4 -type random\n./gen -n 5 -k 5 -type random\n./gen -n 5 -k 5 -type max_moves\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 20 -type random\n./gen -n 10 -k 20 -type max_moves\n./gen -n 20 -k 20 -type random\n./gen -n 20 -k 40 -type random\n./gen -n 30 -k 60 -type random\n./gen -n 40 -k 80 -type random\n./gen -n 50 -k 50 -type random\n./gen -n 50 -k 100 -type random\n./gen -n 50 -k 100 -type max_moves\n./gen -n 1 -k 2 -type random\n./gen -n 3 -k 5 -type random\n./gen -n 3 -k 6 -type random\n./gen -n 4 -k 8 -type random\n./gen -n 5 -k 10 -type random\n./gen -n 50 -k 1 -type random\n./gen -n 50 -k 2 -type random\n./gen -n 49 -k 98 -type random\n./gen -n 50 -k 99 -type random\n./gen -n 50 -k 100 -type random\n./gen -n 10 -k 15 -type random\n./gen -n 10 -k 15 -type max_moves\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:56.146436",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "996/D",
      "title": "D. Костюм с галстуком",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит одно целое число nn (1≤n≤1001≤n≤100) — количество пар людей.Вторая строка содержит 2n2n целых чисел a1,a2,…,a2na1,a2,…,a2n. Для каждого ii, удовлетворяющего 1≤i≤n1≤i≤n, ii встречается в этом списке ровно два раза. Если aj=ak=iaj=ak=i, то люди на jj-м и на kk-м местах образуют пару.",
      "output_spec": "Выходные данныеВыведите одно целое число — минимальное число обменов местами соседних людей для того, чтобы каждая пара занимала соседние позиции.",
      "sample_tests": "ПримерыВходные данныеСкопировать41 1 2 3 3 2 4 4Выходные данныеСкопировать2Входные данныеСкопировать31 1 2 2 3 3Выходные данныеСкопировать0Входные данныеСкопировать33 1 2 3 1 2Выходные данныеСкопировать3",
      "description": "D. Костюм с галстуком\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит одно целое число nn (1≤n≤1001≤n≤100) — количество пар людей.Вторая строка содержит 2n2n целых чисел a1,a2,…,a2na1,a2,…,a2n. Для каждого ii, удовлетворяющего 1≤i≤n1≤i≤n, ii встречается в этом списке ровно два раза. Если aj=ak=iaj=ak=i, то люди на jj-м и на kk-м местах образуют пару.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — минимальное число обменов местами соседних людей для того, чтобы каждая пара занимала соседние позиции.\n\nВыходные данные\n\nВходные данныеСкопировать41 1 2 3 3 2 4 4Выходные данныеСкопировать2Входные данныеСкопировать31 1 2 2 3 3Выходные данныеСкопировать0Входные данныеСкопировать33 1 2 3 1 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать41 1 2 3 3 2 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 1 2 2 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать33 1 2 3 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере можно добиться результата следующим образом: 11233244→11232344→1122334411233244→11232344→11223344 за два шага. Обратите внимание, что последовательность 11233244→11323244→1133224411233244→11323244→11332244 тоже подходит.Во втором примере все пары уже стоят рядом, поэтому ответ 00.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. Tutorial is loading... Tutorial is loading... Tutorial is loading... Tutorial is loading... Tutorial is loading... Tutorial is loading...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 996"
          },
          "content_length": 897
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,100,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(2*n, 1, n, \"a\");\n    inf.readEoln();\n\n    vector<int> freq(n+1, 0);\n    for(int i = 0; i < 2*n; ++i){\n        int x = a[i];\n        freq[x]++;\n    }\n    for(int i = 1; i <= n; ++i){\n        ensuref(freq[i]==2, \"Each integer from 1 to n must appear exactly twice, but integer %d appears %d times\", i, freq[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,100,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(2*n, 1, n, \"a\");\n    inf.readEoln();\n\n    vector<int> freq(n+1, 0);\n    for(int i = 0; i < 2*n; ++i){\n        int x = a[i];\n        freq[x]++;\n    }\n    for(int i = 1; i <= n; ++i){\n        ensuref(freq[i]==2, \"Each integer from 1 to n must appear exactly twice, but integer %d appears %d times\", i, freq[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,100,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(2*n, 1, n, \"a\");\n    inf.readEoln();\n\n    vector<int> freq(n+1, 0);\n    for(int i = 0; i < 2*n; ++i){\n        int x = a[i];\n        freq[x]++;\n    }\n    for(int i = 1; i <= n; ++i){\n        ensuref(freq[i]==2, \"Each integer from 1 to n must appear exactly twice, but integer %d appears %d times\", i, freq[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> seq(2 * n);\n\n    if (type == \"random\") {\n        // Random arrangement of people\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n        shuffle(seq.begin(), seq.end());\n    } else if (type == \"sorted\") {\n        // Couples are already adjacent\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        // Couples are adjacent but in reverse order\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n        reverse(seq.begin(), seq.end());\n    } else if (type == \"maximum_swaps\") {\n        // Arrange the sequence to require the maximum number of swaps\n        for (int i = 0; i < n; ++i) {\n            seq[i] = i + 1;\n            seq[2 * n - i - 1] = i + 1;\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between different couples\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            seq[idx++] = i + 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            seq[idx++] = i + 1;\n        }\n    } else if (type == \"pair_alternating\") {\n        // Arrange as 1 2 1 2 3 4 3 4, etc.\n        for (int i = 0; i < n; ++i) {\n            seq[i] = i + 1;\n            seq[i + n] = i + 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n        shuffle(seq.begin(), seq.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d\", seq[i]);\n        if (i < 2 * n - 1) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> seq(2 * n);\n\n    if (type == \"random\") {\n        // Random arrangement of people\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n        shuffle(seq.begin(), seq.end());\n    } else if (type == \"sorted\") {\n        // Couples are already adjacent\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        // Couples are adjacent but in reverse order\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n        reverse(seq.begin(), seq.end());\n    } else if (type == \"maximum_swaps\") {\n        // Arrange the sequence to require the maximum number of swaps\n        for (int i = 0; i < n; ++i) {\n            seq[i] = i + 1;\n            seq[2 * n - i - 1] = i + 1;\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between different couples\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            seq[idx++] = i + 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            seq[idx++] = i + 1;\n        }\n    } else if (type == \"pair_alternating\") {\n        // Arrange as 1 2 1 2 3 4 3 4, etc.\n        for (int i = 0; i < n; ++i) {\n            seq[i] = i + 1;\n            seq[i + n] = i + 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            seq[2 * i] = i + 1;\n            seq[2 * i + 1] = i + 1;\n        }\n        shuffle(seq.begin(), seq.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < 2 * n; ++i) {\n        printf(\"%d\", seq[i]);\n        if (i < 2 * n - 1) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n\n./gen -n 1 -type sorted\n./gen -n 2 -type sorted\n./gen -n 3 -type sorted\n./gen -n 4 -type sorted\n./gen -n 5 -type sorted\n\n./gen -n 1 -type reverse\n./gen -n 2 -type reverse\n./gen -n 3 -type reverse\n./gen -n 4 -type reverse\n./gen -n 5 -type reverse\n\n./gen -n 1 -type maximum_swaps\n./gen -n 2 -type maximum_swaps\n./gen -n 3 -type maximum_swaps\n./gen -n 4 -type maximum_swaps\n./gen -n 5 -type maximum_swaps\n\n./gen -n 100 -type random\n./gen -n 100 -type sorted\n./gen -n 100 -type reverse\n./gen -n 100 -type maximum_swaps\n./gen -n 100 -type alternating\n./gen -n 100 -type pair_alternating\n\n./gen -n 50 -type maximum_swaps\n./gen -n 75 -type maximum_swaps\n./gen -n 99 -type maximum_swaps\n\n./gen -n 10 -type alternating\n./gen -n 20 -type alternating\n./gen -n 30 -type alternating\n./gen -n 40 -type alternating\n./gen -n 50 -type alternating\n\n./gen -n 6 -type pair_alternating\n./gen -n 7 -type pair_alternating\n./gen -n 8 -type pair_alternating\n./gen -n 9 -type pair_alternating\n./gen -n 10 -type pair_alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:57.760904",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "996/E",
      "title": "E. Leaving the Bar",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (1≤n≤1051≤n≤105) — the number of moves.Each of the following lines contains two space-separated integers xixi and yiyi, meaning that vi→=(xi,yi)vi→=(xi,yi). We have that |vi|≤106|vi|≤106 for all ii.",
      "output_spec": "OutputOutput a single line containing nn integers c1,c2,⋯,cnc1,c2,⋯,cn, each of which is either 11 or −1−1. Your solution is correct if the value of p=∑ni=1civi→p=∑i=1ncivi→, satisfies |p|≤1.5⋅106|p|≤1.5⋅106.It can be shown that a solution always exists under the given constraints.",
      "sample_tests": "ExamplesInputCopy3999999 00 999999999999 0OutputCopy1 1 -1 InputCopy1-824590 246031OutputCopy1 InputCopy8-67761 603277640586 -39667146147 -122580569609 -2112400 914208131792 309779-850150 -4862935272 721899OutputCopy1 1 1 1 1 1 1 -1",
      "description": "E. Leaving the Bar\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (1≤n≤1051≤n≤105) — the number of moves.Each of the following lines contains two space-separated integers xixi and yiyi, meaning that vi→=(xi,yi)vi→=(xi,yi). We have that |vi|≤106|vi|≤106 for all ii.\n\nOutputOutput a single line containing nn integers c1,c2,⋯,cnc1,c2,⋯,cn, each of which is either 11 or −1−1. Your solution is correct if the value of p=∑ni=1civi→p=∑i=1ncivi→, satisfies |p|≤1.5⋅106|p|≤1.5⋅106.It can be shown that a solution always exists under the given constraints.\n\nInputCopy3999999 00 999999999999 0OutputCopy1 1 -1 InputCopy1-824590 246031OutputCopy1 InputCopy8-67761 603277640586 -39667146147 -122580569609 -2112400 914208131792 309779-850150 -4862935272 721899OutputCopy1 1 1 1 1 1 1 -1\n\nInputCopy3999999 00 999999999999 0\n\nOutputCopy1 1 -1\n\nInputCopy1-824590 246031\n\nOutputCopy1\n\nInputCopy8-67761 603277640586 -39667146147 -122580569609 -2112400 914208131792 309779-850150 -4862935272 721899\n\nOutputCopy1 1 1 1 1 1 1 -1",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 996 和字母"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MIN_XY = -1000000;\nconst int64_t MAX_XY =  1000000;\nconst int64_t MAX_SQ_MAG = 1000000000000LL; // 1e12\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(MIN_XY, MAX_XY, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(MIN_XY, MAX_XY, \"y_i\");\n        inf.readEoln();\n        int64_t xi_ll = x_i;\n        int64_t yi_ll = y_i;\n        int64_t sumsq = xi_ll * xi_ll + yi_ll * yi_ll;\n        ensuref(sumsq <= MAX_SQ_MAG, \"The magnitude of vector #%d exceeds 1e6\", i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MIN_XY = -1000000;\nconst int64_t MAX_XY =  1000000;\nconst int64_t MAX_SQ_MAG = 1000000000000LL; // 1e12\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(MIN_XY, MAX_XY, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(MIN_XY, MAX_XY, \"y_i\");\n        inf.readEoln();\n        int64_t xi_ll = x_i;\n        int64_t yi_ll = y_i;\n        int64_t sumsq = xi_ll * xi_ll + yi_ll * yi_ll;\n        ensuref(sumsq <= MAX_SQ_MAG, \"The magnitude of vector #%d exceeds 1e6\", i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MIN_XY = -1000000;\nconst int64_t MAX_XY =  1000000;\nconst int64_t MAX_SQ_MAG = 1000000000000LL; // 1e12\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(MIN_XY, MAX_XY, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(MIN_XY, MAX_XY, \"y_i\");\n        inf.readEoln();\n        int64_t xi_ll = x_i;\n        int64_t yi_ll = y_i;\n        int64_t sumsq = xi_ll * xi_ll + yi_ll * yi_ll;\n        ensuref(sumsq <= MAX_SQ_MAG, \"The magnitude of vector #%d exceeds 1e6\", i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n\n    vector<pair<int, int>> vectors(n);\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000000, 1000000, format(\"x[%d]\", i + 1).c_str());\n        int yi = inf.readInt(-1000000, 1000000, format(\"y[%d]\", i + 1).c_str());\n        vectors[i] = {xi, yi};\n    }\n\n    vector<int> cs(n);\n    for (int i = 0; i < n; ++i) {\n        int ci = ouf.readInt(-1, 1, format(\"c[%d]\", i + 1).c_str());\n        if (ci != -1 && ci != 1) {\n            ouf.quitf(_wa, \"c[%d] is %d, but should be -1 or 1\", i + 1, ci);\n        }\n        cs[i] = ci;\n    }\n\n    ll px = 0, py = 0;\n    for (int i = 0; i < n; ++i) {\n        px += (ll)cs[i] * vectors[i].first;\n        py += (ll)cs[i] * vectors[i].second;\n    }\n\n    // Compute p_norm_squared = px^2 + py^2\n    ull p_norm_sq = (ull)(px) * (ull)(px) + (ull)(py) * (ull)(py);\n\n    const ull limit_sq = 2250000000000ULL; // (1.5e6)^2\n\n    if (p_norm_sq <= limit_sq) {\n        quitf(_ok, \"|p|^2 = %llu ≤ (1.5e6)^2\", p_norm_sq);\n    } else {\n        quitf(_wa, \"|p|^2 = %llu > (1.5e6)^2\", p_norm_sq);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> vectors(n);\n\n    if (type == \"random\") {\n        // Generate random vectors with |v_i| ≤ 1e6\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n            } while (1LL * x * x + 1LL * y * y > 1000000LL * 1000000LL);\n            vectors[i] = make_pair(x, y);\n        }\n    } else if (type == \"max_mag\") {\n        // Generate vectors with magnitudes close to 1e6\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            long long mag2;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n                mag2 = 1LL * x * x + 1LL * y * y;\n            } while (mag2 < 0.99 * 1000000LL * 1000000LL || mag2 > 1000000LL * 1000000LL);\n            vectors[i] = make_pair(x, y);\n        }\n    } else if (type == \"same_dir\") {\n        // Generate vectors pointing in the same direction\n        int a = rnd.next(-100, 100);\n        int b = rnd.next(-100, 100);\n        if (a == 0 && b == 0) a = 1; // Avoid zero vector\n        long long s2 = 1LL * a * a + 1LL * b * b;\n        if (s2 == 0) s2 = 1;  // To avoid division by zero\n        double s = sqrt(s2);\n        double max_length_d = 1000000.0 / s;\n        int max_length = (int)(max_length_d + 1e-9);\n        max_length = min(max_length, 1000000);\n        max_length = max(1, max_length);\n        for (int i = 0; i < n; ++i) {\n            int length = rnd.next(1, max_length);\n            int x = a * length;\n            int y = b * length;\n            if (abs(x) > 1000000 || abs(y) > 1000000) {\n                --i;\n                continue;\n            }\n            vectors[i] = make_pair(x, y);\n        }\n    } else if (type == \"axis_x\") {\n        // Generate vectors along the x-axis\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-1000000, 1000000);\n            if (x == 0)\n                x = 1;\n            vectors[i] = make_pair(x, 0);\n        }\n    } else if (type == \"axis_y\") {\n        // Generate vectors along the y-axis\n        for (int i = 0; i < n; ++i) {\n            int y = rnd.next(-1000000, 1000000);\n            if (y == 0)\n                y = 1;\n            vectors[i] = make_pair(0, y);\n        }\n    } else if (type == \"small_mag\") {\n        // Generate vectors with small magnitudes\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-10, 10);\n                y = rnd.next(-10, 10);\n            } while (x == 0 && y == 0);\n            vectors[i] = make_pair(x, y);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output the vectors\n    printf(\"%d\\n\", n);\n    for (const auto& v : vectors) {\n        printf(\"%d %d\\n\", v.first, v.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> vectors(n);\n\n    if (type == \"random\") {\n        // Generate random vectors with |v_i| ≤ 1e6\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n            } while (1LL * x * x + 1LL * y * y > 1000000LL * 1000000LL);\n            vectors[i] = make_pair(x, y);\n        }\n    } else if (type == \"max_mag\") {\n        // Generate vectors with magnitudes close to 1e6\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            long long mag2;\n            do {\n                x = rnd.next(-1000000, 1000000);\n                y = rnd.next(-1000000, 1000000);\n                mag2 = 1LL * x * x + 1LL * y * y;\n            } while (mag2 < 0.99 * 1000000LL * 1000000LL || mag2 > 1000000LL * 1000000LL);\n            vectors[i] = make_pair(x, y);\n        }\n    } else if (type == \"same_dir\") {\n        // Generate vectors pointing in the same direction\n        int a = rnd.next(-100, 100);\n        int b = rnd.next(-100, 100);\n        if (a == 0 && b == 0) a = 1; // Avoid zero vector\n        long long s2 = 1LL * a * a + 1LL * b * b;\n        if (s2 == 0) s2 = 1;  // To avoid division by zero\n        double s = sqrt(s2);\n        double max_length_d = 1000000.0 / s;\n        int max_length = (int)(max_length_d + 1e-9);\n        max_length = min(max_length, 1000000);\n        max_length = max(1, max_length);\n        for (int i = 0; i < n; ++i) {\n            int length = rnd.next(1, max_length);\n            int x = a * length;\n            int y = b * length;\n            if (abs(x) > 1000000 || abs(y) > 1000000) {\n                --i;\n                continue;\n            }\n            vectors[i] = make_pair(x, y);\n        }\n    } else if (type == \"axis_x\") {\n        // Generate vectors along the x-axis\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-1000000, 1000000);\n            if (x == 0)\n                x = 1;\n            vectors[i] = make_pair(x, 0);\n        }\n    } else if (type == \"axis_y\") {\n        // Generate vectors along the y-axis\n        for (int i = 0; i < n; ++i) {\n            int y = rnd.next(-1000000, 1000000);\n            if (y == 0)\n                y = 1;\n            vectors[i] = make_pair(0, y);\n        }\n    } else if (type == \"small_mag\") {\n        // Generate vectors with small magnitudes\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-10, 10);\n                y = rnd.next(-10, 10);\n            } while (x == 0 && y == 0);\n            vectors[i] = make_pair(x, y);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output the vectors\n    printf(\"%d\\n\", n);\n    for (const auto& v : vectors) {\n        printf(\"%d %d\\n\", v.first, v.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n\n./gen -n 1 -type max_mag\n./gen -n 2 -type max_mag\n./gen -n 3 -type max_mag\n./gen -n 10 -type max_mag\n./gen -n 100 -type max_mag\n./gen -n 1000 -type max_mag\n./gen -n 10000 -type max_mag\n./gen -n 50000 -type max_mag\n./gen -n 100000 -type max_mag\n\n./gen -n 1 -type same_dir\n./gen -n 2 -type same_dir\n./gen -n 3 -type same_dir\n./gen -n 10 -type same_dir\n./gen -n 100 -type same_dir\n./gen -n 1000 -type same_dir\n./gen -n 10000 -type same_dir\n./gen -n 50000 -type same_dir\n./gen -n 100000 -type same_dir\n\n./gen -n 1 -type axis_x\n./gen -n 2 -type axis_x\n./gen -n 3 -type axis_x\n./gen -n 10 -type axis_x\n./gen -n 100 -type axis_x\n./gen -n 1000 -type axis_x\n./gen -n 10000 -type axis_x\n./gen -n 50000 -type axis_x\n./gen -n 100000 -type axis_x\n\n./gen -n 1 -type axis_y\n./gen -n 2 -type axis_y\n./gen -n 3 -type axis_y\n./gen -n 10 -type axis_y\n./gen -n 100 -type axis_y\n./gen -n 1000 -type axis_y\n./gen -n 10000 -type axis_y\n./gen -n 50000 -type axis_y\n./gen -n 100000 -type axis_y\n\n./gen -n 1 -type small_mag\n./gen -n 2 -type small_mag\n./gen -n 3 -type small_mag\n./gen -n 10 -type small_mag\n./gen -n 100 -type small_mag\n./gen -n 1000 -type small_mag\n./gen -n 10000 -type small_mag\n./gen -n 50000 -type small_mag\n./gen -n 100000 -type small_mag\n\n./gen -n 99999 -type random\n./gen -n 99998 -type max_mag\n./gen -n 99997 -type same_dir\n./gen -n 99996 -type axis_x\n./gen -n 99995 -type axis_y\n\n./gen -n 50000 -type random\n./gen -n 50000 -type max_mag\n./gen -n 50000 -type same_dir\n\n./gen -n 100000 -type random\n./gen -n 100000 -type max_mag\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:03:59.923059",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "996/F",
      "title": "F. Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and rr (1≤n≤181≤n≤18, 0≤r≤2180≤r≤218).The next line contains 2n2n integers c0,c1,…,c2n−1c0,c1,…,c2n−1 (0≤ci≤1090≤ci≤109), denoting the initial values of ff. More specifically, f(x0,x1,…,xn−1)=cxf(x0,x1,…,xn−1)=cx, if x=xn−1…x0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯x=xn−1…x0¯ in binary.Each of the next rr lines contains two integers zz and gg (0≤z≤2n−10≤z≤2n−1, 0≤g≤1090≤g≤109). If z=zn−1…z0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯z=zn−1…z0¯ in binary, then this means to set f(z0,…,zn−1)→gf(z0,…,zn−1)→g.",
      "output_spec": "OutputPrint r+1r+1 lines, the ii-th of which denotes the value of the game ff during the ii-th round. Your answer must have absolute or relative error within 10−610−6.Formally, let your answer be aa, and the jury's answer be bb. Your answer is considered correct if |a−b|max(1,|b|)≤10−6|a−b|max(1,|b|)≤10−6.",
      "sample_tests": "ExamplesInputCopy2 20 1 2 32 50 4OutputCopy1.5000002.2500003.250000InputCopy1 02 3OutputCopy2.500000InputCopy2 01 1 1 1OutputCopy1.000000",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and rr (1≤n≤181≤n≤18, 0≤r≤2180≤r≤218).The next line contains 2n2n integers c0,c1,…,c2n−1c0,c1,…,c2n−1 (0≤ci≤1090≤ci≤109), denoting the initial values of ff. More specifically, f(x0,x1,…,xn−1)=cxf(x0,x1,…,xn−1)=cx, if x=xn−1…x0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯x=xn−1…x0¯ in binary.Each of the next rr lines contains two integers zz and gg (0≤z≤2n−10≤z≤2n−1, 0≤g≤1090≤g≤109). If z=zn−1…z0¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯z=zn−1…z0¯ in binary, then this means to set f(z0,…,zn−1)→gf(z0,…,zn−1)→g.\n\nOutputPrint r+1r+1 lines, the ii-th of which denotes the value of the game ff during the ii-th round. Your answer must have absolute or relative error within 10−610−6.Formally, let your answer be aa, and the jury's answer be bb. Your answer is considered correct if |a−b|max(1,|b|)≤10−6|a−b|max(1,|b|)≤10−6.\n\nInputCopy2 20 1 2 32 50 4OutputCopy1.5000002.2500003.250000InputCopy1 02 3OutputCopy2.500000InputCopy2 01 1 1 1OutputCopy1.000000\n\nInputCopy2 20 1 2 32 50 4\n\nOutputCopy1.5000002.2500003.250000\n\nInputCopy1 02 3\n\nOutputCopy2.500000\n\nInputCopy2 01 1 1 1\n\nOutputCopy1.000000\n\nNoteConsider the second test case. If Allen goes first, he will set x1→1x1→1, so the final value will be 33. If Bessie goes first, then she will set x1→0x1→0 so the final value will be 22. Thus the answer is 2.52.5.In the third test case, the game value will always be 11 regardless of Allen and Bessie's play.",
      "solutions": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces",
          "content": "Hello denizens of Codeforces once again!After our last two rounds, Yang Liu (desert97) and I (ksun48) are pleased to announce Codeforces Round #492, which will happen on June 24, 2018 at 19:35 MSK. There will be two versions of the contest, one for users in Division 1 and one for users in Division 2. Both versions will have six problems, with four problems shared between the versions.The round will feature our friend and superstar member of ACM-ICPC team MIT TWO, Allen Liu (cliu568).The scoring distribution will be visible once the contest begins. As usual, we'd like to thank our wonderful problem coordinator KAN and Codeforces administrator MikeMirzayanov, as well as the rest of the Codeforces staff for keeping this site an amazing place for competitive programming. Thanks also to our testy testers winger, AlexFetisov, and demon1999.This round is in honor of uDebug who have supported Codeforces on its anniversary. Thank you, uDebug! uDebug is an enthusiastic community of competitive programmers who help each other out by answering questions on chat, providing hints and solutions to problems from several online judges, furnishing test input and sharing feedback. On uDebug, you can select a problem you’ve coded up a solution for, provide input, and get the \"accepted\" output. You can visit it by the link.Good luck! As always, we encourage competitors to read all the problems.(̶a̶l̶s̶o̶,̶ ̶I̶ ̶s̶e̶e̶m̶ ̶t̶o̶ ̶h̶a̶v̶e̶ ̶h̶e̶a̶r̶d̶ ̶s̶o̶m̶e̶ ̶r̶u̶m̶o̶r̶s̶ ̶f̶l̶o̶a̶t̶i̶n̶g̶ ̶a̶r̶o̶u̶n̶d̶ ̶a̶b̶o̶u̶t̶ ̶a̶ ̶s̶p̶e̶c̶i̶a̶l̶ ̶ ̶s̶u̶r̶p̶r̶i̶s̶e̶ ̶w̶h̶i̶c̶h̶ ̶m̶i̶g̶h̶t̶ ̶b̶e̶ ̶h̶a̶p̶p̶e̶n̶i̶n̶g̶ ̶d̶u̶r̶i̶n̶g̶ ̶s̶y̶s̶t̶e̶m̶ ̶t̶e̶s̶t̶i̶n̶g̶,̶ ̶s̶o̶ ̶k̶e̶e̶p̶ ̶y̶o̶u̶r̶ ̶e̶y̶e̶s̶ ̶p̶e̶e̶l̶e̶d̶!̶)̶EDIT: And the rumors are confirmed! Go to http://codeforces.com/blog/entry/60176 after the contest is over to discuss the problems or voice your complaints along with scott_wu and ecnerwala!EDIT: Due to some last minute changes, each version will have six problems, with four shared problems.EDIT: The Div. 2 score distribution is 500-1000-1500-1750-2500-2750 and the Div. 1 score distribution is 500-750-1500-1750-2250-2500.EDIT: Congratulations to the winners of the round!Div. 1: jqdai0815 Swistakk Um_nik bmerry ainta Div. 2: Fortin Aleks5d KsCla hopcroftkarp davidberard Thanks to everyone for participating! The editorial is available at http://codeforces.com/blog/entry/60217.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60092",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2391
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces",
          "content": "Preliminary, changes to come possibly. 996A - Hit the LotteryThe problem is to minimize x1+x2+x3+x4+x5x1+x2+x3+x4+x5 given that x1+5x2+10x3+20x4+100x5=n.x1+5x2+10x3+20x4+100x5=n. It is pretty simple to see that we can operate greedily: take as many 100100 as we can, then 2020, then 1010, etc.The solutions works because each number in the sequence 1,5,10,20,1001,5,10,20,100 is a divisor of the number after it. 996B - World CupFor gate kk (where 1≤k≤n1≤k≤n) we visit the gate at times k,k+n,k+2n,⋯k,k+n,k+2n,⋯ Therefore, the earliest Allen could enter from gate kk is the time k+tnk+tn such that k+tn≥ak.k+tn≥ak. Now, for each kk, compute the minimal integer bk=k+tnbk=k+tn such that k+tn≥akk+tn≥ak. Now, find the integer kk with minimum bkbk and output kk. 995A - TeslaFirst, whenever any cars are directly to their parking spot, we should move them into the correct parking spot.Now, we can view rows 22 and 33 as a cycle. In at most kk moves, we can spin the entire cycle of cars counterclockwise. By repeating this 2n2n times, each car will have been adjacent to each parking space, and will have had some chance to park.The exception to this rule is when there are no empty spaces in rows 22 and 33. In this case, no cars can even make a valid move, so the answer is −1−1. (This requires k=2nk=2n and no cars are initially adjacent to their parking space)This process will can be implemented in O(nk)O(nk) or O(n2)O(n2) time, with at most 2nk+k≤101002nk+k≤10100, which fits below the 2000020000 move limit. 995B - Suit and TieWe describe a greedy algorithm that achieves the minimum number of swaps.If the leftmost person is in pair aa, swap the other person in pair aa left, to the second position. Now the first two people are both in pair aa, and we repeat the process on the remaining n−1n−1 pairs of people recursively.We now prove that this number of swaps is optimal, and we accomplish this by showing that every swap we made is 'necessary'.For two pairs numbered aa and bb, we can consider the number of times people of pair aa and bb are swapped by our process. There are 33 possible relative orderings: aabbaabb, abababab, and abbaabba.In the case aabbaabb, our algorithm will never swap aa and bb.In the case abababab, any correct swap sequence must swap aa and bb at least once, and our algorithm will swap the second aa left of the first bb when aa is the leftmost person.In the case abbaabba, any correct swap sequence must swap aa and bb at least twice, and our algorithm will swap the second aa left of both bb when aa is the leftmost person.Therefore every swap in our greedy algorithm is necessary, so it is optimal.We can directly simulate this algorithm in O(n2)O(n2) time. We can also use data structures such as a binary indexed tree, or balanced binary search tree to compute the answer in O(nlogn)O(nlog⁡n). (Maybe it can be even done in O(n)O(n), anyone?). 995C - Leaving the BarWe first prove a claim which will help us significantly. The claim is that among any three vectors v1→,v2→,v3→v1→,v2→,v3→ of lengths at most rr, then some sum vi→+vj→vi→+vj→ or difference vi→−vj→vi→−vj→ has at length at most rr.Draw a circle with radius rr centered at the origin. If we plot the vectors v1→,v2→,v3→,−v1→,−v2→,−v3→v1→,v2→,v3→,−v1→,−v2→,−v3→ from the origin, two of these will lie in the same 60∘60∘ sector. Any two points in this sector will have distance at most rr.Therefore, as long as there are at least 33 vectors, two of them can be combined and the input constraints will still be satisfied. In the final step, we can combine two vectors of length at most rr into one of length at most 2–√r2r.Implementation can be done in a number of ways: for example, constructing a binary tree with the input vectors as leaves, or maintaining sets of signed vectors and merging small sets to large sets. These approaches can take O(n)O(n) or O(nlogn)O(nlog⁡n). 995D - GameOne can show by induction that the expected value of the game is E[f]=2−n∑x∈{0,1}nf(x)E[f]=2−n∑x∈{0,1}nf(x).Consider the first turn. For notation, let vi,0vi,0 be the expected value of the game when xixi is set to 00, and let vi,1vi,1 be the expected value of the game when xixi is set to 11. By induction, it is easy to see that vi,0+vi,12=E[f].vi,0+vi,12=E[f].Consider Allen's strategy. If it is Allen's turn, he will set xs=txs=t, where 0≤s<n,0≤t≤10≤s<n,0≤t≤1 are such that vs,tvs,t is maximal. As vi,0+vi,12=E[f]vi,0+vi,12=E[f] for all ii, it is clear that vs,1−tvs,1−t is actually minimal among all the vi,jvi,j. This means that Bessie would have chosen to set xs=1−txs=1−t if it were her turn. Therefore, the expected game value is vs,t+vs,1−t2=E[f].vs,t+vs,1−t2=E[f]. 995E - Number ClickerOur first observation is that the game can be modeled the following way. Construct an undirected graph on {0,1,…,p−1}{0,1,…,p−1} such that ii is connected to i−1,i+1,i−1,i+1, and ip−2(modp).ip−2(modp).We want to find a path of length at most 200 between uu and vv in this graph. Running a BFS will take too long, so we need different techniques. We present two solutions, which both essentially use the fact that the graph is almost \"random\". This follows from some known number theoretic results on expander graphs (keyword is \"Margulis expanders\").Solution 1: Generate p–√p random paths of length 100100 from vertex uu. Now, generate random paths from vv of length 100100 until some pair of endpoints coincide. By the birthday paradox, assuming that the graph is approximately random, the runtime will be O(p–√logp).O(plog⁡p).Solution 2: We can try running a simultaneous BFS from both directions (starting at uu and vv). When they meet, make that path. If you are careful, it should be possible to cover ≤107≤107 vertices, which should then run in time.Additionally, our tester found a different solution. It suffices to find a path from u→1u→1 of length 100.100. The way we do this is: pick a random x(modp).x(modp). Now run the Euclidean algorithm on (ux(modp),x)(ux(modp),x), using operation 22 for a normal subtraction step, and a 33 for the flipping the two entries step. It happens to take a few steps in most cases, but we have no proof. 995F - Cowmpany CowmpensationA immediate simple observation is that we can compute the answer in O(nD)O(nD) with a simple dynamic program. How to speed it up though?To speed it up, we need the following lemma.Lemma 1: For a tree with nn vertices, the answer is a polynomial in DD of degree at most nn.We can prove this via induction, and the fact that for any polynomial p(x)p(x) of degree dd, the sum p(0)+p(1)+⋯+p(n)p(0)+p(1)+⋯+p(n) is a polynomial in nn of degree d+1.d+1.Now the solution is easy: compute the answer for 0≤D≤n0≤D≤n and use interpolation to compute the answer for D>n.D>n. The complexity is O(n2)O(n2) for the initial dp and O(n)O(n) for the interpolation step.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60217",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 996 和字母"
          },
          "content_length": 6817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 1",
          "code": "[user:some_handle,yyyy-mm-dd]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 2",
          "code": "[user:karanbatra,2017-07-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 3",
          "code": "[user:karanbatra,2017-08-01]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 4",
          "code": "[user:karanbatra,2018-06-24]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 5",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 6",
          "code": "<a class=\"rated-user user-red\" href=\"/profile/MohamedAhmed04\" title=\"Legendary grand master MohamedAhmed04\">MohamedAhmed04</a>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 7",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\tprintf(\"100000\");\n\tfor (int i = 0; i < 100000; i++) {\n\t\tint y = 900000 + i;\n\t\tif (i % 4 == 1 || i % 4 == 2)\n\t\t\ty *= -1;\n\t\tprintf(\"20 %d\\n\", y);\n\t}\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 9",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 10",
          "code": "2 2\n0 1\n0 2\n1 0\n2 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 11",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #492 [Thanks, uDebug!] - Codeforces - Code 12",
          "code": "2\n1000000000 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60092",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#ifndef ONLINE_JUDGE\n// freopen(\"input1.txt\", \"r\", stdin);\n// freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ll n, sum=0 ;\nint v[]={100,20,10,5,1};\n    cin >> n;\nint i=0;\nwhile(n!=0){\nsum+=n/v[i];\nn%=v[i];\ni++;\n}\ncout<<sum;\nreturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 2",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 3",
          "code": "n, a, m, res = int(input()), [*(map(int,input().split()))], 10e9,-1\nk = [ math.ceil((ai-i)/n) for i,ai in enumerate(a) ]\nprint(k.index(min(k))+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 4",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 5",
          "code": "int no_of_swaps = 0;\n    vector <int> visited(n + 1, false);\n    for(int i = 1; i <= n; i++)\n    {\n        if(!visited[i])\n        {\n            int cycle_size = 0;\n\n            for(int current = i; !visited[current]; current = permutation[current])\n            {\n                visited[current] = true;\n                cycle_size++;\n            }\n\n            no_of_swaps += cycle_size - 1;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 6",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 7",
          "code": "num=1000;\n        \n        outer: for(i=0;i<N;i++)\n        {\n            for(j=i-1;j>=0;j--)\n            {\n                if(a[i]==a[j])\n                {\n                    b[i]=b[j];\n                    continue outer;\n                }\n            }\n            \n            b[i]=num++;\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 8",
          "code": "abc....ab...c...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 9",
          "code": "|number of elements between a and a|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 10",
          "code": "|number of elements between b and b without the a-s|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 11",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #492 [Thanks u-Debug!] - Codeforces - Code 12",
          "code": "3\n1000000 0\n0 1000000\n707105 707105",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60217",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(0, 262144, \"r\");\n    inf.readEoln();\n\n    int tot = 1 << n;\n    vector<int> c = inf.readInts(tot, 0, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < r; i++) {\n        int z = inf.readInt(0, tot - 1, \"z\");\n        inf.readSpace();\n        int g = inf.readInt(0, 1000000000, \"g\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(0, 262144, \"r\");\n    inf.readEoln();\n\n    int tot = 1 << n;\n    vector<int> c = inf.readInts(tot, 0, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < r; i++) {\n        int z = inf.readInt(0, tot - 1, \"z\");\n        inf.readSpace();\n        int g = inf.readInt(0, 1000000000, \"g\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(0, 262144, \"r\");\n    inf.readEoln();\n\n    int tot = 1 << n;\n    vector<int> c = inf.readInts(tot, 0, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < r; i++) {\n        int z = inf.readInt(0, tot - 1, \"z\");\n        inf.readSpace();\n        int g = inf.readInt(0, 1000000000, \"g\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isEqual(double expected, double result, double EPS);\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int r = inf.readInt();\n\n    int expected_output_lines = r + 1;\n\n    vector<double> ans_values, ouf_values;\n\n    // Read outputs from ans\n    for (int i = 0; i < expected_output_lines; ++i) {\n        double val = ans.readDouble();\n        ans.readEoln();\n        ans_values.push_back(val);\n    }\n    ans.readEof();\n\n    // Read outputs from ouf\n    for (int i = 0; i < expected_output_lines; ++i) {\n        double val = ouf.readDouble();\n        ouf.readEoln();\n        ouf_values.push_back(val);\n    }\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"Extra data in the output after reading %d lines\", expected_output_lines);\n    }\n\n    // Now compare each pair\n    double EPS = 1E-6;\n    for (int i = 0; i < expected_output_lines; ++i) {\n        double expected = ans_values[i];\n        double result = ouf_values[i];\n        if (!isEqual(expected, result, EPS)) {\n            quitf(_wa, \"At line %d, expected %.10f, found %.10f\", i+1, expected, result);\n        }\n    }\n\n    quitf(_ok, \"All %d numbers match within acceptable error\", expected_output_lines);\n}\n\nbool isEqual(double expected, double result, double EPS) {\n    double diff = fabs(expected - result);\n    double maxv = max(1.0, fabs(expected));\n    return diff <= EPS * maxv;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\", 0);\n    string ctype = opt<string>(\"ctype\", \"random\");\n    string utype = opt<string>(\"utype\", \"random\");\n    \n    int tot = 1 << n;\n    vector<int> c(tot);\n    \n    /* Generate c_i according to ctype */\n    if (ctype == \"zeros\") {\n        for(int i = 0; i < tot; ++i) c[i] = 0;\n    } else if (ctype == \"max\") {\n        for(int i = 0; i < tot; ++i) c[i] = 1000000000;\n    } else if (ctype == \"random\") {\n        for(int i = 0; i < tot; ++i) c[i] = rnd.next(0, 1000000000);\n    } else if (ctype == \"increasing\") {\n        int step = tot > 1 ? 1000000000 / (tot - 1) : 0;\n        for(int i = 0; i < tot; ++i) c[i] = step * i;\n    } else if (ctype == \"decreasing\") {\n        int step = tot > 1 ? 1000000000 / (tot - 1) : 0;\n        for(int i = 0; i < tot; ++i) c[i] = 1000000000 - step * i;\n    } else if (ctype == \"smallrandom\") {\n        for(int i = 0; i < tot; ++i) c[i] = rnd.next(0, 10);\n    } else {\n        // default to random\n        for(int i = 0; i < tot; ++i) c[i] = rnd.next(0, 1000000000);\n    }\n    \n    /* Now output n and r */\n    printf(\"%d %d\\n\", n, r);\n    \n    /* Output c_i */\n    for(int i = 0; i < tot; ++i) {\n        printf(\"%d\", c[i]);\n        if (i+1 < tot) printf(\" \");\n        else printf(\"\\n\");\n    }\n    \n    /* Generate updates */\n    /* According to utype */\n    \n    vector<pair<int,int>> updates; // vector of (z, g)\n    \n    if (r > 0) {\n    \n        if (utype == \"random\") {\n            for(int i = 0; i < r; ++i) {\n                int z = rnd.next(0, tot - 1);\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"duplicate\") {\n            int num_z = rnd.next(1, tot); // Number of different z's to update\n            vector<int> zs(tot);\n            for(int i = 0; i < tot; ++i) zs[i] = i;\n            shuffle(zs.begin(), zs.end());\n            zs.resize(num_z);\n            for(int i = 0; i < r; ++i) {\n                int z = zs[rnd.next(0, num_z - 1)];\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"unique\") {\n            // We need r <= tot\n            if (r > tot) {\n                fprintf(stderr, \"Error: r(%d) > total number of c_i(%d) in unique utype\\n\", r, tot);\n                exit(1);\n            }\n            vector<int> zs(tot);\n            for(int i = 0; i < tot; ++i) zs[i] = i;\n            shuffle(zs.begin(), zs.end());\n            zs.resize(r);\n            for(int i = 0; i < r; ++i) {\n                int z = zs[i];\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"same\") {\n            int z = rnd.next(0, tot - 1);\n            for(int i = 0; i < r; ++i) {\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"sequence\") {\n            // Update c_i in order\n            for(int i = 0; i < r; ++i) {\n                int z = i % tot;\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else {\n            // default to random\n            for(int i = 0; i < r; ++i) {\n                int z = rnd.next(0, tot - 1);\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        }\n        \n        // Output updates\n        for(int i = 0; i < r; ++i) {\n            printf(\"%d %d\\n\", updates[i].first, updates[i].second);\n        }\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\", 0);\n    string ctype = opt<string>(\"ctype\", \"random\");\n    string utype = opt<string>(\"utype\", \"random\");\n    \n    int tot = 1 << n;\n    vector<int> c(tot);\n    \n    /* Generate c_i according to ctype */\n    if (ctype == \"zeros\") {\n        for(int i = 0; i < tot; ++i) c[i] = 0;\n    } else if (ctype == \"max\") {\n        for(int i = 0; i < tot; ++i) c[i] = 1000000000;\n    } else if (ctype == \"random\") {\n        for(int i = 0; i < tot; ++i) c[i] = rnd.next(0, 1000000000);\n    } else if (ctype == \"increasing\") {\n        int step = tot > 1 ? 1000000000 / (tot - 1) : 0;\n        for(int i = 0; i < tot; ++i) c[i] = step * i;\n    } else if (ctype == \"decreasing\") {\n        int step = tot > 1 ? 1000000000 / (tot - 1) : 0;\n        for(int i = 0; i < tot; ++i) c[i] = 1000000000 - step * i;\n    } else if (ctype == \"smallrandom\") {\n        for(int i = 0; i < tot; ++i) c[i] = rnd.next(0, 10);\n    } else {\n        // default to random\n        for(int i = 0; i < tot; ++i) c[i] = rnd.next(0, 1000000000);\n    }\n    \n    /* Now output n and r */\n    printf(\"%d %d\\n\", n, r);\n    \n    /* Output c_i */\n    for(int i = 0; i < tot; ++i) {\n        printf(\"%d\", c[i]);\n        if (i+1 < tot) printf(\" \");\n        else printf(\"\\n\");\n    }\n    \n    /* Generate updates */\n    /* According to utype */\n    \n    vector<pair<int,int>> updates; // vector of (z, g)\n    \n    if (r > 0) {\n    \n        if (utype == \"random\") {\n            for(int i = 0; i < r; ++i) {\n                int z = rnd.next(0, tot - 1);\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"duplicate\") {\n            int num_z = rnd.next(1, tot); // Number of different z's to update\n            vector<int> zs(tot);\n            for(int i = 0; i < tot; ++i) zs[i] = i;\n            shuffle(zs.begin(), zs.end());\n            zs.resize(num_z);\n            for(int i = 0; i < r; ++i) {\n                int z = zs[rnd.next(0, num_z - 1)];\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"unique\") {\n            // We need r <= tot\n            if (r > tot) {\n                fprintf(stderr, \"Error: r(%d) > total number of c_i(%d) in unique utype\\n\", r, tot);\n                exit(1);\n            }\n            vector<int> zs(tot);\n            for(int i = 0; i < tot; ++i) zs[i] = i;\n            shuffle(zs.begin(), zs.end());\n            zs.resize(r);\n            for(int i = 0; i < r; ++i) {\n                int z = zs[i];\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"same\") {\n            int z = rnd.next(0, tot - 1);\n            for(int i = 0; i < r; ++i) {\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else if (utype == \"sequence\") {\n            // Update c_i in order\n            for(int i = 0; i < r; ++i) {\n                int z = i % tot;\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        } else {\n            // default to random\n            for(int i = 0; i < r; ++i) {\n                int z = rnd.next(0, tot - 1);\n                int g = rnd.next(0, 1000000000);\n                updates.push_back(make_pair(z, g));\n            }\n        }\n        \n        // Output updates\n        for(int i = 0; i < r; ++i) {\n            printf(\"%d %d\\n\", updates[i].first, updates[i].second);\n        }\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -r 0 -ctype zeros -utype random\n./gen -n 1 -r 0 -ctype max -utype random\n./gen -n 1 -r 0 -ctype random -utype random\n\n./gen -n 1 -r 1 -ctype random -utype random\n./gen -n 1 -r 2 -ctype random -utype random\n\n./gen -n 2 -r 0 -ctype zeros -utype random\n./gen -n 2 -r 0 -ctype max -utype random\n./gen -n 2 -r 4 -ctype random -utype random\n\n./gen -n 3 -r 0 -ctype increasing -utype random\n./gen -n 3 -r 5 -ctype decreasing -utype random\n\n./gen -n 5 -r 0 -ctype random -utype random\n./gen -n 5 -r 10 -ctype random -utype random\n\n./gen -n 10 -r 0 -ctype random -utype random\n./gen -n 10 -r 100 -ctype random -utype random\n\n./gen -n 15 -r 0 -ctype random -utype random\n./gen -n 15 -r 10000 -ctype random -utype duplicate\n\n./gen -n 18 -r 0 -ctype random -utype random\n./gen -n 18 -r 100000 -ctype random -utype duplicate\n\n./gen -n 18 -r 262144 -ctype random -utype duplicate\n\n./gen -n 18 -r 0 -ctype zeros -utype random\n./gen -n 18 -r 0 -ctype max -utype random\n\n./gen -n 5 -r 10 -ctype smallrandom -utype random\n./gen -n 5 -r 20 -ctype smallrandom -utype same\n\n./gen -n 8 -r 16 -ctype random -utype unique\n\n./gen -n 8 -r 256 -ctype random -utype sequence\n\n./gen -n 4 -r 16 -ctype random -utype random\n./gen -n 4 -r 16 -ctype random -utype same\n\n./gen -n 17 -r 131072 -ctype random -utype random\n./gen -n 17 -r 131072 -ctype decreasing -utype sequence\n\n./gen -n 2 -r 1 -ctype zeros -utype duplicate\n./gen -n 2 -r 2 -ctype zeros -utype unique\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:02.012511",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "997/A",
      "title": "A. Превратить в единицы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа nn, xx и yy (1 ≤ n ≤ 300000,0≤x,y≤1091 ≤ n ≤ 300000,0≤x,y≤109) — длина строки, стоимость первой операции (разворота подотрезка) и стоимость второй операции (инвертирования всех элементов некоторого подотрезка) соответственно.Во второй строке записана строка aa длины nn, состоящая из нулей и единиц.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальную суммарную стоимость изменений, необходимых для получения строки, состоящей только из единиц. Выведите 00, если не требуется совершать никаких изменений.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 1 1001000Выходные данныеСкопировать11Входные данныеСкопировать5 10 101000Выходные данныеСкопировать2Входные данныеСкопировать7 2 31111111Выходные данныеСкопировать0",
      "description": "A. Превратить в единицы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записаны целые числа nn, xx и yy (1 ≤ n ≤ 300000,0≤x,y≤1091 ≤ n ≤ 300000,0≤x,y≤109) — длина строки, стоимость первой операции (разворота подотрезка) и стоимость второй операции (инвертирования всех элементов некоторого подотрезка) соответственно.Во второй строке записана строка aa длины nn, состоящая из нулей и единиц.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальную суммарную стоимость изменений, необходимых для получения строки, состоящей только из единиц. Выведите 00, если не требуется совершать никаких изменений.\n\nВыходные данные\n\nВходные данныеСкопировать5 1 1001000Выходные данныеСкопировать11Входные данныеСкопировать5 10 101000Выходные данныеСкопировать2Входные данныеСкопировать7 2 31111111Выходные данныеСкопировать0\n\nВходные данныеСкопировать5 1 1001000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 10 101000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 2 31111111\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нужно сначала перевернуть подстроку [1…2][1…2], а затем инвертировать подстроку [2…5][2…5]. Тогда строка изменялась так:«01000» →→ «10000» →→ «11111».И затраченная стоимость соответственно равна 1+10=111+10=11.Во втором примере нужно сначала инвертировать подстроку [1…1][1…1], а затем инвертировать подстроку [3…5][3…5]. Тогда строка изменялась так:«01000» →→ «11000» →→ «11111».И затраченная стоимость соответственно равна 1+1=21+1=2.В третьем примере строка уже состоит только из единиц, поэтому ответ 00.",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Привет, codeforces!Рад пригласить вас на рейтинговый раунд #493, который состоится в воскресенье, 1 июля 2018 г. в 22:05UTC+8.Авторы раунда — Ильдар 300iq Гайнуллин, Григорий vintage_Vlad_Makeev Резников, Михаил MikeMirzayanov Мирзаянов, и я, cdkrot.Большое спасибо Shiqing cyand1317 Lyu, Андрею GreenGrape Райскому, Ивану isaf27 Сафонову, Алексею Aleks5d Упирвицкому за тестирование раунда. Михаилу MikeMirzayanov Мирзаянову и Николаю KAN Калинину за помощь с подготовкой раунда.А также Михаилу MikeMirzayanov Мирзаянову за системы codeforces и polygon.Как обычно, в раунде будет 5 задач на 2 часа. Надеюсь, что вам понравятся задачи, и желаю удачи!Разбаловка будет опубликована незадолго перед раундом.UPD: Разбаловка выглядит следующим образом:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500Возможно, вы также хотите обратить внимание на этот пост со стримом-обсуждением после контеста.UPD2: Опубликован разборUPD3: Поздравляем победителей!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1133
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - ШарикиНесложно показать, что если хотя бы один ответ существует, то можно взять в ответ всего один элемент — минимальный.Предположим, что такое множество не подходит. Тогда верно одно из двух: Либо n=1n=1, и тогда решения не существует. Либо n=2n=2, и тогда второй элемент равен минимальному, в таком случае легко видеть что решения тоже нет. Ограничения также позволяли перебрать каждое из 2n2n подмножеств и проверить что оно подходит.Author — MikeMirzayanov 998B - РаспилМожно показать, что разрез после ii-го числа можно провести тогда и только тогда, когда префикс длины ii содержит равное число чётных и нечётных чисел.Тем самым, каждый разрез можно провести или не провести независимо от других (за исключением вопроса бюджета).Почему это верно?Покажем достаточность. Если провести некоторое множество разрезов соответствуя критерию выше, то результат получится корректным — каждый кусочек результата зажат между двумя разрезами, если каждый из префиксов, соответствующих разрезу, содержит одинаковое число чётных-нечётных, то и \"разница\" тоже будет такой.Покажем необходимость — если было проведено некоторое множество разрезов, то каждый из кусочков результата содержит равное количество чётных-нечётных, а значит и каждый префикс соответствующий разрезу содержит равное количество чётных-нечётных.Так как каждый разрез можно провести независимо от других, то достаточно идентифицировать все корректные разрезы, выписать их в сортированном порядке по цене, и жадно набирать минимальные.Author — 300iq 997A - Превратить в единицыВыделим отрезки подряд идущих элементов одного цвета. Например, мы разобьем «00011001110» на «000» + «11» + «00» + «111» + «0».Тогда очевидно, что не стоит делать ходы внутри одной группы, а далее (если у нас есть хотя бы два отрезка цвета 00) за один ход мы можем уменьшить на один (и не больше чем на один) количество отрезков цвета 00, заплатив за это либо xx, либо yy (как угодно).Рассмотрим на примере, пусть у нас есть строка «11001100», мы можем перевернуть отрезок [5…8][5…8], и превратить ее в строку «11000011», или, например, инвертировать отрезок [3…4][3…4], превратив строку в «11111100» (Тогда количество групп цвета 00 уменьшилось с двух до одного).Но в конце все равно требуется сделать хотя бы одно инвертирование отрезка (который в конце будет один).Тогда пусть pp — количество групп цвета 00.Если p=0p=0, ответ равен 00.Иначе ответ равен (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Римские цифрыTL; DR — среди всех вариантов выбираем вариант в котором наибольшее количество 5050, среди них с наибольшим количеством 99. Перебираем конфигурации таким образом чтобы считать каждый вариант единожды, в максимальном варианте.Так как длина записи фиксированная, то можно решать задачу не для множества цифр {1,5,10,50}{1,5,10,50}, а для множества цифр {0,4,9,49}{0,4,9,49}.Для начала решим задачу только для множества {0,4,9}{0,4,9}.Нужно бороться с тем, что некоторые числа бывают несколько раз. Но это, на самом деле, достаточно просто — если есть ≥9≥9 четвёрок, то их можно прокачать в некоторое количество девяток, а остаток заполнить нулями.В таком случае решение — это перебор количества четвёрок от 00 до min(8,n)min(8,n), а затем выбора из оставшегося множества произвольного количества девяток — все такие варианты получаются различными.Вернёмся к исходной задаче с {0,4,9,49}{0,4,9,49}.В таком случае бывает ещё ситуация, когда можно увеличить количество 4949. Нужно вычислить все такие пары (x,y)(x,y) в пределах x,y≤50x,y≤50, что их можно прокачать в другую пару (x′,y′)(x′,y′) с отщеплением некоторого количества 4949-ок.Можно перебрать xx, yy, x′x′, y′y′ четырьмя вложенными циклами и проверить что сумма одного отличается от суммы другой только 4949-ками, в таком случае помечаем пару (x,y)(x,y) как бракованную.Можно также заметить, что если мы отбраковываем какую-то пару, то и все мажорирующие пары тоже отрбраковываются.После того как мы отметили какие пары хорошие, сделаем просто:for number_of_4for number_of_9if хорошая параСчитаем ответ, просто все оставшиеся цифры или 0, или 49 и всё однозначно————Другое решение: если вы внимательно изучите решение выше, то вы заметите, что с некоторого, достаточно небольшого nn (несложно доказать оценку в духе 5050 или 100100, но на самом деле точная граница — 1212), функция растёт линейно.Таким образом, если n≤12n≤12, можно вычислить ответ любым тупым способом, а иначе просто линейно его вычислить используя answer(12)answer(12) и answer(13)answer(13).Author — cdkrot 997C - Небо в огнеПусть AiAi — множество всех раскрасок, что ii-ая строка состоит только из одного цвета, а BiBi — множество всех раскрасок, где ii-ый столбец состоит только из одного цвета.Тогда требуется вычислить |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.Как обычно, можно с помощи формулы включений исключений, вычислить можность объединения, зная мощности всех возможных пересечений описанных множеств.Более того, в силу очевидной симметрии, чтобы вычислить мощность пересечения некоторых AiAi и BiBi не важно знать какие именно индексы взяты — только количество AA-шек и количество BB-шек.Тогда ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Где f(i,j)f(i,j) — количество раскрасок у которых первые ii правильных строк и первые jj правильных столбцов.Оказывается, что ff принимает существенно разные значения в зависимости от того, есть ли ноль в её аргументах, или нет.Пусть есть, тогда f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Действительно, нужно выбрать по одному цвету в каждом из первых kk столбцов, а остальное покрасить произвольным образом.——Если оба аргумента >0>0, то есть есть хотя бы один одноцветный столбец и одна одноцветная строка, то заметим, что все Одноцветные строки и столбцы одинакового цвета, в силу пересечения строк со столбцами.Тем самым, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Так как нужно выбрать сначала общий цвет любым способом, а затем покрасить остаток произвольным образом.Просуммировав формулу выше, можно получить решение за O(n2)O(n2) или O(n2log)O(n2log) в зависимости от реализации.Но нужно быстрее.——Просуммируем все слагаемые где i=0i=0 или j=0j=0 втупую, за O(n)O(n).Изучим остальные слагаемые, имеем формулу:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Сделаем замену переменных: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijВ силу Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)ians=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijЗаметим, что (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.С помощью этого можно свернуть слагаемые при одном ii, при этом, одному ii соответствует не nn слагаемых, а n−1n−1. Можно добавить и вычесть последнее слагаемое.——-Приступимans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–В этой формуле уже O(n)O(n) слагаемых, а значит её можно просуммировать достаточно быстро.Для возведения в степень можно воспользоваться быстрым возведением в степень.Author — cdkrot 997D - Циклы в произведенииРассмотрим произвольный цикл в графе-произведении.В силу определения произведения, соседние вершины в цикле соответствуют переходу либо по ребру в первом дереве, либо переходу во втором.Тем самым, если выписать рёбра соответствующие одному дереву в отдельный список, то получим цикл в этом дереве.Также, если у нас есть цикл в одном дереве длины aa и цикл длины bb во втором дереве, то из них можно сделать Caa+bCa+ba циклов в произведении.Тем самым, задача сводится к тому, чтобы посчитать для каждой длины до kk количество циклов в каждом из деревьев по отдельности, а затем перемешать их в циклы в произведении.—–Рассмотрим центроид cc дерева, посчитаем все циклы которые проходят через него, удалим центроид и решим задачу рекурсивно в каждой из оставшихся компонент.Как выглядит цикл проходящий через cc? Это нужно начать в какой-то вершине vv, затем дойти до cc (не проходя через cc в промежуточных вершин), дойти до вершины vv, возможно проходя через cc.Определим две динамики: f[v][k]f[v][k] — это количество способов догулять из cc до vv за ровно kk шагов не проходя через cc в промежуточных вершинах, g[v][k]g[v][k] — число способов дойти от cc до vv за kk шагов без предыдущего ограничения.Тогда ответом будет свёртка f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Случай если v=cv=c нужно разобрать отдельно, тогда нужно просто сделать ans[i]+=g[c][i]ans[i]+=g[c][i].За сколько времени можно посчитать динамику? За O(nk)O(nk), g[v][i]g[v][i] равна сумме g[u][i−1]g[u][i−1] по соседям uu. Так как граф это дерево, то суммарное число соседей O(n)O(n) и суммарно O(nk)O(nk) переходов.f[v]f[v] считается аналогично, только нужно запретить все переходы в вершину cc.——Итоговая асимптотика: O(nk2log(n))O(nk2log(n)).log(n)log⁡(n) берётся из-за центроидной декомпозиции.На уровне мы считаем динамику за O(nk)O(nk), а затем считаем свёртку O(nk2)O(nk2), тем самым O(nk2log(n))O(nk2log(n)).Решение можно также соптимизировать с помощью быстрого перемножения многочленов и получить O(nklog(k)log(n))O(nklog⁡(k)log(n)), но этого не требовалось.Author — 300iq 997E - Хорошие подотрезкиРассмотрим два решения задачи для всего массива, каждое из них может быть обобщено для решения задачи на отрезка за субквадратичное время.Первое решение это разделяй и властвуй.Давайте возьмем середину массива и посчитаем число хороших отрезков, проходящих через нее.Пусть минимум и максимум лежат по одну сторону от середины, тогда по границе на той половине, где они находятся, можно восстановить весь отрезок и проверить, что он корректный (и запомнить его где-нибудь).Иначе пусть они лежат по разные стороны от середины.Тогда пусть максимум лежит слева (второй случай симметричен и может быть рассмотрен аналогично), тогда нужно чтобы r−l=max−minr−l=max−min, но rr и maxmax мы уже знаем, тогда можно перенести и сказать, что единственное необходимое условие это r−max=l−minr−max=l−min.Тогда давайте разобьем элементы на классы эквивалентности, где разбираем на классы по r−maxr−max если элемент слева и по l−minl−min если элемент справа (где maxmax и minmin это минимум и максимум на отрезке до середины mm, соответственно), тогда отрезок l≤m<rl≤m<r (где максимум слева) хороший тогда и только тогда, когда на отрезке [l…m][l…m] нет чисел меньших минимума на отрезке (m…r](m…r] и на отрезке (m…r](m…r] нет чисел больших максимума на отрезке [l…m][l…m], и при этом ll и rr лежат в одном классе.Тогда для одной границы отрезка подходит какой-то отрезок элементов из ее класса (эти отрезки можно выделить, например, проходом со стеком или бинпоиском).Еще нужно не забыть запуститься рекурсивно от левой половины и правой половины :)А далее можно применить алгоритм Мо!Будем двигать левую и правую границу, пробегаться по классам, в которым лежит эта граница, и прибавлять/вычитать из ответа размер пересечения отрезка, который подходит этой границе и отрезка, который сейчас содержится (на текущем отрезке [l…r][l…r]), таким образом эта часть работает за O(nn−−√logn)O(nnlog⁡n) (но с не очень большой константой, потому что часть при корне это просто пробежаться по массиву и провести операции с интами).Так же нужно не забыть про отрезки, где минимум и максимум содержатся по одну сторону, их можно обработать, например, пройдя сканлайном с деревом фенвика, эта часть работает за O(nlogn)O(nlog⁡n).Таким образом идея с разделяй и властвуй обобщается до O(nn−−√logn)O(nnlog⁡n).Но давайте рассмотрим геометрическую интерпретацию задачи.Пусть хорошие отрезки это точки (l,r)(l,r) на плоскости!Тогда запрос это просто сумма на прямоугольнике [1…l][r…n][1…l][r…n].Для решения задачи на всем массива давайте будем двигать правую границу запроса, и для каждой левой будем хранить r−l−(max−min)r−l−(max−min), это можно хранить в дереве отрезков (и пересчитывать храня стеки), а далее нужно заметить, что эта величина всегда неположительна, поэтому можно просто хранить в дереве отрезков количество максимумов, и каждый раз прибавлять эту величину к ответу.Для того чтобы обобщить эту идею для полного решения, давайте разобьем поле N×NN×N на квадраты K×KK×K(Цвета не важны, а просто служат для более приятного просмотра).Тогда давайте пойдем таким же сканлайном слева направо, но будем хранить все не в дереве отрезков, а в корневой.А еще будем хранить для кусочка размера KK по yy-координате количество (хороших отрезков) точек, которые мы уже в нем встретили.Таким образом мы можем отрезать от исходного запросаНижнюю часть, оставив горизонтальную полоску высотой размера ≤K≤K.Это мы сделали за O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).Пройдя аналогичным сканлайном сверху-вниз, а не слева-направо мы можем отрезать и левую часть, оставив в качестве запроса прямоугольник со сторонами <K<K.Тогда можно создать <K<K событий вида: \"Добавить к ответу на ii-й запрос сумму на вертикальном отрезке\", а эти события можно обработать пройдя сканлайном с деревом отрезков слева-направо, и выполнить эту часть за O(n⋅k⋅logn)O(n⋅k⋅log⁡n).Таким образом получается решение за O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), и выбор k=nlogn−−−−√k=nlog⁡n позволяет добиться асимптотики O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 997\\s*A"
          },
          "content_length": 13431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "cout << min(cnt * y, (cnt - 1) * x + y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 8",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if хорошая параСчитаем ответ, просто все оставшиеся цифры или 0, или 49 и всё однозначно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string a = inf.readToken(pattern, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string a = inf.readToken(pattern, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    string a = inf.readToken(pattern, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"all_ones\") {\n        s = string(n, '1');\n    } else if (type == \"all_zeros\") {\n        s = string(n, '0');\n    } else if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) + '0';\n    } else if (type == \"alternating\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2) + '0';\n    } else if (type == \"single_zero\") {\n        s = string(n, '1');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = '0';\n    } else if (type == \"blocks\") {\n        s = \"\";\n        while ((int)s.size() < n) {\n            int len = rnd.next(1, min(1000, n - (int)s.size()));\n            char c = '0' + rnd.next(2);\n            s += string(len, c);\n        }\n        s = s.substr(0, n);\n    } else if (type == \"leading_ones_trailing_zeros\") {\n        int num_ones = rnd.next(1, n - 1);\n        s = string(num_ones, '1') + string(n - num_ones, '0');\n    } else if (type == \"inverted_blocks\") {\n        s = \"\";\n        char c = '0' + rnd.next(2);\n        while ((int)s.size() < n) {\n            int len = rnd.next(1, min(1000, n - (int)s.size()));\n            s += string(len, c);\n            c = (c == '0') ? '1' : '0';\n        }\n        s = s.substr(0, n);\n    } else {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) + '0';\n    }\n\n    printf(\"%d %d %d\\n\", n, x, y);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"all_ones\") {\n        s = string(n, '1');\n    } else if (type == \"all_zeros\") {\n        s = string(n, '0');\n    } else if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) + '0';\n    } else if (type == \"alternating\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2) + '0';\n    } else if (type == \"single_zero\") {\n        s = string(n, '1');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = '0';\n    } else if (type == \"blocks\") {\n        s = \"\";\n        while ((int)s.size() < n) {\n            int len = rnd.next(1, min(1000, n - (int)s.size()));\n            char c = '0' + rnd.next(2);\n            s += string(len, c);\n        }\n        s = s.substr(0, n);\n    } else if (type == \"leading_ones_trailing_zeros\") {\n        int num_ones = rnd.next(1, n - 1);\n        s = string(num_ones, '1') + string(n - num_ones, '0');\n    } else if (type == \"inverted_blocks\") {\n        s = \"\";\n        char c = '0' + rnd.next(2);\n        while ((int)s.size() < n) {\n            int len = rnd.next(1, min(1000, n - (int)s.size()));\n            s += string(len, c);\n            c = (c == '0') ? '1' : '0';\n        }\n        s = s.substr(0, n);\n    } else {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) + '0';\n    }\n\n    printf(\"%d %d %d\\n\", n, x, y);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -x 0 -y 0 -type all_ones\n./gen -n 1 -x 1 -y 1 -type all_zeros\n./gen -n 2 -x 0 -y 1000000000 -type alternating\n./gen -n 10 -x 1000000000 -y 0 -type single_zero\n./gen -n 100 -x 1000000000 -y 1000000000 -type blocks\n./gen -n 100 -x 0 -y 0 -type random\n./gen -n 1000 -x 123456789 -y 987654321 -type leading_ones_trailing_zeros\n./gen -n 10000 -x 5000 -y 5000 -type inverted_blocks\n./gen -n 100000 -x 1 -y 1 -type all_ones\n./gen -n 300000 -x 1000000000 -y 1000000000 -type all_zeros\n./gen -n 300000 -x 0 -y 0 -type random\n./gen -n 300000 -x 0 -y 1000000000 -type single_zero\n./gen -n 300000 -x 1000000000 -y 0 -type single_zero\n./gen -n 300000 -x 123456789 -y 987654321 -type leading_ones_trailing_zeros\n./gen -n 300000 -x 10000 -y 20000 -type alternating\n./gen -n 299999 -x 1000 -y 1 -type inverted_blocks\n./gen -n 300000 -x 1 -y 1000 -type inverted_blocks\n./gen -n 100000 -x 0 -y 1 -type all_zeros\n./gen -n 100000 -x 1 -y 0 -type all_zeros\n./gen -n 100000 -x 1000000000 -y 1000000000 -type random\n./gen -n 10000 -x 1000000000 -y 0 -type all_ones\n./gen -n 10000 -x 0 -y 1000000000 -type all_zeros\n./gen -n 10000 -x 1000000000 -y 1000000000 -type alternating\n./gen -n 10000 -x 0 -y 0 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:04.040597",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "997/B",
      "title": "B. Roman Digits",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input file contains a single integer nn (1≤n≤1091≤n≤109) — the number of roman digits to use.",
      "output_spec": "OutputOutput a single integer — the number of distinct integers which can be represented using nn roman digits exactly.",
      "sample_tests": "ExamplesInputCopy1OutputCopy4InputCopy2OutputCopy10InputCopy10OutputCopy244",
      "description": "B. Roman Digits\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input file contains a single integer nn (1≤n≤1091≤n≤109) — the number of roman digits to use.\n\nOutputOutput a single integer — the number of distinct integers which can be represented using nn roman digits exactly.\n\nInputCopy1OutputCopy4InputCopy2OutputCopy10InputCopy10OutputCopy244\n\nOutputCopy4\n\nOutputCopy10\n\nInputCopy10\n\nOutputCopy244\n\nNoteIn the first sample there are exactly 44 integers which can be represented — I, V, X and L.In the second sample it is possible to represent integers 22 (II), 66 (VI), 1010 (VV), 1111 (XI), 1515 (XV), 2020 (XX), 5151 (IL), 5555 (VL), 6060 (XL) and 100100 (LL).",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds: Either n=1n=1, and then there is no solution Or n=2n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n2n subsets and checks them also passes.Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 997\\s*B"
          },
          "content_length": 13513
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n != -1) {\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n\n    string type = opt<string>(\"type\", \"small\");\n\n    if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"medium\") {\n        n = rnd.next(10, 1000);\n    } else if (type == \"large\") {\n        n = rnd.next(100000, 100000000);\n    } else if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"random\") {\n        int from = opt<int>(\"from\",1);\n        int to = opt<int>(\"to\",1000000000);\n        n = rnd.next(from, to);\n    } else if (type == \"special\") {\n        string which = opt<string>(\"which\", \"1\");\n        if (which == \"1\") n = 1;\n        else if (which == \"2\") n = 2;\n        else if (which == \"3\") n = 3;\n        else if (which == \"large_prime\") n = 999999937; // A large prime less than 1e9\n        else if (which == \"max\") n = 1000000000;\n        else n = rnd.next(1,1000000000);\n    } else {\n        n = rnd.next(1, 1000000000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    if (n != -1) {\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n\n    string type = opt<string>(\"type\", \"small\");\n\n    if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"medium\") {\n        n = rnd.next(10, 1000);\n    } else if (type == \"large\") {\n        n = rnd.next(100000, 100000000);\n    } else if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"random\") {\n        int from = opt<int>(\"from\",1);\n        int to = opt<int>(\"to\",1000000000);\n        n = rnd.next(from, to);\n    } else if (type == \"special\") {\n        string which = opt<string>(\"which\", \"1\");\n        if (which == \"1\") n = 1;\n        else if (which == \"2\") n = 2;\n        else if (which == \"3\") n = 3;\n        else if (which == \"large_prime\") n = 999999937; // A large prime less than 1e9\n        else if (which == \"max\") n = 1000000000;\n        else n = rnd.next(1,1000000000);\n    } else {\n        n = rnd.next(1, 1000000000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n (edge cases)\n./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n\n# Small random n\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Medium n\n./gen -n 10\n./gen -n 20\n./gen -n 50\n./gen -n 100\n\n# Medium random n\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n# Large n\n./gen -n 100000\n./gen -n 500000\n./gen -n 1000000\n\n# Large random n\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Max n\n./gen -n 1000000000\n./gen -type max\n\n# Random n in full range\n./gen -type random -from 1 -to 1000000000\n./gen -type random -from 1 -to 1000000000\n./gen -type random -from 1 -to 1000000000\n\n# Random n in high range\n./gen -type random -from 999999900 -to 1000000000\n./gen -type random -from 999999900 -to 1000000000\n./gen -type random -from 999999900 -to 1000000000\n\n# Random n in low range\n./gen -type random -from 1 -to 100\n\n# Special n (special cases)\n./gen -type special -which 1\n./gen -type special -which 2\n./gen -type special -which 3\n./gen -type special -which large_prime\n./gen -type special -which max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:06.406888",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "997/C",
      "title": "C. Sky Full of Stars",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and only line of input contains a single integer nn (1≤n≤10000001≤n≤1000000) — the number of rows and columns in the calendar.",
      "output_spec": "OutputPrint one number — number of lucky colorings of the calendar modulo 998244353998244353",
      "sample_tests": "ExamplesInputCopy1OutputCopy3InputCopy2OutputCopy63InputCopy3OutputCopy9933",
      "description": "C. Sky Full of Stars\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and only line of input contains a single integer nn (1≤n≤10000001≤n≤1000000) — the number of rows and columns in the calendar.\n\nOutputPrint one number — number of lucky colorings of the calendar modulo 998244353998244353\n\nInputCopy1OutputCopy3InputCopy2OutputCopy63InputCopy3OutputCopy9933\n\nOutputCopy3\n\nOutputCopy63\n\nOutputCopy9933\n\nNoteIn the first sample any coloring is lucky, since the only column contains cells of only one color.In the second sample, there are a lot of lucky colorings, in particular, the following colorings are lucky:  While these colorings are not lucky:",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev Tutorial is loading...Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 997\\s*C"
          },
          "content_length": 13036
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 5\n./gen -n 10\n./gen -n 50\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 10000\n./gen -n 50000\n./gen -n 100000\n./gen -n 200000\n./gen -n 300000\n./gen -n 400000\n./gen -n 500000\n./gen -n 600000\n./gen -n 700000\n./gen -n 800000\n./gen -n 900000\n./gen -n 950000\n./gen -n 999999\n./gen -n 1000000\n./gen -n 123456\n./gen -n 234567\n./gen -n 345678\n./gen -n 456789\n./gen -n 567890\n./gen -n 678901\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:08.844034",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "997/D",
      "title": "D. Cycles in product",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test7 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains three integers — n1n1, n2n2 and kk (2≤n1,n2≤40002≤n1,n2≤4000, 2≤k≤752≤k≤75) — number of vertices in the first tree, number of vertices in the second tree and the cycle length respectively.Then follow n1−1n1−1 lines describing the first tree. Each of this lines contains two integers — vi,uivi,ui (1≤vi,ui≤n11≤vi,ui≤n1), which define edges of the first tree.Then follow n2−1n2−1 lines, which describe the second tree in the same format.It is guaranteed, that given graphs are trees.",
      "output_spec": "OutputPrint one integer — number of cycles modulo 998244353998244353.",
      "sample_tests": "ExamplesInputCopy2 2 21 21 2OutputCopy8InputCopy2 2 41 21 2OutputCopy32InputCopy2 3 41 21 21 3OutputCopy70InputCopy4 2 21 21 31 41 2OutputCopy20",
      "description": "D. Cycles in product\n\ntime limit per test7 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains three integers — n1n1, n2n2 and kk (2≤n1,n2≤40002≤n1,n2≤4000, 2≤k≤752≤k≤75) — number of vertices in the first tree, number of vertices in the second tree and the cycle length respectively.Then follow n1−1n1−1 lines describing the first tree. Each of this lines contains two integers — vi,uivi,ui (1≤vi,ui≤n11≤vi,ui≤n1), which define edges of the first tree.Then follow n2−1n2−1 lines, which describe the second tree in the same format.It is guaranteed, that given graphs are trees.\n\nOutputPrint one integer — number of cycles modulo 998244353998244353.\n\nInputCopy2 2 21 21 2OutputCopy8InputCopy2 2 41 21 2OutputCopy32InputCopy2 3 41 21 21 3OutputCopy70InputCopy4 2 21 21 31 41 2OutputCopy20\n\nInputCopy2 2 21 21 2\n\nOutputCopy8\n\nInputCopy2 2 41 21 2\n\nOutputCopy32\n\nInputCopy2 3 41 21 21 3\n\nOutputCopy70\n\nInputCopy4 2 21 21 31 41 2\n\nOutputCopy20\n\nNoteThe following three pictures illustrate graph, which are products of the trees from sample tests.In the first example, the list of cycles of length 22 is as follows:  «AB», «BA»  «BC», «CB»  «AD», «DA»  «CD», «DC»",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds: Either n=1n=1, and then there is no solution Or n=2n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n2n subsets and checks them also passes.Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 997\\s*D"
          },
          "content_length": 13513
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid validate_tree(int n, int tree_num) {\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        ensuref(vi != ui, \"Edges cannot be self-loops in tree %d at edge %d\", tree_num, i+1);\n        int a = min(vi, ui);\n        int b = max(vi, ui);\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Multiple edges are not allowed in tree %d between nodes %d and %d\", tree_num, vi, ui);\n        edges.insert(make_pair(a, b));\n        adj[vi].push_back(ui);\n        adj[ui].push_back(vi);\n    }\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n    dfs(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Tree %d is not connected, node %d is not reachable from node 1\", tree_num, i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n1 = inf.readInt(2, 4000, \"n1\");\n    inf.readSpace();\n    int n2 = inf.readInt(2, 4000, \"n2\");\n    inf.readSpace();\n    int k = inf.readInt(2, 75, \"k\");\n    inf.readEoln();\n\n    validate_tree(n1, 1);\n\n    validate_tree(n2, 2);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid validate_tree(int n, int tree_num) {\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        ensuref(vi != ui, \"Edges cannot be self-loops in tree %d at edge %d\", tree_num, i+1);\n        int a = min(vi, ui);\n        int b = max(vi, ui);\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Multiple edges are not allowed in tree %d between nodes %d and %d\", tree_num, vi, ui);\n        edges.insert(make_pair(a, b));\n        adj[vi].push_back(ui);\n        adj[ui].push_back(vi);\n    }\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n    dfs(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Tree %d is not connected, node %d is not reachable from node 1\", tree_num, i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n1 = inf.readInt(2, 4000, \"n1\");\n    inf.readSpace();\n    int n2 = inf.readInt(2, 4000, \"n2\");\n    inf.readSpace();\n    int k = inf.readInt(2, 75, \"k\");\n    inf.readEoln();\n\n    validate_tree(n1, 1);\n\n    validate_tree(n2, 2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid validate_tree(int n, int tree_num) {\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        ensuref(vi != ui, \"Edges cannot be self-loops in tree %d at edge %d\", tree_num, i+1);\n        int a = min(vi, ui);\n        int b = max(vi, ui);\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Multiple edges are not allowed in tree %d between nodes %d and %d\", tree_num, vi, ui);\n        edges.insert(make_pair(a, b));\n        adj[vi].push_back(ui);\n        adj[ui].push_back(vi);\n    }\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n    dfs(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Tree %d is not connected, node %d is not reachable from node 1\", tree_num, i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n1 = inf.readInt(2, 4000, \"n1\");\n    inf.readSpace();\n    int n2 = inf.readInt(2, 4000, \"n2\");\n    inf.readSpace();\n    int k = inf.readInt(2, 75, \"k\");\n    inf.readEoln();\n\n    validate_tree(n1, 1);\n\n    validate_tree(n2, 2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_chain(int n) {\n    vector<pair<int,int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({i-1, i});\n    }\n    return edges;\n}\n\nvector<pair<int,int>> generate_star(int n) {\n    vector<pair<int,int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n    return edges;\n}\n\nvector<pair<int,int>> generate_random_tree(int n) {\n    vector<int> p(n+1);\n    for(int i = 2; i <= n; ++i) {\n        p[i] = rnd.next(1, i-1);\n    }\n    vector<pair<int,int>> edges;\n    for(int i = 2; i <= n; ++i) {\n        edges.push_back({p[i], i});\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\nvector<pair<int,int>> generate_bbt(int n) {\n    vector<pair<int,int>> edges;\n\n    int idx = 1;\n    queue<int> q;\n    q.push(idx++); // start with node 1\n    while(idx <= n) {\n        int u = q.front(); q.pop();\n        int left = idx++;\n        edges.push_back({u, left});\n        q.push(left);\n        if(idx <= n) {\n            int right = idx++;\n            edges.push_back({u, right});\n            q.push(right);\n        }\n    }\n    return edges;\n}\n\nvoid shuffle_and_output_edges(vector<pair<int,int>> &edges, int n) {\n    // Maybe shuffle labels\n    vector<int> labels(n+1);\n    for(int i = 1; i <= n; ++i) labels[i] = i;\n    shuffle(labels.begin()+1, labels.end());\n\n    for(auto &e : edges) {\n        e.first = labels[e.first];\n        e.second = labels[e.second];\n        if(rnd.next(0,1)) swap(e.first, e.second);\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n1 = opt<int>(\"n1\");\n    string type1 = opt<string>(\"type1\", \"random\");\n    int n2 = opt<int>(\"n2\");\n    string type2 = opt<string>(\"type2\", \"random\");\n    int k = opt<int>(\"k\");\n\n    printf(\"%d %d %d\\n\", n1, n2, k);\n\n    // Generate T1\n    vector<pair<int,int>> edges1;\n    if(type1 == \"chain\") {\n        edges1 = generate_chain(n1);\n    } else if(type1 == \"star\") {\n        edges1 = generate_star(n1);\n    } else if(type1 == \"bbt\") {\n        edges1 = generate_bbt(n1);\n    } else { // random\n        edges1 = generate_random_tree(n1);\n    }\n    shuffle_and_output_edges(edges1, n1);\n\n    // Generate T2\n    vector<pair<int,int>> edges2;\n    if(type2 == \"chain\") {\n        edges2 = generate_chain(n2);\n    } else if(type2 == \"star\") {\n        edges2 = generate_star(n2);\n    } else if(type2 == \"bbt\") {\n        edges2 = generate_bbt(n2);\n    } else { // random\n        edges2 = generate_random_tree(n2);\n    }\n    shuffle_and_output_edges(edges2, n2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_chain(int n) {\n    vector<pair<int,int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({i-1, i});\n    }\n    return edges;\n}\n\nvector<pair<int,int>> generate_star(int n) {\n    vector<pair<int,int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n    return edges;\n}\n\nvector<pair<int,int>> generate_random_tree(int n) {\n    vector<int> p(n+1);\n    for(int i = 2; i <= n; ++i) {\n        p[i] = rnd.next(1, i-1);\n    }\n    vector<pair<int,int>> edges;\n    for(int i = 2; i <= n; ++i) {\n        edges.push_back({p[i], i});\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\nvector<pair<int,int>> generate_bbt(int n) {\n    vector<pair<int,int>> edges;\n\n    int idx = 1;\n    queue<int> q;\n    q.push(idx++); // start with node 1\n    while(idx <= n) {\n        int u = q.front(); q.pop();\n        int left = idx++;\n        edges.push_back({u, left});\n        q.push(left);\n        if(idx <= n) {\n            int right = idx++;\n            edges.push_back({u, right});\n            q.push(right);\n        }\n    }\n    return edges;\n}\n\nvoid shuffle_and_output_edges(vector<pair<int,int>> &edges, int n) {\n    // Maybe shuffle labels\n    vector<int> labels(n+1);\n    for(int i = 1; i <= n; ++i) labels[i] = i;\n    shuffle(labels.begin()+1, labels.end());\n\n    for(auto &e : edges) {\n        e.first = labels[e.first];\n        e.second = labels[e.second];\n        if(rnd.next(0,1)) swap(e.first, e.second);\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n1 = opt<int>(\"n1\");\n    string type1 = opt<string>(\"type1\", \"random\");\n    int n2 = opt<int>(\"n2\");\n    string type2 = opt<string>(\"type2\", \"random\");\n    int k = opt<int>(\"k\");\n\n    printf(\"%d %d %d\\n\", n1, n2, k);\n\n    // Generate T1\n    vector<pair<int,int>> edges1;\n    if(type1 == \"chain\") {\n        edges1 = generate_chain(n1);\n    } else if(type1 == \"star\") {\n        edges1 = generate_star(n1);\n    } else if(type1 == \"bbt\") {\n        edges1 = generate_bbt(n1);\n    } else { // random\n        edges1 = generate_random_tree(n1);\n    }\n    shuffle_and_output_edges(edges1, n1);\n\n    // Generate T2\n    vector<pair<int,int>> edges2;\n    if(type2 == \"chain\") {\n        edges2 = generate_chain(n2);\n    } else if(type2 == \"star\") {\n        edges2 = generate_star(n2);\n    } else if(type2 == \"bbt\") {\n        edges2 = generate_bbt(n2);\n    } else { // random\n        edges2 = generate_random_tree(n2);\n    }\n    shuffle_and_output_edges(edges2, n2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n1 2 -type1 chain -n2 2 -type2 chain -k 2\n./gen -n1 2 -type1 chain -n2 2 -type2 chain -k 75\n\n./gen -n1 2 -type1 star -n2 2 -type2 star -k 2\n./gen -n1 2 -type1 star -n2 2 -type2 star -k 75\n\n./gen -n1 3 -type1 bbt -n2 3 -type2 bbt -k 3\n\n./gen -n1 4000 -type1 random -n2 4000 -type2 random -k 2\n./gen -n1 4000 -type1 random -n2 4000 -type2 random -k 75\n\n./gen -n1 4000 -type1 chain -n2 4000 -type2 chain -k 75\n./gen -n1 4000 -type1 star -n2 4000 -type2 star -k 75\n./gen -n1 4000 -type1 bbt -n2 4000 -type2 bbt -k 75\n\n./gen -n1 1000 -type1 chain -n2 1000 -type2 star -k 50\n./gen -n1 1000 -type1 bbt -n2 1000 -type2 random -k 50\n\n./gen -n1 4000 -type1 star -n2 2 -type2 chain -k 75\n./gen -n1 2 -type1 chain -n2 4000 -type2 star -k 75\n\n./gen -n1 2000 -type1 bbt -n2 2000 -type2 chain -k 75\n\n./gen -n1 4000 -type1 random -n2 3 -type2 chain -k 75\n./gen -n1 2 -type1 star -n2 4000 -type2 random -k 75\n\n./gen -n1 3000 -type1 random -n2 3000 -type2 random -k 10\n./gen -n1 4000 -type1 random -n2 4000 -type2 random -k 10\n\n./gen -n1 4000 -type1 chain -n2 4000 -type2 random -k 75\n./gen -n1 4000 -type1 star -n2 4000 -type2 random -k 75\n./gen -n1 4000 -type1 bbt -n2 4000 -type2 random -k 75\n./gen -n1 4000 -type1 random -n2 4000 -type2 random -k 50\n./gen -n1 50 -type1 star -n2 4000 -type2 chain -k 75\n./gen -n1 4000 -type1 chain -n2 50 -type2 star -k 75\n./gen -n1 4000 -type1 star -n2 4000 -type2 bbt -k 75\n./gen -n1 4000 -type1 random -n2 4000 -type2 random -k 2\n./gen -n1 4000 -type1 random -n2 4000 -type2 random -k 75\n./gen -n1 4000 -type1 chain -n2 4000 -type2 star -k 75\n./gen -n1 4000 -type1 star -n2 4000 -type2 chain -k 75\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:10.894285",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "997/E",
      "title": "E. Good Subsegments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test7 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (1≤n≤1200001≤n≤120000) — the number of elements in the permutation.The second line contains nn distinct integers p1,p2,…,pnp1,p2,…,pn separated by spaces (1≤pi≤n1≤pi≤n).The third line contains an integer qq (1≤q≤1200001≤q≤120000) — number of queries.The following qq lines describe queries, each line contains a pair of integers ll, rr separated by space (1≤l≤r≤n1≤l≤r≤n).",
      "output_spec": "OutputPrint a qq lines, ii-th of them should contain a number of good subsegments of a segment, given in the ii-th query.",
      "sample_tests": "ExampleInputCopy51 3 2 5 4151 11 21 31 41 52 22 32 42 53 33 43 54 44 55 5OutputCopy1256101347124131",
      "description": "E. Good Subsegments\n\ntime limit per test7 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (1≤n≤1200001≤n≤120000) — the number of elements in the permutation.The second line contains nn distinct integers p1,p2,…,pnp1,p2,…,pn separated by spaces (1≤pi≤n1≤pi≤n).The third line contains an integer qq (1≤q≤1200001≤q≤120000) — number of queries.The following qq lines describe queries, each line contains a pair of integers ll, rr separated by space (1≤l≤r≤n1≤l≤r≤n).\n\nOutputPrint a qq lines, ii-th of them should contain a number of good subsegments of a segment, given in the ii-th query.\n\nInputCopy51 3 2 5 4151 11 21 31 41 52 22 32 42 53 33 43 54 44 55 5OutputCopy1256101347124131\n\nInputCopy51 3 2 5 4151 11 21 31 41 52 22 32 42 53 33 43 54 44 55 5\n\nOutputCopy1256101347124131",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds: Either n=1n=1, and then there is no solution Or n=2n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n2n subsets and checks them also passes.Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 997\\s*E"
          },
          "content_length": 13513
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 120000, \"n\");\n    inf.readEoln();\n\n    // Read p_i and ensure they are between 1 and n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    // Check that p is a permutation of {1..n}\n    vector<int> sorted_p = p;\n    sort(sorted_p.begin(), sorted_p.end());\n    for (int i = 0; i < n; i++) {\n        ensuref(sorted_p[i] == i + 1, \"p must be a permutation of {1..n}, but found %d at position %d\", sorted_p[i], i + 1);\n    }\n\n    // Read q\n    int q = inf.readInt(1, 120000, \"q\");\n    inf.readEoln();\n\n    // Read each query and ensure constraints\n    for (int i = 0; i < q; i++) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 120000, \"n\");\n    inf.readEoln();\n\n    // Read p_i and ensure they are between 1 and n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    // Check that p is a permutation of {1..n}\n    vector<int> sorted_p = p;\n    sort(sorted_p.begin(), sorted_p.end());\n    for (int i = 0; i < n; i++) {\n        ensuref(sorted_p[i] == i + 1, \"p must be a permutation of {1..n}, but found %d at position %d\", sorted_p[i], i + 1);\n    }\n\n    // Read q\n    int q = inf.readInt(1, 120000, \"q\");\n    inf.readEoln();\n\n    // Read each query and ensure constraints\n    for (int i = 0; i < q; i++) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 120000, \"n\");\n    inf.readEoln();\n\n    // Read p_i and ensure they are between 1 and n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    // Check that p is a permutation of {1..n}\n    vector<int> sorted_p = p;\n    sort(sorted_p.begin(), sorted_p.end());\n    for (int i = 0; i < n; i++) {\n        ensuref(sorted_p[i] == i + 1, \"p must be a permutation of {1..n}, but found %d at position %d\", sorted_p[i], i + 1);\n    }\n\n    // Read q\n    int q = inf.readInt(1, 120000, \"q\");\n    inf.readEoln();\n\n    // Read each query and ensure constraints\n    for (int i = 0; i < q; i++) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> p(n);\n    if (type == \"sorted\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"alternate\") {\n        int left = 1, right = n;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = left++;\n            else\n                p[i] = right--;\n        }\n    } else if (type == \"zigzag\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = i / 2 + 1;\n            else\n                p[i] = n - i / 2;\n        }\n    } else {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output permutation p\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], (i == n - 1) ? '\\n' : ' ');\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    if (query_type == \"full\") {\n        // Each query covers the full range\n        for (int i = 0; i < q; ++i)\n            printf(\"%d %d\\n\", 1, n);\n    } else if (query_type == \"single\") {\n        // Each query covers a single random element\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            printf(\"%d %d\\n\", l, l);\n        }\n    } else if (query_type == \"edge\") {\n        // Queries starting or ending at edges\n        for (int i = 0; i < q; ++i) {\n            if (i % 2 == 0)\n                printf(\"%d %d\\n\", 1, rnd.next(1, n));\n            else\n                printf(\"%d %d\\n\", rnd.next(1, n), n);\n        }\n    } else if (query_type == \"first_half\") {\n        // Queries within the first half\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(1, n / 2);\n            if (l > r) swap(l, r);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (query_type == \"second_half\") {\n        // Queries within the second half\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(n / 2 + 1, n);\n            int r = rnd.next(n / 2 + 1, n);\n            if (l > r) swap(l, r);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (query_type == \"random_same\") {\n        // All queries are the same random segment\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if (l > r) swap(l, r);\n        for (int i = 0; i < q; ++i)\n            printf(\"%d %d\\n\", l, r);\n    } else {\n        // Random queries\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            printf(\"%d %d\\n\", l, r);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> p(n);\n    if (type == \"sorted\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"alternate\") {\n        int left = 1, right = n;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = left++;\n            else\n                p[i] = right--;\n        }\n    } else if (type == \"zigzag\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p[i] = i / 2 + 1;\n            else\n                p[i] = n - i / 2;\n        }\n    } else {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output permutation p\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], (i == n - 1) ? '\\n' : ' ');\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    if (query_type == \"full\") {\n        // Each query covers the full range\n        for (int i = 0; i < q; ++i)\n            printf(\"%d %d\\n\", 1, n);\n    } else if (query_type == \"single\") {\n        // Each query covers a single random element\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            printf(\"%d %d\\n\", l, l);\n        }\n    } else if (query_type == \"edge\") {\n        // Queries starting or ending at edges\n        for (int i = 0; i < q; ++i) {\n            if (i % 2 == 0)\n                printf(\"%d %d\\n\", 1, rnd.next(1, n));\n            else\n                printf(\"%d %d\\n\", rnd.next(1, n), n);\n        }\n    } else if (query_type == \"first_half\") {\n        // Queries within the first half\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(1, n / 2);\n            if (l > r) swap(l, r);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (query_type == \"second_half\") {\n        // Queries within the second half\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(n / 2 + 1, n);\n            int r = rnd.next(n / 2 + 1, n);\n            if (l > r) swap(l, r);\n            printf(\"%d %d\\n\", l, r);\n        }\n    } else if (query_type == \"random_same\") {\n        // All queries are the same random segment\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if (l > r) swap(l, r);\n        for (int i = 0; i < q; ++i)\n            printf(\"%d %d\\n\", l, r);\n    } else {\n        // Random queries\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            printf(\"%d %d\\n\", l, r);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size test case\n./gen -n 1 -q 1 -type sorted -query_type single\n\n# Small sizes\n./gen -n 10 -q 5 -type sorted -query_type single\n./gen -n 10 -q 5 -type reversed -query_type single\n./gen -n 10 -q 5 -type random -query_type random\n\n# Medium sizes\n./gen -n 1000 -q 500 -type random -query_type random\n./gen -n 1000 -q 500 -type alternate -query_type random\n\n# Edge cases with maximum sizes\n./gen -n 120000 -q 120000 -type sorted -query_type full\n./gen -n 120000 -q 120000 -type reversed -query_type full\n./gen -n 120000 -q 1 -type random -query_type full\n./gen -n 120000 -q 120000 -type random -query_type random\n./gen -n 120000 -q 120000 -type random -query_type single\n./gen -n 1 -q 120000 -type sorted -query_type single\n\n# Stress tests\n./gen -n 120000 -q 120000 -type random -query_type random\n./gen -n 120000 -q 120000 -type alternate -query_type edge\n./gen -n 120000 -q 120000 -type zigzag -query_type edge\n\n# Half range queries\n./gen -n 100000 -q 50000 -type random -query_type first_half\n./gen -n 100000 -q 50000 -type random -query_type second_half\n\n# Random same queries\n./gen -n 100000 -q 100000 -type random -query_type random_same\n\n# Different permutations with random queries\n./gen -n 100000 -q 100000 -type sorted -query_type random\n./gen -n 100000 -q 100000 -type reversed -query_type random\n./gen -n 100000 -q 100000 -type zigzag -query_type random\n\n# Edge queries\n./gen -n 100000 -q 50000 -type random -query_type edge\n\n# Maximum size single element queries\n./gen -n 120000 -q 120000 -type random -query_type single\n\n# Maximum size full range queries\n./gen -n 120000 -q 120000 -type random -query_type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:12.649628",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "998/A",
      "title": "A. Шарики",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке дано единственное число nn (1≤n≤101≤n≤10) — количество пакетов с шариками.Вторая строка содержит nn чисел: a1a1, a2a2, ……, anan (1≤ai≤10001≤ai≤1000) — количество шариков внутри соответствующего пакета.",
      "output_spec": "Выходные данныеЕсли поделить пакеты с шариками, соблюдая все ограничения, не удастся, выведите −1−1.Иначе выведите число kk — количество пакетов, которые надо отдать Грише, а затем kk различных чисел от 11 до nn — номера соответствующих пакетов.Если существует несколько способов раздать пакеты с шариками, выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 2 1Выходные данныеСкопировать21 2Входные данныеСкопировать25 5Выходные данныеСкопировать-1Входные данныеСкопировать110Выходные данныеСкопировать-1",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке дано единственное число nn (1≤n≤101≤n≤10) — количество пакетов с шариками.Вторая строка содержит nn чисел: a1a1, a2a2, ……, anan (1≤ai≤10001≤ai≤1000) — количество шариков внутри соответствующего пакета.\n\nВходные данные\n\nВыходные данныеЕсли поделить пакеты с шариками, соблюдая все ограничения, не удастся, выведите −1−1.Иначе выведите число kk — количество пакетов, которые надо отдать Грише, а затем kk различных чисел от 11 до nn — номера соответствующих пакетов.Если существует несколько способов раздать пакеты с шариками, выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать31 2 1Выходные данныеСкопировать21 2Входные данныеСкопировать25 5Выходные данныеСкопировать-1Входные данныеСкопировать110Выходные данныеСкопировать-1\n\nВходные данныеСкопировать31 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать25 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать110\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Гриша получит суммарно 33 шарика, а Андрей 11.Во втором примере единственный способ разделить пакеты так, чтобы каждый получил хотя бы один из них, приведёт к тому, что суммарное количество шариков у Гриши и Андрея совпадёт.В третьем примере нельзя разделить пакеты так, чтобы каждый получил хотя бы один.",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Привет, codeforces!Рад пригласить вас на рейтинговый раунд #493, который состоится в воскресенье, 1 июля 2018 г. в 22:05UTC+8.Авторы раунда — Ильдар 300iq Гайнуллин, Григорий vintage_Vlad_Makeev Резников, Михаил MikeMirzayanov Мирзаянов, и я, cdkrot.Большое спасибо Shiqing cyand1317 Lyu, Андрею GreenGrape Райскому, Ивану isaf27 Сафонову, Алексею Aleks5d Упирвицкому за тестирование раунда. Михаилу MikeMirzayanov Мирзаянову и Николаю KAN Калинину за помощь с подготовкой раунда.А также Михаилу MikeMirzayanov Мирзаянову за системы codeforces и polygon.Как обычно, в раунде будет 5 задач на 2 часа. Надеюсь, что вам понравятся задачи, и желаю удачи!Разбаловка будет опубликована незадолго перед раундом.UPD: Разбаловка выглядит следующим образом:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500Возможно, вы также хотите обратить внимание на этот пост со стримом-обсуждением после контеста.UPD2: Опубликован разборUPD3: Поздравляем победителей!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1133
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - ШарикиНесложно показать, что если хотя бы один ответ существует, то можно взять в ответ всего один элемент — минимальный.Предположим, что такое множество не подходит. Тогда верно одно из двух: Либо n=1n=1, и тогда решения не существует. Либо n=2n=2, и тогда второй элемент равен минимальному, в таком случае легко видеть что решения тоже нет. Ограничения также позволяли перебрать каждое из 2n2n подмножеств и проверить что оно подходит.Author — MikeMirzayanov 998B - РаспилМожно показать, что разрез после ii-го числа можно провести тогда и только тогда, когда префикс длины ii содержит равное число чётных и нечётных чисел.Тем самым, каждый разрез можно провести или не провести независимо от других (за исключением вопроса бюджета).Почему это верно?Покажем достаточность. Если провести некоторое множество разрезов соответствуя критерию выше, то результат получится корректным — каждый кусочек результата зажат между двумя разрезами, если каждый из префиксов, соответствующих разрезу, содержит одинаковое число чётных-нечётных, то и \"разница\" тоже будет такой.Покажем необходимость — если было проведено некоторое множество разрезов, то каждый из кусочков результата содержит равное количество чётных-нечётных, а значит и каждый префикс соответствующий разрезу содержит равное количество чётных-нечётных.Так как каждый разрез можно провести независимо от других, то достаточно идентифицировать все корректные разрезы, выписать их в сортированном порядке по цене, и жадно набирать минимальные.Author — 300iq 997A - Превратить в единицыВыделим отрезки подряд идущих элементов одного цвета. Например, мы разобьем «00011001110» на «000» + «11» + «00» + «111» + «0».Тогда очевидно, что не стоит делать ходы внутри одной группы, а далее (если у нас есть хотя бы два отрезка цвета 00) за один ход мы можем уменьшить на один (и не больше чем на один) количество отрезков цвета 00, заплатив за это либо xx, либо yy (как угодно).Рассмотрим на примере, пусть у нас есть строка «11001100», мы можем перевернуть отрезок [5…8][5…8], и превратить ее в строку «11000011», или, например, инвертировать отрезок [3…4][3…4], превратив строку в «11111100» (Тогда количество групп цвета 00 уменьшилось с двух до одного).Но в конце все равно требуется сделать хотя бы одно инвертирование отрезка (который в конце будет один).Тогда пусть pp — количество групп цвета 00.Если p=0p=0, ответ равен 00.Иначе ответ равен (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Римские цифрыTL; DR — среди всех вариантов выбираем вариант в котором наибольшее количество 5050, среди них с наибольшим количеством 99. Перебираем конфигурации таким образом чтобы считать каждый вариант единожды, в максимальном варианте.Так как длина записи фиксированная, то можно решать задачу не для множества цифр {1,5,10,50}{1,5,10,50}, а для множества цифр {0,4,9,49}{0,4,9,49}.Для начала решим задачу только для множества {0,4,9}{0,4,9}.Нужно бороться с тем, что некоторые числа бывают несколько раз. Но это, на самом деле, достаточно просто — если есть ≥9≥9 четвёрок, то их можно прокачать в некоторое количество девяток, а остаток заполнить нулями.В таком случае решение — это перебор количества четвёрок от 00 до min(8,n)min(8,n), а затем выбора из оставшегося множества произвольного количества девяток — все такие варианты получаются различными.Вернёмся к исходной задаче с {0,4,9,49}{0,4,9,49}.В таком случае бывает ещё ситуация, когда можно увеличить количество 4949. Нужно вычислить все такие пары (x,y)(x,y) в пределах x,y≤50x,y≤50, что их можно прокачать в другую пару (x′,y′)(x′,y′) с отщеплением некоторого количества 4949-ок.Можно перебрать xx, yy, x′x′, y′y′ четырьмя вложенными циклами и проверить что сумма одного отличается от суммы другой только 4949-ками, в таком случае помечаем пару (x,y)(x,y) как бракованную.Можно также заметить, что если мы отбраковываем какую-то пару, то и все мажорирующие пары тоже отрбраковываются.После того как мы отметили какие пары хорошие, сделаем просто:for number_of_4for number_of_9if хорошая параСчитаем ответ, просто все оставшиеся цифры или 0, или 49 и всё однозначно————Другое решение: если вы внимательно изучите решение выше, то вы заметите, что с некоторого, достаточно небольшого nn (несложно доказать оценку в духе 5050 или 100100, но на самом деле точная граница — 1212), функция растёт линейно.Таким образом, если n≤12n≤12, можно вычислить ответ любым тупым способом, а иначе просто линейно его вычислить используя answer(12)answer(12) и answer(13)answer(13).Author — cdkrot 997C - Небо в огнеПусть AiAi — множество всех раскрасок, что ii-ая строка состоит только из одного цвета, а BiBi — множество всех раскрасок, где ii-ый столбец состоит только из одного цвета.Тогда требуется вычислить |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.Как обычно, можно с помощи формулы включений исключений, вычислить можность объединения, зная мощности всех возможных пересечений описанных множеств.Более того, в силу очевидной симметрии, чтобы вычислить мощность пересечения некоторых AiAi и BiBi не важно знать какие именно индексы взяты — только количество AA-шек и количество BB-шек.Тогда ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Где f(i,j)f(i,j) — количество раскрасок у которых первые ii правильных строк и первые jj правильных столбцов.Оказывается, что ff принимает существенно разные значения в зависимости от того, есть ли ноль в её аргументах, или нет.Пусть есть, тогда f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Действительно, нужно выбрать по одному цвету в каждом из первых kk столбцов, а остальное покрасить произвольным образом.——Если оба аргумента >0>0, то есть есть хотя бы один одноцветный столбец и одна одноцветная строка, то заметим, что все Одноцветные строки и столбцы одинакового цвета, в силу пересечения строк со столбцами.Тем самым, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Так как нужно выбрать сначала общий цвет любым способом, а затем покрасить остаток произвольным образом.Просуммировав формулу выше, можно получить решение за O(n2)O(n2) или O(n2log)O(n2log) в зависимости от реализации.Но нужно быстрее.——Просуммируем все слагаемые где i=0i=0 или j=0j=0 втупую, за O(n)O(n).Изучим остальные слагаемые, имеем формулу:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Сделаем замену переменных: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijВ силу Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)ians=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijЗаметим, что (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.С помощью этого можно свернуть слагаемые при одном ii, при этом, одному ii соответствует не nn слагаемых, а n−1n−1. Можно добавить и вычесть последнее слагаемое.——-Приступимans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–В этой формуле уже O(n)O(n) слагаемых, а значит её можно просуммировать достаточно быстро.Для возведения в степень можно воспользоваться быстрым возведением в степень.Author — cdkrot 997D - Циклы в произведенииРассмотрим произвольный цикл в графе-произведении.В силу определения произведения, соседние вершины в цикле соответствуют переходу либо по ребру в первом дереве, либо переходу во втором.Тем самым, если выписать рёбра соответствующие одному дереву в отдельный список, то получим цикл в этом дереве.Также, если у нас есть цикл в одном дереве длины aa и цикл длины bb во втором дереве, то из них можно сделать Caa+bCa+ba циклов в произведении.Тем самым, задача сводится к тому, чтобы посчитать для каждой длины до kk количество циклов в каждом из деревьев по отдельности, а затем перемешать их в циклы в произведении.—–Рассмотрим центроид cc дерева, посчитаем все циклы которые проходят через него, удалим центроид и решим задачу рекурсивно в каждой из оставшихся компонент.Как выглядит цикл проходящий через cc? Это нужно начать в какой-то вершине vv, затем дойти до cc (не проходя через cc в промежуточных вершин), дойти до вершины vv, возможно проходя через cc.Определим две динамики: f[v][k]f[v][k] — это количество способов догулять из cc до vv за ровно kk шагов не проходя через cc в промежуточных вершинах, g[v][k]g[v][k] — число способов дойти от cc до vv за kk шагов без предыдущего ограничения.Тогда ответом будет свёртка f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Случай если v=cv=c нужно разобрать отдельно, тогда нужно просто сделать ans[i]+=g[c][i]ans[i]+=g[c][i].За сколько времени можно посчитать динамику? За O(nk)O(nk), g[v][i]g[v][i] равна сумме g[u][i−1]g[u][i−1] по соседям uu. Так как граф это дерево, то суммарное число соседей O(n)O(n) и суммарно O(nk)O(nk) переходов.f[v]f[v] считается аналогично, только нужно запретить все переходы в вершину cc.——Итоговая асимптотика: O(nk2log(n))O(nk2log(n)).log(n)log⁡(n) берётся из-за центроидной декомпозиции.На уровне мы считаем динамику за O(nk)O(nk), а затем считаем свёртку O(nk2)O(nk2), тем самым O(nk2log(n))O(nk2log(n)).Решение можно также соптимизировать с помощью быстрого перемножения многочленов и получить O(nklog(k)log(n))O(nklog⁡(k)log(n)), но этого не требовалось.Author — 300iq 997E - Хорошие подотрезкиРассмотрим два решения задачи для всего массива, каждое из них может быть обобщено для решения задачи на отрезка за субквадратичное время.Первое решение это разделяй и властвуй.Давайте возьмем середину массива и посчитаем число хороших отрезков, проходящих через нее.Пусть минимум и максимум лежат по одну сторону от середины, тогда по границе на той половине, где они находятся, можно восстановить весь отрезок и проверить, что он корректный (и запомнить его где-нибудь).Иначе пусть они лежат по разные стороны от середины.Тогда пусть максимум лежит слева (второй случай симметричен и может быть рассмотрен аналогично), тогда нужно чтобы r−l=max−minr−l=max−min, но rr и maxmax мы уже знаем, тогда можно перенести и сказать, что единственное необходимое условие это r−max=l−minr−max=l−min.Тогда давайте разобьем элементы на классы эквивалентности, где разбираем на классы по r−maxr−max если элемент слева и по l−minl−min если элемент справа (где maxmax и minmin это минимум и максимум на отрезке до середины mm, соответственно), тогда отрезок l≤m<rl≤m<r (где максимум слева) хороший тогда и только тогда, когда на отрезке [l…m][l…m] нет чисел меньших минимума на отрезке (m…r](m…r] и на отрезке (m…r](m…r] нет чисел больших максимума на отрезке [l…m][l…m], и при этом ll и rr лежат в одном классе.Тогда для одной границы отрезка подходит какой-то отрезок элементов из ее класса (эти отрезки можно выделить, например, проходом со стеком или бинпоиском).Еще нужно не забыть запуститься рекурсивно от левой половины и правой половины :)А далее можно применить алгоритм Мо!Будем двигать левую и правую границу, пробегаться по классам, в которым лежит эта граница, и прибавлять/вычитать из ответа размер пересечения отрезка, который подходит этой границе и отрезка, который сейчас содержится (на текущем отрезке [l…r][l…r]), таким образом эта часть работает за O(nn−−√logn)O(nnlog⁡n) (но с не очень большой константой, потому что часть при корне это просто пробежаться по массиву и провести операции с интами).Так же нужно не забыть про отрезки, где минимум и максимум содержатся по одну сторону, их можно обработать, например, пройдя сканлайном с деревом фенвика, эта часть работает за O(nlogn)O(nlog⁡n).Таким образом идея с разделяй и властвуй обобщается до O(nn−−√logn)O(nnlog⁡n).Но давайте рассмотрим геометрическую интерпретацию задачи.Пусть хорошие отрезки это точки (l,r)(l,r) на плоскости!Тогда запрос это просто сумма на прямоугольнике [1…l][r…n][1…l][r…n].Для решения задачи на всем массива давайте будем двигать правую границу запроса, и для каждой левой будем хранить r−l−(max−min)r−l−(max−min), это можно хранить в дереве отрезков (и пересчитывать храня стеки), а далее нужно заметить, что эта величина всегда неположительна, поэтому можно просто хранить в дереве отрезков количество максимумов, и каждый раз прибавлять эту величину к ответу.Для того чтобы обобщить эту идею для полного решения, давайте разобьем поле N×NN×N на квадраты K×KK×K(Цвета не важны, а просто служат для более приятного просмотра).Тогда давайте пойдем таким же сканлайном слева направо, но будем хранить все не в дереве отрезков, а в корневой.А еще будем хранить для кусочка размера KK по yy-координате количество (хороших отрезков) точек, которые мы уже в нем встретили.Таким образом мы можем отрезать от исходного запросаНижнюю часть, оставив горизонтальную полоску высотой размера ≤K≤K.Это мы сделали за O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).Пройдя аналогичным сканлайном сверху-вниз, а не слева-направо мы можем отрезать и левую часть, оставив в качестве запроса прямоугольник со сторонами <K<K.Тогда можно создать <K<K событий вида: \"Добавить к ответу на ii-й запрос сумму на вертикальном отрезке\", а эти события можно обработать пройдя сканлайном с деревом отрезков слева-направо, и выполнить эту часть за O(n⋅k⋅logn)O(n⋅k⋅log⁡n).Таким образом получается решение за O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), и выбор k=nlogn−−−−√k=nlog⁡n позволяет добиться асимптотики O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 998\\s*A"
          },
          "content_length": 13431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "cout << min(cnt * y, (cnt - 1) * x + y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 8",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if хорошая параСчитаем ответ, просто все оставшиеся цифры или 0, или 49 и всё однозначно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,10,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n,1,1000,\"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,10,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n,1,1000,\"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,10,\"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n,1,1000,\"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the input file\n    int n = inf.readInt(1, 10, \"n\");\n    vector<int> a(n);\n    int total_sum = 0;\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt(1, 1000, format(\"a[%d]\", i+1).c_str());\n        total_sum += a[i];\n    }\n\n    // Precompute whether it's possible to divide the packets\n    bool possible = false;\n    for (int mask = 1; mask < (1 << n); mask++) {\n        int k = __builtin_popcount(mask);\n        if (k == 0 || k == n) continue; // Both should get at least one packet\n        int sumG = 0;\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                sumG += a[i];\n            }\n        }\n        int sumA = total_sum - sumG;\n        if (sumG != sumA) {\n            possible = true;\n            break;\n        }\n    }\n\n    // Read contestant's output\n    int k = ouf.readInt(-1, n, \"k\");\n\n    if (k == -1) {\n        if (possible) {\n            quitf(_wa, \"Possible to divide the packets but contestant outputs -1\");\n        } else {\n            quitf(_ok, \"Correctly determined that it's impossible\");\n        }\n    } else {\n        if (!possible) {\n            quitf(_wa, \"Impossible to divide the packets but contestant provides a division\");\n        }\n        if (k < 1 || k >= n) {\n            quitf(_wa, \"k = %d is not in the valid range [1, n-1]\", k);\n        }\n        set<int> indices;\n        vector<int> idxs;\n        for (int i = 0; i < k; i++) {\n            int idx = ouf.readInt(1, n, format(\"index[%d]\", i+1).c_str());\n            if (indices.count(idx)) {\n                quitf(_wa, \"Index %d is repeated\", idx);\n            }\n            indices.insert(idx);\n            idxs.push_back(idx);\n        }\n        if (indices.size() != k) {\n            quitf(_wa, \"Indices are not distinct\");\n        }\n        int sumG = 0;\n        for (int idx : idxs) {\n            sumG += a[idx - 1];\n        }\n        int sumA = total_sum - sumG;\n        if (sumG == sumA) {\n            quitf(_wa, \"Sums are equal: sumG = %d, sumA = %d\", sumG, sumA);\n        }\n        quitf(_ok, \"Correct division with sumG = %d, sumA = %d\", sumG, sumA);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\", rnd.next(1, 10));\n    int max_a = opt<int>(\"max_a\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate random a_i between 1 and max_a\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"min_n\") {\n        // n = 1, any a_i\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, max_a);\n    } else if (type == \"max_n\") {\n        // n = 10, random a_i\n        n = 10;\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"all_equal\") {\n        // All a_i are the same\n        int val = rnd.next(1, max_a);\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"impossible_equal_sums\") {\n        // Generate a case where sums are always equal\n        a.resize(n);\n        if (n % 2 == 0) {\n            int val = rnd.next(1, max_a / 2);\n            for (int i = 0; i < n; ++i) {\n                a[i] = val;\n            }\n        } else {\n            int val = rnd.next(1, max_a / n);\n            for (int i = 0; i < n; ++i) {\n                a[i] = val;\n            }\n        }\n    } else if (type == \"impossible_one_packet\") {\n        // n = 1, impossible to split\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, max_a);\n    } else if (type == \"possible_different_sums\") {\n        // Generate a case where it's possible to have different sums\n        a.resize(n);\n        int total_sum = 0;\n        do {\n            total_sum = 0;\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, max_a);\n                total_sum += a[i];\n            }\n        } while (total_sum % 2 == 0 || n <= 1);\n    } else if (type == \"edge_case\") {\n        // All a_i are 1\n        a.resize(n, 1);\n    } else {\n        // Default to random\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    // Output n and a_i\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\", rnd.next(1, 10));\n    int max_a = opt<int>(\"max_a\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate random a_i between 1 and max_a\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"min_n\") {\n        // n = 1, any a_i\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, max_a);\n    } else if (type == \"max_n\") {\n        // n = 10, random a_i\n        n = 10;\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"all_equal\") {\n        // All a_i are the same\n        int val = rnd.next(1, max_a);\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"impossible_equal_sums\") {\n        // Generate a case where sums are always equal\n        a.resize(n);\n        if (n % 2 == 0) {\n            int val = rnd.next(1, max_a / 2);\n            for (int i = 0; i < n; ++i) {\n                a[i] = val;\n            }\n        } else {\n            int val = rnd.next(1, max_a / n);\n            for (int i = 0; i < n; ++i) {\n                a[i] = val;\n            }\n        }\n    } else if (type == \"impossible_one_packet\") {\n        // n = 1, impossible to split\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, max_a);\n    } else if (type == \"possible_different_sums\") {\n        // Generate a case where it's possible to have different sums\n        a.resize(n);\n        int total_sum = 0;\n        do {\n            total_sum = 0;\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, max_a);\n                total_sum += a[i];\n            }\n        } while (total_sum % 2 == 0 || n <= 1);\n    } else if (type == \"edge_case\") {\n        // All a_i are 1\n        a.resize(n, 1);\n    } else {\n        // Default to random\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    // Output n and a_i\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type impossible_one_packet\n./gen -n 2 -type possible_different_sums\n./gen -n 2 -type all_equal\n./gen -n 2 -type impossible_equal_sums\n./gen -n 2 -type random\n./gen -n 3 -type possible_different_sums\n./gen -n 3 -type all_equal\n./gen -n 3 -type impossible_equal_sums\n./gen -n 3 -type random\n./gen -n 4 -type possible_different_sums\n./gen -n 4 -type all_equal\n./gen -n 4 -type impossible_equal_sums\n./gen -n 4 -type random\n./gen -n 5 -type possible_different_sums\n./gen -n 5 -type all_equal\n./gen -n 5 -type impossible_equal_sums\n./gen -n 5 -type random\n./gen -n 6 -type possible_different_sums\n./gen -n 6 -type all_equal\n./gen -n 6 -type impossible_equal_sums\n./gen -n 6 -type random\n./gen -n 7 -type possible_different_sums\n./gen -n 7 -type all_equal\n./gen -n 7 -type impossible_equal_sums\n./gen -n 7 -type random\n./gen -n 8 -type possible_different_sums\n./gen -n 8 -type all_equal\n./gen -n 8 -type impossible_equal_sums\n./gen -n 8 -type random\n./gen -n 9 -type possible_different_sums\n./gen -n 9 -type all_equal\n./gen -n 9 -type impossible_equal_sums\n./gen -n 9 -type random\n./gen -n 10 -type max_n\n./gen -n 10 -type possible_different_sums\n./gen -n 10 -type all_equal\n./gen -n 10 -type impossible_equal_sums\n./gen -n 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:14.875328",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "998/B",
      "title": "B. Cutting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains an integer nn (2≤n≤1002≤n≤100) and an integer BB (1≤B≤1001≤B≤100) — the number of elements in the sequence and the number of bitcoins you have.Second line contains nn integers: a1a1, a2a2, ..., anan (1≤ai≤1001≤ai≤100) — elements of the sequence, which contains the equal number of even and odd numbers",
      "output_spec": "OutputPrint the maximum possible number of cuts which can be made while spending no more than BB bitcoins.",
      "sample_tests": "ExamplesInputCopy6 41 2 5 10 15 20OutputCopy1InputCopy4 101 3 2 4OutputCopy0InputCopy6 1001 2 3 4 5 6OutputCopy2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of the input contains an integer nn (2≤n≤1002≤n≤100) and an integer BB (1≤B≤1001≤B≤100) — the number of elements in the sequence and the number of bitcoins you have.Second line contains nn integers: a1a1, a2a2, ..., anan (1≤ai≤1001≤ai≤100) — elements of the sequence, which contains the equal number of even and odd numbers\n\nOutputPrint the maximum possible number of cuts which can be made while spending no more than BB bitcoins.\n\nInputCopy6 41 2 5 10 15 20OutputCopy1InputCopy4 101 3 2 4OutputCopy0InputCopy6 1001 2 3 4 5 6OutputCopy2\n\nInputCopy6 41 2 5 10 15 20\n\nOutputCopy1\n\nInputCopy4 101 3 2 4\n\nOutputCopy0\n\nInputCopy6 1001 2 3 4 5 6\n\nOutputCopy2\n\nNoteIn the first sample the optimal answer is to split sequence between 22 and 55. Price of this cut is equal to 33 bitcoins.In the second sample it is not possible to make even one cut even with unlimited number of bitcoins.In the third sample the sequence should be cut between 22 and 33, and between 44 and 55. The total price of the cuts is 1+1=21+1=2 bitcoins.",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds: Either n=1n=1, and then there is no solution Or n=2n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n2n subsets and checks them also passes.Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 998\\s*B"
          },
          "content_length": 13513
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int B = inf.readInt(1, 100, \"B\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    int cntEven = 0, cntOdd = 0;\n    for(int i = 0; i < n; ++i){\n        if(a[i]%2==0) ++cntEven;\n        else ++cntOdd;\n    }\n    ensuref(cntEven == cntOdd, \"Sequence must contain equal number of even and odd numbers.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int B = inf.readInt(1, 100, \"B\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    int cntEven = 0, cntOdd = 0;\n    for(int i = 0; i < n; ++i){\n        if(a[i]%2==0) ++cntEven;\n        else ++cntOdd;\n    }\n    ensuref(cntEven == cntOdd, \"Sequence must contain equal number of even and odd numbers.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int B = inf.readInt(1, 100, \"B\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    int cntEven = 0, cntOdd = 0;\n    for(int i = 0; i < n; ++i){\n        if(a[i]%2==0) ++cntEven;\n        else ++cntOdd;\n    }\n    ensuref(cntEven == cntOdd, \"Sequence must contain equal number of even and odd numbers.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int B = opt<int>(\"B\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\") {\n        // Generate n/2 random even numbers and n/2 random odd numbers\n        vector<int> numbers;\n        for (int i = 0; i < n/2; ++i) {\n            int even_num = rnd.next(1, 50) * 2; // even number between 2 and 100\n            numbers.push_back(even_num);\n        }\n        for (int i = 0; i < n/2; ++i) {\n            int odd_num = rnd.next(0, 49) * 2 + 1; // odd number between 1 and 99\n            numbers.push_back(odd_num);\n        }\n        shuffle(numbers.begin(), numbers.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = numbers[i];\n        }\n    } else if (type == \"max_cuts\") {\n        // Generate sequence where counts balance at every possible position\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Odd number\n                a[i] = rnd.next(0, 49) * 2 + 1;\n            } else {\n                // Even number\n                a[i] = rnd.next(1, 50) * 2;\n            }\n        }\n    } else if (type == \"no_cuts\") {\n        // All odd numbers first, then even numbers\n        for (int i = 0; i < n/2; ++i) {\n            a[i] = rnd.next(0, 49) * 2 + 1;\n        }\n        for (int i = n/2; i < n; ++i) {\n            a[i] = rnd.next(1, 50) * 2;\n        }\n    } else if (type == \"zero_cost\") {\n        // Adjacent numbers are equal\n        int idx = 0;\n        for (int i = 0; i < n/2; ++i) {\n            int num;\n            if (i % 2 == 0) {\n                num = rnd.next(0, 49) * 2 +1; // odd number\n            } else {\n                num = rnd.next(1, 50) * 2; // even number\n            }\n            a[idx++] = num;\n            a[idx++] = num; // same number for zero cost\n        }\n    } else if (type == \"max_cost\") {\n        // Adjacent numbers differ by maximum\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Odd number 1\n                a[i] = 1;\n            } else {\n                // Even number 100\n                a[i] = 100;\n            }\n        }\n    } else {\n        // Unsupported type\n        fprintf(stderr, \"Unsupported type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and B\n    printf(\"%d %d\\n\", n, B);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int B = opt<int>(\"B\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    if (type == \"random\") {\n        // Generate n/2 random even numbers and n/2 random odd numbers\n        vector<int> numbers;\n        for (int i = 0; i < n/2; ++i) {\n            int even_num = rnd.next(1, 50) * 2; // even number between 2 and 100\n            numbers.push_back(even_num);\n        }\n        for (int i = 0; i < n/2; ++i) {\n            int odd_num = rnd.next(0, 49) * 2 + 1; // odd number between 1 and 99\n            numbers.push_back(odd_num);\n        }\n        shuffle(numbers.begin(), numbers.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = numbers[i];\n        }\n    } else if (type == \"max_cuts\") {\n        // Generate sequence where counts balance at every possible position\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Odd number\n                a[i] = rnd.next(0, 49) * 2 + 1;\n            } else {\n                // Even number\n                a[i] = rnd.next(1, 50) * 2;\n            }\n        }\n    } else if (type == \"no_cuts\") {\n        // All odd numbers first, then even numbers\n        for (int i = 0; i < n/2; ++i) {\n            a[i] = rnd.next(0, 49) * 2 + 1;\n        }\n        for (int i = n/2; i < n; ++i) {\n            a[i] = rnd.next(1, 50) * 2;\n        }\n    } else if (type == \"zero_cost\") {\n        // Adjacent numbers are equal\n        int idx = 0;\n        for (int i = 0; i < n/2; ++i) {\n            int num;\n            if (i % 2 == 0) {\n                num = rnd.next(0, 49) * 2 +1; // odd number\n            } else {\n                num = rnd.next(1, 50) * 2; // even number\n            }\n            a[idx++] = num;\n            a[idx++] = num; // same number for zero cost\n        }\n    } else if (type == \"max_cost\") {\n        // Adjacent numbers differ by maximum\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                // Odd number 1\n                a[i] = 1;\n            } else {\n                // Even number 100\n                a[i] = 100;\n            }\n        }\n    } else {\n        // Unsupported type\n        fprintf(stderr, \"Unsupported type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and B\n    printf(\"%d %d\\n\", n, B);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n-1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -B 10 -type random\n./gen -n 2 -B 10 -type max_cuts\n./gen -n 2 -B 10 -type no_cuts\n./gen -n 2 -B 10 -type zero_cost\n./gen -n 2 -B 10 -type max_cost\n\n./gen -n 4 -B 10 -type random\n./gen -n 4 -B 10 -type max_cuts\n./gen -n 4 -B 10 -type no_cuts\n./gen -n 4 -B 10 -type zero_cost\n./gen -n 4 -B 10 -type max_cost\n\n./gen -n 10 -B 15 -type random\n./gen -n 10 -B 15 -type max_cuts\n./gen -n 10 -B 15 -type no_cuts\n./gen -n 10 -B 15 -type zero_cost\n./gen -n 10 -B 15 -type max_cost\n\n./gen -n 50 -B 50 -type random\n./gen -n 50 -B 50 -type max_cuts\n./gen -n 50 -B 50 -type no_cuts\n./gen -n 50 -B 50 -type zero_cost\n./gen -n 50 -B 50 -type max_cost\n\n./gen -n 100 -B 100 -type random\n./gen -n 100 -B 100 -type max_cuts\n./gen -n 100 -B 100 -type no_cuts\n./gen -n 100 -B 100 -type zero_cost\n./gen -n 100 -B 100 -type max_cost\n\n./gen -n 100 -B 1 -type random\n./gen -n 100 -B 1 -type max_cuts\n./gen -n 100 -B 1 -type zero_cost\n\n./gen -n 100 -B 100 -type max_cost\n\n./gen -n 100 -B 0 -type max_cuts\n\n./gen -n 2 -B 5 -type random\n\n./gen -n 6 -B 20 -type random\n./gen -n 8 -B 15 -type zero_cost\n./gen -n 10 -B 50 -type max_cuts\n./gen -n 10 -B 50 -type no_cuts\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:16.669143",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "998/C",
      "title": "C. Convert to Ones",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integers nn, xx and yy (1 ≤ n ≤ 300000,0≤x,y≤1091 ≤ n ≤ 300000,0≤x,y≤109) — length of the string, cost of the first operation (substring reverse) and cost of the second operation (inverting all elements of substring).The second line contains the string aa of length nn, consisting of zeros and ones.",
      "output_spec": "OutputPrint a single integer — the minimum total cost of operations you need to spend to get a string consisting only of ones. Print 00, if you do not need to perform any operations.",
      "sample_tests": "ExamplesInputCopy5 1 1001000OutputCopy11InputCopy5 10 101000OutputCopy2InputCopy7 2 31111111OutputCopy0",
      "description": "C. Convert to Ones\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integers nn, xx and yy (1 ≤ n ≤ 300000,0≤x,y≤1091 ≤ n ≤ 300000,0≤x,y≤109) — length of the string, cost of the first operation (substring reverse) and cost of the second operation (inverting all elements of substring).The second line contains the string aa of length nn, consisting of zeros and ones.\n\nOutputPrint a single integer — the minimum total cost of operations you need to spend to get a string consisting only of ones. Print 00, if you do not need to perform any operations.\n\nInputCopy5 1 1001000OutputCopy11InputCopy5 10 101000OutputCopy2InputCopy7 2 31111111OutputCopy0\n\nInputCopy5 1 1001000\n\nOutputCopy11\n\nInputCopy5 10 101000\n\nOutputCopy2\n\nInputCopy7 2 31111111\n\nOutputCopy0\n\nNoteIn the first sample, at first you need to reverse substring [1…2][1…2], and then you need to invert substring [2…5][2…5]. Then the string was changed as follows:«01000» →→ «10000» →→ «11111».The total cost of operations is 1+10=111+10=11.In the second sample, at first you need to invert substring [1…1][1…1], and then you need to invert substring [3…5][3…5]. Then the string was changed as follows:«01000» →→ «11000» →→ «11111».The overall cost is 1+1=21+1=2.In the third example, string already consists only of ones, so the answer is 00.",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds: Either n=1n=1, and then there is no solution Or n=2n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n2n subsets and checks them also passes.Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 998 和字母"
          },
          "content_length": 13513
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    string a = inf.readLine();\n    ensuref((int)a.size() == n, \"The length of a must be n=%d, but is %d\", n, (int)a.size());\n    for(int i = 0; i < n; i++) {\n        ensuref(a[i] == '0' || a[i] == '1', \"a[%d]='%c' is not '0' or '1'\", i+1, a[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    string a = inf.readLine();\n    ensuref((int)a.size() == n, \"The length of a must be n=%d, but is %d\", n, (int)a.size());\n    for(int i = 0; i < n; i++) {\n        ensuref(a[i] == '0' || a[i] == '1', \"a[%d]='%c' is not '0' or '1'\", i+1, a[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    string a = inf.readLine();\n    ensuref((int)a.size() == n, \"The length of a must be n=%d, but is %d\", n, (int)a.size());\n    for(int i = 0; i < n; i++) {\n        ensuref(a[i] == '0' || a[i] == '1', \"a[%d]='%c' is not '0' or '1'\", i+1, a[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n    long long y = opt<long long>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '0');\n\n    if (type == \"random\") {\n        // Random zeros and ones\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    } else if (type == \"allzeros\") {\n        // All zeros\n        s = string(n, '0');\n    } else if (type == \"allones\") {\n        // All ones\n        s = string(n, '1');\n    } else if (type == \"alternate\") {\n        // Alternate zeros and ones, starting with zero\n        for (int i = 0; i < n; i++) {\n            s[i] = (i % 2) + '0';\n        }\n    } else if (type == \"onesegments\") {\n        // Each zero is isolated between ones ('1's)\n        // E.g., \"1010101\"\n        for (int i = 0; i < n; i++) {\n            s[i] = ((i % 2) ^ 1) + '0'; // Alternate '1's and '0's, starting with '1'\n        }\n    } else if (type == \"onezero\") {\n        // Only one zero in the string\n        s = string(n, '1');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = '0';\n    } else if (type == \"zerosones\") {\n        // String with zeros followed by ones or vice versa\n        int k = rnd.next(1, n - 1);\n        int order = rnd.next(0, 1);\n        if (order == 0) {\n            // zeros followed by ones\n            for (int i = 0; i < n; i++) {\n                s[i] = i < k ? '0' : '1';\n            }\n        } else {\n            // ones followed by zeros\n            for (int i = 0; i < n; i++) {\n                s[i] = i < k ? '1' : '0';\n            }\n        }\n    } else if (type == \"fewzeros\") {\n        // Mostly ones, few zeros\n        int numZeros = rnd.next(1, min(n, 10));\n        s = string(n, '1');\n        set<int> zeroPos;\n        while ((int)zeroPos.size() < numZeros) {\n            int pos = rnd.next(0, n - 1);\n            zeroPos.insert(pos);\n        }\n        for (int pos : zeroPos) {\n            s[pos] = '0';\n        }\n    } else if (type == \"bigsegments\") {\n        // Few random large segments of zeros and ones\n        int numSegments = rnd.next(1, min(n, 10));\n        vector<int> segmentPositions;\n        for (int i = 0; i < numSegments - 1; i++) {\n            segmentPositions.push_back(rnd.next(1, n - 1));\n        }\n        segmentPositions.push_back(n);\n        sort(segmentPositions.begin(), segmentPositions.end());\n        int start = 0;\n        int val = rnd.next(0, 1);\n        for (int pos : segmentPositions) {\n            for (int i = start; i < pos; i++) {\n                s[i] = val + '0';\n            }\n            start = pos;\n            val ^= 1; // flip between 0 and 1\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    }\n\n    // Output n, x, y\n    printf(\"%d %lld %lld\\n\", n, x, y);\n    printf(\"%s\\n\", s.c_str()); // Output s\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n    long long y = opt<long long>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '0');\n\n    if (type == \"random\") {\n        // Random zeros and ones\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    } else if (type == \"allzeros\") {\n        // All zeros\n        s = string(n, '0');\n    } else if (type == \"allones\") {\n        // All ones\n        s = string(n, '1');\n    } else if (type == \"alternate\") {\n        // Alternate zeros and ones, starting with zero\n        for (int i = 0; i < n; i++) {\n            s[i] = (i % 2) + '0';\n        }\n    } else if (type == \"onesegments\") {\n        // Each zero is isolated between ones ('1's)\n        // E.g., \"1010101\"\n        for (int i = 0; i < n; i++) {\n            s[i] = ((i % 2) ^ 1) + '0'; // Alternate '1's and '0's, starting with '1'\n        }\n    } else if (type == \"onezero\") {\n        // Only one zero in the string\n        s = string(n, '1');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = '0';\n    } else if (type == \"zerosones\") {\n        // String with zeros followed by ones or vice versa\n        int k = rnd.next(1, n - 1);\n        int order = rnd.next(0, 1);\n        if (order == 0) {\n            // zeros followed by ones\n            for (int i = 0; i < n; i++) {\n                s[i] = i < k ? '0' : '1';\n            }\n        } else {\n            // ones followed by zeros\n            for (int i = 0; i < n; i++) {\n                s[i] = i < k ? '1' : '0';\n            }\n        }\n    } else if (type == \"fewzeros\") {\n        // Mostly ones, few zeros\n        int numZeros = rnd.next(1, min(n, 10));\n        s = string(n, '1');\n        set<int> zeroPos;\n        while ((int)zeroPos.size() < numZeros) {\n            int pos = rnd.next(0, n - 1);\n            zeroPos.insert(pos);\n        }\n        for (int pos : zeroPos) {\n            s[pos] = '0';\n        }\n    } else if (type == \"bigsegments\") {\n        // Few random large segments of zeros and ones\n        int numSegments = rnd.next(1, min(n, 10));\n        vector<int> segmentPositions;\n        for (int i = 0; i < numSegments - 1; i++) {\n            segmentPositions.push_back(rnd.next(1, n - 1));\n        }\n        segmentPositions.push_back(n);\n        sort(segmentPositions.begin(), segmentPositions.end());\n        int start = 0;\n        int val = rnd.next(0, 1);\n        for (int pos : segmentPositions) {\n            for (int i = start; i < pos; i++) {\n                s[i] = val + '0';\n            }\n            start = pos;\n            val ^= 1; // flip between 0 and 1\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(0,1) + '0';\n        }\n    }\n\n    // Output n, x, y\n    printf(\"%d %lld %lld\\n\", n, x, y);\n    printf(\"%s\\n\", s.c_str()); // Output s\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random data, various x and y\n./gen -n 1 -x 0 -y 0 -type random\n./gen -n 2 -x 1 -y 1 -type random\n\n# Small n, edge cases in x and y\n./gen -n 2 -x 0 -y 1000000000 -type random\n./gen -n 2 -x 1000000000 -y 0 -type random\n\n# Medium n, type allzeros\n./gen -n 10 -x 5 -y 5 -type allzeros\n\n# Medium n, type allones\n./gen -n 10 -x 5 -y 5 -type allones\n\n# Alternate zeros and ones, maximizing c\n./gen -n 20 -x 10 -y 1 -type alternate\n\n# Alternate zeros and ones, maximizing c, x less than y\n./gen -n 20 -x 1 -y 10 -type alternate\n\n# Large n, random data\n./gen -n 300000 -x 10 -y 10 -type random\n\n# Large n, allzeros\n./gen -n 300000 -x 10 -y 10 -type allzeros\n\n# Large n, allones\n./gen -n 300000 -x 10 -y 10 -type allones\n\n# Large n, few zeros\n./gen -n 300000 -x 10 -y 10 -type fewzeros\n\n# Large n, bigsegments\n./gen -n 300000 -x 10 -y 10 -type bigsegments\n\n# Large n, x < y\n./gen -n 300000 -x 1 -y 1000000000 -type random\n\n# Large n, x > y\n./gen -n 300000 -x 1000000000 -y 1 -type random\n\n# Small n, x = 0\n./gen -n 1000 -x 0 -y 100 -type random\n\n# Small n, y = 0\n./gen -n 1000 -x 100 -y 0 -type random\n\n# Test with x=y\n./gen -n 1000 -x 1000 -y 1000 -type random\n\n# Onesegments, maximize c\n./gen -n 100000 -x 1 -y 1000 -type onesegments\n\n# Onesegments, x > y\n./gen -n 100000 -x 1000 -y 1 -type onesegments\n\n# One zero in a large string\n./gen -n 300000 -x 10 -y 10 -type onezero\n\n# Zeros then ones\n./gen -n 300000 -x 10 -y 5 -type zerosones\n\n# Ones then zeros\n./gen -n 300000 -x 5 -y 10 -type zerosones\n\n# Random few zeros\n./gen -n 300000 -x 10 -y 10 -type fewzeros\n\n# x and y are large\n./gen -n 300000 -x 1000000000 -y 1000000000 -type random\n\n# x and y are zeros\n./gen -n 300000 -x 0 -y 0 -type random\n\n# x is zero, y is large\n./gen -n 300000 -x 0 -y 100000000 -type random\n\n# y is zero, x is large\n./gen -n 300000 -x 100000000 -y 0 -type random\n\n# n = 1\n./gen -n 1 -x 100 -y 100 -type random\n\n# n = 300000, random\n./gen -n 300000 -x 100 -y 100 -type random\n\n# n = 300000, x=0, y=random big value\n./gen -n 300000 -x 0 -y 100000000 -type random\n\n# n=300000, x=random big value, y=0\n./gen -n 300000 -x 100000000 -y 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:18.937951",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "998/D",
      "title": "D. Roman Digits",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input file contains a single integer nn (1≤n≤1091≤n≤109) — the number of roman digits to use.",
      "output_spec": "OutputOutput a single integer — the number of distinct integers which can be represented using nn roman digits exactly.",
      "sample_tests": "ExamplesInputCopy1OutputCopy4InputCopy2OutputCopy10InputCopy10OutputCopy244",
      "description": "D. Roman Digits\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input file contains a single integer nn (1≤n≤1091≤n≤109) — the number of roman digits to use.\n\nOutputOutput a single integer — the number of distinct integers which can be represented using nn roman digits exactly.\n\nInputCopy1OutputCopy4InputCopy2OutputCopy10InputCopy10OutputCopy244\n\nOutputCopy4\n\nOutputCopy10\n\nInputCopy10\n\nOutputCopy244\n\nNoteIn the first sample there are exactly 44 integers which can be represented — I, V, X and L.In the second sample it is possible to represent integers 22 (II), 66 (VI), 1010 (VV), 1111 (XI), 1515 (XV), 2020 (XX), 5151 (IL), 5555 (VL), 6060 (XL) and 100100 (LL).",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Hi, codeforces!I am happy to invite you to the codeforces round #493, which happens at Sunday, July 1, 2018 at 22:05UTC+8.This round writers are — Ildar 300iq Gainullin, Grigory vintage_Vlad_Makeev Reznikov, Mike MikeMirzayanov Mirzayanov, and me, cdkrot.Big thanks for people, who tested round — Shiqing cyand1317 Lyu, Andrew GreenGrape Rayskiy, Ivan isaf27 Safonov, Alexey Aleks5d Upirvitsky. Also thanks to Mike MikeMirzayanov Mirzayanov and Nikolay KAN Kalinin for help with round preparation.And to Mike MikeMirzayanov Mirzayanov for codeforces and polygon systems.Traditionally, there will be 5 problems for 2 hours. I hope you will enjoy the problemset, good luck and have fun!Scoring distribution will be published before the round.UPD: Scoring distribution is as follows:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500You may also want to check this post for post-contest stream.UPD2: The editorial was published!UPD3: Congratulations to winners!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1145
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev 998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds: Either n=1n=1, and then there is no solution Or n=2n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n2n subsets and checks them also passes.Author — MikeMirzayanov 998B - CuttingIt is possible to proof, that cut after ii-th number can be done if and only if the prefix of length ii contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct — each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required — if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author — 300iq 997A - Convert to OnesLet's partite consecutive elements of the same color into groups.For example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».Then it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 00) for one move we can reduce by one (and can't reduce by two) the number of segments of color 00, paying for it either xx or yy (whatever).Let's consider, for example, if we have a string «11001100», we can flip the segment [5…8][5…8], and turn it into a string «11000011», or, for example, invert the segment [3…4][3…4], turning the string into «111111111100> (Then the number of color groups 00 decreased from two to one).But in the end you still need to do at least one inverting of the segment (which will be one at the end).Then let pp — number of groups of color 00.If p=0p=0, the answer is 00.Otherwise, the answer is (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Roman DigitsTL; DR — among all the sequences, select the one, which contains the maximum number of 5050, in case of tie, select one with largest number of 99. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.Since the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}{1,5,10,50}, but for digits {0,4,9,49}{0,4,9,49}.Let's solve the problem for digits {0,4,9}{0,4,9} first.We have a problem that some numbers have many representations. But this, in fact, is easy to deal with — if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.In this case, the solution is to bruteforce the number of \"4\" from 00 to min(8,n)min(8,n), and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.Let's return to the original problem with {0,4,9,49}{0,4,9,49}.In this case we can also face the situation, when the number of 4949 can be increased. We need to identify all pairs (x,y)(x,y) where x,y≤50x,y≤50, such that they can be transformed to other pair (x′,y′)(x′,y′) with detachment of few 4949.We can bruteforce all xx, yy, x′x′, y′y′ with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 4949 removed, in such case we mark the pair (x,y)(x,y) as broken.We can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.When we discovered which pairs are good we can simply:for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.———Another solution: if you examine the solution above precisely, you will notice that starting some reasonable nn (you can easy proof a lowerbound like 5050 or 100100, but it is, in fact, 1212), the function grows linearly.So if n≤12n≤12, you count the answer in any stupid way, and otherwise, simply approximate it linearly using answer(12)answer(12) and answer(13)answer(13).Author — cdkrot 997C - Sky Full of StarsLet AiAi be the set of all colorings, where ii-th line contains only one color, and BiBi be the set of colorings, where ii-th column contains only one color.This way, you need to calculate |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.As usual, we can use inclusion-exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above.More over, due to the obvious symmetry, to calculate the size of intersection of some set of AiAi and BiBi it is not important to know exact indices — only number of taken AA-s and number of BB-s.This way ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Where f(i,j)f(i,j) — is the number of colorings, where first ii rows and first jj columns are onecolored.It turns out, that formula for ff differs significantly depending on presence of zero in it's arguments.Let's examine the case where zero is present, the f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Indeed, you should choose one color in each of the first kk columns, and the rest should be painted in any way.——If both arguments are >0>0, that is, there is at least one one-colored column and at least one-colored row, than we can notice, that all one-colored rows and columns are in fact of one color.This way, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Since we should first select the globally common color, and then paint all the rest in any way.Summation of all ff-s gives solution with O(n2)O(n2) or O(n2log)O(n2log) complexity, depending on implementation.But we need to go faster.—–Let's sum all summands with i=0i=0 or j=0j=0 in a stupid way, in O(n)O(n).Then examine all other summands. We have a formula:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Let's replace our variables: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijSince Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)i we haveans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijNote, that (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.Using this, we can collect all summands for fixed ii, however with fixed ii we have not nn summands, but n−1n−1. We can workaround it by adding and removing the missing summand.—–Let's go:ans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–This formula has only O(n)O(n) summands, аnd hence can be evaluated fast enough.To calculate powers of number fast, we can use binary pow method.Author — cdkrot 997D - Cycles in productConsider an arbitrary cycle in a graph product.Due to the definition of the product, the adjacent vertices in the cycle correspond to the transition by the edge either in the first tree or in the second tree.This way, if you write the edges corresponding to one tree in a separate list, you will get a cycle in this tree.Also, if we have a cycle in one tree of length aa and a cycle of length bb in the second tree, we can make Caa+bCa+ba cycles in the product.Thus, the problem is reduced to calculating for each length up to kk the number of cycles in each tree separately, and then mixing them into cycles in the product.—–Let's select the centroid cc of the tree and count all cycles, which go through it, delete centroid and then recursively count in remaining components.How looks cycle which goes through cc? We need to start in some vertex vv, then go to cc (not going through cc in between), and then go back to vv, possibly going through cc.Let's define two dp's: f[v][k]f[v][k] — number of ways to go from cc to vv by exactly kk steps not going through cc in between, g[v][k]g[v][k] — number of ways to go from cc to vv, but without previous limitation.This way the answer for vv through centroid cc in convolution of f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Case where v=cv=c should be processed separately, in this case we can simply ans[i]+=g[c][i]ans[i]+=g[c][i].How much time it takes to compute dp? In fact, it is O(nk)O(nk), g[v][i]g[v][i] is equal to sum of g[u][i−1]g[u][i−1] where uu is neighbor of vv. Since the graph is tree, there are O(n)O(n) neighbors in total and O(nk)O(nk) transitions.f[v]f[v] is counted the same way, but with removed transitions through cc. ——The final complextiy is: O(nk2log(n))O(nk2log(n)).\\O(log(n))\\O(log⁡(n)) is for centroid decomposition.On one level we need to compute dp O(nk)O(nk) and then compute convolution O(nk2)O(nk2), so it is O(nk2log(n))O(nk2log(n)).Solution can be optimized with fast polynomial multiplication, leading to complexity O(nklog(k)log(n))O(nklog⁡(k)log(n)), but it wasn't required.Author — 300iq 997E - Good SubsegmentsLet's look at two solutions for all array, and each of them can be upgraded to subquadratic time for queries on subsegments.First solution is Divide&Conquer.Let's take a middle of the array and find number of segments, that contain it.If minimum and maximum are at one side of middle, then by the end on the half where they are, you can restore the entire segment and check that it is correct (and remember it somewhere).Else let them be on different sides.Then let maximum will be at the right (other case are symmetric and you can solve them similarly), so we need r−l=max−minr−l=max−min, but we already know rr and maxmax , so we can get r−max=l−minr−max=l−min.Then let's partite the elements into equivalence classes, where we broke into classes by r−maxr−max if element on the left and l−minl−min if element on the right (where the maxmax and minmin is the minimum and maximum on the segment to the middle mm), then the segment l≤m<rl≤m<r (where the maximum on the left) is good if and only if when in the interval [l…m][l…m] there are no numbers less than minimum on the interval (m,…r](m,…r] and the interval (m,…r](m,…r] has no numbers larger than maximum on the interval [l…m][l…m], and ll and rr are in the same class.Then, for one segment end, some interval of elements from its class is suitable (these intervals can be selected, for example, by stack or a binary search).Also you need (don't forget it!) to go recursively to the left half and to the right half :)And then you can apply the Mo's algorithm!Let's move the left and right ends, run through the classes where this end lies, and add/subtract from the answer the size of the intersection of the interval of this class that fits this end and the interval of this class that current segment now contains, so this part works for O(nn−−√logn)O(nnlog⁡n) (but operations are not so heavy, so it is working fast).Also you need to not forget about the segments where the minimum and maximum contained at one side of the middle, they can be processed, for example, by passing with a sweep line with a fenwick tree, this part works in O(nlogn)O(nlog⁡n).So we can upgrade D&C idea to O(nn−−√logn)O(nnlog⁡n).But let's look at the geometric interpretation of the problem.Let good segments be points (l,r)(l,r) on the plane!Then the query is just the sum on the rectangle [1…l][r…n][1…l][r…n].To solve the problem on the whole array, let's move the right end of the query, and for each left we will store r−l−(max−min)r−l−(max−min), this can be stored in the segment tree (and you can recalculate it with stacks), and then you can note that values always are ≤0≤0, so you can simply store in the segment tree the maximum and number of maximums, and at each time add this value to the answer.In order to generalize this idea for a complete solution, let's split the field N×NN×N into squares K×KK×K(Colors are not important, they are just for convenience).Then let's go with the same sweep line from left to right, but we will store everything not in the segment tree, but in the sqrt decomposition.And we will store for a piece of size KK by yy-coordinate the number of (good segments) points that we have already met in it.So we can cut off from the original queryThe lower part, leaving a horizontal strip of size ≤K≤K.We made it in O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).With similar sweep line from top to bottom, and not from left to right, we can cut off the left part, leaving as a query a rectangle with sides <K<K.Then you can create <K<K events of the form: \"Add the sum on the vertical segment to the answer to ii-th query\", and these events can be processed by a sweep line from left to right with the segment tree , so you can solve this part in O(n⋅k⋅logn)O(n⋅k⋅log⁡n).So we can get a solution in O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), and choosing k=nlogn−−−−√k=nlog⁡n allows to solve the task in O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 998 和字母"
          },
          "content_length": 13513
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if pair_is_goodcount the answer, all remaining digits are either $$$0$$$ or $$$49$$$ and all such alternatives are unique.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"\");\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        n = 1000000000 - rnd.next(0, 10);\n    } else if (type == \"random\") {\n        int minN = opt<int>(\"minN\", 1);\n        int maxN = opt<int>(\"maxN\", 1000000000);\n        n = rnd.next(minN, maxN);\n    } else if (type == \"special\") {\n        vector<int> specialNs = {1, 2, 3, 4, 5, 10, 50, 99, 100, 999, 1000, 9999, 10000, 50000, 999999999, 1000000000};\n        n = specialNs[rnd.next(specialNs.size())];\n    } else if (n == -1) {\n        cerr << \"Error: n not provided and type not recognized\" << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"\");\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        n = 1000000000 - rnd.next(0, 10);\n    } else if (type == \"random\") {\n        int minN = opt<int>(\"minN\", 1);\n        int maxN = opt<int>(\"maxN\", 1000000000);\n        n = rnd.next(minN, maxN);\n    } else if (type == \"special\") {\n        vector<int> specialNs = {1, 2, 3, 4, 5, 10, 50, 99, 100, 999, 1000, 9999, 10000, 50000, 999999999, 1000000000};\n        n = specialNs[rnd.next(specialNs.size())];\n    } else if (n == -1) {\n        cerr << \"Error: n not provided and type not recognized\" << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n\n./gen -type random -minN 1 -maxN 100\n./gen -type random -minN 100 -maxN 1000\n./gen -type random -minN 1000 -maxN 1000000\n./gen -type random -minN 1000000 -maxN 1000000000\n\n./gen -type special\n./gen -type special\n./gen -type special\n\n./gen -n 1\n./gen -n 2\n./gen -n 5\n./gen -n 10\n./gen -n 50\n./gen -n 99\n./gen -n 100\n./gen -n 999\n./gen -n 1000\n./gen -n 9999\n./gen -n 10000\n./gen -n 50000\n./gen -n 999999999\n./gen -n 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:20.777136",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "998/E",
      "title": "E. Небо в огне",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая и единственная строка входных данных содержит одно число nn (1≤n≤10000001≤n≤1000000) — количество строк и столбцов в календаре.",
      "output_spec": "Выходные данныеВыведите одно число — количество удачных раскрасок календаря по модулю 998244353998244353",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать3Входные данныеСкопировать2Выходные данныеСкопировать63Входные данныеСкопировать3Выходные данныеСкопировать9933",
      "description": "E. Небо в огне\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая и единственная строка входных данных содержит одно число nn (1≤n≤10000001≤n≤1000000) — количество строк и столбцов в календаре.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество удачных раскрасок календаря по модулю 998244353998244353\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать3Входные данныеСкопировать2Выходные данныеСкопировать63Входные данныеСкопировать3Выходные данныеСкопировать9933\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать63\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9933\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере любая раскраска является удачной, так как единственный столбец состоит только из одного цвета.Во втором примере удачными, в том числе, являются следующие раскраски:  А вот эти раскраски удачными не являются:",
      "solutions": [
        {
          "title": "Codeforces Round #493 - Codeforces",
          "content": "Привет, codeforces!Рад пригласить вас на рейтинговый раунд #493, который состоится в воскресенье, 1 июля 2018 г. в 22:05UTC+8.Авторы раунда — Ильдар 300iq Гайнуллин, Григорий vintage_Vlad_Makeev Резников, Михаил MikeMirzayanov Мирзаянов, и я, cdkrot.Большое спасибо Shiqing cyand1317 Lyu, Андрею GreenGrape Райскому, Ивану isaf27 Сафонову, Алексею Aleks5d Упирвицкому за тестирование раунда. Михаилу MikeMirzayanov Мирзаянову и Николаю KAN Калинину за помощь с подготовкой раунда.А также Михаилу MikeMirzayanov Мирзаянову за системы codeforces и polygon.Как обычно, в раунде будет 5 задач на 2 часа. Надеюсь, что вам понравятся задачи, и желаю удачи!Разбаловка будет опубликована незадолго перед раундом.UPD: Разбаловка выглядит следующим образом:Div1: 500 1250 1500 2500 3000Div2: 500 1000 1250 2000 2500Возможно, вы также хотите обратить внимание на этот пост со стримом-обсуждением после контеста.UPD2: Опубликован разборUPD3: Поздравляем победителей!Div1: TLE ksun48 fateice Swistakk Um_nik Petr V--o_o--V consecutivelimit LHiC uwi Div2: kirisamejin liu_runda AntiLeaf TheFallenOne haj_lemon st-Firdavs traxex paladin kmyiu Maxim",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1133
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces",
          "content": "Author — vintage_Vlad_Makeev Tutorial is loading...Author — MikeMirzayanov 998B - РаспилМожно показать, что разрез после ii-го числа можно провести тогда и только тогда, когда префикс длины ii содержит равное число чётных и нечётных чисел.Тем самым, каждый разрез можно провести или не провести независимо от других (за исключением вопроса бюджета).Почему это верно?Покажем достаточность. Если провести некоторое множество разрезов соответствуя критерию выше, то результат получится корректным — каждый кусочек результата зажат между двумя разрезами, если каждый из префиксов, соответствующих разрезу, содержит одинаковое число чётных-нечётных, то и \"разница\" тоже будет такой.Покажем необходимость — если было проведено некоторое множество разрезов, то каждый из кусочков результата содержит равное количество чётных-нечётных, а значит и каждый префикс соответствующий разрезу содержит равное количество чётных-нечётных.Так как каждый разрез можно провести независимо от других, то достаточно идентифицировать все корректные разрезы, выписать их в сортированном порядке по цене, и жадно набирать минимальные.Author — 300iq 997A - Превратить в единицыВыделим отрезки подряд идущих элементов одного цвета. Например, мы разобьем «00011001110» на «000» + «11» + «00» + «111» + «0».Тогда очевидно, что не стоит делать ходы внутри одной группы, а далее (если у нас есть хотя бы два отрезка цвета 00) за один ход мы можем уменьшить на один (и не больше чем на один) количество отрезков цвета 00, заплатив за это либо xx, либо yy (как угодно).Рассмотрим на примере, пусть у нас есть строка «11001100», мы можем перевернуть отрезок [5…8][5…8], и превратить ее в строку «11000011», или, например, инвертировать отрезок [3…4][3…4], превратив строку в «11111100» (Тогда количество групп цвета 00 уменьшилось с двух до одного).Но в конце все равно требуется сделать хотя бы одно инвертирование отрезка (который в конце будет один).Тогда пусть pp — количество групп цвета 00.Если p=0p=0, ответ равен 00.Иначе ответ равен (p−1)⋅min(x,y)+y(p−1)⋅min(x,y)+yAuthor — cdkrot 997B - Римские цифрыTL; DR — среди всех вариантов выбираем вариант в котором наибольшее количество 5050, среди них с наибольшим количеством 99. Перебираем конфигурации таким образом чтобы считать каждый вариант единожды, в максимальном варианте.Так как длина записи фиксированная, то можно решать задачу не для множества цифр {1,5,10,50}{1,5,10,50}, а для множества цифр {0,4,9,49}{0,4,9,49}.Для начала решим задачу только для множества {0,4,9}{0,4,9}.Нужно бороться с тем, что некоторые числа бывают несколько раз. Но это, на самом деле, достаточно просто — если есть ≥9≥9 четвёрок, то их можно прокачать в некоторое количество девяток, а остаток заполнить нулями.В таком случае решение — это перебор количества четвёрок от 00 до min(8,n)min(8,n), а затем выбора из оставшегося множества произвольного количества девяток — все такие варианты получаются различными.Вернёмся к исходной задаче с {0,4,9,49}{0,4,9,49}.В таком случае бывает ещё ситуация, когда можно увеличить количество 4949. Нужно вычислить все такие пары (x,y)(x,y) в пределах x,y≤50x,y≤50, что их можно прокачать в другую пару (x′,y′)(x′,y′) с отщеплением некоторого количества 4949-ок.Можно перебрать xx, yy, x′x′, y′y′ четырьмя вложенными циклами и проверить что сумма одного отличается от суммы другой только 4949-ками, в таком случае помечаем пару (x,y)(x,y) как бракованную.Можно также заметить, что если мы отбраковываем какую-то пару, то и все мажорирующие пары тоже отрбраковываются.После того как мы отметили какие пары хорошие, сделаем просто:for number_of_4for number_of_9if хорошая параСчитаем ответ, просто все оставшиеся цифры или 0, или 49 и всё однозначно————Другое решение: если вы внимательно изучите решение выше, то вы заметите, что с некоторого, достаточно небольшого nn (несложно доказать оценку в духе 5050 или 100100, но на самом деле точная граница — 1212), функция растёт линейно.Таким образом, если n≤12n≤12, можно вычислить ответ любым тупым способом, а иначе просто линейно его вычислить используя answer(12)answer(12) и answer(13)answer(13).Author — cdkrot 997C - Небо в огнеПусть AiAi — множество всех раскрасок, что ii-ая строка состоит только из одного цвета, а BiBi — множество всех раскрасок, где ii-ый столбец состоит только из одного цвета.Тогда требуется вычислить |A1∪A2…An∪B1∪B2…Bn||A1∪A2…An∪B1∪B2…Bn|.Как обычно, можно с помощи формулы включений исключений, вычислить можность объединения, зная мощности всех возможных пересечений описанных множеств.Более того, в силу очевидной симметрии, чтобы вычислить мощность пересечения некоторых AiAi и BiBi не важно знать какие именно индексы взяты — только количество AA-шек и количество BB-шек.Тогда ans=∑i=0…n,j=0…n,i+j>0CinCjn(−1)i+j+1f(i,j)ans=∑i=0…n,j=0…n,i+j>0CniCnj(−1)i+j+1f(i,j)Где f(i,j)f(i,j) — количество раскрасок у которых первые ii правильных строк и первые jj правильных столбцов.Оказывается, что ff принимает существенно разные значения в зависимости от того, есть ли ноль в её аргументах, или нет.Пусть есть, тогда f(0,k)=3k⋅3n(n−k)f(0,k)=3k⋅3n(n−k).Действительно, нужно выбрать по одному цвету в каждом из первых kk столбцов, а остальное покрасить произвольным образом.——Если оба аргумента >0>0, то есть есть хотя бы один одноцветный столбец и одна одноцветная строка, то заметим, что все Одноцветные строки и столбцы одинакового цвета, в силу пересечения строк со столбцами.Тем самым, f(i,j)=3⋅3(n−i)(n−j)f(i,j)=3⋅3(n−i)(n−j)Так как нужно выбрать сначала общий цвет любым способом, а затем покрасить остаток произвольным образом.Просуммировав формулу выше, можно получить решение за O(n2)O(n2) или O(n2log)O(n2log) в зависимости от реализации.Но нужно быстрее.——Просуммируем все слагаемые где i=0i=0 или j=0j=0 втупую, за O(n)O(n).Изучим остальные слагаемые, имеем формулу:ans=∑ni=1∑nj=1CinCjn(−1)i+j+13⋅3(n−i)(n−j)ans=∑i=1n∑j=1nCniCnj(−1)i+j+13⋅3(n−i)(n−j)Сделаем замену переменных: i→n−ii→n−i, j→n−jj→n−j.ans=3∑n−1i=0∑n−1j=0Cn−inCn−jn(−1)n−i+n−j+1⋅3ijans=3∑i=0n−1∑j=0n−1Cnn−iCnn−j(−1)n−i+n−j+1⋅3ijВ силу Cn−in=CinCnn−i=Cni, (−1)2n=1(−1)2n=1, (−1)−i=(−1)i(−1)−i=(−1)ians=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijЗаметим, что (a+b)n=∑ni=0Cinaibn−i(a+b)n=∑i=0nCniaibn−i.С помощью этого можно свернуть слагаемые при одном ii, при этом, одному ii соответствует не nn слагаемых, а n−1n−1. Можно добавить и вычесть последнее слагаемое.——-Приступимans=3∑n−1i=0∑n−1j=0CinCjn(−1)i+j+1⋅3ijans=3∑i=0n−1∑j=0n−1CniCnj(−1)i+j+1⋅3ijans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−1)j⋅(3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−1)j⋅(3i)jans=3∑n−1i=0Cin(−1)i+1∑n−1j=0Cjn(−3i)jans=3∑i=0n−1Cni(−1)i+1∑j=0n−1Cnj(−3i)jans=3∑n−1i=0Cin(−1)i+1[(1+(−3i))n−(−3i)n]ans=3∑i=0n−1Cni(−1)i+1[(1+(−3i))n−(−3i)n]—–В этой формуле уже O(n)O(n) слагаемых, а значит её можно просуммировать достаточно быстро.Для возведения в степень можно воспользоваться быстрым возведением в степень.Author — cdkrot 997D - Циклы в произведенииРассмотрим произвольный цикл в графе-произведении.В силу определения произведения, соседние вершины в цикле соответствуют переходу либо по ребру в первом дереве, либо переходу во втором.Тем самым, если выписать рёбра соответствующие одному дереву в отдельный список, то получим цикл в этом дереве.Также, если у нас есть цикл в одном дереве длины aa и цикл длины bb во втором дереве, то из них можно сделать Caa+bCa+ba циклов в произведении.Тем самым, задача сводится к тому, чтобы посчитать для каждой длины до kk количество циклов в каждом из деревьев по отдельности, а затем перемешать их в циклы в произведении.—–Рассмотрим центроид cc дерева, посчитаем все циклы которые проходят через него, удалим центроид и решим задачу рекурсивно в каждой из оставшихся компонент.Как выглядит цикл проходящий через cc? Это нужно начать в какой-то вершине vv, затем дойти до cc (не проходя через cc в промежуточных вершин), дойти до вершины vv, возможно проходя через cc.Определим две динамики: f[v][k]f[v][k] — это количество способов догулять из cc до vv за ровно kk шагов не проходя через cc в промежуточных вершинах, g[v][k]g[v][k] — число способов дойти от cc до vv за kk шагов без предыдущего ограничения.Тогда ответом будет свёртка f[v]f[v] и g[v]g[v]: ans[i+j]+=f[v][i]∗g[v][j]ans[i+j]+=f[v][i]∗g[v][j].Случай если v=cv=c нужно разобрать отдельно, тогда нужно просто сделать ans[i]+=g[c][i]ans[i]+=g[c][i].За сколько времени можно посчитать динамику? За O(nk)O(nk), g[v][i]g[v][i] равна сумме g[u][i−1]g[u][i−1] по соседям uu. Так как граф это дерево, то суммарное число соседей O(n)O(n) и суммарно O(nk)O(nk) переходов.f[v]f[v] считается аналогично, только нужно запретить все переходы в вершину cc.——Итоговая асимптотика: O(nk2log(n))O(nk2log(n)).log(n)log⁡(n) берётся из-за центроидной декомпозиции.На уровне мы считаем динамику за O(nk)O(nk), а затем считаем свёртку O(nk2)O(nk2), тем самым O(nk2log(n))O(nk2log(n)).Решение можно также соптимизировать с помощью быстрого перемножения многочленов и получить O(nklog(k)log(n))O(nklog⁡(k)log(n)), но этого не требовалось.Author — 300iq 997E - Хорошие подотрезкиРассмотрим два решения задачи для всего массива, каждое из них может быть обобщено для решения задачи на отрезка за субквадратичное время.Первое решение это разделяй и властвуй.Давайте возьмем середину массива и посчитаем число хороших отрезков, проходящих через нее.Пусть минимум и максимум лежат по одну сторону от середины, тогда по границе на той половине, где они находятся, можно восстановить весь отрезок и проверить, что он корректный (и запомнить его где-нибудь).Иначе пусть они лежат по разные стороны от середины.Тогда пусть максимум лежит слева (второй случай симметричен и может быть рассмотрен аналогично), тогда нужно чтобы r−l=max−minr−l=max−min, но rr и maxmax мы уже знаем, тогда можно перенести и сказать, что единственное необходимое условие это r−max=l−minr−max=l−min.Тогда давайте разобьем элементы на классы эквивалентности, где разбираем на классы по r−maxr−max если элемент слева и по l−minl−min если элемент справа (где maxmax и minmin это минимум и максимум на отрезке до середины mm, соответственно), тогда отрезок l≤m<rl≤m<r (где максимум слева) хороший тогда и только тогда, когда на отрезке [l…m][l…m] нет чисел меньших минимума на отрезке (m…r](m…r] и на отрезке (m…r](m…r] нет чисел больших максимума на отрезке [l…m][l…m], и при этом ll и rr лежат в одном классе.Тогда для одной границы отрезка подходит какой-то отрезок элементов из ее класса (эти отрезки можно выделить, например, проходом со стеком или бинпоиском).Еще нужно не забыть запуститься рекурсивно от левой половины и правой половины :)А далее можно применить алгоритм Мо!Будем двигать левую и правую границу, пробегаться по классам, в которым лежит эта граница, и прибавлять/вычитать из ответа размер пересечения отрезка, который подходит этой границе и отрезка, который сейчас содержится (на текущем отрезке [l…r][l…r]), таким образом эта часть работает за O(nn−−√logn)O(nnlog⁡n) (но с не очень большой константой, потому что часть при корне это просто пробежаться по массиву и провести операции с интами).Так же нужно не забыть про отрезки, где минимум и максимум содержатся по одну сторону, их можно обработать, например, пройдя сканлайном с деревом фенвика, эта часть работает за O(nlogn)O(nlog⁡n).Таким образом идея с разделяй и властвуй обобщается до O(nn−−√logn)O(nnlog⁡n).Но давайте рассмотрим геометрическую интерпретацию задачи.Пусть хорошие отрезки это точки (l,r)(l,r) на плоскости!Тогда запрос это просто сумма на прямоугольнике [1…l][r…n][1…l][r…n].Для решения задачи на всем массива давайте будем двигать правую границу запроса, и для каждой левой будем хранить r−l−(max−min)r−l−(max−min), это можно хранить в дереве отрезков (и пересчитывать храня стеки), а далее нужно заметить, что эта величина всегда неположительна, поэтому можно просто хранить в дереве отрезков количество максимумов, и каждый раз прибавлять эту величину к ответу.Для того чтобы обобщить эту идею для полного решения, давайте разобьем поле N×NN×N на квадраты K×KK×K(Цвета не важны, а просто служат для более приятного просмотра).Тогда давайте пойдем таким же сканлайном слева направо, но будем хранить все не в дереве отрезков, а в корневой.А еще будем хранить для кусочка размера KK по yy-координате количество (хороших отрезков) точек, которые мы уже в нем встретили.Таким образом мы можем отрезать от исходного запросаНижнюю часть, оставив горизонтальную полоску высотой размера ≤K≤K.Это мы сделали за O(n⋅k+n⋅nk)O(n⋅k+n⋅nk).Пройдя аналогичным сканлайном сверху-вниз, а не слева-направо мы можем отрезать и левую часть, оставив в качестве запроса прямоугольник со сторонами <K<K.Тогда можно создать <K<K событий вида: \"Добавить к ответу на ii-й запрос сумму на вертикальном отрезке\", а эти события можно обработать пройдя сканлайном с деревом отрезков слева-направо, и выполнить эту часть за O(n⋅k⋅logn)O(n⋅k⋅log⁡n).Таким образом получается решение за O(n⋅nk+n⋅k⋅logn)O(n⋅nk+n⋅k⋅log⁡n), и выбор k=nlogn−−−−√k=nlog⁡n позволяет добиться асимптотики O(n⋅n⋅logn−−−−−−√)O(n⋅n⋅log⁡n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 998 和字母"
          },
          "content_length": 13009
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #493 - Codeforces - Code 1",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 2",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292, 341};\nif (n < a.size())\n    return a[n];\nelse\n    return a[12] + 49 * (n - 12);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 3",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 4",
          "code": "vector<int> a = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292};\nif (n < a.size())\n    return a[n];\nelse\n    return a[11] + 49 * (n - 11);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 5",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 6",
          "code": "set<int> st;\nfor(int i=0;i<=n;i++) for(int v=0;v+i<=n;v++){\n\tfor(int x=0;x+v+i<=n;x++){\n\t\tint l = n - i - v - x, cur = i+v*5+x*10+l*50;\n\t\tst.insert(cur);\n\t}\n}\ncout << st.size() << '\\n';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 7",
          "code": "cout << min(cnt * y, (cnt - 1) * x + y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 - Codeforces - Code 8",
          "code": "scanf(\" %c\", &c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 1",
          "code": "for number_of_4for number_of_9if хорошая параСчитаем ответ, просто все оставшиеся цифры или 0, или 49 и всё однозначно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int>st;\nint n;\nint v[] = {1, 5, 10, 50};\n \nvoid gen(int digit, int sum){\n\tif(digit == n){\n\t\tst.insert(sum);\n\t\treturn;\n\t}\n \n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tgen(digit + 1, sum + v[i]);\n\t}\n}\n \nint main() {\n\tcin >> n;\n \n\tgen(0, 0);\n \n\tcout << st.size() << endl;\n \n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/* CODE */\nint main(int argc, char const *argv[]){\n\t//IO();\n\tFAST_IO();\n\tint n;\n\tcin >> n;\n\tint mem[15];\n\tset<int> s;\n\ts.insert(0);\n\tfor(int i=0;i<15;i++){\n\t\tset<int >tmp;\n\t\tfor(auto it :s){\n\t\t\ttmp.insert(it+1);\n\t\t\ttmp.insert(it+5);\n\t\t\ttmp.insert(it+10);\n\t\t\ttmp.insert(it+50);\n\t\t}\n\t\ts=tmp;\n\t\tmem[i]=s.size();\n\t}\n\t// for(int i=0;i<15;i++){\n\t// \tcout << i << \" \" << mem[i] << endl;\n\t// }\n\tif(n<=15){\n\t\tcout << mem[n-1] << endl;\n\t}\n\telse{\n\t\tn=n-15;\n\t\tcout << (lli)mem[14] + (lli)n*(49LL) << endl;\n\t}\nreturn 0;\t\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 6",
          "code": "(-1)^(i + j + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 7",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 8",
          "code": "set<lli> a;\nfo(i,48) fo(j,48)\n{\n    bool fl=true;\n    for(set<lli> :: iterator it=a.begin();it!=a.end()&&fl;++it) if(abs(4*i+9*j-*it)%49==0) fl=false;\n    if(fl)  a.insert(4*i+9*j);\n}\ncout<<\"Total distinct pairs : \"<<a.size();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 9",
          "code": "Total distinct pairs : 49",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 10",
          "code": "There are only 49 distint values of n%49.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 11",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 12",
          "code": "lli sz=0;\nbool a[50];\nfor(n=1;n<=50;++n)\n{\n    fo(i,n+1) fo(j,n+1)\n    {\n        lli val = (4*i+9*j)%49;\n        if(a[val]==false&&((4*i+9*j)/49+i+j<=n))\n        { \n            a[val]=true;\n            sz++;\n        }\n    }\n    if(sz==49)\n        break;\n}\ncout<<\"Lower Bound : \"<<n<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 13",
          "code": "Lower Bound : 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 14",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 15",
          "code": "typedef long long ll;\nconst int LIM = 48;\n\nll solve(int n) {\n    // x : # of 4\n    // y : # of 9\n    vector<vector<int>> validpair(LIM+1, vector<int>(LIM+1, true));\n\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y > n) continue;\n\n            for (int xs = 0; xs <= LIM; xs++) {\n                for (int ys = 0; ys <= LIM; ys++) {\n                    if (xs + ys > n) continue;\n                    if (x == xs && y == ys) continue;\n\n                    ll a = x * 4LL + y * 9LL;\n                    ll b = xs * 4LL + ys * 9LL;\n\n                    if (a > b && ((a - b) % 49 == 0)) {\n                        validpair[x][y] = false;\n                    }\n\n                    // only cancel one smaller pair\n                    if (a == b && (x+y) > (xs+ys)) {\n                        validpair[x][y] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    ll cnt = 0;\n    for (int x = 0; x <= LIM; x++) {\n        for (int y = 0; y <= LIM; y++) {\n            if (x + y <= n && validpair[x][y]) {\n                int left = n - (x + y);\n                cnt += left + 1;\n            }\n        }\n    }\n\n    return cnt;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 16",
          "code": "[submission:40032568]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #493 — Editorial - Codeforces - Code 17",
          "code": "(1 + (-3^i))^n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60357",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 15\n./gen -n 17\n./gen -n 20\n./gen -n 25\n./gen -n 30\n./gen -n 50\n./gen -n 64\n./gen -n 100\n./gen -n 128\n./gen -n 256\n./gen -n 512\n./gen -n 1024\n./gen -n 2048\n./gen -n 4096\n./gen -n 8192\n./gen -n 16384\n./gen -n 32768\n./gen -n 65536\n./gen -n 999983\n./gen -n 999999\n./gen -n 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:22.475366",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "999/A",
      "title": "A. Мишка и контест",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задано два целых числа nn и kk (1≤n,k≤1001≤n,k≤100) — количество задач в контесте и умение Мишки решать задачи.Во второй строке входных данных задано nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤1001≤ai≤100), где aiai равняется сложности задачи с номером ii. Задачи заданы в порядке их расположения в списке слева направо.",
      "output_spec": "Выходные данныеВыведите одно целое число — максимальное количество задач, которое сможет решить Мишка.",
      "sample_tests": "ПримерыВходные данныеСкопировать8 44 2 3 1 5 1 6 4Выходные данныеСкопировать5Входные данныеСкопировать5 23 1 2 1 3Выходные данныеСкопировать0Входные данныеСкопировать5 10012 34 55 43 21Выходные данныеСкопировать5",
      "description": "A. Мишка и контест\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных задано два целых числа nn и kk (1≤n,k≤1001≤n,k≤100) — количество задач в контесте и умение Мишки решать задачи.Во второй строке входных данных задано nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤1001≤ai≤100), где aiai равняется сложности задачи с номером ii. Задачи заданы в порядке их расположения в списке слева направо.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — максимальное количество задач, которое сможет решить Мишка.\n\nВыходные данные\n\nВходные данныеСкопировать8 44 2 3 1 5 1 6 4Выходные данныеСкопировать5Входные данныеСкопировать5 23 1 2 1 3Выходные данныеСкопировать0Входные данныеСкопировать5 10012 34 55 43 21Выходные данныеСкопировать5\n\nВходные данныеСкопировать8 44 2 3 1 5 1 6 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 23 1 2 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 10012 34 55 43 21\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере Мишка может решать задачи в следующем порядке: [4,2,3,1,5,1,6,4]→[2,3,1,5,1,6,4]→[2,3,1,5,1,6]→[3,1,5,1,6]→[1,5,1,6]→[5,1,6][4,2,3,1,5,1,6,4]→[2,3,1,5,1,6,4]→[2,3,1,5,1,6]→[3,1,5,1,6]→[1,5,1,6]→[5,1,6]. Таким образом, количество решенных им задач будет равно 55.Во втором тестовом примере Мишка не может решить ни одной задачи, так как задачи как с левого, так и с правого концов списка имеют сложность, превышающую kk.В третьем тестовом примере Мишка умеет очень хорошо решать задачи и сможет решить их все.",
      "solutions": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Привет!21 июня (четверг) в 17:35 (Московское время) начнётся Codeforces Round 490 (Div. 3) — очередной Codeforces раунд для третьего дивизиона. В этом раунде будет 6 задач, которые подобраны по сложности так, чтобы составить интересное соревнование для участников с рейтингами до 1600. Наверное, участникам из первого дивизиона они будут совсем не интересны, а для 1600-1899 покажутся простыми. Однако все желающие, чей рейтинг 1600 и выше могут зарегистрироваться на раунд вне конкурса.Раунд пройдет по правилам образовательных раундов. Таким образом, во время раунда задачи будут тестироваться на предварительных тестах, а после раунда будет 12-ти часовая фаза открытых взломов. Я постарался сделать приличные тесты — так же как и вы буду расстроен, если у многих попадают решения после окончания контеста.Вам будет предложено 6 задач и 2 часа на их решение.Напоминаем, что в таблицу официальных результатов попадут только достоверные участники третьего дивизиона. Как написано по ссылке — это вынужденная мера для борьбы с неспортивным поведением. Для квалификации в качестве достоверного участника третьего дивизиона надо: принять участие не менее чем в двух рейтинговых раундах (и решить в каждом из них хотя бы одну задачу), не иметь в рейтинге точку 1900 или выше. Независимо от того являетесь вы достоверными участниками третьего дивизиона или нет, если ваш рейтинг менее 1600, то раунд для вас будет рейтинговым.Спасибо MikeMirzayanov за платформы, помощь с идеями для задач и координацию моей работы. Спасибо Михаилу awoo Пикляеву, Максиму Neon Мещерякову и Ивану BledDest Андросову за помощь в подготовке и тестирование раунда.Удачи!UPD: Также спасибо step_by_step, kevinsogo и nhho за помощь в подготовке раунда и его тестирование.UPD2: Таблица результатов!Поздравляем победителей: Rank Competitor Problems Solved Penalty 1 EricHuang2003 6 150 2 JerryKFC 6 151 3 Lovely_qgq 6 170 4 Meroeht 6 181 5 MYTH_vs_REALiTY 6 209 Поздравляем лучших взломщиков: Rank Competitor Hack Count 1 djm03178 30:-2 2 2014CAIS01 13:-3 3 quailty 5:-2 4 Harmonium_Wale 4:-2 5 kimden 2 Было сделано 110 успешных взломов и 226 неудачных взломов!И, наконец, поздравляем людей, отправивших первое полное решение по задаче: Problem Competitor Penalty A jh05013 0:01 B JerryKFC 0:02 C GrayGlobe 0:03 D T______________T 0:21 E NamikazeBoruto 0:11 F Counting_Stars 0:20 UPD3: Разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60096",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2363
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Я сильно сожалею, что задача D оказалась намного сложнее, чем я ожидал, и образовалась пропасть в сложности между задачами C и D. Надеюсь, в следующих раундах такого не повторится.UPD: Хочу сказать отдельное спасибо kevinsogo за огромную помощь с разборами и с подготовкой раунда в целом.999A - Мишка и контест Разбор999A - Мишка и контестВ этой задаче можно было пройти по всем элементам массива слева направо, считая количество задач, которые Мишка решит с левого конца списка и остановиться, если он не сможет решить следующую задачу. Пусть количество задач, которое Мишка сможет решить с левого конца списка, равно lflf. Сделаем то же самое независимо, проходя по элементам массива справа налево. Пусть количество задач, которое Мишка сможет решить с правого конца списка, будет равно rgrg. Тогда ответ это min(n,lf+rg)min(n,lf+rg).Асимптотика решения — O(n)O(n). Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999B - Переворотное шифрование Разбор999B - Переворотное шифрованиеВ этой задаче можно реализовать алгоритм шифрования за исключением одного момента: нам необходимо проходиться под всем делителям nn в возрастающем порядке.Асимптотика решения — O(n ⋅d(n))O(n ⋅d(n)), где d(n)d(n) — функция, считающая количество делителей числа nn. Например, maxi=1106d(i)=240maxi=1106d(i)=240. Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\n\treturn 0;\n}999C - Алфавитное удаление Разбор999C - Алфавитное удалениеПусть строчные латинские буквы будут пронумерованы от 00 до 2525.В этой задаче существует как минимум два различных решения:Если k=nk=n, закончим выполнение программы. Иначе посчитаем количество вхождений каждой буквы от 00 до 2525. Пусть это будет cntcnt. Теперь найдем наименьшую (в алфавитном порядке) букву, которая будет в ответе. Это можно сделать следующим образом: пройдем по всем ii от 00 до 2525, если cnti≤kcnti≤k, то просто вычитаем его из kk, иначе ii будет наименьшей буквой, которая встретится в ответе. Но (возможно) нам также необходимо удалить некоторое количество самых левых вхождений этой буквы. Очевидно, что буквы меньше ii не будут встречаться в ответе. Также kk самых левых вхождений буквы ii тоже не должны быть в ответе. Пройдемся по всем буквам строки ss слева направо и будем хранить строку-ответ resres. Если текущий символ строки ss (пусть он равен sjsj) меньше ii, тогда ничего не нужно делать. Если sjsj больше, чем ii, то он точно будет присутствовать в ответе. Иначе sj=isj=i. Если k>0k>0, уменьшим kk на единицу, иначе добавим sjsj к строке-ответу. Сложность решения — O(n)O(n).Другое решение заключается в следующем. Сохраним вектор пар (si,i)(si,i), где sisi — ii-й символ ss, а ii — его позиция. Если мы отсортируем этот вектор со стандартной функцией сравнения, то легко заметить, что первые kk его элементов будут удалены из заданной строки. Теперь если мы отсортируем последние n−kn−k элементов этого вектора в порядке возрастания их позиций в заданной строке, мы получим ответ. Сложность решения — O(n logn)O(n log⁡n). Решение 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Решение 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\n\treturn 0;\n}999D - Уравняй остатки Разбор999D - Уравняй остаткиДля каждого i∈[0..m−1]i∈[0..m−1] будем хранить список позиций элементов заданного массива, которые равны ii по модулю mm. Также будем хранить вектор пар freefree, и пусть kk равно nmnm.Запустим следующий цикл дважды: для всех ii от 00 до m−1m−1 сначала, пока в текущем списке слишком много элементов, равных ii по модулю mm (больше, чем kk), будем удалять лишние и добавлять их в вектор freefree (первый элемент пары будет являться индексом элемента в массиве, а второй будет равен ii, при котором этот элемент встретился). После этого, пока в текущем списке слишком мало элементов, равных ii по модулю mm (меньше, чем kk), будем удалять последний элемент из вектора freefree (пусть он равен (fidx,fmodfidx,fmod)), добавлять к ответу и к afidxafidx значение, равное i−fmodi−fmod.После всего этого выведем ответ и измененный массив aa.Очевидно, что после первых mm итераций ни в одном из списков не будет лишних элементов, и после всех 2⋅m2⋅m итераций все списки будут иметь одинаковый размер. Также можно легко доказать, что это решение строит оптимальный ответ.Сложность решения — O(n+m)O(n+m). Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}999E - Достижимость из столицы Разбор999E - Достижимость из столицыДанная задача эквивалентна следующей: посчитать количество истоков (вершин с полустепенью захода 00) в конденсации заданного графа. Очевидно, что у данной задачи есть решение за O(n+m)O(n+m), но в данной задаче ограничения были совсем небольшими, чтобы решения с асимптотикой O(n⋅m)O(n⋅m) проходили все тесты.Одно из таких решений выглядит так: сначала отметим хорошими вершины, достижимые из ss, при помощи простого обхода в глубину. Затем для каждой нехорошей вершины vv посчитаем количество достижимых нехороших вершин из vv (это тоже можно сделать при помощи простого обхода в глубину). Пусть это количество для вершины vv будет равно cntvcntv. Отсортируем все нехорошие вершины в порядке невозрастания cntvcntv, пройдем по всем нехорошим вершинам в отсортированном порядке, и для текущей вершины vv, если на данный момент она не является хорошей, запустим из нее обход в глубину, отметим все достижимые вершины хорошими и увеличим ответ на 11 (на самом деле, мы неявно добавляем ребро (s,v)(s,v)). Можно доказать, что такое решение дает оптимальный ответ. Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\n\tdfs1(s);\n\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Линейное решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999F - Карты и радость Разбор999F - Карты и радостьОчевидно, что можно решать эту задачу отдельно для каждого любимого числа, потому что каждый из игроков имеет ровно одно любимое число и если игрок получает карту с записанным на ней числом, которое не является его любимым, его радость не меняется.Пусть dpx,ydpx,y будет означать максимально возможную суммарную радость xx игроков с одинаковым (неважно, каким) любимым числом и yy карт (с числами, записанными на них, равными любимым числам игроков), распределенных между этими xx игроками оптимально. Заметим, что x∈[0..n]x∈[0..n] и y∈[0..k⋅n]y∈[0..k⋅n]. Сначала все значения dpdp равны нулю. Переходы в этом динамическом программировании будут означать, сколько карт получит xx-й игрок (от 00 до kk). Другими словами, переходы в этом динамическом программировании будут выглядеть так: for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),где h[i]h[i] — радость игрока, если он получит ровно ii карт с любимым числом. Заметим, что h[0]=0h[0]=0.Теперь ответ можно посчитать очень легко: ans:=∑i=1105dp[fi][ci]ans:=∑i=1105dp[fi][ci], где fifi — количество игроков с любимым числом ii, а cici — количество карт с числом ii.Асимптотика решения — O(n2⋅k2)O(n2⋅k2). Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 999\\s*A"
          },
          "content_length": 12407
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "div-3 rocks, I think you will give some critical test cases. Getting hacked after contest is too much painful.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "div-3 rocks, I think you will give some critical test cases. Getting hacked after contest is too much painful.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "(Correct me if i am wrong until this point)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "count all nodes with either indegree=0 or all strongly connected graphs with connected nodes more than 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "distribute m cards to 3 people while maximum the score",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "after the round it will be a 12-hour phase of open hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "anss=s[n-1-i]+anss;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "printf/cout",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 27",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 28",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "X = count(large[i]) - n / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "[i + 1, m - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "count < group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "count > group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "N = 8, M = 4, K = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "0 4 12 1 5 8 9 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "[4, 4, 0, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "i mod m = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "[2, 2, 2(from 1), 2(from 0)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 27",
          "code": "i mod m = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 28",
          "code": "[2, 2, 2(from 0), 2(from 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 29",
          "code": "[4, 0, 4, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 30",
          "code": "i mean just find connected component",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 31",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 32",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 33",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 34",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 35",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 36",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 37",
          "code": "H[0] = 0, H[1] = 2 , H[2] = 6, H[3] = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 38",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 39",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 40",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 41",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 42",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 43",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 44",
          "code": "map<int,bool> v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 45",
          "code": "bool v[5005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 46",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #490 (Div. 3) - Codeforces - Code 47",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readInts(n, 1, 100);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readInts(n, 1, 100);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readInts(n, 1, 100);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\" if not given\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"all_solvable\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"none_solvable\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(k+1, 100);\n    } else if (type == \"only_left_solvable\") {\n        int solvable_length = rnd.next(1, n); // Decide how many on left are solvable\n        for (int i = 0; i < solvable_length; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = solvable_length; i < n; ++i)\n            a[i] = rnd.next(k+1, 100);\n    } else if (type == \"only_right_solvable\") {\n        int solvable_length = rnd.next(1, n); // Decide how many on right are solvable\n        for (int i = 0; i < n - solvable_length; ++i)\n            a[i] = rnd.next(k+1, 100);\n        for (int i = n - solvable_length; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"solvable_ends\") {\n        int left_solvable_length = rnd.next(1, n-1);\n        int right_solvable_length = rnd.next(1, n - left_solvable_length);\n        int middle_length = n - left_solvable_length - right_solvable_length;\n        for (int i = 0; i < left_solvable_length; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = left_solvable_length; i < left_solvable_length + middle_length; ++i)\n            a[i] = rnd.next(k+1, 100);\n        for (int i = left_solvable_length + middle_length; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"unsolvable_ends\") {\n        int left_unsolvable_length = rnd.next(1, n-1);\n        int right_unsolvable_length = rnd.next(1, n - left_unsolvable_length);\n        int middle_length = n - left_unsolvable_length - right_unsolvable_length;\n        for (int i = 0; i < left_unsolvable_length; ++i)\n            a[i] = rnd.next(k+1, 100);\n        for (int i = left_unsolvable_length; i < left_unsolvable_length + middle_length; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = left_unsolvable_length + middle_length; i < n; ++i)\n            a[i] = rnd.next(k+1, 100);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, k);\n            else\n                a[i] = rnd.next(k+1, 100);\n    } else if (type == \"max_difficulty\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"min_difficulty\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"k_equals_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"k_minus_1\") {\n        int diff = max(1, k - 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = diff;\n    } else if (type == \"k_plus_1\") {\n        int diff = min(100, k + 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = diff;\n    } else if (type == \"single_solvable\") {\n        int solvable_pos = rnd.next(0, 1); // 0 for left, 1 for right\n        if (solvable_pos == 0) {\n            a[0] = rnd.next(1, k);\n            for (int i = 1; i < n; ++i)\n                a[i] = rnd.next(k+1, 100);\n        } else {\n            for (int i = 0; i < n-1; ++i)\n                a[i] = rnd.next(k+1, 100);\n            a[n-1] = rnd.next(1, k);\n        }\n    } else {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\" if not given\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"all_solvable\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"none_solvable\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(k+1, 100);\n    } else if (type == \"only_left_solvable\") {\n        int solvable_length = rnd.next(1, n); // Decide how many on left are solvable\n        for (int i = 0; i < solvable_length; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = solvable_length; i < n; ++i)\n            a[i] = rnd.next(k+1, 100);\n    } else if (type == \"only_right_solvable\") {\n        int solvable_length = rnd.next(1, n); // Decide how many on right are solvable\n        for (int i = 0; i < n - solvable_length; ++i)\n            a[i] = rnd.next(k+1, 100);\n        for (int i = n - solvable_length; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"solvable_ends\") {\n        int left_solvable_length = rnd.next(1, n-1);\n        int right_solvable_length = rnd.next(1, n - left_solvable_length);\n        int middle_length = n - left_solvable_length - right_solvable_length;\n        for (int i = 0; i < left_solvable_length; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = left_solvable_length; i < left_solvable_length + middle_length; ++i)\n            a[i] = rnd.next(k+1, 100);\n        for (int i = left_solvable_length + middle_length; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"unsolvable_ends\") {\n        int left_unsolvable_length = rnd.next(1, n-1);\n        int right_unsolvable_length = rnd.next(1, n - left_unsolvable_length);\n        int middle_length = n - left_unsolvable_length - right_unsolvable_length;\n        for (int i = 0; i < left_unsolvable_length; ++i)\n            a[i] = rnd.next(k+1, 100);\n        for (int i = left_unsolvable_length; i < left_unsolvable_length + middle_length; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = left_unsolvable_length + middle_length; i < n; ++i)\n            a[i] = rnd.next(k+1, 100);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, k);\n            else\n                a[i] = rnd.next(k+1, 100);\n    } else if (type == \"max_difficulty\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"min_difficulty\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"k_equals_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"k_minus_1\") {\n        int diff = max(1, k - 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = diff;\n    } else if (type == \"k_plus_1\") {\n        int diff = min(100, k + 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = diff;\n    } else if (type == \"single_solvable\") {\n        int solvable_pos = rnd.next(0, 1); // 0 for left, 1 for right\n        if (solvable_pos == 0) {\n            a[0] = rnd.next(1, k);\n            for (int i = 1; i < n; ++i)\n                a[i] = rnd.next(k+1, 100);\n        } else {\n            for (int i = 0; i < n-1; ++i)\n                a[i] = rnd.next(k+1, 100);\n            a[n-1] = rnd.next(1, k);\n        }\n    } else {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -n 10 -k 5 -type random\n./gen -n 100 -k 50 -type random\n\n# All solvable\n./gen -n 10 -k 5 -type all_solvable\n./gen -n 100 -k 50 -type all_solvable\n\n# None solvable\n./gen -n 10 -k 5 -type none_solvable\n./gen -n 100 -k 50 -type none_solvable\n\n# Only left solvable\n./gen -n 10 -k 5 -type only_left_solvable\n./gen -n 100 -k 50 -type only_left_solvable\n\n# Only right solvable\n./gen -n 10 -k 5 -type only_right_solvable\n./gen -n 100 -k 50 -type only_right_solvable\n\n# Solvable ends\n./gen -n 10 -k 5 -type solvable_ends\n./gen -n 100 -k 50 -type solvable_ends\n\n# Unsolvable ends\n./gen -n 10 -k 5 -type unsolvable_ends\n./gen -n 100 -k 50 -type unsolvable_ends\n\n# Alternating difficulties\n./gen -n 10 -k 5 -type alternating\n./gen -n 100 -k 50 -type alternating\n\n# Max difficulty (all a_i = 100)\n./gen -n 10 -k 50 -type max_difficulty\n./gen -n 100 -k 100 -type max_difficulty\n\n# Min difficulty (all a_i = 1)\n./gen -n 10 -k 1 -type min_difficulty\n./gen -n 100 -k 50 -type min_difficulty\n\n# All elements equal to k\n./gen -n 10 -k 5 -type k_equals_ai\n./gen -n 100 -k 50 -type k_equals_ai\n\n# All elements equal to k - 1\n./gen -n 10 -k 5 -type k_minus_1\n./gen -n 100 -k 50 -type k_minus_1\n\n# All elements equal to k + 1\n./gen -n 10 -k 5 -type k_plus_1\n./gen -n 100 -k 50 -type k_plus_1\n\n# Single solvable problem at one end\n./gen -n 10 -k 5 -type single_solvable\n./gen -n 100 -k 50 -type single_solvable\n\n# Small n\n./gen -n 1 -k 5 -type random\n./gen -n 1 -k 1 -type all_solvable\n\n# Large n\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 100 -type all_solvable\n\n# k minimal\n./gen -n 10 -k 1 -type random\n./gen -n 100 -k 1 -type random\n\n# k maximal\n./gen -n 10 -k 100 -type random\n./gen -n 100 -k 100 -type random\n\n# Edge cases with solvable ends\n./gen -n 2 -k 50 -type solvable_ends\n./gen -n 3 -k 50 -type solvable_ends\n\n# Mix of various types\n./gen -n 50 -k 25 -type random\n./gen -n 50 -k 25 -type alternating\n./gen -n 50 -k 25 -type only_left_solvable\n./gen -n 50 -k 25 -type only_right_solvable\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:24.132402",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "999/B",
      "title": "B. Reversing Encryption",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input consists of a single integer nn (1≤n≤1001≤n≤100) — the length of the string tt. The second line of input consists of the string tt. The length of tt is nn, and it consists only of lowercase Latin letters.",
      "output_spec": "OutputPrint a string ss such that the above algorithm results in tt.",
      "sample_tests": "ExamplesInputCopy10rocesfedocOutputCopycodeforcesInputCopy16plmaetwoxesisihtOutputCopythisisexampletwoInputCopy1zOutputCopyz",
      "description": "B. Reversing Encryption\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input consists of a single integer nn (1≤n≤1001≤n≤100) — the length of the string tt. The second line of input consists of the string tt. The length of tt is nn, and it consists only of lowercase Latin letters.\n\nOutputPrint a string ss such that the above algorithm results in tt.\n\nInputCopy10rocesfedocOutputCopycodeforcesInputCopy16plmaetwoxesisihtOutputCopythisisexampletwoInputCopy1zOutputCopyz\n\nInputCopy10rocesfedoc\n\nOutputCopycodeforces\n\nInputCopy16plmaetwoxesisiht\n\nOutputCopythisisexampletwo\n\nInputCopy1z\n\nOutputCopyz\n\nNoteThe first example is described in the problem statement.",
      "solutions": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Hello!Codeforces Round 490 (Div. 3) will start on June 21 (Thursday) at 14:35 (UTC). You will be offered 6 problems with expected difficulties to compose an interesting competition for participants with ratings up to 1600. Probably, participants from the first division will not be at all interested by this problems. And for 1600-1899 the problems will be too easy. However, all of you who wish to take part and have rating 1600 or higher, can register for the round unofficially.The round will be hosted by rules of educational rounds (extended ACM-ICPC). Thus, during the round, solutions will be judged on preliminary tests, and after the round it will be a 12-hour phase of open hacks. I tried to make strong tests — just like you will be upset if many solutions fail after the contest is over.You will be given 6 problems and 2 hours to solve them.Remember that only the trusted participants of the third division will be included in the official standings table. As it is written by link, this is a compulsory measure for combating unsporting behavior. To qualify as a trusted participants of the third division, you must: take part in at least two rated rounds (and solve at least one problem in each of them), do not have a point of 1900 or higher in the rating. Regardless of whether you are a trusted participant of the third division or not, if your rating is less than 1600, then the round will be rated for you.Thanks to MikeMirzayanov for the platform, help with ideas for problems and for coordination of my work. Thanks to Mikhail awoo Piklyaev, Maksim Neon Mescheryakov and Ivan BledDest Androsov for help in round preparation and testing the round.Good luck!UPD: Also great thanks to step_by_step, kevinsogo and nhho for help in round preparation and testing the round.UPD2: The results table!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 EricHuang2003 6 150 2 JerryKFC 6 151 3 Lovely_qgq 6 170 4 Meroeht 6 181 5 MYTH_vs_REALiTY 6 209 Congratulations to the best hackers: Rank Competitor Hack Count 1 djm03178 30:-2 2 2014CAIS01 13:-3 3 quailty 5:-2 4 Harmonium_Wale 4:-2 5 kimden 2 110 successful hacks and 226 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A jh05013 0:01 B JerryKFC 0:02 C GrayGlobe 0:03 D T______________T 0:21 E NamikazeBoruto 0:11 F Counting_Stars 0:20 UPD3: Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60096",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2416
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces",
          "content": "I'm really sorry for the issue with the problem D difficulty, it was much harder than i expected, and there was a big difficulty gap between problems C and D. I hope in the next rounds it will never happen again.UPD: I'd like to say a big thanks to kevinsogo for the great help with tutorials and the round preparation in general.999A - Mishka and Contest Tutorial999A - Mishka and ContestYou can iterate over all the elements of the array from left to right. Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one. Let's denote the number of problems Mishka will solve from the left end of the list by lflf. Do the same thing independently from right to left. Denote the number of problems Mishka will solve from the right end of the list by rgrg. Then the answer is min(n,lf+rg)min(n,lf+rg).Time complexity — O(n)O(n). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999B - Reversing Encryption Tutorial999B - Reversing EncryptionTo solve the problem, we can implement the encryption algorithm with a single change: we have to iterate over all divisors of nn in increasing order.Time complexity — O(n ⋅d(n))O(n ⋅d(n)), where d(n)d(n) is a divisor count function for nn. For example, maxi=1106d(i)=240maxi=1106d(i)=240. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\n\treturn 0;\n}999C - Alphabetic Removals Tutorial999C - Alphabetic RemovalsLet the lowercase Latin letters be indexed from 00 to 2525.There are exists at least two different solutions:If k=nk=n exit the program. Otherwise, count the number of occurrences of each letter ii from 00 to 2525. Let it be cntcnt. Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all ii from 00 to 2525, and if cnti≤kcnti≤k then subtract it from kk, otherwise, ii will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than ii will not appear in the resulting string. Also, the kk leftmost occurrences of letter ii will be removed. Now, let's iterate over all letters in string ss from left to right and construct the resulting string resres. If the current character of ss (let it be sjsj) is smaller than ii, then do nothing. If sjsj is greater than ii, then add it to resres. Otherwise sj=isj=i. If k>0k>0, then decrease kk by one, otherwise, add sjsj to resres. The time complexity is O(n)O(n).Another solution is the following. Let's carry the vector of pairs (si,i)(si,i) where sisi is the ii-th character of ss and ii is its position. If we sort this vector with the standard compare function, it is easy to see that the first kk elements of this vector will be removed from the input string. Then if we will sort the last n−kn−k elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is O(nlogn)O(nlog⁡n). Solution 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Solution 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\n\treturn 0;\n}999D - Equalize the Remainders Tutorial999D - Equalize the RemaindersFor each ii from 00 to m−1m−1, find all elements of the array that are congruent to ii modulo mm, and store their indices in a list. Also, create a vector called freefree, and let kk be nmnm.We have to cycle from 00 to m−1m−1 twice. For each ii from 00 to m−1m−1, if there are in list too many (i.e., >k>k) elements congruent to ii modulo mm, remove the extra elements from this list and add them to freefree. If instead there are too few (i.e., <k<k) elements congruent to ii modulo mm, remove the last few elements from the vector freefree. For every removed index idxidx, increase aidxaidx by (i−aidx)modm(i−aidx)modm. After doing so (after two passes), we print the total increase and the updated array.It is obvious that after the first mm iterations, every list will have size at most kk, and after mm more iterations, all lists will have the same sizes. It can be easily proved that this algorithm produces an optimal answer.The time complexity is O(n+m)O(n+m). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}999E - Reachability from the Capital Tutorial999E - Reachability from the CapitalThis problem is (almost) equivalent to the following: count the number of sources (the vertices with indegree equal to 00) in the given graph's condensation. Thus, there exist solutions with complexity O(n+m)O(n+m). However, the constraints in the problem are small, so solutions with complexity O(n⋅m)O(n⋅m) also pass.One of these solutions is the following: first, let's mark all the vertices reachable from ss as good, using a simple DFS. Then, for each bad vertex vv, count the number of bad vertices reachable from vv (it also can be done by simple DFS). Let this number be cntvcntv. Now, iterate over all bad vertices in non-increasing order of cntvcntv. For the current bad vertex vv, if it is still not marked as good, run a DFS from it, marking all the reachable vertices as good, and increase the answer by 11 (in fact, we are implicitly adding the edge (s,v)(s,v)). It can be proved that this solution gives an optimal answer. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\n\tdfs1(s);\n\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Linear Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999F - Cards and Joy Tutorial999F - Cards and JoyIt is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number, and if the player gets a card not having his favorite number, his joy will not change.Let dp[x][y]dp[x][y] be the maximum possible total joy of xx players with the same favorite number (it doesn't matter which one) and yy cards (containing their favorite number) if the cards are distributed among the players optimally. Note that x∈[0,n]x∈[0,n] and y∈[0,k⋅n]y∈[0,k⋅n]. At the beginning, all entries of the dpdp table are zeroes. The transition in this dynamic programming depends on how many cards the xx-th player will receive (which is between 00 and kk). In other words, the dynamic programming transition will look like: for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),where h[i]h[i] is the joy of the player if he receives exactly ii cards containing his favorite number. Note that h[0]=0h[0]=0.After filling the dpdp table, the answer can be calculated very easily: ans=∑i=1105dp[fi][ci]ans=∑i=1105dp[fi][ci], where fifi is the number of players with favorite number ii and cici is the number of cards containing the number ii.Time complexity is O(n2⋅k2)O(n2⋅k2). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/60138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 999\\s*B"
          },
          "content_length": 12256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "(Correct me if i am wrong until this point)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "count all nodes with either indegree=0 or all strongly connected graphs with connected nodes more than 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "distribute m cards to 3 people while maximum the score",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "after the round it will be a 12-hour phase of open hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "anss=s[n-1-i]+anss;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "printf/cout",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "X = count(large[i]) - n / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "[i + 1, m - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "count < group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "count > group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "N = 8, M = 4, K = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 23",
          "code": "0 4 12 1 5 8 9 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 24",
          "code": "[4, 4, 0, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 25",
          "code": "i mod m = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 26",
          "code": "[2, 2, 2(from 1), 2(from 0)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 27",
          "code": "i mod m = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 28",
          "code": "[2, 2, 2(from 0), 2(from 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 29",
          "code": "[4, 0, 4, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 30",
          "code": "i mean just find connected component",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 31",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 32",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 33",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 34",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 35",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 36",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 37",
          "code": "H[0] = 0, H[1] = 2 , H[2] = 6, H[3] = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 38",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 39",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 40",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 41",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 42",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 43",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 44",
          "code": "map<int,bool> v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 45",
          "code": "bool v[5005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 46",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 47",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string t = inf.readLine(\"[a-z]{\" + toString(n) + \"}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string t = inf.readLine(\"[a-z]{\" + toString(n) + \"}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string t = inf.readLine(\"[a-z]{\" + toString(n) + \"}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring encrypt(string s) {\n    int n = s.size();\n    for(int d = n; d >= 1; d--) {\n        if (n % d == 0) {\n            reverse(s.begin(), s.begin() + d);\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    } else if (type == \"same_char\") {\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        s.resize(n);\n        for(int i = 0; i < (n+1)/2; ++i) {\n            s[i] = rnd.next('a', 'z');\n            s[n - i -1] = s[i];\n        }\n    } else if (type == \"increasing\") {\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'a' + (i % 26);\n        }\n    } else if (type == \"decreasing\") {\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'z' - (i % 26);\n        }\n    } else if (type == \"alternating\") {\n        char c1 = rnd.next('a', 'z');\n        char c2 = rnd.next('a', 'z');\n        while(c2 == c1) c2 = rnd.next('a', 'z');\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"repetitive\") {\n        int k = opt<int>(\"k\", 1);\n        if (k > n) k = n;\n        string sub;\n        sub.resize(k);\n        for(int i = 0; i < k; ++i) {\n            sub[i] = rnd.next('a', 'z');\n        }\n        s = \"\";\n        while((int)s.size() < n) {\n            s += sub;\n        }\n        s = s.substr(0,n);\n    } else {\n        // Default to random if unknown type\n        s.resize(n);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    }\n\n    string t = encrypt(s);\n\n    // Output n and t\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring encrypt(string s) {\n    int n = s.size();\n    for(int d = n; d >= 1; d--) {\n        if (n % d == 0) {\n            reverse(s.begin(), s.begin() + d);\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    } else if (type == \"same_char\") {\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        s.resize(n);\n        for(int i = 0; i < (n+1)/2; ++i) {\n            s[i] = rnd.next('a', 'z');\n            s[n - i -1] = s[i];\n        }\n    } else if (type == \"increasing\") {\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'a' + (i % 26);\n        }\n    } else if (type == \"decreasing\") {\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'z' - (i % 26);\n        }\n    } else if (type == \"alternating\") {\n        char c1 = rnd.next('a', 'z');\n        char c2 = rnd.next('a', 'z');\n        while(c2 == c1) c2 = rnd.next('a', 'z');\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"repetitive\") {\n        int k = opt<int>(\"k\", 1);\n        if (k > n) k = n;\n        string sub;\n        sub.resize(k);\n        for(int i = 0; i < k; ++i) {\n            sub[i] = rnd.next('a', 'z');\n        }\n        s = \"\";\n        while((int)s.size() < n) {\n            s += sub;\n        }\n        s = s.substr(0,n);\n    } else {\n        // Default to random if unknown type\n        s.resize(n);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n    }\n\n    string t = encrypt(s);\n\n    // Output n and t\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_char\n./gen -n 1 -type palindrome\n\n./gen -n 2 -type random\n./gen -n 2 -type palindrome\n./gen -n 2 -type same_char\n\n./gen -n 5 -type random\n./gen -n 5 -type palindrome\n./gen -n 5 -type decreasing\n\n./gen -n 6 -type repetitive -k 2\n./gen -n 6 -type repetitive -k 3\n./gen -n 6 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type palindrome\n./gen -n 10 -type increasing\n\n./gen -n 15 -type random\n./gen -n 15 -type repetitive -k 5\n\n./gen -n 20 -type same_char\n./gen -n 20 -type alternating\n\n./gen -n 50 -type random\n./gen -n 50 -type palindrome\n./gen -n 50 -type repetitive -k 5\n\n./gen -n 50 -type decreasing\n./gen -n 50 -type increasing\n\n./gen -n 75 -type random\n./gen -n 75 -type repetitive -k 1\n\n./gen -n 100 -type random\n./gen -n 100 -type palindrome\n./gen -n 100 -type same_char\n\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n./gen -n 100 -type repetitive -k 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:26.393762",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "999/C",
      "title": "C. Alphabetic Removals",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers nn and kk (1≤k≤n≤4⋅1051≤k≤n≤4⋅105) — the length of the string and the number of letters Polycarp will remove.The second line contains the string ss consisting of nn lowercase Latin letters.",
      "output_spec": "OutputPrint the string that will be obtained from ss after Polycarp removes exactly kk letters using the above algorithm kk times.If the resulting string is empty, print nothing. It is allowed to print nothing or an empty line (line break).",
      "sample_tests": "ExamplesInputCopy15 3cccaabababaccbcOutputCopycccbbabaccbcInputCopy15 9cccaabababaccbcOutputCopyccccccInputCopy1 1uOutputCopy",
      "description": "C. Alphabetic Removals\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers nn and kk (1≤k≤n≤4⋅1051≤k≤n≤4⋅105) — the length of the string and the number of letters Polycarp will remove.The second line contains the string ss consisting of nn lowercase Latin letters.\n\nOutputPrint the string that will be obtained from ss after Polycarp removes exactly kk letters using the above algorithm kk times.If the resulting string is empty, print nothing. It is allowed to print nothing or an empty line (line break).\n\nInputCopy15 3cccaabababaccbcOutputCopycccbbabaccbcInputCopy15 9cccaabababaccbcOutputCopyccccccInputCopy1 1uOutputCopy\n\nInputCopy15 3cccaabababaccbc\n\nOutputCopycccbbabaccbc\n\nInputCopy15 9cccaabababaccbc\n\nOutputCopycccccc\n\nInputCopy1 1u",
      "solutions": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Hello!Codeforces Round 490 (Div. 3) will start on June 21 (Thursday) at 14:35 (UTC). You will be offered 6 problems with expected difficulties to compose an interesting competition for participants with ratings up to 1600. Probably, participants from the first division will not be at all interested by this problems. And for 1600-1899 the problems will be too easy. However, all of you who wish to take part and have rating 1600 or higher, can register for the round unofficially.The round will be hosted by rules of educational rounds (extended ACM-ICPC). Thus, during the round, solutions will be judged on preliminary tests, and after the round it will be a 12-hour phase of open hacks. I tried to make strong tests — just like you will be upset if many solutions fail after the contest is over.You will be given 6 problems and 2 hours to solve them.Remember that only the trusted participants of the third division will be included in the official standings table. As it is written by link, this is a compulsory measure for combating unsporting behavior. To qualify as a trusted participants of the third division, you must: take part in at least two rated rounds (and solve at least one problem in each of them), do not have a point of 1900 or higher in the rating. Regardless of whether you are a trusted participant of the third division or not, if your rating is less than 1600, then the round will be rated for you.Thanks to MikeMirzayanov for the platform, help with ideas for problems and for coordination of my work. Thanks to Mikhail awoo Piklyaev, Maksim Neon Mescheryakov and Ivan BledDest Androsov for help in round preparation and testing the round.Good luck!UPD: Also great thanks to step_by_step, kevinsogo and nhho for help in round preparation and testing the round.UPD2: The results table!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 EricHuang2003 6 150 2 JerryKFC 6 151 3 Lovely_qgq 6 170 4 Meroeht 6 181 5 MYTH_vs_REALiTY 6 209 Congratulations to the best hackers: Rank Competitor Hack Count 1 djm03178 30:-2 2 2014CAIS01 13:-3 3 quailty 5:-2 4 Harmonium_Wale 4:-2 5 kimden 2 110 successful hacks and 226 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A jh05013 0:01 B JerryKFC 0:02 C GrayGlobe 0:03 D T______________T 0:21 E NamikazeBoruto 0:11 F Counting_Stars 0:20 UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60096",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2416
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces",
          "content": "I'm really sorry for the issue with the problem D difficulty, it was much harder than i expected, and there was a big difficulty gap between problems C and D. I hope in the next rounds it will never happen again.UPD: I'd like to say a big thanks to kevinsogo for the great help with tutorials and the round preparation in general.999A - Mishka and Contest Tutorial999A - Mishka and ContestYou can iterate over all the elements of the array from left to right. Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one. Let's denote the number of problems Mishka will solve from the left end of the list by lflf. Do the same thing independently from right to left. Denote the number of problems Mishka will solve from the right end of the list by rgrg. Then the answer is min(n,lf+rg)min(n,lf+rg).Time complexity — O(n)O(n). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999B - Reversing Encryption Tutorial999B - Reversing EncryptionTo solve the problem, we can implement the encryption algorithm with a single change: we have to iterate over all divisors of nn in increasing order.Time complexity — O(n ⋅d(n))O(n ⋅d(n)), where d(n)d(n) is a divisor count function for nn. For example, maxi=1106d(i)=240maxi=1106d(i)=240. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\n\treturn 0;\n}999C - Alphabetic Removals Tutorial999C - Alphabetic RemovalsLet the lowercase Latin letters be indexed from 00 to 2525.There are exists at least two different solutions:If k=nk=n exit the program. Otherwise, count the number of occurrences of each letter ii from 00 to 2525. Let it be cntcnt. Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all ii from 00 to 2525, and if cnti≤kcnti≤k then subtract it from kk, otherwise, ii will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than ii will not appear in the resulting string. Also, the kk leftmost occurrences of letter ii will be removed. Now, let's iterate over all letters in string ss from left to right and construct the resulting string resres. If the current character of ss (let it be sjsj) is smaller than ii, then do nothing. If sjsj is greater than ii, then add it to resres. Otherwise sj=isj=i. If k>0k>0, then decrease kk by one, otherwise, add sjsj to resres. The time complexity is O(n)O(n).Another solution is the following. Let's carry the vector of pairs (si,i)(si,i) where sisi is the ii-th character of ss and ii is its position. If we sort this vector with the standard compare function, it is easy to see that the first kk elements of this vector will be removed from the input string. Then if we will sort the last n−kn−k elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is O(nlogn)O(nlog⁡n). Solution 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Solution 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\n\treturn 0;\n}999D - Equalize the Remainders Tutorial999D - Equalize the RemaindersFor each ii from 00 to m−1m−1, find all elements of the array that are congruent to ii modulo mm, and store their indices in a list. Also, create a vector called freefree, and let kk be nmnm.We have to cycle from 00 to m−1m−1 twice. For each ii from 00 to m−1m−1, if there are in list too many (i.e., >k>k) elements congruent to ii modulo mm, remove the extra elements from this list and add them to freefree. If instead there are too few (i.e., <k<k) elements congruent to ii modulo mm, remove the last few elements from the vector freefree. For every removed index idxidx, increase aidxaidx by (i−aidx)modm(i−aidx)modm. After doing so (after two passes), we print the total increase and the updated array.It is obvious that after the first mm iterations, every list will have size at most kk, and after mm more iterations, all lists will have the same sizes. It can be easily proved that this algorithm produces an optimal answer.The time complexity is O(n+m)O(n+m). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}999E - Reachability from the Capital Tutorial999E - Reachability from the CapitalThis problem is (almost) equivalent to the following: count the number of sources (the vertices with indegree equal to 00) in the given graph's condensation. Thus, there exist solutions with complexity O(n+m)O(n+m). However, the constraints in the problem are small, so solutions with complexity O(n⋅m)O(n⋅m) also pass.One of these solutions is the following: first, let's mark all the vertices reachable from ss as good, using a simple DFS. Then, for each bad vertex vv, count the number of bad vertices reachable from vv (it also can be done by simple DFS). Let this number be cntvcntv. Now, iterate over all bad vertices in non-increasing order of cntvcntv. For the current bad vertex vv, if it is still not marked as good, run a DFS from it, marking all the reachable vertices as good, and increase the answer by 11 (in fact, we are implicitly adding the edge (s,v)(s,v)). It can be proved that this solution gives an optimal answer. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\n\tdfs1(s);\n\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Linear Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999F - Cards and Joy Tutorial999F - Cards and JoyIt is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number, and if the player gets a card not having his favorite number, his joy will not change.Let dp[x][y]dp[x][y] be the maximum possible total joy of xx players with the same favorite number (it doesn't matter which one) and yy cards (containing their favorite number) if the cards are distributed among the players optimally. Note that x∈[0,n]x∈[0,n] and y∈[0,k⋅n]y∈[0,k⋅n]. At the beginning, all entries of the dpdp table are zeroes. The transition in this dynamic programming depends on how many cards the xx-th player will receive (which is between 00 and kk). In other words, the dynamic programming transition will look like: for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),where h[i]h[i] is the joy of the player if he receives exactly ii cards containing his favorite number. Note that h[0]=0h[0]=0.After filling the dpdp table, the answer can be calculated very easily: ans=∑i=1105dp[fi][ci]ans=∑i=1105dp[fi][ci], where fifi is the number of players with favorite number ii and cici is the number of cards containing the number ii.Time complexity is O(n2⋅k2)O(n2⋅k2). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 999\\s*C"
          },
          "content_length": 12256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "(Correct me if i am wrong until this point)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "count all nodes with either indegree=0 or all strongly connected graphs with connected nodes more than 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "distribute m cards to 3 people while maximum the score",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "after the round it will be a 12-hour phase of open hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "anss=s[n-1-i]+anss;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "printf/cout",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "X = count(large[i]) - n / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "[i + 1, m - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "count < group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "count > group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "N = 8, M = 4, K = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 23",
          "code": "0 4 12 1 5 8 9 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 24",
          "code": "[4, 4, 0, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 25",
          "code": "i mod m = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 26",
          "code": "[2, 2, 2(from 1), 2(from 0)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 27",
          "code": "i mod m = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 28",
          "code": "[2, 2, 2(from 0), 2(from 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 29",
          "code": "[4, 0, 4, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 30",
          "code": "i mean just find connected component",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 31",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 32",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 33",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 34",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 35",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 36",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 37",
          "code": "H[0] = 0, H[1] = 2 , H[2] = 6, H[3] = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 38",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 39",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 40",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 41",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 42",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 43",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 44",
          "code": "map<int,bool> v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 45",
          "code": "bool v[5005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 46",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 47",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]{1,400000}\", \"s\");\n    ensuref(int(s.length()) == n, \"The length of s must be equal to n, but s.length()=%d and n=%d\", int(s.length()), n);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]{1,400000}\", \"s\");\n    ensuref(int(s.length()) == n, \"The length of s must be equal to n, but s.length()=%d and n=%d\", int(s.length()), n);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]{1,400000}\", \"s\");\n    ensuref(int(s.length()) == n, \"The length of s must be equal to n, but s.length()=%d and n=%d\", int(s.length()), n);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    // Validate constraints\n    if (n < 1 || n > 400000 || k < 1 || k > n) {\n        fprintf(stderr, \"Invalid parameters: n=%d, k=%d\\n\", n, k);\n        exit(1);\n    }\n    string s(n, 'a');\n    if (type == \"random\") {\n        // Random string of length n\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"all_same_letter\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"lex_order\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'a' + (i % 26);\n        }\n    } else if (type == \"reverse_lex_order\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'z' - (i % 26);\n        }\n    } else if (type == \"alternating_letters\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) s[i] = c1;\n            else s[i] = c2;\n        }\n    } else if (type == \"worst_case\") {\n        // Generate a string designed to be a worst case\n        // All letters are 'a' except for every 100th character is 'z'\n        char c1 = 'a';\n        char c2 = 'z';\n        for(int i = 0; i < n; ++i) {\n            if (i % 100 == 0)\n                s[i] = c2;\n            else\n                s[i] = c1;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    // Validate constraints\n    if (n < 1 || n > 400000 || k < 1 || k > n) {\n        fprintf(stderr, \"Invalid parameters: n=%d, k=%d\\n\", n, k);\n        exit(1);\n    }\n    string s(n, 'a');\n    if (type == \"random\") {\n        // Random string of length n\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"all_same_letter\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"lex_order\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'a' + (i % 26);\n        }\n    } else if (type == \"reverse_lex_order\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'z' - (i % 26);\n        }\n    } else if (type == \"alternating_letters\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) s[i] = c1;\n            else s[i] = c2;\n        }\n    } else if (type == \"worst_case\") {\n        // Generate a string designed to be a worst case\n        // All letters are 'a' except for every 100th character is 'z'\n        char c1 = 'a';\n        char c2 = 'z';\n        for(int i = 0; i < n; ++i) {\n            if (i % 100 == 0)\n                s[i] = c2;\n            else\n                s[i] = c1;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type all_same_letter\n./gen -n 1 -k 1 -type lex_order\n./gen -n 5 -k 3 -type random\n./gen -n 5 -k 3 -type all_same_letter\n./gen -n 5 -k 3 -type reverse_lex_order\n./gen -n 2 -k 1 -type alternating_letters\n./gen -n 2 -k 2 -type alternating_letters\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 10 -type random\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 100 -type all_same_letter\n./gen -n 1000 -k 1 -type lex_order\n./gen -n 1000 -k 500 -type reverse_lex_order\n./gen -n 1000 -k 1000 -type alternating_letters\n./gen -n 10000 -k 9999 -type worst_case\n./gen -n 10000 -k 1 -type worst_case\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 99999 -type all_same_letter\n./gen -n 100000 -k 100000 -type lex_order\n./gen -n 400000 -k 400000 -type random\n./gen -n 400000 -k 399999 -type reverse_lex_order\n./gen -n 400000 -k 1 -type alternating_letters\n./gen -n 400000 -k 200000 -type worst_case\n./gen -n 400000 -k 200001 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:28.262081",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "999/D",
      "title": "D. Equalize the Remainders",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers nn and mm (1≤n≤2⋅105,1≤m≤n1≤n≤2⋅105,1≤m≤n). It is guaranteed that mm is a divisor of nn.The second line of input contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤1090≤ai≤109), the elements of the array.",
      "output_spec": "OutputIn the first line, print a single integer — the minimum number of moves required to satisfy the following condition: for each remainder from 00 to m−1m−1, the number of elements of the array having this remainder equals nmnm.In the second line, print any array satisfying the condition and can be obtained from the given array with the minimum number of moves. The values of the elements of the resulting array must not exceed 10181018.",
      "sample_tests": "ExamplesInputCopy6 33 2 0 6 10 12OutputCopy33 2 0 7 10 14 InputCopy4 20 1 2 3OutputCopy00 1 2 3",
      "description": "D. Equalize the Remainders\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers nn and mm (1≤n≤2⋅105,1≤m≤n1≤n≤2⋅105,1≤m≤n). It is guaranteed that mm is a divisor of nn.The second line of input contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤1090≤ai≤109), the elements of the array.\n\nOutputIn the first line, print a single integer — the minimum number of moves required to satisfy the following condition: for each remainder from 00 to m−1m−1, the number of elements of the array having this remainder equals nmnm.In the second line, print any array satisfying the condition and can be obtained from the given array with the minimum number of moves. The values of the elements of the resulting array must not exceed 10181018.\n\nInputCopy6 33 2 0 6 10 12OutputCopy33 2 0 7 10 14 InputCopy4 20 1 2 3OutputCopy00 1 2 3\n\nInputCopy6 33 2 0 6 10 12\n\nOutputCopy33 2 0 7 10 14\n\nInputCopy4 20 1 2 3\n\nOutputCopy00 1 2 3",
      "solutions": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Hello!Codeforces Round 490 (Div. 3) will start on June 21 (Thursday) at 14:35 (UTC). You will be offered 6 problems with expected difficulties to compose an interesting competition for participants with ratings up to 1600. Probably, participants from the first division will not be at all interested by this problems. And for 1600-1899 the problems will be too easy. However, all of you who wish to take part and have rating 1600 or higher, can register for the round unofficially.The round will be hosted by rules of educational rounds (extended ACM-ICPC). Thus, during the round, solutions will be judged on preliminary tests, and after the round it will be a 12-hour phase of open hacks. I tried to make strong tests — just like you will be upset if many solutions fail after the contest is over.You will be given 6 problems and 2 hours to solve them.Remember that only the trusted participants of the third division will be included in the official standings table. As it is written by link, this is a compulsory measure for combating unsporting behavior. To qualify as a trusted participants of the third division, you must: take part in at least two rated rounds (and solve at least one problem in each of them), do not have a point of 1900 or higher in the rating. Regardless of whether you are a trusted participant of the third division or not, if your rating is less than 1600, then the round will be rated for you.Thanks to MikeMirzayanov for the platform, help with ideas for problems and for coordination of my work. Thanks to Mikhail awoo Piklyaev, Maksim Neon Mescheryakov and Ivan BledDest Androsov for help in round preparation and testing the round.Good luck!UPD: Also great thanks to step_by_step, kevinsogo and nhho for help in round preparation and testing the round.UPD2: The results table!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 EricHuang2003 6 150 2 JerryKFC 6 151 3 Lovely_qgq 6 170 4 Meroeht 6 181 5 MYTH_vs_REALiTY 6 209 Congratulations to the best hackers: Rank Competitor Hack Count 1 djm03178 30:-2 2 2014CAIS01 13:-3 3 quailty 5:-2 4 Harmonium_Wale 4:-2 5 kimden 2 110 successful hacks and 226 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A jh05013 0:01 B JerryKFC 0:02 C GrayGlobe 0:03 D T______________T 0:21 E NamikazeBoruto 0:11 F Counting_Stars 0:20 UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60096",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2416
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces",
          "content": "I'm really sorry for the issue with the problem D difficulty, it was much harder than i expected, and there was a big difficulty gap between problems C and D. I hope in the next rounds it will never happen again.UPD: I'd like to say a big thanks to kevinsogo for the great help with tutorials and the round preparation in general.999A - Mishka and Contest Tutorial999A - Mishka and ContestYou can iterate over all the elements of the array from left to right. Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one. Let's denote the number of problems Mishka will solve from the left end of the list by lflf. Do the same thing independently from right to left. Denote the number of problems Mishka will solve from the right end of the list by rgrg. Then the answer is min(n,lf+rg)min(n,lf+rg).Time complexity — O(n)O(n). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999B - Reversing Encryption Tutorial999B - Reversing EncryptionTo solve the problem, we can implement the encryption algorithm with a single change: we have to iterate over all divisors of nn in increasing order.Time complexity — O(n ⋅d(n))O(n ⋅d(n)), where d(n)d(n) is a divisor count function for nn. For example, maxi=1106d(i)=240maxi=1106d(i)=240. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\n\treturn 0;\n}999C - Alphabetic Removals Tutorial999C - Alphabetic RemovalsLet the lowercase Latin letters be indexed from 00 to 2525.There are exists at least two different solutions:If k=nk=n exit the program. Otherwise, count the number of occurrences of each letter ii from 00 to 2525. Let it be cntcnt. Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all ii from 00 to 2525, and if cnti≤kcnti≤k then subtract it from kk, otherwise, ii will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than ii will not appear in the resulting string. Also, the kk leftmost occurrences of letter ii will be removed. Now, let's iterate over all letters in string ss from left to right and construct the resulting string resres. If the current character of ss (let it be sjsj) is smaller than ii, then do nothing. If sjsj is greater than ii, then add it to resres. Otherwise sj=isj=i. If k>0k>0, then decrease kk by one, otherwise, add sjsj to resres. The time complexity is O(n)O(n).Another solution is the following. Let's carry the vector of pairs (si,i)(si,i) where sisi is the ii-th character of ss and ii is its position. If we sort this vector with the standard compare function, it is easy to see that the first kk elements of this vector will be removed from the input string. Then if we will sort the last n−kn−k elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is O(nlogn)O(nlog⁡n). Solution 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Solution 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\n\treturn 0;\n}999D - Equalize the Remainders Tutorial999D - Equalize the RemaindersFor each ii from 00 to m−1m−1, find all elements of the array that are congruent to ii modulo mm, and store their indices in a list. Also, create a vector called freefree, and let kk be nmnm.We have to cycle from 00 to m−1m−1 twice. For each ii from 00 to m−1m−1, if there are in list too many (i.e., >k>k) elements congruent to ii modulo mm, remove the extra elements from this list and add them to freefree. If instead there are too few (i.e., <k<k) elements congruent to ii modulo mm, remove the last few elements from the vector freefree. For every removed index idxidx, increase aidxaidx by (i−aidx)modm(i−aidx)modm. After doing so (after two passes), we print the total increase and the updated array.It is obvious that after the first mm iterations, every list will have size at most kk, and after mm more iterations, all lists will have the same sizes. It can be easily proved that this algorithm produces an optimal answer.The time complexity is O(n+m)O(n+m). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}999E - Reachability from the Capital Tutorial999E - Reachability from the CapitalThis problem is (almost) equivalent to the following: count the number of sources (the vertices with indegree equal to 00) in the given graph's condensation. Thus, there exist solutions with complexity O(n+m)O(n+m). However, the constraints in the problem are small, so solutions with complexity O(n⋅m)O(n⋅m) also pass.One of these solutions is the following: first, let's mark all the vertices reachable from ss as good, using a simple DFS. Then, for each bad vertex vv, count the number of bad vertices reachable from vv (it also can be done by simple DFS). Let this number be cntvcntv. Now, iterate over all bad vertices in non-increasing order of cntvcntv. For the current bad vertex vv, if it is still not marked as good, run a DFS from it, marking all the reachable vertices as good, and increase the answer by 11 (in fact, we are implicitly adding the edge (s,v)(s,v)). It can be proved that this solution gives an optimal answer. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\n\tdfs1(s);\n\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Linear Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999F - Cards and Joy Tutorial999F - Cards and JoyIt is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number, and if the player gets a card not having his favorite number, his joy will not change.Let dp[x][y]dp[x][y] be the maximum possible total joy of xx players with the same favorite number (it doesn't matter which one) and yy cards (containing their favorite number) if the cards are distributed among the players optimally. Note that x∈[0,n]x∈[0,n] and y∈[0,k⋅n]y∈[0,k⋅n]. At the beginning, all entries of the dpdp table are zeroes. The transition in this dynamic programming depends on how many cards the xx-th player will receive (which is between 00 and kk). In other words, the dynamic programming transition will look like: for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),where h[i]h[i] is the joy of the player if he receives exactly ii cards containing his favorite number. Note that h[0]=0h[0]=0.After filling the dpdp table, the answer can be calculated very easily: ans=∑i=1105dp[fi][ci]ans=∑i=1105dp[fi][ci], where fifi is the number of players with favorite number ii and cici is the number of cards containing the number ii.Time complexity is O(n2⋅k2)O(n2⋅k2). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 999\\s*D"
          },
          "content_length": 12256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "(Correct me if i am wrong until this point)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "count all nodes with either indegree=0 or all strongly connected graphs with connected nodes more than 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "distribute m cards to 3 people while maximum the score",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "after the round it will be a 12-hour phase of open hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "anss=s[n-1-i]+anss;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "printf/cout",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "X = count(large[i]) - n / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "[i + 1, m - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "count < group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "count > group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "N = 8, M = 4, K = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 23",
          "code": "0 4 12 1 5 8 9 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 24",
          "code": "[4, 4, 0, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 25",
          "code": "i mod m = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 26",
          "code": "[2, 2, 2(from 1), 2(from 0)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 27",
          "code": "i mod m = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 28",
          "code": "[2, 2, 2(from 0), 2(from 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 29",
          "code": "[4, 0, 4, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 30",
          "code": "i mean just find connected component",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 31",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 32",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 33",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 34",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 35",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 36",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 37",
          "code": "H[0] = 0, H[1] = 2 , H[2] = 6, H[3] = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 38",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 39",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 40",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 41",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 42",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 43",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 44",
          "code": "map<int,bool> v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 45",
          "code": "bool v[5005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 46",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 47",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    ensuref(n % m == 0, \"m (%d) must divide n (%d)\", m, n);\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    ensuref(n % m == 0, \"m (%d) must divide n (%d)\", m, n);\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n    ensuref(n % m == 0, \"m (%d) must divide n (%d)\", m, n);\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const long long MAX_VAL = 1000000000000000000LL; // 1e18\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n, m from input (test file)\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    // Read the original array\n    vector<long long> orig(n);\n    for (int i = 0; i < n; i++) {\n        orig[i] = inf.readLong();\n    }\n\n    // Function to read and validate an answer (jury or participant). \n    // It returns the declared number of moves.\n    auto readAnswer = [&](InStream& stream) -> long long\n    {\n        // 1) Read the declared number of moves:\n        long long moves = stream.readLong(0LL, LLONG_MAX, \"declared number of moves\");\n\n        // 2) Read exactly n array elements:\n        vector<long long> arr(n);\n        for (int i = 0; i < n; i++) {\n            arr[i] = stream.readLong(0LL, MAX_VAL,\n                                     (\"arr[\" + to_string(i + 1) + \"]\").c_str());\n        }\n\n        // 3) Skip trailing blanks (if any):\n        stream.skipBlanks();\n\n        // 4) If there's still data, read one extra token:\n        if (!stream.seekEof()) {\n            string leftover = stream.readWord();\n            // Must be \".\" if present\n            if (leftover != \".\") {\n                stream.quitf(_wa, \"unexpected trailing token \\\"%s\\\"\", leftover.c_str());\n            }\n            // Skip any new whitespace after reading \".\"\n            stream.skipBlanks();\n            // If still not EOF, that's invalid\n            if (!stream.seekEof()) {\n                stream.quitf(_wa, \"extra data after the trailing dot\");\n            }\n        }\n\n        // 5) Check sum of increments and distribution:\n\n        // Ensure the new array is not smaller than original\n        long long sumDiff = 0;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] < orig[i]) {\n                stream.quitf(_wa,\n                             \"element %d is smaller than original: orig=%lld, new=%lld\",\n                             i + 1, orig[i], arr[i]);\n            }\n            sumDiff += (arr[i] - orig[i]);\n            if (sumDiff < 0) {\n                // Should not happen if we only do increments\n                stream.quitf(_fail, \"negative total increment (overflow or logic error)\");\n            }\n        }\n        // The sum of those increments must match the declared moves\n        if (sumDiff != moves) {\n            stream.quitf(_wa, \n                         \"declared moves = %lld, but actual increments = %lld\",\n                         moves, sumDiff);\n        }\n\n        // Check remainder distribution\n        vector<int> freq(m, 0);\n        for (long long val : arr) {\n            freq[val % m]++;\n        }\n        for (int r = 0; r < m; r++) {\n            if (freq[r] != n / m) {\n                stream.quitf(_wa,\n                             \"invalid remainder distribution: remainder %d appears %d times, expected %d\",\n                             r, freq[r], n / m);\n            }\n        }\n\n        return moves;\n    };\n\n    // Read jury's (correct) answer\n    long long jans = readAnswer(ans);\n    // Read participant's answer\n    long long pans = readAnswer(ouf);\n\n    // Compare answers\n    if (pans > jans) {\n        quitf(_wa, \"participant used more moves (%lld) than jury's solution (%lld)\",\n              pans, jans);\n    } else if (pans < jans) {\n        // It's unusual for participant to do better than jury in a typical setup\n        quitf(_fail, \"participant found a better solution (%lld) than jury's (%lld)\",\n              pans, jans);\n    } else {\n        quitf(_ok, \"correct solution with %lld moves\", pans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long max_a = opt<long long>(\"max_a\", 1000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m divides n\n    assert(1 <= n && n <= 200000);\n    assert(1 <= m && m <= n);\n    assert(n % m == 0);\n    assert(0 <= max_a && max_a <= 1000000000000000000LL);\n\n    vector<long long> a(n);\n\n    if (type == \"random\") {\n        // Random array with elements between 0 and max_a\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, max_a);\n        }\n    } else if (type == \"same\") {\n        // All elements are the same\n        long long val = rnd.next(0LL, max_a);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"already_balanced\") {\n        // Generate an array where c_0 = c_1 = ... = c_{m-1} = n/m\n        int count_per_remainder = n / m;\n        vector<int> remainders;\n        for (int r = 0; r < m; ++r) {\n            for (int c = 0; c < count_per_remainder; ++c) {\n                remainders.push_back(r);\n            }\n        }\n        shuffle(remainders.begin(), remainders.end());\n        for (int i = 0; i < n; ++i) {\n            long long base = rnd.next(0LL, max_a / m) * m;\n            a[i] = base + remainders[i];\n        }\n    } else if (type == \"max_moves\") {\n        // All elements have the same remainder\n        int remainder = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, max_a / m) * m + remainder;\n        }\n        // Adjust n/m elements to have different remainders\n        int count_per_remainder = n / m;\n        int idx = 0;\n        for (int r = 0; r < m; ++r) {\n            if (r != remainder) {\n                for (int c = 0; c < count_per_remainder; ++c) {\n                    a[idx] = a[idx] - remainder + r;\n                    idx++;\n                }\n            }\n        }\n    } else if (type == \"min_moves\") {\n        // Minimal moves (possibly zero)\n        int count_per_remainder = n / m;\n        vector<int> remainders;\n        for (int r = 0; r < m; ++r) {\n            for (int c = 0; c < count_per_remainder; ++c) {\n                remainders.push_back(r);\n            }\n        }\n        shuffle(remainders.begin(), remainders.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = remainders[i];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, max_a);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long max_a = opt<long long>(\"max_a\", 1000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m divides n\n    assert(1 <= n && n <= 200000);\n    assert(1 <= m && m <= n);\n    assert(n % m == 0);\n    assert(0 <= max_a && max_a <= 1000000000000000000LL);\n\n    vector<long long> a(n);\n\n    if (type == \"random\") {\n        // Random array with elements between 0 and max_a\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, max_a);\n        }\n    } else if (type == \"same\") {\n        // All elements are the same\n        long long val = rnd.next(0LL, max_a);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"already_balanced\") {\n        // Generate an array where c_0 = c_1 = ... = c_{m-1} = n/m\n        int count_per_remainder = n / m;\n        vector<int> remainders;\n        for (int r = 0; r < m; ++r) {\n            for (int c = 0; c < count_per_remainder; ++c) {\n                remainders.push_back(r);\n            }\n        }\n        shuffle(remainders.begin(), remainders.end());\n        for (int i = 0; i < n; ++i) {\n            long long base = rnd.next(0LL, max_a / m) * m;\n            a[i] = base + remainders[i];\n        }\n    } else if (type == \"max_moves\") {\n        // All elements have the same remainder\n        int remainder = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, max_a / m) * m + remainder;\n        }\n        // Adjust n/m elements to have different remainders\n        int count_per_remainder = n / m;\n        int idx = 0;\n        for (int r = 0; r < m; ++r) {\n            if (r != remainder) {\n                for (int c = 0; c < count_per_remainder; ++c) {\n                    a[idx] = a[idx] - remainder + r;\n                    idx++;\n                }\n            }\n        }\n    } else if (type == \"min_moves\") {\n        // Minimal moves (possibly zero)\n        int count_per_remainder = n / m;\n        vector<int> remainders;\n        for (int r = 0; r < m; ++r) {\n            for (int c = 0; c < count_per_remainder; ++c) {\n                remainders.push_back(r);\n            }\n        }\n        shuffle(remainders.begin(), remainders.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = remainders[i];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, max_a);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 2 -m 1 -type same\n./gen -n 2 -m 2 -type already_balanced\n./gen -n 5 -m 5 -type min_moves\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type min_moves\n./gen -n 10 -m 5 -type max_moves\n./gen -n 100 -m 10 -type random\n./gen -n 100 -m 10 -type same\n./gen -n 100 -m 10 -type already_balanced\n./gen -n 100 -m 10 -type max_moves\n./gen -n 1000 -m 100 -type random\n./gen -n 1000 -m 100 -type same\n./gen -n 1000 -m 100 -type min_moves\n./gen -n 10000 -m 1000 -type random\n./gen -n 10000 -m 1000 -type max_moves\n./gen -n 100000 -m 10000 -type random\n./gen -n 100000 -m 10000 -type same\n./gen -n 100000 -m 10000 -type already_balanced\n./gen -n 200000 -m 1 -type random\n./gen -n 200000 -m 200000 -type max_moves\n./gen -n 200000 -m 2 -type random\n./gen -n 200000 -m 100000 -type same\n./gen -n 200000 -m 100000 -type already_balanced\n./gen -n 200000 -m 100000 -type min_moves\n./gen -n 200000 -m 1 -type min_moves\n./gen -n 200000 -m 2 -type max_moves\n./gen -n 200000 -m 200000 -type min_moves\n./gen -n 199998 -m 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:30.396233",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "999/E",
      "title": "E. Reachability from the Capital",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input consists of three integers nn, mm and ss (1≤n≤5000,0≤m≤5000,1≤s≤n1≤n≤5000,0≤m≤5000,1≤s≤n) — the number of cities, the number of roads and the index of the capital. Cities are indexed from 11 to nn.The following mm lines contain roads: road ii is given as a pair of cities uiui, vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi). For each pair of cities (u,v)(u,v), there can be at most one road from uu to vv. Roads in opposite directions between a pair of cities are allowed (i.e. from uu to vv and from vv to uu).",
      "output_spec": "OutputPrint one integer — the minimum number of extra roads needed to make all the cities reachable from city ss. If all the cities are already reachable from ss, print 0.",
      "sample_tests": "ExamplesInputCopy9 9 11 21 32 31 55 66 11 89 87 1OutputCopy3InputCopy5 4 51 22 33 44 1OutputCopy1",
      "description": "E. Reachability from the Capital\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input consists of three integers nn, mm and ss (1≤n≤5000,0≤m≤5000,1≤s≤n1≤n≤5000,0≤m≤5000,1≤s≤n) — the number of cities, the number of roads and the index of the capital. Cities are indexed from 11 to nn.The following mm lines contain roads: road ii is given as a pair of cities uiui, vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi). For each pair of cities (u,v)(u,v), there can be at most one road from uu to vv. Roads in opposite directions between a pair of cities are allowed (i.e. from uu to vv and from vv to uu).\n\nOutputPrint one integer — the minimum number of extra roads needed to make all the cities reachable from city ss. If all the cities are already reachable from ss, print 0.\n\nInputCopy9 9 11 21 32 31 55 66 11 89 87 1OutputCopy3InputCopy5 4 51 22 33 44 1OutputCopy1\n\nInputCopy9 9 11 21 32 31 55 66 11 89 87 1\n\nOutputCopy3\n\nInputCopy5 4 51 22 33 44 1\n\nOutputCopy1\n\nNoteThe first example is illustrated by the following:  For example, you can add roads (6,46,4), (7,97,9), (1,71,7) to make all the cities reachable from s=1s=1.The second example is illustrated by the following:  In this example, you can add any one of the roads (5,15,1), (5,25,2), (5,35,3), (5,45,4) to make all the cities reachable from s=5s=5.",
      "solutions": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Hello!Codeforces Round 490 (Div. 3) will start on June 21 (Thursday) at 14:35 (UTC). You will be offered 6 problems with expected difficulties to compose an interesting competition for participants with ratings up to 1600. Probably, participants from the first division will not be at all interested by this problems. And for 1600-1899 the problems will be too easy. However, all of you who wish to take part and have rating 1600 or higher, can register for the round unofficially.The round will be hosted by rules of educational rounds (extended ACM-ICPC). Thus, during the round, solutions will be judged on preliminary tests, and after the round it will be a 12-hour phase of open hacks. I tried to make strong tests — just like you will be upset if many solutions fail after the contest is over.You will be given 6 problems and 2 hours to solve them.Remember that only the trusted participants of the third division will be included in the official standings table. As it is written by link, this is a compulsory measure for combating unsporting behavior. To qualify as a trusted participants of the third division, you must: take part in at least two rated rounds (and solve at least one problem in each of them), do not have a point of 1900 or higher in the rating. Regardless of whether you are a trusted participant of the third division or not, if your rating is less than 1600, then the round will be rated for you.Thanks to MikeMirzayanov for the platform, help with ideas for problems and for coordination of my work. Thanks to Mikhail awoo Piklyaev, Maksim Neon Mescheryakov and Ivan BledDest Androsov for help in round preparation and testing the round.Good luck!UPD: Also great thanks to step_by_step, kevinsogo and nhho for help in round preparation and testing the round.UPD2: The results table!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 EricHuang2003 6 150 2 JerryKFC 6 151 3 Lovely_qgq 6 170 4 Meroeht 6 181 5 MYTH_vs_REALiTY 6 209 Congratulations to the best hackers: Rank Competitor Hack Count 1 djm03178 30:-2 2 2014CAIS01 13:-3 3 quailty 5:-2 4 Harmonium_Wale 4:-2 5 kimden 2 110 successful hacks and 226 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A jh05013 0:01 B JerryKFC 0:02 C GrayGlobe 0:03 D T______________T 0:21 E NamikazeBoruto 0:11 F Counting_Stars 0:20 UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60096",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2416
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces",
          "content": "I'm really sorry for the issue with the problem D difficulty, it was much harder than i expected, and there was a big difficulty gap between problems C and D. I hope in the next rounds it will never happen again.UPD: I'd like to say a big thanks to kevinsogo for the great help with tutorials and the round preparation in general.999A - Mishka and Contest Tutorial999A - Mishka and ContestYou can iterate over all the elements of the array from left to right. Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one. Let's denote the number of problems Mishka will solve from the left end of the list by lflf. Do the same thing independently from right to left. Denote the number of problems Mishka will solve from the right end of the list by rgrg. Then the answer is min(n,lf+rg)min(n,lf+rg).Time complexity — O(n)O(n). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999B - Reversing Encryption Tutorial999B - Reversing EncryptionTo solve the problem, we can implement the encryption algorithm with a single change: we have to iterate over all divisors of nn in increasing order.Time complexity — O(n ⋅d(n))O(n ⋅d(n)), where d(n)d(n) is a divisor count function for nn. For example, maxi=1106d(i)=240maxi=1106d(i)=240. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\n\treturn 0;\n}999C - Alphabetic Removals Tutorial999C - Alphabetic RemovalsLet the lowercase Latin letters be indexed from 00 to 2525.There are exists at least two different solutions:If k=nk=n exit the program. Otherwise, count the number of occurrences of each letter ii from 00 to 2525. Let it be cntcnt. Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all ii from 00 to 2525, and if cnti≤kcnti≤k then subtract it from kk, otherwise, ii will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than ii will not appear in the resulting string. Also, the kk leftmost occurrences of letter ii will be removed. Now, let's iterate over all letters in string ss from left to right and construct the resulting string resres. If the current character of ss (let it be sjsj) is smaller than ii, then do nothing. If sjsj is greater than ii, then add it to resres. Otherwise sj=isj=i. If k>0k>0, then decrease kk by one, otherwise, add sjsj to resres. The time complexity is O(n)O(n).Another solution is the following. Let's carry the vector of pairs (si,i)(si,i) where sisi is the ii-th character of ss and ii is its position. If we sort this vector with the standard compare function, it is easy to see that the first kk elements of this vector will be removed from the input string. Then if we will sort the last n−kn−k elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is O(nlogn)O(nlog⁡n). Solution 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Solution 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\n\treturn 0;\n}999D - Equalize the Remainders Tutorial999D - Equalize the RemaindersFor each ii from 00 to m−1m−1, find all elements of the array that are congruent to ii modulo mm, and store their indices in a list. Also, create a vector called freefree, and let kk be nmnm.We have to cycle from 00 to m−1m−1 twice. For each ii from 00 to m−1m−1, if there are in list too many (i.e., >k>k) elements congruent to ii modulo mm, remove the extra elements from this list and add them to freefree. If instead there are too few (i.e., <k<k) elements congruent to ii modulo mm, remove the last few elements from the vector freefree. For every removed index idxidx, increase aidxaidx by (i−aidx)modm(i−aidx)modm. After doing so (after two passes), we print the total increase and the updated array.It is obvious that after the first mm iterations, every list will have size at most kk, and after mm more iterations, all lists will have the same sizes. It can be easily proved that this algorithm produces an optimal answer.The time complexity is O(n+m)O(n+m). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}999E - Reachability from the Capital Tutorial999E - Reachability from the CapitalThis problem is (almost) equivalent to the following: count the number of sources (the vertices with indegree equal to 00) in the given graph's condensation. Thus, there exist solutions with complexity O(n+m)O(n+m). However, the constraints in the problem are small, so solutions with complexity O(n⋅m)O(n⋅m) also pass.One of these solutions is the following: first, let's mark all the vertices reachable from ss as good, using a simple DFS. Then, for each bad vertex vv, count the number of bad vertices reachable from vv (it also can be done by simple DFS). Let this number be cntvcntv. Now, iterate over all bad vertices in non-increasing order of cntvcntv. For the current bad vertex vv, if it is still not marked as good, run a DFS from it, marking all the reachable vertices as good, and increase the answer by 11 (in fact, we are implicitly adding the edge (s,v)(s,v)). It can be proved that this solution gives an optimal answer. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\n\tdfs1(s);\n\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Linear Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999F - Cards and Joy Tutorial999F - Cards and JoyIt is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number, and if the player gets a card not having his favorite number, his joy will not change.Let dp[x][y]dp[x][y] be the maximum possible total joy of xx players with the same favorite number (it doesn't matter which one) and yy cards (containing their favorite number) if the cards are distributed among the players optimally. Note that x∈[0,n]x∈[0,n] and y∈[0,k⋅n]y∈[0,k⋅n]. At the beginning, all entries of the dpdp table are zeroes. The transition in this dynamic programming depends on how many cards the xx-th player will receive (which is between 00 and kk). In other words, the dynamic programming transition will look like: for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),where h[i]h[i] is the joy of the player if he receives exactly ii cards containing his favorite number. Note that h[0]=0h[0]=0.After filling the dpdp table, the answer can be calculated very easily: ans=∑i=1105dp[fi][ci]ans=∑i=1105dp[fi][ci], where fifi is the number of players with favorite number ii and cici is the number of cards containing the number ii.Time complexity is O(n2⋅k2)O(n2⋅k2). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 999\\s*E"
          },
          "content_length": 12256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "(Correct me if i am wrong until this point)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "count all nodes with either indegree=0 or all strongly connected graphs with connected nodes more than 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "distribute m cards to 3 people while maximum the score",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "after the round it will be a 12-hour phase of open hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "anss=s[n-1-i]+anss;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "printf/cout",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "X = count(large[i]) - n / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "[i + 1, m - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "count < group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "count > group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "N = 8, M = 4, K = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 23",
          "code": "0 4 12 1 5 8 9 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 24",
          "code": "[4, 4, 0, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 25",
          "code": "i mod m = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 26",
          "code": "[2, 2, 2(from 1), 2(from 0)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 27",
          "code": "i mod m = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 28",
          "code": "[2, 2, 2(from 0), 2(from 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 29",
          "code": "[4, 0, 4, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 30",
          "code": "i mean just find connected component",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 31",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 32",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 33",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 34",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 35",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 36",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 37",
          "code": "H[0] = 0, H[1] = 2 , H[2] = 6, H[3] = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 38",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 39",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 40",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 41",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 42",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 43",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 44",
          "code": "map<int,bool> v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 45",
          "code": "bool v[5005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 46",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 47",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 5000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"u_i should not be equal to v_i\");\n        inf.readEoln();\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge found from %d to %d\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 5000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"u_i should not be equal to v_i\");\n        inf.readEoln();\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge found from %d to %d\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 5000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"u_i should not be equal to v_i\");\n        inf.readEoln();\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge found from %d to %d\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (s == -1)\n        s = rnd.next(1, n);\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"random\") {\n        // Random graph\n        int max_edges = n * (n - 1); // Maximum possible number of edges without self-loops\n        if (m == -1)\n            m = rnd.next(0, min(max_edges, 5000));\n\n        m = min(m, min(max_edges, 5000));\n\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v)\n                continue;\n            pair<int,int> edge(u, v);\n            if (edge_set.count(edge))\n                continue;\n            edge_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } \n    else if (type == \"complete\") {\n        // Complete graph\n        int max_edges = n * (n - 1); // Number of possible edges without self-loops\n        m = min(max_edges, 5000);\n        for (int u = 1; u <= n && (int)edges.size() < m; ++u) {\n            for (int v = 1; v <= n && (int)edges.size() < m; ++v) {\n                if (u != v) {\n                    edges.push_back({u, v});\n                }\n            }\n        }\n    }\n    else if (type == \"no_edges\") {\n        // No edges\n        m = 0;\n    }\n    else if (type == \"chain\") {\n        // Build a chain from 1 to n\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    }\n    else if (type == \"star\") {\n        // Build from s to all others\n        m = n - 1;\n        for (int v = 1; v <= n; ++v) {\n            if (v != s)\n                edges.push_back({s, v});\n        }\n    }\n    else if (type == \"scc\") {\n        // Build a strongly connected component\n        m = n;\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"disconnected\") {\n        // Build multiple components not connected to s\n        int components = opt<int>(\"components\", 2);\n        components = max(1, min(components, n));\n        vector<vector<int>> comp_nodes(components);\n        for (int i = 1; i <= n; ++i) {\n            comp_nodes[(i - 1) % components].push_back(i);\n        }\n        m = 0;\n        for (int c = 0; c < components; ++c) {\n            int size = comp_nodes[c].size();\n            if (size > 1) {\n                for (int i = 0; i < size - 1; ++i) {\n                    edges.push_back({comp_nodes[c][i], comp_nodes[c][i + 1]});\n                    ++m;\n                }\n            }\n        }\n    }\n    else if (type == \"tree\") {\n        // Build a tree rooted at s\n        m = n - 1;\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i)\n            if (i != s)\n                nodes.push_back(i);\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = nodes[i];\n            int v = (i == 0) ? s : nodes[rnd.next(0, i - 1)];\n            edges.push_back({v, u});\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n m s\n    printf(\"%d %d %d\\n\", n, m, s);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (s == -1)\n        s = rnd.next(1, n);\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"random\") {\n        // Random graph\n        int max_edges = n * (n - 1); // Maximum possible number of edges without self-loops\n        if (m == -1)\n            m = rnd.next(0, min(max_edges, 5000));\n\n        m = min(m, min(max_edges, 5000));\n\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v)\n                continue;\n            pair<int,int> edge(u, v);\n            if (edge_set.count(edge))\n                continue;\n            edge_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } \n    else if (type == \"complete\") {\n        // Complete graph\n        int max_edges = n * (n - 1); // Number of possible edges without self-loops\n        m = min(max_edges, 5000);\n        for (int u = 1; u <= n && (int)edges.size() < m; ++u) {\n            for (int v = 1; v <= n && (int)edges.size() < m; ++v) {\n                if (u != v) {\n                    edges.push_back({u, v});\n                }\n            }\n        }\n    }\n    else if (type == \"no_edges\") {\n        // No edges\n        m = 0;\n    }\n    else if (type == \"chain\") {\n        // Build a chain from 1 to n\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    }\n    else if (type == \"star\") {\n        // Build from s to all others\n        m = n - 1;\n        for (int v = 1; v <= n; ++v) {\n            if (v != s)\n                edges.push_back({s, v});\n        }\n    }\n    else if (type == \"scc\") {\n        // Build a strongly connected component\n        m = n;\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"disconnected\") {\n        // Build multiple components not connected to s\n        int components = opt<int>(\"components\", 2);\n        components = max(1, min(components, n));\n        vector<vector<int>> comp_nodes(components);\n        for (int i = 1; i <= n; ++i) {\n            comp_nodes[(i - 1) % components].push_back(i);\n        }\n        m = 0;\n        for (int c = 0; c < components; ++c) {\n            int size = comp_nodes[c].size();\n            if (size > 1) {\n                for (int i = 0; i < size - 1; ++i) {\n                    edges.push_back({comp_nodes[c][i], comp_nodes[c][i + 1]});\n                    ++m;\n                }\n            }\n        }\n    }\n    else if (type == \"tree\") {\n        // Build a tree rooted at s\n        m = n - 1;\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i)\n            if (i != s)\n                nodes.push_back(i);\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = nodes[i];\n            int v = (i == 0) ? s : nodes[rnd.next(0, i - 1)];\n            edges.push_back({v, u});\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n m s\n    printf(\"%d %d %d\\n\", n, m, s);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type no_edges\n\n./gen -n 5 -type no_edges\n\n./gen -n 10 -type chain -s 1\n\n./gen -n 10 -type chain -s 10\n\n./gen -n 10 -type star -s 5\n\n./gen -n 10 -type scc\n\n./gen -n 10 -type disconnected -components 2\n\n./gen -n 10 -type disconnected -components 5\n\n./gen -n 10 -type tree -s 1\n\n./gen -n 10 -type tree -s 10\n\n./gen -n 100 -type random\n\n./gen -n 100 -type random -m 0\n\n./gen -n 100 -type random -m 5000\n\n./gen -n 100 -type scc\n\n./gen -n 1000 -type random\n\n./gen -n 5000 -type random\n\n./gen -n 5000 -type random -m 0\n\n./gen -n 5000 -type random -m 5000\n\n./gen -n 5000 -type chain\n\n./gen -n 5000 -type star -s 5000\n\n./gen -n 5000 -type scc\n\n./gen -n 5000 -type tree -s 1\n\n./gen -n 5000 -type disconnected -components 2\n\n./gen -n 5000 -type disconnected -components 500\n\n./gen -n 5000 -type disconnected -components 5000\n\n./gen -n 4999 -type complete\n\n./gen -n 5000 -type complete\n\n./gen -n 5000 -type random -m 1\n\n./gen -n 5000 -type random -m 4999\n\n./gen -n 5000 -type random -m 5000\n\n./gen -n 5000 -type random -s 5000 -m 0\n\n./gen -n 5000 -type random -s 1 -m 0\n\n./gen -n 5000 -type chain -s 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:32.460043",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "999/F",
      "title": "F. Cards and Joy",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers nn and kk (1≤n≤500,1≤k≤101≤n≤500,1≤k≤10) — the number of players and the number of cards each player will get.The second line contains k⋅nk⋅n integers c1,c2,…,ck⋅nc1,c2,…,ck⋅n (1≤ci≤1051≤ci≤105) — the numbers written on the cards.The third line contains nn integers f1,f2,…,fnf1,f2,…,fn (1≤fj≤1051≤fj≤105) — the favorite numbers of the players.The fourth line contains kk integers h1,h2,…,hkh1,h2,…,hk (1≤ht≤1051≤ht≤105), where htht is the joy level of a player if he gets exactly tt cards with his favorite number written on them. It is guaranteed that the condition ht−1<htht−1<ht holds for each t∈[2..k]t∈[2..k].",
      "output_spec": "OutputPrint one integer — the maximum possible total joy levels of the players among all possible card distributions.",
      "sample_tests": "ExamplesInputCopy4 31 3 2 8 5 5 8 2 2 8 5 21 2 2 52 6 7OutputCopy21InputCopy3 39 9 9 9 9 9 9 9 91 2 31 2 3OutputCopy0",
      "description": "F. Cards and Joy\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers nn and kk (1≤n≤500,1≤k≤101≤n≤500,1≤k≤10) — the number of players and the number of cards each player will get.The second line contains k⋅nk⋅n integers c1,c2,…,ck⋅nc1,c2,…,ck⋅n (1≤ci≤1051≤ci≤105) — the numbers written on the cards.The third line contains nn integers f1,f2,…,fnf1,f2,…,fn (1≤fj≤1051≤fj≤105) — the favorite numbers of the players.The fourth line contains kk integers h1,h2,…,hkh1,h2,…,hk (1≤ht≤1051≤ht≤105), where htht is the joy level of a player if he gets exactly tt cards with his favorite number written on them. It is guaranteed that the condition ht−1<htht−1<ht holds for each t∈[2..k]t∈[2..k].\n\nOutputPrint one integer — the maximum possible total joy levels of the players among all possible card distributions.\n\nInputCopy4 31 3 2 8 5 5 8 2 2 8 5 21 2 2 52 6 7OutputCopy21InputCopy3 39 9 9 9 9 9 9 9 91 2 31 2 3OutputCopy0\n\nInputCopy4 31 3 2 8 5 5 8 2 2 8 5 21 2 2 52 6 7\n\nOutputCopy21\n\nInputCopy3 39 9 9 9 9 9 9 9 91 2 31 2 3\n\nOutputCopy0\n\nNoteIn the first example, one possible optimal card distribution is the following:  Player 11 gets cards with numbers [1,3,8][1,3,8];  Player 22 gets cards with numbers [2,2,8][2,2,8];  Player 33 gets cards with numbers [2,2,8][2,2,8];  Player 44 gets cards with numbers [5,5,5][5,5,5]. Thus, the answer is 2+6+6+7=212+6+6+7=21.In the second example, no player can get a card with his favorite number. Thus, the answer is 00.",
      "solutions": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces",
          "content": "Hello!Codeforces Round 490 (Div. 3) will start on June 21 (Thursday) at 14:35 (UTC). You will be offered 6 problems with expected difficulties to compose an interesting competition for participants with ratings up to 1600. Probably, participants from the first division will not be at all interested by this problems. And for 1600-1899 the problems will be too easy. However, all of you who wish to take part and have rating 1600 or higher, can register for the round unofficially.The round will be hosted by rules of educational rounds (extended ACM-ICPC). Thus, during the round, solutions will be judged on preliminary tests, and after the round it will be a 12-hour phase of open hacks. I tried to make strong tests — just like you will be upset if many solutions fail after the contest is over.You will be given 6 problems and 2 hours to solve them.Remember that only the trusted participants of the third division will be included in the official standings table. As it is written by link, this is a compulsory measure for combating unsporting behavior. To qualify as a trusted participants of the third division, you must: take part in at least two rated rounds (and solve at least one problem in each of them), do not have a point of 1900 or higher in the rating. Regardless of whether you are a trusted participant of the third division or not, if your rating is less than 1600, then the round will be rated for you.Thanks to MikeMirzayanov for the platform, help with ideas for problems and for coordination of my work. Thanks to Mikhail awoo Piklyaev, Maksim Neon Mescheryakov and Ivan BledDest Androsov for help in round preparation and testing the round.Good luck!UPD: Also great thanks to step_by_step, kevinsogo and nhho for help in round preparation and testing the round.UPD2: The results table!Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 EricHuang2003 6 150 2 JerryKFC 6 151 3 Lovely_qgq 6 170 4 Meroeht 6 181 5 MYTH_vs_REALiTY 6 209 Congratulations to the best hackers: Rank Competitor Hack Count 1 djm03178 30:-2 2 2014CAIS01 13:-3 3 quailty 5:-2 4 Harmonium_Wale 4:-2 5 kimden 2 110 successful hacks and 226 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A jh05013 0:01 B JerryKFC 0:02 C GrayGlobe 0:03 D T______________T 0:21 E NamikazeBoruto 0:11 F Counting_Stars 0:20 UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60096",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2416
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces",
          "content": "I'm really sorry for the issue with the problem D difficulty, it was much harder than i expected, and there was a big difficulty gap between problems C and D. I hope in the next rounds it will never happen again.UPD: I'd like to say a big thanks to kevinsogo for the great help with tutorials and the round preparation in general.999A - Mishka and Contest Tutorial999A - Mishka and ContestYou can iterate over all the elements of the array from left to right. Count the number of problems Mishka will solve from the left end of the list and break if he cannot solve the next one. Let's denote the number of problems Mishka will solve from the left end of the list by lflf. Do the same thing independently from right to left. Denote the number of problems Mishka will solve from the right end of the list by rgrg. Then the answer is min(n,lf+rg)min(n,lf+rg).Time complexity — O(n)O(n). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999B - Reversing Encryption Tutorial999B - Reversing EncryptionTo solve the problem, we can implement the encryption algorithm with a single change: we have to iterate over all divisors of nn in increasing order.Time complexity — O(n ⋅d(n))O(n ⋅d(n)), where d(n)d(n) is a divisor count function for nn. For example, maxi=1106d(i)=240maxi=1106d(i)=240. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\n\treturn 0;\n}999C - Alphabetic Removals Tutorial999C - Alphabetic RemovalsLet the lowercase Latin letters be indexed from 00 to 2525.There are exists at least two different solutions:If k=nk=n exit the program. Otherwise, count the number of occurrences of each letter ii from 00 to 2525. Let it be cntcnt. Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all ii from 00 to 2525, and if cnti≤kcnti≤k then subtract it from kk, otherwise, ii will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than ii will not appear in the resulting string. Also, the kk leftmost occurrences of letter ii will be removed. Now, let's iterate over all letters in string ss from left to right and construct the resulting string resres. If the current character of ss (let it be sjsj) is smaller than ii, then do nothing. If sjsj is greater than ii, then add it to resres. Otherwise sj=isj=i. If k>0k>0, then decrease kk by one, otherwise, add sjsj to resres. The time complexity is O(n)O(n).Another solution is the following. Let's carry the vector of pairs (si,i)(si,i) where sisi is the ii-th character of ss and ii is its position. If we sort this vector with the standard compare function, it is easy to see that the first kk elements of this vector will be removed from the input string. Then if we will sort the last n−kn−k elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is O(nlogn)O(nlog⁡n). Solution 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Solution 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\n\treturn 0;\n}999D - Equalize the Remainders Tutorial999D - Equalize the RemaindersFor each ii from 00 to m−1m−1, find all elements of the array that are congruent to ii modulo mm, and store their indices in a list. Also, create a vector called freefree, and let kk be nmnm.We have to cycle from 00 to m−1m−1 twice. For each ii from 00 to m−1m−1, if there are in list too many (i.e., >k>k) elements congruent to ii modulo mm, remove the extra elements from this list and add them to freefree. If instead there are too few (i.e., <k<k) elements congruent to ii modulo mm, remove the last few elements from the vector freefree. For every removed index idxidx, increase aidxaidx by (i−aidx)modm(i−aidx)modm. After doing so (after two passes), we print the total increase and the updated array.It is obvious that after the first mm iterations, every list will have size at most kk, and after mm more iterations, all lists will have the same sizes. It can be easily proved that this algorithm produces an optimal answer.The time complexity is O(n+m)O(n+m). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}999E - Reachability from the Capital Tutorial999E - Reachability from the CapitalThis problem is (almost) equivalent to the following: count the number of sources (the vertices with indegree equal to 00) in the given graph's condensation. Thus, there exist solutions with complexity O(n+m)O(n+m). However, the constraints in the problem are small, so solutions with complexity O(n⋅m)O(n⋅m) also pass.One of these solutions is the following: first, let's mark all the vertices reachable from ss as good, using a simple DFS. Then, for each bad vertex vv, count the number of bad vertices reachable from vv (it also can be done by simple DFS). Let this number be cntvcntv. Now, iterate over all bad vertices in non-increasing order of cntvcntv. For the current bad vertex vv, if it is still not marked as good, run a DFS from it, marking all the reachable vertices as good, and increase the answer by 11 (in fact, we are implicitly adding the edge (s,v)(s,v)). It can be proved that this solution gives an optimal answer. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\n\tdfs1(s);\n\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n} Linear Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}999F - Cards and Joy Tutorial999F - Cards and JoyIt is obvious that we can solve the problem separately for each favorite number because each player has only one favorite number, and if the player gets a card not having his favorite number, his joy will not change.Let dp[x][y]dp[x][y] be the maximum possible total joy of xx players with the same favorite number (it doesn't matter which one) and yy cards (containing their favorite number) if the cards are distributed among the players optimally. Note that x∈[0,n]x∈[0,n] and y∈[0,k⋅n]y∈[0,k⋅n]. At the beginning, all entries of the dpdp table are zeroes. The transition in this dynamic programming depends on how many cards the xx-th player will receive (which is between 00 and kk). In other words, the dynamic programming transition will look like: for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),where h[i]h[i] is the joy of the player if he receives exactly ii cards containing his favorite number. Note that h[0]=0h[0]=0.After filling the dpdp table, the answer can be calculated very easily: ans=∑i=1105dp[fi][ci]ans=∑i=1105dp[fi][ci], where fifi is the number of players with favorite number ii and cici is the number of cards containing the number ii.Time complexity is O(n2⋅k2)O(n2⋅k2). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/60138",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 999\\s*F"
          },
          "content_length": 12256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 1",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 2",
          "code": "Div-3 rocks. I think you will add some critical test cases.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 3",
          "code": "(Correct me if i am wrong until this point)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 4",
          "code": "count all nodes with either indegree=0 or all strongly connected graphs with connected nodes more than 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 5",
          "code": "distribute m cards to 3 people while maximum the score",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 6",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 7",
          "code": "check this test\n8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7\n\nthe answer is 2\nin your approach the answer will be 3 as i think ,is it ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 8",
          "code": "after the round it will be a 12-hour phase of open hacks",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 9",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 10",
          "code": "200000 200000\n200000 199999 199998 199997 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 11",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 12",
          "code": "s1[r--]=s[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 13",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 14",
          "code": "s1[r] = s[i];\nr--;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 15",
          "code": "anss=s[n-1-i]+anss;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 16",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 17",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 18",
          "code": "printf/cout",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 19",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 20",
          "code": "6 3\n3 2 0 6 10 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 21",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 22",
          "code": "3\n13 8 0 3 10 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 23",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 24",
          "code": "8 7 1\n2 3\n2 4\n2 5\n2 6\n7 4\n7 5\n8 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 25",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) - Codeforces - Code 26",
          "code": "if(vis[node[s1[i]]!=s&& \n   vis[node[s1][i]]!=s1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60096",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tint ans = 0;\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\treverse(a.begin(), a.end());\n\twhile (!a.empty() && a.back() <= k) {\n\t\t++ans;\n\t\ta.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\treverse(s.begin(), s.begin() + i);\n\t\t}\n\t}\n\tcout << s << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tint k = n / m;\n\tvector<int> a(n);\n\tvector<vector<int>> val(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tval[a[i] % m].push_back(i);\n\t}\n\t\n\tlong long ans = 0;\n\tvector<pair<int, int>> fre;\n\tfor (int i = 0; i < 2 * m; ++i) {\n\t\tint cur = i % m;\n\t\twhile (int(val[cur].size()) > k) {\n\t\t\tint elem = val[cur].back();\n\t\t\tval[cur].pop_back();\n\t\t\tfre.push_back(make_pair(elem, i));\n\t\t}\n\t\twhile (int(val[cur].size()) < k && !fre.empty()) {\n\t\t\tint elem = fre.back().first;\n\t\t\tint mmod = fre.back().second;\n\t\t\tfre.pop_back();\n\t\t\tval[cur].push_back(elem);\n\t\t\ta[elem] += i - mmod;\n\t\t\tans += i - mmod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nbool used[N];\nbool ok[N];\n\nint cnt;\n\nvoid dfs1(int v) {\n\tok[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!ok[to])\n\t\t\tdfs1(to);\n}\n\nvoid dfs2(int v) {\n\tused[v] = true;\n\t++cnt;\n\tfor (auto to : g[v])\n\t\tif (!used[to] && !ok[to])\n\t\t\tdfs2(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t}\n\t\n\tdfs1(s);\n\t\n\tvector<pair<int, int>> val;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!ok[i]) {\n\t\t\tcnt = 0;\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tdfs2(i);\n\t\t\tval.push_back(make_pair(cnt, i));\n\t\t}\n\t}\n\tsort(val.begin(), val.end());\n\treverse(val.begin(), val.end());\n\t\n\tint ans = 0;\n\tfor (auto it : val) {\n\t\tif (!ok[it.second]) {\n\t\t\t++ans;\n\t\t\tdfs1(it.second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5010;\n\nint n, m, s;\nvector<int> g[N];\nvector<int> tg[N];\nvector<int> cg[N];\nvector<int> ord;\nint indeg[N];\nbool ucomp[N];\nbool used[N];\nint comp[N];\nint cnt;\n\nvoid dfs1(int v) {\n\tused[v] = true;\n\tfor (auto to : g[v])\n\t\tif (!used[to])\n\t\t\tdfs1(to);\n\tord.push_back(v);\n}\n\nvoid dfs2(int v) {\n\tcomp[v] = cnt;\n\tfor (auto to : tg[v])\n\t\tif (comp[to] == -1)\n\t\t\tdfs2(to);\n}\n\nvoid dfs3(int v) {\n\tucomp[v] = true;\n\tfor (auto to : cg[v])\n\t\tif (!ucomp[to])\n\t\t\tdfs3(to);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> m >> s;\n\t--s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\ttg[y].push_back(x);\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\tmemset(comp, -1, sizeof(comp));\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (comp[ord[i]] == -1) {\n\t\t\tdfs2(ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; ++v) {\n\t\tfor (auto to : g[v]) {\n\t\t\tif (comp[v] != comp[to]) {\n\t\t\t\tcg[comp[v]].push_back(comp[to]);\n\t\t\t\t++indeg[comp[to]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs3(comp[s]);\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; ++i)\n\t\tif (!ucomp[i] && indeg[i] == 0)\n\t\t\t++ans;\n\t\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] + h[i]),",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 520;\nconst int K = 12;\nconst int C = 100 * 1000 + 11;\n\nint n, k;\nint c[C];\nint f[C];\nvector<int> h;\n\nint dp[N][K * N];\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n >> k;\n\th = vector<int>(k + 1);\n\tfor (int i = 0; i < n * k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++c[x];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++f[x];\n\t}\n\tfor (int i = 1; i <= k; ++i)\n\t\tcin >> h[i];\n\t\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n * k; ++j) {\n\t\t\tfor (int cur = 0; cur <= k; ++cur) {\n\t\t\t\tdp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < C; ++i) {\n\t\tif (f[i] != 0) ans += dp[f[i]][c[i]];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "X = count(large[i]) - n / m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "[i + 1, m - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "count < group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "count > group size(k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "N = 8, M = 4, K = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 23",
          "code": "0 4 12 1 5 8 9 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 24",
          "code": "[4, 4, 0, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 25",
          "code": "i mod m = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 26",
          "code": "[2, 2, 2(from 1), 2(from 0)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 27",
          "code": "i mod m = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 28",
          "code": "[2, 2, 2(from 0), 2(from 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 29",
          "code": "[4, 0, 4, 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 30",
          "code": "i mean just find connected component",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 31",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 32",
          "code": "4 2 4\n1 2\n3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 33",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 34",
          "code": "4 3 1\n2 3\n3 2\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 35",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 36",
          "code": "for(int i=0;i<n;i++)\n    if(!visited1[i])\n    {\n        for(int ind=0;ind<n;ind++)\n            visited2[ind]=false;\n        _dfs(graph,visited2,i,i);\n        for(int ind=0;ind<n;ind++)\n            if(visited2[ind])\n                visited1[ind]=true;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 37",
          "code": "H[0] = 0, H[1] = 2 , H[2] = 6, H[3] = 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 38",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 39",
          "code": "4 5 1\n1 2\n2 1\n3 4\n4 3\n2 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 40",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 41",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[5002];\nbool vis[5002];\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n}\nstack<int> stk;\nvoid dfs2(int u)\n{\n    vis[u]=1;\n    for(int v:g[u]) if(!vis[v])\n        dfs(v);\n    stk.push(u);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);\n    //freopen(\"in.txt\", \"r\", stdin);\n    int n, e, s;\n    cin>>n>>e>>s;\n    for(int i = 1;i<=e;i++)\n    {\n        int u, v;\n        cin>>u>>v;\n        g[u].push_back(v);\n    }\n    dfs(s);\n    for(int i = 1;i<=n;i++) \n        if(vis[i]==0) dfs2(i);\n    \n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    while(!stk.empty())\n    {\n        int u = stk.top(); stk.pop();\n        if(!vis[u])\n        {\n            cnt++;\n            dfs(u);\n        }\n    }\n    cout << cnt;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 42",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 43",
          "code": "for(ll u : adj[s]){\n\tif(visited[s])\tcontinue;//it should be v[u]\n\tif(v[s]) continue;//it should be v[u]\n\tnei++;\n\tv[s]=true;//it should be v[u]\n\tQ.push(u);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 44",
          "code": "map<int,bool> v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 45",
          "code": "bool v[5005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 46",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #490 (Div. 3) Editorial - Codeforces - Code 47",
          "code": "10 5\n0 5 10 2 7 12 3 4 9 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/60138",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and k\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    \n    // Read c_i\n    int total_c = n * k;\n    vector<int> c = inf.readInts(total_c, 1, 100000, \"c_i\");\n    inf.readEoln();\n    \n    // Read f_j\n    vector<int> f = inf.readInts(n, 1, 100000, \"f_j\");\n    inf.readEoln();\n    \n    // Read h_t\n    vector<int> h = inf.readInts(k, 1, 100000, \"h_t\");\n    inf.readEoln();\n    \n    // Check that h_t sequence is strictly increasing\n    for (int t = 1; t < k; ++t) {\n        ensuref(h[t - 1] < h[t], \"h[%d]=%d should be less than h[%d]=%d\", t, h[t -1], t+1, h[t]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and k\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    \n    // Read c_i\n    int total_c = n * k;\n    vector<int> c = inf.readInts(total_c, 1, 100000, \"c_i\");\n    inf.readEoln();\n    \n    // Read f_j\n    vector<int> f = inf.readInts(n, 1, 100000, \"f_j\");\n    inf.readEoln();\n    \n    // Read h_t\n    vector<int> h = inf.readInts(k, 1, 100000, \"h_t\");\n    inf.readEoln();\n    \n    // Check that h_t sequence is strictly increasing\n    for (int t = 1; t < k; ++t) {\n        ensuref(h[t - 1] < h[t], \"h[%d]=%d should be less than h[%d]=%d\", t, h[t -1], t+1, h[t]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and k\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    \n    // Read c_i\n    int total_c = n * k;\n    vector<int> c = inf.readInts(total_c, 1, 100000, \"c_i\");\n    inf.readEoln();\n    \n    // Read f_j\n    vector<int> f = inf.readInts(n, 1, 100000, \"f_j\");\n    inf.readEoln();\n    \n    // Read h_t\n    vector<int> h = inf.readInts(k, 1, 100000, \"h_t\");\n    inf.readEoln();\n    \n    // Check that h_t sequence is strictly increasing\n    for (int t = 1; t < k; ++t) {\n        ensuref(h[t - 1] < h[t], \"h[%d]=%d should be less than h[%d]=%d\", t, h[t -1], t+1, h[t]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string ctype = opt<string>(\"ctype\", \"random\");\n    string ftype = opt<string>(\"ftype\", \"random\");\n    string htype = opt<string>(\"htype\", \"random_increasing\");\n\n    const int MAX_C = 100000;\n    const int MAX_F = 100000;\n    const int MAX_H = 100000;\n\n    // Generate f_j (favorite numbers)\n    vector<int> f_j(n);\n    if (ftype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = rnd.next(1, MAX_F);\n        }\n    } else if (ftype == \"same\") {\n        int fav = rnd.next(1, MAX_F);\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = fav;\n        }\n    } else if (ftype == \"sequential\") {\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = i + 1;\n        }\n    } else if (ftype == \"limited\") {\n        int m = opt<int>(\"fm\", 5); // Number of unique favorite numbers\n        vector<int> fav_numbers;\n        for (int i = 0; i < m; ++i) {\n            fav_numbers.push_back(rnd.next(1, MAX_F));\n        }\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = fav_numbers[rnd.next(0, m - 1)];\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = rnd.next(1, MAX_F);\n        }\n    }\n\n    // Generate c_i (cards)\n    int total_cards = n * k;\n    vector<int> c_i(total_cards);\n    if (ctype == \"random\") {\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = rnd.next(1, MAX_C);\n        }\n    } else if (ctype == \"same\") {\n        int card_num = rnd.next(1, MAX_C);\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = card_num;\n        }\n    } else if (ctype == \"favorites\") {\n        // Fill cards with favorite numbers of players\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = f_j[rnd.next(0, n - 1)];\n        }\n    } else if (ctype == \"nofavorites\") {\n        // Ensure c_i are not equal to any f_j\n        set<int> fav_set(f_j.begin(), f_j.end());\n        for (int i = 0; i < total_cards; ++i) {\n            do {\n                c_i[i] = rnd.next(1, MAX_C);\n            } while (fav_set.count(c_i[i]));\n        }\n    } else if (ctype == \"big\") {\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = rnd.next(MAX_C - n, MAX_C);\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = rnd.next(1, MAX_C);\n        }\n    }\n\n    // Generate h_t\n    vector<int> h_t(k + 1); // h_t[1..k]\n    if (htype == \"random_increasing\") {\n        h_t[1] = rnd.next(1, MAX_H / k);\n        for (int t = 2; t <= k; ++t) {\n            h_t[t] = h_t[t - 1] + rnd.next(1, MAX_H / k);\n        }\n    } else if (htype == \"linear\") {\n        int h0 = rnd.next(1, MAX_H / k);\n        for (int t = 1; t <= k; ++t) {\n            h_t[t] = h0 * t;\n        }\n    } else if (htype == \"constant\") {\n        int h0 = rnd.next(1, MAX_H - k);\n        for (int t = 1; t <= k; ++t) {\n            h_t[t] = h0 + t; // Ensure h_t increases\n        }\n    } else if (htype == \"max\") {\n        h_t[1] = MAX_H - k + 1;\n        for (int t = 2; t <= k; ++t) {\n            h_t[t] = h_t[t - 1] + 1;\n        }\n    } else {\n        // Default random_increasing\n        h_t[1] = rnd.next(1, MAX_H / k);\n        for (int t = 2; t <= k; ++t) {\n            h_t[t] = h_t[t - 1] + rnd.next(1, MAX_H / k);\n        }\n    }\n\n    // Output\n\n    // First line: n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Second line: c_1 .. c_{k*n}\n    for (int i = 0; i < total_cards; ++i) {\n        printf(\"%d%c\", c_i[i], (i + 1 == total_cards) ? '\\n' : ' ');\n    }\n\n    // Third line: f_1 .. f_n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", f_j[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    // Fourth line: h_1 .. h_k\n    for (int t = 1; t <= k; ++t) {\n        printf(\"%d%c\", h_t[t], (t == k) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string ctype = opt<string>(\"ctype\", \"random\");\n    string ftype = opt<string>(\"ftype\", \"random\");\n    string htype = opt<string>(\"htype\", \"random_increasing\");\n\n    const int MAX_C = 100000;\n    const int MAX_F = 100000;\n    const int MAX_H = 100000;\n\n    // Generate f_j (favorite numbers)\n    vector<int> f_j(n);\n    if (ftype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = rnd.next(1, MAX_F);\n        }\n    } else if (ftype == \"same\") {\n        int fav = rnd.next(1, MAX_F);\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = fav;\n        }\n    } else if (ftype == \"sequential\") {\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = i + 1;\n        }\n    } else if (ftype == \"limited\") {\n        int m = opt<int>(\"fm\", 5); // Number of unique favorite numbers\n        vector<int> fav_numbers;\n        for (int i = 0; i < m; ++i) {\n            fav_numbers.push_back(rnd.next(1, MAX_F));\n        }\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = fav_numbers[rnd.next(0, m - 1)];\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            f_j[i] = rnd.next(1, MAX_F);\n        }\n    }\n\n    // Generate c_i (cards)\n    int total_cards = n * k;\n    vector<int> c_i(total_cards);\n    if (ctype == \"random\") {\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = rnd.next(1, MAX_C);\n        }\n    } else if (ctype == \"same\") {\n        int card_num = rnd.next(1, MAX_C);\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = card_num;\n        }\n    } else if (ctype == \"favorites\") {\n        // Fill cards with favorite numbers of players\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = f_j[rnd.next(0, n - 1)];\n        }\n    } else if (ctype == \"nofavorites\") {\n        // Ensure c_i are not equal to any f_j\n        set<int> fav_set(f_j.begin(), f_j.end());\n        for (int i = 0; i < total_cards; ++i) {\n            do {\n                c_i[i] = rnd.next(1, MAX_C);\n            } while (fav_set.count(c_i[i]));\n        }\n    } else if (ctype == \"big\") {\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = rnd.next(MAX_C - n, MAX_C);\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < total_cards; ++i) {\n            c_i[i] = rnd.next(1, MAX_C);\n        }\n    }\n\n    // Generate h_t\n    vector<int> h_t(k + 1); // h_t[1..k]\n    if (htype == \"random_increasing\") {\n        h_t[1] = rnd.next(1, MAX_H / k);\n        for (int t = 2; t <= k; ++t) {\n            h_t[t] = h_t[t - 1] + rnd.next(1, MAX_H / k);\n        }\n    } else if (htype == \"linear\") {\n        int h0 = rnd.next(1, MAX_H / k);\n        for (int t = 1; t <= k; ++t) {\n            h_t[t] = h0 * t;\n        }\n    } else if (htype == \"constant\") {\n        int h0 = rnd.next(1, MAX_H - k);\n        for (int t = 1; t <= k; ++t) {\n            h_t[t] = h0 + t; // Ensure h_t increases\n        }\n    } else if (htype == \"max\") {\n        h_t[1] = MAX_H - k + 1;\n        for (int t = 2; t <= k; ++t) {\n            h_t[t] = h_t[t - 1] + 1;\n        }\n    } else {\n        // Default random_increasing\n        h_t[1] = rnd.next(1, MAX_H / k);\n        for (int t = 2; t <= k; ++t) {\n            h_t[t] = h_t[t - 1] + rnd.next(1, MAX_H / k);\n        }\n    }\n\n    // Output\n\n    // First line: n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Second line: c_1 .. c_{k*n}\n    for (int i = 0; i < total_cards; ++i) {\n        printf(\"%d%c\", c_i[i], (i + 1 == total_cards) ? '\\n' : ' ');\n    }\n\n    // Third line: f_1 .. f_n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", f_j[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    // Fourth line: h_1 .. h_k\n    for (int t = 1; t <= k; ++t) {\n        printf(\"%d%c\", h_t[t], (t == k) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest possible input\n./gen -n 1 -k 1 -ctype random -ftype random -htype random_increasing\n\n# Small inputs with different types\n./gen -n 2 -k 1 -ctype same -ftype same -htype linear\n./gen -n 2 -k 2 -ctype favorites -ftype sequential -htype constant\n./gen -n 3 -k 2 -ctype nofavorites -ftype random -htype random_increasing\n\n# Medium inputs\n./gen -n 50 -k 5 -ctype random -ftype random -htype random_increasing\n./gen -n 100 -k 10 -ctype big -ftype same -htype linear\n./gen -n 100 -k 5 -ctype favorites -ftype limited -fm 2 -htype random_increasing\n./gen -n 100 -k 5 -ctype nofavorites -ftype limited -fm 5 -htype constant\n\n# Maximum n with small k\n./gen -n 500 -k 1 -ctype random -ftype random -htype random_increasing\n./gen -n 500 -k 2 -ctype same -ftype same -htype linear\n./gen -n 500 -k 5 -ctype big -ftype random -htype constant\n\n# Maximum n and k\n./gen -n 500 -k 10 -ctype random -ftype sequential -htype random_increasing\n./gen -n 500 -k 10 -ctype random -ftype random -htype max\n\n# Special cases\n./gen -n 10 -k 10 -ctype favorites -ftype same -htype linear\n./gen -n 10 -k 10 -ctype nofavorites -ftype same -htype linear\n./gen -n 100 -k 10 -ctype same -ftype same -htype constant\n./gen -n 100 -k 10 -ctype same -ftype random -htype random_increasing\n\n# Edge cases\n./gen -n 1 -k 10 -ctype big -ftype same -htype constant\n./gen -n 500 -k 10 -ctype nofavorites -ftype same -htype random_increasing\n\n# Random tests\n./gen -n 200 -k 5 -ctype random -ftype random -htype linear\n./gen -n 250 -k 6 -ctype random -ftype random -htype random_increasing\n./gen -n 300 -k 7 -ctype random -ftype random -htype constant\n\n# Tests where no joy can be gained\n./gen -n 100 -k 5 -ctype nofavorites -ftype random -htype random_increasing\n\n# Tests where maximum joy can be gained\n./gen -n 100 -k 5 -ctype favorites -ftype random -htype random_increasing\n\n# Tests with limited favorite numbers, potential conflicts\n./gen -n 200 -k 5 -ctype random -ftype limited -fm 1 -htype random_increasing\n./gen -n 200 -k 5 -ctype random -ftype limited -fm 2 -htype random_increasing\n./gen -n 200 -k 5 -ctype random -ftype limited -fm 5 -htype random_increasing\n\n# Tests with h_t values at maximum\n./gen -n 100 -k 10 -ctype random -ftype random -htype max\n\n# Additional random tests\n./gen -n 500 -k 10 -ctype random -ftype random -htype random_increasing\n./gen -n 500 -k 10 -ctype random -ftype random -htype linear\n./gen -n 500 -k 10 -ctype random -ftype random -htype constant\n\n# Tests with k=1\n./gen -n 500 -k 1 -ctype random -ftype random -htype random_increasing\n\n# Tests with k at maximum and n small\n./gen -n 10 -k 10 -ctype random -ftype random -htype random_increasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T22:04:34.057121",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}